/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/lucid-extension-sdk/commandtypes.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/commandtypes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZOrderOperation = exports.isRawSendXHRResponse = exports.MermaidDiagramType = exports.GetLLMContextType = exports.GetItemsAtSearchType = exports.GetDocumentChunksType = exports.HashAlgorithmEnum = exports.AuthorizationFlowHandlerStage = exports.commandTitles = void 0;\nconst checks_1 = __webpack_require__(/*! ./core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\n/** @ignore */\nexports.commandTitles = new Map([\n    [\"aafh\" /* CommandName.AddAuthorizationFlowHandler */, 'AddAuthorizationFlowHandler'],\n    [\"aci\" /* CommandName.AddCardIntegration */, 'AddCardIntegration'],\n    [\"adfm\" /* CommandName.AddDiagramFromMermaid */, 'AddDiagramFromMermaid'],\n    [\"luma\" /* CommandName.AddDiagramFromLuma */, 'AddDiagramFromLuma'],\n    [\"adft\" /* CommandName.AddDiagramFromText */, 'AddDiagramFromText'],\n    [\"alta\" /* CommandName.AddLineTextArea */, 'AddLineTextArea'],\n    [\"ami\" /* CommandName.AddMenuItem */, 'AddMenuItem'],\n    [\"aqa\" /* CommandName.AddQuickAction */, 'AddQuickAction'],\n    [\"asd\" /* CommandName.AddShapeData */, 'AddShapeData'],\n    [\"asi\" /* CommandName.AddSpreadsheetIntegration */, 'AddSpreadsheetIntegration'],\n    [\"atc\" /* CommandName.AddTableColumn */, 'AddTableColumn'],\n    [\"atr\" /* CommandName.AddTableRow */, 'AddTableRow'],\n    [\"a\" /* CommandName.Alert */, 'Alert'],\n    [\"av\" /* CommandName.AnimateViewport */, 'AnimateViewport'],\n    [\"adi\" /* CommandName.AwaitDataSourceImport */, 'AwaitDataSourceImport'],\n    [\"ai\" /* CommandName.AwaitImport */, 'AwaitImport'],\n    [\"b\" /* CommandName.Bootstrap */, 'Bootstrap'],\n    [\"ceps\" /* CommandName.CanEditPackageSettings */, 'CanEditPackageSettings'],\n    [\"cdc\" /* CommandName.CancelDragBlockToCanvas */, 'CancelDragBlockToCanvas'],\n    [\"c\" /* CommandName.Confirm */, 'Confirm'],\n    [\"cb\" /* CommandName.CreateBlock */, 'CreateBlock'],\n    [\"cc\" /* CommandName.CreateCollection */, 'CreateCollection'],\n    [\"cds\" /* CommandName.CreateDataSource */, 'CreateDataSource'],\n    [\"cde\" /* CommandName.CreateDocumentElement */, 'CreateDocumentElement'],\n    [\"cg\" /* CommandName.CreateGroup */, 'CreateGroup'],\n    [\"cl\" /* CommandName.CreateLine */, 'CreateLine'],\n    [\"cp\" /* CommandName.CreatePage */, 'CreatePage'],\n    [\"die\" /* CommandName.DataItemExists */, 'DataItemExists'],\n    [\"dde\" /* CommandName.DeleteDocumentElement */, 'DeleteDocumentElement'],\n    [\"di\" /* CommandName.DeleteItem */, 'DeleteItem'],\n    [\"dp\" /* CommandName.DeletePage */, 'DeletePage'],\n    [\"dsd\" /* CommandName.DeleteShapeData */, 'DeleteShapeData'],\n    [\"dtc\" /* CommandName.DeleteTableColumn */, 'DeleteTableColumn'],\n    [\"dtr\" /* CommandName.DeleteTableRow */, 'DeleteTableRow'],\n    [\"d\" /* CommandName.Download */, 'Download'],\n    [\"dpm\" /* CommandName.DragPointerMove */, 'DragPointerMove'],\n    [\"dpu\" /* CommandName.DragPointerUp */, 'DragPointerUp'],\n    [\"dis\" /* CommandName.DuplicateItems */, 'DuplicateItems'],\n    [\"ee\" /* CommandName.ElementExists */, 'ElementExists'],\n    [\"ef\" /* CommandName.ExecuteFormula */, 'ExecuteFormula'],\n    [\"fas\" /* CommandName.FindAvailableSpace */, 'FindAvailableSpace'],\n    [\"fbe\" /* CommandName.FireBeaconEvent */, 'FireBeaconEvent'],\n    [\"gcl\" /* CommandName.GetConnectedLines */, 'GetConnectedLines'],\n    [\"gcp\" /* CommandName.GetCurrentPage */, 'GetCurrentPage'],\n    [\"gcs\" /* CommandName.GetCustomShape */, 'GetCustomShape'],\n    [\"gdif\" /* CommandName.GetDataItemField */, 'GetDataItemField'],\n    [\"gdap\" /* CommandName.GetDocumentAccessPermission */, 'GetDocumentAccessPermission'],\n    [\"gdc\" /* CommandName.GetDocumentChunks */, 'GetDocumentChunks'],\n    [\"gdid\" /* CommandName.GetDocumentId */, 'GetDocumentId'],\n    [\"get\" /* CommandName.GetElementType */, 'GetElementType'],\n    [\"gec\" /* CommandName.GetEnvironmentConfig */, 'GetEnvironmentConfig'],\n    [\"gip\" /* CommandName.GetItemPageId */, 'GetItemPageId'],\n    [\"gia\" /* CommandName.GetItemsAt */, 'GetItemsAt'],\n    [\"llm\" /* CommandName.GetLLMContextFromItems */, 'GetLLMContextFromItems'],\n    [\"goci\" /* CommandName.GetOAuthClientId */, 'GetOAuthClientId'],\n    [\"got\" /* CommandName.GetOAuthToken */, 'GetOAuthToken'],\n    [\"gps\" /* CommandName.GetPackageSettings */, 'GetPackageSettings'],\n    [\"gpr\" /* CommandName.GetProduct */, 'GetProduct'],\n    [\"gp\" /* CommandName.GetProperty */, 'GetProperty'],\n    [\"grk\" /* CommandName.GetReferenceKey */, 'GetReferenceKey'],\n    [\"grlp\" /* CommandName.GetRelativeLinePosition */, 'GetRelativeLinePosition'],\n    [\"gs\" /* CommandName.GetSelection */, 'GetSelection'],\n    [\"gsd\" /* CommandName.GetShapeData */, 'GetShapeData'],\n    [\"gsvg\" /* CommandName.GetSvg */, 'GetSvg'],\n    [\"gts\" /* CommandName.GetTextStyle */, 'GetTextStyle'],\n    [\"guid\" /* CommandName.GetUserId */, 'GetUserId'],\n    [\"gvr\" /* CommandName.GetVisibleRect */, 'GetVisibleRect'],\n    [\"hm\" /* CommandName.HideModal */, 'HideModal'],\n    [\"hp\" /* CommandName.HidePanel */, 'HidePanel'],\n    [\"hac\" /* CommandName.HookAllChanges */, 'HookAllChanges'],\n    [\"hci\" /* CommandName.HookCreateItems */, 'HookCreateItems'],\n    [\"hdi\" /* CommandName.HookDeleteItems */, 'HookDeleteItems'],\n    [\"hs\" /* CommandName.HookSelection */, 'HookSelection'],\n    [\"hte\" /* CommandName.HookTextEdit */, 'HookTextEdit'],\n    [\"ic\" /* CommandName.ImportCards */, 'ImportCards'],\n    [\"il\" /* CommandName.ImportLinks */, 'ImportLinks'],\n    [\"imp\" /* CommandName.ImportPage */, 'ImportPage'],\n    [\"k\" /* CommandName.KillExtension */, 'KillExtension'],\n    [\"lb\" /* CommandName.ListBlocks */, 'ListBlocks'],\n    [\"lcf\" /* CommandName.ListCollectionFields */, 'ListCollectionFields'],\n    [\"lc\" /* CommandName.ListCollections */, 'ListCollections'],\n    [\"ldi\" /* CommandName.ListDataItems */, 'ListDataItems'],\n    [\"lds\" /* CommandName.ListDataSources */, 'ListDataSources'],\n    [\"lde\" /* CommandName.ListDocumentElements */, 'ListDocumentElements'],\n    [\"lg\" /* CommandName.ListGroups */, 'ListGroups'],\n    [\"ll\" /* CommandName.ListLines */, 'ListLines'],\n    [\"lp\" /* CommandName.ListPages */, 'ListPages'],\n    [\"lpr\" /* CommandName.ListProperties */, 'ListProperties'],\n    [\"lrk\" /* CommandName.ListReferenceKeys */, 'ListReferenceKeys'],\n    [\"lsd\" /* CommandName.ListShapeData */, 'ListShapeData'],\n    [\"lta\" /* CommandName.ListTextAreas */, 'ListTextAreas'],\n    [\"lbc\" /* CommandName.LoadBlockClasses */, 'LoadBlockClasses'],\n    [\"log\" /* CommandName.LogForTestCase */, 'LogForTestCase'],\n    [\"mt\" /* CommandName.MeasureText */, 'MeasureText'],\n    [\"oi\" /* CommandName.OffsetItems */, 'OffsetItems'],\n    [\"pdi\" /* CommandName.PatchDataItems */, 'PatchDataItems'],\n    [\"p\" /* CommandName.Prompt */, 'Prompt'],\n    [\"rp\" /* CommandName.RegisterPanel */, 'RegisterPanel'],\n    [\"ru\" /* CommandName.RegisterUnfurl */, 'RegisterUnfurl'],\n    [\"r\" /* CommandName.ReloadExtension */, 'ReloadExtension'],\n    [\"aoauth\" /* CommandName.SendAsyncOAuthRequest */, 'SendAsyncOAuthRequest'],\n    [\"oauth\" /* CommandName.SendOAuthRequest */, 'SendOAuthRequest'],\n    [\"suim\" /* CommandName.SendUIMessage */, 'SendUIMessage'],\n    [\"xhr\" /* CommandName.SendXHR */, 'SendXHR'],\n    [\"scp\" /* CommandName.SetCurrentPage */, 'SetCurrentPage'],\n    [\"sps\" /* CommandName.SetPackageSettings */, 'SetPackageSettings'],\n    [\"sp\" /* CommandName.SetProperty */, 'SetProperty'],\n    [\"srk\" /* CommandName.SetReferenceKey */, 'SetReferenceKey'],\n    [\"ss\" /* CommandName.SetSelection */, 'SetSelection'],\n    [\"ssd\" /* CommandName.SetShapeData */, 'SetShapeData'],\n    [\"sts\" /* CommandName.SetTextStyle */, 'SetTextStyle'],\n    [\"sm\" /* CommandName.ShowModal */, 'ShowModal'],\n    [\"spsm\" /* CommandName.ShowPackageSettingsModal */, 'ShowPackageSettingsModal'],\n    [\"spn\" /* CommandName.ShowPanel */, 'ShowPanel'],\n    [\"sleep\" /* CommandName.SleepForTestCase */, 'SleepForTestCase'],\n    [\"sdc\" /* CommandName.StartDragBlockToCanvas */, 'StartDragBlockToCanvas'],\n    [\"pdf\" /* CommandName.StartPDFUploadRequest */, 'StartPDFUploadRequest'],\n    [\"throw\" /* CommandName.ThrowForTestCase */, 'ThrowForTestCase'],\n    [\"tauth\" /* CommandName.TriggerAuthFlow */, 'TriggerAuthFlow'],\n    [\"uac\" /* CommandName.UnhookAllChanges */, 'UnhookAllChanges'],\n    [\"uci\" /* CommandName.UnhookCreateItems */, 'UnhookCreateItems'],\n    [\"udi\" /* CommandName.UnhookDeleteItems */, 'UnhookDeleteItems'],\n    [\"us\" /* CommandName.UnhookSelection */, 'UnhookSelection'],\n    [\"ute\" /* CommandName.UnhookTextEdit */, 'UnhookTextEdit'],\n    [\"wm\" /* CommandName.WithMutex */, 'WithMutex'],\n    [\"wsa\" /* CommandName.WithSilentActions */, 'WithSilentActions'],\n    [\"z\" /* CommandName.ZOrder */, 'ZOrder'],\n]);\nvar AuthorizationFlowHandlerStage;\n(function (AuthorizationFlowHandlerStage) {\n    AuthorizationFlowHandlerStage[\"OnFailure\"] = \"onFailure\";\n})(AuthorizationFlowHandlerStage || (exports.AuthorizationFlowHandlerStage = AuthorizationFlowHandlerStage = {}));\nvar HashAlgorithmEnum;\n(function (HashAlgorithmEnum) {\n    /** Use the SHA 256 hashing algorithm */\n    HashAlgorithmEnum[\"sha256\"] = \"SHA256\";\n})(HashAlgorithmEnum || (exports.HashAlgorithmEnum = HashAlgorithmEnum = {}));\nvar GetDocumentChunksType;\n(function (GetDocumentChunksType) {\n    /**\n     * Breaks up a document into chunks geographically\n     */\n    GetDocumentChunksType[GetDocumentChunksType[\"Geographic\"] = 0] = \"Geographic\";\n    /**\n     * Breaks up a document into chunks by finding containing blocks\n     */\n    GetDocumentChunksType[GetDocumentChunksType[\"Container\"] = 1] = \"Container\";\n})(GetDocumentChunksType || (exports.GetDocumentChunksType = GetDocumentChunksType = {}));\nvar GetItemsAtSearchType;\n(function (GetItemsAtSearchType) {\n    GetItemsAtSearchType[GetItemsAtSearchType[\"PossiblyOverlapping\"] = 0] = \"PossiblyOverlapping\";\n    GetItemsAtSearchType[GetItemsAtSearchType[\"Overlapping\"] = 1] = \"Overlapping\";\n    GetItemsAtSearchType[GetItemsAtSearchType[\"Contained\"] = 2] = \"Contained\";\n})(GetItemsAtSearchType || (exports.GetItemsAtSearchType = GetItemsAtSearchType = {}));\nvar GetLLMContextType;\n(function (GetLLMContextType) {\n    /** Get context in a format for LLMs where relationships among connected and\n     * contained items are preserved. Expand the scope of the selection to\n     * include blocks contained by the selection as well as lines connecting\n     * items in the selection. */\n    GetLLMContextType[GetLLMContextType[\"Relational\"] = 1] = \"Relational\";\n    /** Get context containing only plain text displayed on the given items, more suitable for embeddings */\n    GetLLMContextType[GetLLMContextType[\"PlainText\"] = 2] = \"PlainText\";\n    /** Get context in a format for LLMs where relationships among connected and\n     * contained items are preserved. Do not expand the scope of the selection,\n     * other than to ensure relationships are represented. Text on selected\n     * items will be included, but text on automatically added items will not.\n     * */\n    GetLLMContextType[GetLLMContextType[\"RelationalWithoutExpansion\"] = 3] = \"RelationalWithoutExpansion\";\n})(GetLLMContextType || (exports.GetLLMContextType = GetLLMContextType = {}));\nvar MermaidDiagramType;\n(function (MermaidDiagramType) {\n    MermaidDiagramType[\"FLOWCHART\"] = \"flowchart\";\n    MermaidDiagramType[\"CLASS_DIAGRAM\"] = \"class_diagram\";\n    MermaidDiagramType[\"ERD\"] = \"erd\";\n    // The following types are not yet supported.\n    // SEQUENCE_DIAGRAM = 'sequence_diagram',\n    // STATE_DIAGRAM = 'state_diagram',\n    // USER_JOURNEY = 'user_journey',\n    // GANTT = 'gantt',\n    // PIECHART = 'piechart',\n    // MINDMAP = 'mindmap',\n    // REQUIREMENT_DIAGRAM = 'requirement_diagram',\n    // GITGRAPH = 'gitgraph',\n    // TIMELINE = 'timeline',\n})(MermaidDiagramType || (exports.MermaidDiagramType = MermaidDiagramType = {}));\nfunction isRawSendXHRResponse(val) {\n    return (0, checks_1.isString)(val['url']) && (0, checks_1.isString)(val['t']) && (0, checks_1.isNumber)(val['s']) && (0, checks_1.isObject)(val['h']);\n}\nexports.isRawSendXHRResponse = isRawSendXHRResponse;\nvar ZOrderOperation;\n(function (ZOrderOperation) {\n    ZOrderOperation[ZOrderOperation[\"UP\"] = 1] = \"UP\";\n    ZOrderOperation[ZOrderOperation[\"TOP\"] = 2] = \"TOP\";\n    ZOrderOperation[ZOrderOperation[\"DOWN\"] = 3] = \"DOWN\";\n    ZOrderOperation[ZOrderOperation[\"BOTTOM\"] = 4] = \"BOTTOM\";\n})(ZOrderOperation || (exports.ZOrderOperation = ZOrderOperation = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/commandtypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/base64.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/base64.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeBase64 = exports.decodeBase64 = void 0;\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n//This gives a ~8x speedup vs. using alphabet.indexOf() in the main decode loop.\nconst charCodeToEncodedInt = [];\nfor (let i = 0; i < alphabet.length; i++) {\n    charCodeToEncodedInt[alphabet.charCodeAt(i)] = i;\n}\nfunction decodeBase64(base64String) {\n    //Filter out whitespace, etc\n    base64String = base64String.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n    if (base64String.length % 4 !== 0) {\n        throw new Error('Invalid base64 input; length must be a multiple of 4');\n    }\n    //4 characters of input turns into 3 bytes of output\n    let bytes = (base64String.length / 4) * 3;\n    //But each trailing = (up to 2) is one fewer byte of output\n    if (base64String.endsWith('==')) {\n        bytes -= 2;\n    }\n    else if (base64String.endsWith('=')) {\n        bytes -= 1;\n    }\n    const output = new Uint8Array(bytes);\n    let inputIndex = 0;\n    for (let outputIndex = 0; outputIndex < bytes; outputIndex += 3) {\n        //Get the 4 numbers 0-63 encoded in the next 4 characters\n        const enc1 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        const enc2 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        const enc3 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        const enc4 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        if (enc1 === undefined || enc2 === undefined || enc3 === undefined || enc4 === undefined) {\n            throw new Error('char code to encoded int contains an undefined index');\n        }\n        //Read 8 total bits into each of the output values. Skip one byte\n        //for each padding = at the end of the string\n        output[outputIndex] = (enc1 << 2) | (enc2 >> 4);\n        if (enc3 != 64) {\n            output[outputIndex + 1] = ((enc2 & 15) << 4) | (enc3 >> 2);\n        }\n        if (enc4 != 64) {\n            output[outputIndex + 2] = ((enc3 & 3) << 6) | enc4;\n        }\n    }\n    return output;\n}\nexports.decodeBase64 = decodeBase64;\nfunction encodeBase64(byteArray) {\n    // 3 bytes of input become 4 chars of output\n    // i.e. every 6 bits of input becomes 1 char of output\n    const fullByteChunkCount = Math.floor(byteArray.length / 3);\n    const outputLength = Math.ceil(byteArray.length / 3) * 4;\n    const output = new Array(outputLength);\n    let inputIndex = 0;\n    let outputIndex = 0;\n    for (let byteChunkIndex = 0; byteChunkIndex < fullByteChunkCount; byteChunkIndex++) {\n        const byte1 = byteArray[inputIndex++];\n        const byte2 = byteArray[inputIndex++];\n        const byte3 = byteArray[inputIndex++];\n        if (byte1 === undefined || byte2 === undefined || byte3 === undefined) {\n            throw new Error('byteArray contains undefined indexes');\n        }\n        const enc1 = byte1 >> 2; // first 6 bits of byte1\n        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4); // last 2 bits of byte1 and first 4 bits of byte2\n        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6); // last 4 bits of byte2 and first 2 bits of byte3\n        const enc4 = byte3 & 63; // last 6 bits of byte3\n        output[outputIndex++] = alphabet[enc1];\n        output[outputIndex++] = alphabet[enc2];\n        output[outputIndex++] = alphabet[enc3];\n        output[outputIndex++] = alphabet[enc4];\n    }\n    // handle remainder, i.e. trailing one or two bytes\n    if (inputIndex < byteArray.length) {\n        const byte1 = byteArray[inputIndex++];\n        const hasSecondByte = inputIndex < byteArray.length;\n        const byte2 = hasSecondByte ? byteArray[inputIndex++] : 0;\n        const enc1 = byte1 >> 2; // first 6 bits of byte1\n        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4); // last 2 bits of byte1 and first 4 bits of byte2\n        const enc3 = hasSecondByte ? (byte2 & 15) << 2 : 64; // last 4 bits of byte2\n        output[outputIndex++] = alphabet[enc1];\n        output[outputIndex++] = alphabet[enc2];\n        output[outputIndex++] = alphabet[enc3];\n        output[outputIndex++] = '=';\n    }\n    return output.join('');\n}\nexports.encodeBase64 = encodeBase64;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/base64.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidCardFields = exports.StatusValues = exports.deserializeLucidCardFieldDisplaySettings = exports.serializeLucidCardFieldDisplaySettings = exports.isSerializedLucidCardFieldSettings = exports.isOnClickHandlerKey = exports.OnClickHandlerKeys = exports.isFieldDisplayType = exports.FieldDisplayType = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst badgeposition_1 = __webpack_require__(/*! ../properties/datagraphic/badgeposition */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * When configuring a field on a LucidCardBlock to be displayed as a data graphic, one of these values specifies\n * the function to convert the field value to the data graphic settings. The definition of these functions is in\n * LucidCardsLibrary.registerStencilDisplayTypes.\n */\nvar FieldDisplayType;\n(function (FieldDisplayType) {\n    /**\n     * Text badge with the full text of the field.\n     * Black text on a light gray background in the upper-right of the card.\n     */\n    FieldDisplayType[\"BasicTextBadge\"] = \"BasicTextBadge\";\n    /**\n     * Given a name (usually of a user), puts a text badge with their initials (first letter of each name)\n     * at the bottom-left of the card, black text on a light gray background.\n     */\n    FieldDisplayType[\"InitializedString\"] = \"InitializedString\";\n    /**\n     * Given a number, display the number in the bottom-left of the card. If the number is higher than 999,\n     * display 999.\n     */\n    FieldDisplayType[\"StandardEstimation\"] = \"StandardEstimation\";\n    /**\n     * Given a URL, display a small image cropped into a circle in the lower-left of the card.\n     */\n    FieldDisplayType[\"ImageBadge\"] = \"ImageBadge\";\n    /**\n     * Given a URL, display a small image cropped into a square in the lower-left of the card.\n     */\n    FieldDisplayType[\"SquareImageBadge\"] = \"SquareImageBadge\";\n    /**\n     * Given a date, display a small calendar icon alongside a very short version of the date\n     * as a string, e.g. \"Sep 9\"\n     */\n    FieldDisplayType[\"DateBadge\"] = \"DateBadge\";\n    /** Given an object containing iconUrl (optional) and name (optional), determine whether\n     * to display as an ImageBadge or InitializedString (or nothing, if neither is present).\n     *\n     * If FF LucidCardUIRefresh ON:\n     * Given or string of name or an object containing iconUrl and name, display as\n     * an as a full name or an ImageBadge with full name (if name is present).\n     */\n    FieldDisplayType[\"UserProfile\"] = \"UserProfile\";\n})(FieldDisplayType || (exports.FieldDisplayType = FieldDisplayType = {}));\nexports.isFieldDisplayType = (0, validators_1.enumValidator)(FieldDisplayType);\n/**\n * When configuring a field on a LucidCardBlock to be displayed as a data graphic, this click handler value\n * specifies what to do when the user clicks on the data graphic produced.\n */\nvar OnClickHandlerKeys;\n(function (OnClickHandlerKeys) {\n    /**\n     * Display the UI panel to edit fields on the data associated with the card\n     */\n    OnClickHandlerKeys[\"BasicEditPanel\"] = \"BasicEditPanel\";\n    /**\n     * Open a new browser window to a URL specified by linkFormula\n     */\n    OnClickHandlerKeys[\"OpenBrowserWindow\"] = \"OpenBrowserWindow\";\n    /**\n     * Display a custom UI panel to edit non-standard fields on the data associated with the card\n     */\n    OnClickHandlerKeys[\"CustomEditAction\"] = \"CustomEditAction\";\n})(OnClickHandlerKeys || (exports.OnClickHandlerKeys = OnClickHandlerKeys = {}));\nexports.isOnClickHandlerKey = (0, validators_1.enumValidator)(OnClickHandlerKeys);\nconst isImageBadgeSettings = (0, validators_1.objectValidator)({\n    'height': checks_1.isNumber,\n    'width': checks_1.isNumber,\n});\nconst isTextBadgeSettings = (0, validators_1.objectValidator)({\n    'bold': (0, validators_1.option)(checks_1.isBoolean),\n    'italic': (0, validators_1.option)(checks_1.isBoolean),\n    'underline': (0, validators_1.option)(checks_1.isBoolean),\n    'rounding': (0, validators_1.option)(checks_1.isNumber),\n    'minwidth': (0, validators_1.option)(checks_1.isNumber),\n    'minheight': (0, validators_1.option)(checks_1.isNumber),\n    'maxfontsize': (0, validators_1.option)(checks_1.isNumber),\n    'maxtextwidth': (0, validators_1.option)(checks_1.isNumber),\n    'iswithinpill': (0, validators_1.option)(checks_1.isBoolean),\n    'usingcarduirefresh': (0, validators_1.option)(checks_1.isBoolean),\n    'hasleadingicon': (0, validators_1.option)(checks_1.isBoolean),\n});\nconst isStencilConfig = (0, validators_1.objectValidator)({\n    'getterKey': exports.isFieldDisplayType,\n    'fg': (0, validators_1.option)(checks_1.isString),\n    'bg': (0, validators_1.option)(checks_1.isString),\n    'f': (0, validators_1.option)(checks_1.isString),\n    't': (0, validators_1.option)(checks_1.isString),\n    'l': (0, validators_1.option)(checks_1.isString),\n    'h': (0, validators_1.option)((0, validators_1.enumValidator)(badgeposition_1.HorizontalBadgePos)),\n    'v': (0, validators_1.option)((0, validators_1.enumValidator)(badgeposition_1.VerticalBadgePos)),\n    'onClickHandlerKey': (0, validators_1.option)(exports.isOnClickHandlerKey),\n    'imageBadgeSettings': (0, validators_1.option)(isImageBadgeSettings),\n    'textBadgeSettings': (0, validators_1.option)(isTextBadgeSettings),\n});\nexports.isSerializedLucidCardFieldSettings = (0, validators_1.objectValidator)({\n    'StencilConfig': (0, validators_1.option)(isStencilConfig),\n});\n/** @ignore */\nfunction serializeLucidCardFieldDisplaySettings(settings) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    return {\n        'StencilConfig': settings.stencilConfig && {\n            'getterKey': settings.stencilConfig.displayType,\n            'f': settings.stencilConfig.valueFormula,\n            't': settings.stencilConfig.tooltipFormula,\n            'l': settings.stencilConfig.linkFormula,\n            'fg': settings.stencilConfig.foregroundColor,\n            'bg': settings.stencilConfig.backgroundColor,\n            'h': settings.stencilConfig.horizontalPosition,\n            'v': settings.stencilConfig.verticalPosition,\n            'onClickHandlerKey': settings.stencilConfig.onClickHandlerKey,\n            'imageBadgeSettings': settings.stencilConfig.imageBadgeSettings && {\n                'height': settings.stencilConfig.imageBadgeSettings.height,\n                'width': settings.stencilConfig.imageBadgeSettings.width,\n            },\n            'textBadgeSettings': {\n                'rounding': (_a = settings.stencilConfig.textBadgeSettings) === null || _a === void 0 ? void 0 : _a.rounding,\n                'bold': (_b = settings.stencilConfig.textBadgeSettings) === null || _b === void 0 ? void 0 : _b.bold,\n                'italic': (_c = settings.stencilConfig.textBadgeSettings) === null || _c === void 0 ? void 0 : _c.italic,\n                'underline': (_d = settings.stencilConfig.textBadgeSettings) === null || _d === void 0 ? void 0 : _d.underline,\n                'minwidth': (_e = settings.stencilConfig.textBadgeSettings) === null || _e === void 0 ? void 0 : _e.minwidth,\n                'minheight': (_f = settings.stencilConfig.textBadgeSettings) === null || _f === void 0 ? void 0 : _f.minheight,\n                'maxfontsize': (_g = settings.stencilConfig.textBadgeSettings) === null || _g === void 0 ? void 0 : _g.maxfontsize,\n                'maxtextwidth': (_h = settings.stencilConfig.textBadgeSettings) === null || _h === void 0 ? void 0 : _h.maxtextwidth,\n                'iswithinpill': (_j = settings.stencilConfig.textBadgeSettings) === null || _j === void 0 ? void 0 : _j.iswithinpill,\n                'usingcarduirefresh': (_k = settings.stencilConfig.textBadgeSettings) === null || _k === void 0 ? void 0 : _k.usingcarduirefresh,\n                'hasleadingicon': (_l = settings.stencilConfig.textBadgeSettings) === null || _l === void 0 ? void 0 : _l.hasleadingicon,\n            },\n        },\n    };\n}\nexports.serializeLucidCardFieldDisplaySettings = serializeLucidCardFieldDisplaySettings;\n/** @ignore */\nfunction deserializeLucidCardFieldDisplaySettings(settings) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    return {\n        stencilConfig: settings['StencilConfig'] && {\n            displayType: settings['StencilConfig']['getterKey'],\n            valueFormula: settings['StencilConfig']['f'],\n            tooltipFormula: settings['StencilConfig']['t'],\n            linkFormula: settings['StencilConfig']['l'],\n            foregroundColor: settings['StencilConfig']['fg'],\n            backgroundColor: settings['StencilConfig']['bg'],\n            horizontalPosition: settings['StencilConfig']['h'],\n            verticalPosition: settings['StencilConfig']['v'],\n            onClickHandlerKey: settings['StencilConfig']['onClickHandlerKey'],\n            imageBadgeSettings: settings['StencilConfig']['imageBadgeSettings'] && {\n                height: settings['StencilConfig']['imageBadgeSettings']['height'],\n                width: settings['StencilConfig']['imageBadgeSettings']['width'],\n            },\n            textBadgeSettings: {\n                rounding: (_a = settings['StencilConfig']['textBadgeSettings']) === null || _a === void 0 ? void 0 : _a['rounding'],\n                bold: (_b = settings['StencilConfig']['textBadgeSettings']) === null || _b === void 0 ? void 0 : _b['bold'],\n                italic: (_c = settings['StencilConfig']['textBadgeSettings']) === null || _c === void 0 ? void 0 : _c['italic'],\n                underline: (_d = settings['StencilConfig']['textBadgeSettings']) === null || _d === void 0 ? void 0 : _d['underline'],\n                minwidth: (_e = settings['StencilConfig']['textBadgeSettings']) === null || _e === void 0 ? void 0 : _e['minwidth'],\n                minheight: (_f = settings['StencilConfig']['textBadgeSettings']) === null || _f === void 0 ? void 0 : _f['minheight'],\n                maxfontsize: (_g = settings['StencilConfig']['textBadgeSettings']) === null || _g === void 0 ? void 0 : _g['maxfontsize'],\n                maxtextwidth: (_h = settings['StencilConfig']['textBadgeSettings']) === null || _h === void 0 ? void 0 : _h['maxtextwidth'],\n                iswithinpill: (_j = settings['StencilConfig']['textBadgeSettings']) === null || _j === void 0 ? void 0 : _j['iswithinpill'],\n                usingcarduirefresh: (_k = settings['StencilConfig']['textBadgeSettings']) === null || _k === void 0 ? void 0 : _k['usingcarduirefresh'],\n                hasleadingicon: (_l = settings['StencilConfig']['textBadgeSettings']) === null || _l === void 0 ? void 0 : _l['hasleadingicon'],\n            },\n        },\n    };\n}\nexports.deserializeLucidCardFieldDisplaySettings = deserializeLucidCardFieldDisplaySettings;\n/**\n * These are the six possible values for the status of a basic card block.\n * Must be kept in sync with cake/app/webroot/ts/libraries/lucidcards/lucidcarddefaultstatus.ts\n */\nvar StatusValues;\n(function (StatusValues) {\n    StatusValues[\"New\"] = \"New\";\n    StatusValues[\"Todo\"] = \"To Do\";\n    StatusValues[\"InProgress\"] = \"In Progress\";\n    StatusValues[\"Done\"] = \"Done\";\n    StatusValues[\"NotDoing\"] = \"Not Doing\";\n    StatusValues[\"Blocked\"] = \"Blocked\";\n})(StatusValues || (exports.StatusValues = StatusValues = {}));\nvar LucidCardFields;\n(function (LucidCardFields) {\n    LucidCardFields[\"Title\"] = \"Title\";\n    LucidCardFields[\"Description\"] = \"Description\";\n    LucidCardFields[\"Assignee\"] = \"Assignee\";\n    LucidCardFields[\"Estimate\"] = \"Estimate\";\n    LucidCardFields[\"Status\"] = \"Status\";\n    LucidCardFields[\"StartTime\"] = \"StartTime\";\n    LucidCardFields[\"EndTime\"] = \"EndTime\";\n})(LucidCardFields || (exports.LucidCardFields = LucidCardFields = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeCardIntegrationConfig = exports.serializeCardIntegrationConfig = exports.isSerializedCardIntegrationConfig = void 0;\nconst textstyle_1 = __webpack_require__(/*! ../../document/text/textstyle */ \"./node_modules/lucid-extension-sdk/document/text/textstyle.js\");\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst cardfielddisplaysettings_1 = __webpack_require__(/*! ./cardfielddisplaysettings */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js\");\nexports.isSerializedCardIntegrationConfig = (0, validators_1.objectValidator)({\n    'cc': (0, validators_1.objectValidator)({\n        'f': (0, checks_1.isTypedArray)(checks_1.isString),\n        'fd': (0, validators_1.option)((0, checks_1.isTypedArray)((0, checks_1.isPair)(checks_1.isString, cardfielddisplaysettings_1.isSerializedLucidCardFieldSettings))),\n        'fs': (0, validators_1.option)((0, checks_1.isTypedArray)((0, checks_1.isPair)(checks_1.isString, textstyle_1.isPartialTextStyle))),\n        'id': (0, validators_1.option)(checks_1.isString),\n    }),\n    'cdpc': (0, validators_1.objectValidator)({ 'f': (0, checks_1.isTypedArray)((0, validators_1.objectValidator)({ 'n': checks_1.isString, 'l': (0, validators_1.option)(checks_1.isBoolean) })) }),\n});\n/** @ignore */\nfunction serializeCardIntegrationConfig(config) {\n    return {\n        'cc': {\n            'f': config.cardConfig.fieldNames,\n            'fd': config.cardConfig.fieldDisplaySettings\n                ? [...config.cardConfig.fieldDisplaySettings].map(([key, settings]) => [\n                    key,\n                    (0, cardfielddisplaysettings_1.serializeLucidCardFieldDisplaySettings)(settings),\n                ])\n                : undefined,\n            'fs': config.cardConfig.fieldStyles ? [...config.cardConfig.fieldStyles] : undefined,\n        },\n        'cdpc': {\n            'f': config.cardDetailsPanelConfig.fields.map((field) => {\n                return {\n                    'n': field.name,\n                    'l': field.locked,\n                };\n            }),\n        },\n    };\n}\nexports.serializeCardIntegrationConfig = serializeCardIntegrationConfig;\n/** @ignore */\nfunction deserializeCardIntegrationConfig(raw) {\n    return {\n        cardConfig: {\n            fieldNames: raw['cc']['f'],\n            fieldStyles: raw['cc']['fs'] ? new Map(raw['cc']['fs']) : undefined,\n            fieldDisplaySettings: raw['cc']['fd']\n                ? new Map(raw['cc']['fd'].map(([key, settings]) => [\n                    key,\n                    (0, cardfielddisplaysettings_1.deserializeLucidCardFieldDisplaySettings)(settings),\n                ]))\n                : undefined,\n        },\n        cardDetailsPanelConfig: {\n            fields: raw['cdpc']['f'].map((field) => {\n                return {\n                    name: field['n'],\n                    locked: field['l'],\n                };\n            }),\n        },\n    };\n}\nexports.deserializeCardIntegrationConfig = deserializeCardIntegrationConfig;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidCardIntegration = exports.isFieldDescriptor = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nexports.isFieldDescriptor = (0, validators_1.objectValidator)({\n    name: checks_1.isString,\n    label: (0, validators_1.option)(checks_1.isString),\n    locked: (0, validators_1.option)(checks_1.isBoolean),\n});\nclass LucidCardIntegration {\n    constructor(client) {\n        this.client = client;\n    }\n    showCardImport(name) {\n        return this.client.sendCommand(\"ic\" /* CommandName.ImportCards */, name);\n    }\n}\nexports.LucidCardIntegration = LucidCardIntegration;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationcustomimportmodal.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationcustomimportmodal.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidCardIntegrationCustomImportModal = void 0;\nconst modal_1 = __webpack_require__(/*! ../../ui/modal */ \"./node_modules/lucid-extension-sdk/ui/modal.js\");\n/**\n * Extending this class lets you create a custom import modal for a Lucid card integration.\n */\nclass LucidCardIntegrationCustomImportModal extends modal_1.Modal {\n    constructor(client, config, cardIntegrationLabel) {\n        super(client, config);\n        this.cardIntegrationLabel = cardIntegrationLabel;\n    }\n    /**\n     * Once the data has been imported, call this function to create Lucid cards on the canvas.\n     */\n    createCards(collectionId, primaryKeys) {\n        return this.client.sendCommand(\"ca\" /* CommandName.CreateCards */, {\n            'cid': this.cardIntegrationLabel,\n            'coid': collectionId,\n            'pks': primaryKeys,\n        });\n    }\n}\nexports.LucidCardIntegrationCustomImportModal = LucidCardIntegrationCustomImportModal;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationcustomimportmodal.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidCardIntegrationRegistry = void 0;\nconst collectiondefinition_1 = __webpack_require__(/*! ../../data/collectiondefinition */ \"./node_modules/lucid-extension-sdk/data/collectiondefinition.js\");\nconst collectionproxy_1 = __webpack_require__(/*! ../../data/collectionproxy */ \"./node_modules/lucid-extension-sdk/data/collectionproxy.js\");\nconst dataitemproxy_1 = __webpack_require__(/*! ../../data/dataitemproxy */ \"./node_modules/lucid-extension-sdk/data/dataitemproxy.js\");\nconst datasourceproxy_1 = __webpack_require__(/*! ../../data/datasourceproxy */ \"./node_modules/lucid-extension-sdk/data/datasourceproxy.js\");\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst cardintegrationdefinitions_1 = __webpack_require__(/*! ../sharedcardintegration/cardintegrationdefinitions */ \"./node_modules/lucid-extension-sdk/core/sharedcardintegration/cardintegrationdefinitions.js\");\nconst cardintegrationconfig_1 = __webpack_require__(/*! ./cardintegrationconfig */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js\");\nconst lucidcardintegrationcustomimportmodal_1 = __webpack_require__(/*! ./lucidcardintegrationcustomimportmodal */ \"./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationcustomimportmodal.js\");\nclass LucidCardIntegrationRegistry {\n    static nextHookName() {\n        return '__lucidcard__hook' + LucidCardIntegrationRegistry.nextHookId++;\n    }\n    static registerFieldOptionsCallback(client, callback) {\n        const name = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(name, async ({ 'i': inputSoFar }) => {\n            const result = await callback(new Map(inputSoFar));\n            return result.map((option) => (0, cardintegrationdefinitions_1.serializeCardFieldOption)(option));\n        });\n        return name;\n    }\n    static registerFieldSearchCallback(client, callback) {\n        const name = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(name, async ({ 'i': inputSoFar, 's': searchText, 'fd': serializedFieldData }) => {\n            const fieldData = serializedFieldData ? { name: serializedFieldData.n } : undefined;\n            const result = await callback(searchText, new Map(inputSoFar), fieldData);\n            return result.map((option) => (0, cardintegrationdefinitions_1.serializeCardFieldOption)(option));\n        });\n        return name;\n    }\n    static registerUserSearchCallback(client, callback) {\n        const name = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(name, async ({ 'i': inputSoFar, 's': searchText }) => {\n            const result = await callback(searchText, new Map(inputSoFar));\n            return result.map((userData) => (0, cardintegrationdefinitions_1.serializeCardUserData)(userData));\n        });\n        return name;\n    }\n    static registerDependencyMapping(client, cardIntegration, serialized) {\n        if (cardIntegration.showDependencyMapping) {\n            serialized['sdm'] = true;\n        }\n        if (cardIntegration.dependencyMappingPhrases) {\n            const dependencyMappingPhrases = cardIntegration.dependencyMappingPhrases;\n            const manager = dependencyMappingPhrases.manager;\n            const emptyState = manager === null || manager === void 0 ? void 0 : manager.emptyState;\n            const edit = dependencyMappingPhrases.edit;\n            // Strings that appear on the canvas must calculate their locale at runtime,\n            // so all users get canvas content in the same locale\n            const cardLabelActionName = dependencyMappingPhrases.cardLabel\n                ? LucidCardIntegrationRegistry.nextHookName()\n                : undefined;\n            if (cardLabelActionName) {\n                client.registerAction(cardLabelActionName, ({ 'l': locale, 'c': count }) => { var _a; return (_a = dependencyMappingPhrases.cardLabel) === null || _a === void 0 ? void 0 : _a.call(dependencyMappingPhrases, locale, count); });\n            }\n            const noDependencyHeadingActionName = (emptyState === null || emptyState === void 0 ? void 0 : emptyState.noDependencyHeading)\n                ? LucidCardIntegrationRegistry.nextHookName()\n                : undefined;\n            if (noDependencyHeadingActionName) {\n                client.registerAction(noDependencyHeadingActionName, ({ 'k': key }) => {\n                    var _a;\n                    return (_a = emptyState === null || emptyState === void 0 ? void 0 : emptyState.noDependencyHeading) === null || _a === void 0 ? void 0 : _a.call(emptyState, key);\n                });\n            }\n            const selectedIssueHeadingActionName = (edit === null || edit === void 0 ? void 0 : edit.selectedIssueHeading)\n                ? LucidCardIntegrationRegistry.nextHookName()\n                : undefined;\n            if (selectedIssueHeadingActionName) {\n                client.registerAction(selectedIssueHeadingActionName, ({ 'k': key }) => {\n                    var _a;\n                    return (_a = edit === null || edit === void 0 ? void 0 : edit.selectedIssueHeading) === null || _a === void 0 ? void 0 : _a.call(edit, key);\n                });\n            }\n            serialized['dmp'] = {\n                'ep': dependencyMappingPhrases.entrypoint,\n                'cl': cardLabelActionName,\n                'm': manager\n                    ? {\n                        'h': manager.header,\n                        'all': manager.allLinksLabel,\n                        'salb': manager.showAllLinksButton,\n                        'halb': manager.hideAllLinksButton,\n                        'dsalt': manager.disabledShowAllLinksTooltip,\n                        'dhalt': manager.disabledHideAllLinksTooltip,\n                        'es': emptyState\n                            ? {\n                                'cli': emptyState.createLinkInstruction,\n                                'nssi': emptyState.noSelectionStateInstruction,\n                                'nssh': emptyState.noSelectionStateHeading,\n                                'ndh': noDependencyHeadingActionName,\n                                'mikwnl': emptyState.multipleIssueKeyWithNoLink,\n                            }\n                            : undefined,\n                    }\n                    : undefined,\n                'ed': edit\n                    ? {\n                        'ch': edit.createHeader,\n                        'cnlo': edit.createNoLinkOption,\n                        'dh': edit.deleteHeader,\n                        'dd': edit.deleteDescription,\n                        'dab': edit.deleteActionButton,\n                        'sih': selectedIssueHeadingActionName,\n                    }\n                    : undefined,\n            };\n        }\n        if (cardIntegration.importDependencies) {\n            const importDependencies = cardIntegration.importDependencies;\n            const importDependenciesActionName = LucidCardIntegrationRegistry.nextHookName();\n            serialized['idep'] = importDependenciesActionName;\n            client.registerAction(importDependenciesActionName, async ({ 'dfi': serializedDependenciesForItems }) => {\n                const proxiedDependenciesForItems = new Map(serializedDependenciesForItems.map((_) => {\n                    const collectionProxy = new collectionproxy_1.CollectionProxy(_.oci, client);\n                    const originalItemProxy = new dataitemproxy_1.DataItemProxy(_.opk, collectionProxy, client);\n                    return [originalItemProxy, _.pks];\n                }));\n                const proxiedResults = await importDependencies(proxiedDependenciesForItems);\n                const results = proxiedResults.map((result) => {\n                    return {\n                        'c': result.collection.id,\n                        'pks': result.primaryKeys,\n                    };\n                });\n                return results;\n            });\n        }\n        return serialized;\n    }\n    static serializeSearchResult(searchResult) {\n        return {\n            'd': (0, collectiondefinition_1.serializeCollectionDefinition)(searchResult.data),\n            'f': (0, cardintegrationdefinitions_1.serializeCardFieldArrayDefinition)(searchResult.fields),\n            'm': searchResult.partialImportMetadata && {\n                'cid': searchResult.partialImportMetadata.collectionId,\n                'sid': searchResult.partialImportMetadata.syncDataSourceId,\n            },\n        };\n    }\n    /**\n     * Register a card integration.\n     */\n    static addCardIntegration(client, cardIntegration) {\n        const getFieldsActionName = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(getFieldsActionName, async (param) => {\n            const dataSource = new datasourceproxy_1.DataSourceProxy(param['d'], client);\n            const fields = await cardIntegration.fieldConfiguration.getAllFields(dataSource);\n            return fields;\n        });\n        let onSelectedFieldsChangeActionName = undefined;\n        const onSelectedFieldsChange = cardIntegration.fieldConfiguration.onSelectedFieldsChange;\n        if (onSelectedFieldsChange) {\n            onSelectedFieldsChangeActionName = LucidCardIntegrationRegistry.nextHookName();\n            client.registerAction(onSelectedFieldsChangeActionName, async (param) => {\n                const dataSource = new datasourceproxy_1.DataSourceProxy(param['ds'], client);\n                await onSelectedFieldsChange(dataSource, param['sf']);\n            });\n        }\n        const getDefaultConfigActionName = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(getDefaultConfigActionName, async (param) => {\n            const dataSource = new datasourceproxy_1.DataSourceProxy(param['d'], client);\n            return (0, cardintegrationconfig_1.serializeCardIntegrationConfig)(await cardIntegration.getDefaultConfig(dataSource));\n        });\n        let showIntroActionName = undefined;\n        if (cardIntegration.showIntro) {\n            showIntroActionName = LucidCardIntegrationRegistry.nextHookName();\n            client.registerAction(showIntroActionName, cardIntegration.showIntro);\n        }\n        const serialized = {\n            'n': cardIntegration.label,\n            'dcn': cardIntegration.dataConnectorName,\n            'il': cardIntegration.itemLabel,\n            'isl': cardIntegration.itemsLabel,\n            'u': cardIntegration.iconUrl,\n            'ts': cardIntegration.textStyle,\n            'fc': {\n                'gf': getFieldsActionName,\n                'osfc': onSelectedFieldsChangeActionName,\n                'fvsc': cardIntegration.fieldConfiguration.fieldValueSearchCallbacks\n                    ? [...cardIntegration.fieldConfiguration.fieldValueSearchCallbacks.entries()]\n                    : undefined,\n                'dsc': cardIntegration.fieldConfiguration.defaultSearchCallback,\n            },\n            'subn': cardIntegration.searchUserByName,\n            'usc': cardIntegration.userSearchCallback,\n            'gdc': getDefaultConfigActionName,\n            'i': showIntroActionName,\n        };\n        if (cardIntegration.iconConfiguration) {\n            serialized['icu'] = {\n                'pi': cardIntegration.iconConfiguration.primaryIconUrl,\n                'li': cardIntegration.iconConfiguration.lightIconUrl,\n            };\n        }\n        if (cardIntegration.importModal) {\n            const importModal = cardIntegration.importModal;\n            if (importModal instanceof lucidcardintegrationcustomimportmodal_1.LucidCardIntegrationCustomImportModal) {\n                serialized['cim'] = {\n                    'sh': LucidCardIntegrationRegistry.nextHookName(),\n                };\n                client.registerAction(serialized['cim']['sh'], () => importModal.show());\n            }\n            else {\n                serialized['im'] = {\n                    'gsf': LucidCardIntegrationRegistry.nextHookName(),\n                    's': LucidCardIntegrationRegistry.nextHookName(),\n                    'i': LucidCardIntegrationRegistry.nextHookName(),\n                    'os': importModal.onSetup ? LucidCardIntegrationRegistry.nextHookName() : undefined,\n                };\n                if (importModal.importModalHeading) {\n                    serialized['im']['imh'] = importModal.importModalHeading;\n                }\n                if (importModal.useIsolatedSearchBarUI) {\n                    serialized['im']['uisbui'] = importModal.useIsolatedSearchBarUI;\n                }\n                client.registerAction(serialized['im']['gsf'], async ({ 's': searchSoFar }) => {\n                    const result = await importModal.getSearchFields(new Map(searchSoFar));\n                    return (0, cardintegrationdefinitions_1.serializeCardFieldArrayDefinition)(result);\n                });\n                client.registerAction(serialized['im']['s'], async ({ 's': param }) => {\n                    const result = await importModal.search(new Map(param));\n                    if ((0, checks_1.isArray)(result)) {\n                        return result.map((searchResult) => {\n                            return this.serializeSearchResult(searchResult);\n                        });\n                    }\n                    else {\n                        return this.serializeSearchResult(result);\n                    }\n                });\n                client.registerAction(serialized['im']['i'], async ({ 'pks': primaryKeys, 's': searchFields }) => {\n                    const result = await importModal.import(primaryKeys, new Map(searchFields));\n                    if ((0, checks_1.isArray)(result)) {\n                        return result.map((importResult) => {\n                            return {\n                                'c': importResult.collection.id,\n                                'pks': importResult.primaryKeys,\n                            };\n                        });\n                    }\n                    return {\n                        'c': result.collection.id,\n                        'pks': result.primaryKeys,\n                    };\n                });\n                if (serialized['im']['os']) {\n                    client.registerAction(serialized['im']['os'], async () => {\n                        var _a;\n                        await ((_a = importModal.onSetup) === null || _a === void 0 ? void 0 : _a.call(importModal));\n                    });\n                }\n            }\n        }\n        if (cardIntegration.addCard) {\n            const addCard = cardIntegration.addCard;\n            serialized['ac'] = {\n                'gif': LucidCardIntegrationRegistry.nextHookName(),\n                'cc': LucidCardIntegrationRegistry.nextHookName(),\n            };\n            client.registerAction(serialized['ac']['gif'], async ({ 'i': inputSoFar }) => {\n                const result = await addCard.getInputFields(new Map(inputSoFar));\n                return (0, cardintegrationdefinitions_1.serializeCardFieldArrayDefinition)(result);\n            });\n            client.registerAction(serialized['ac']['cc'], async ({ 'i': input }) => {\n                const result = await addCard.createCardData(new Map(input));\n                return {\n                    'c': result.collection.id,\n                    'pk': result.primaryKey,\n                };\n            });\n        }\n        this.registerDependencyMapping(client, cardIntegration, serialized);\n        client.sendCommand(\"aci\" /* CommandName.AddCardIntegration */, serialized);\n    }\n}\nexports.LucidCardIntegrationRegistry = LucidCardIntegrationRegistry;\nLucidCardIntegrationRegistry.nextHookId = 0;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/checks.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/checks.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInstanceOf = exports.isLiteral = exports.isPromise = exports.isUnknown = exports.isAny = exports.isEmptyOrNullishObject = exports.isPair = exports.isAtLeastLength = exports.isExactLength = exports.isMap = exports.isTypedArray = exports.isArray = exports.isRecord = exports.isObjectUnsafer = exports.isObjectUnsafe = exports.isObject = exports.isFunction = exports.isInfinite = exports.isInt = exports.isNumber = exports.isBoolean = exports.isString = exports.isNullish = exports.isDefAndNotNull = exports.isVoid = exports.isUndefined = exports.isNull = exports.isDef = void 0;\n/**\n * Returns true if the specified value is not undefined.\n *\n * @param val Variable to test.\n * @return Whether variable is defined.\n */\nfunction isDef(val) {\n    return val !== undefined;\n}\nexports.isDef = isDef;\n/**\n * Returns true if the specified value is null.\n * @param val Variable to test.\n * @return Whether variable is null.\n */\nfunction isNull(val) {\n    return val === null;\n}\nexports.isNull = isNull;\n/**\n * Returns true if the specified value is undefined.\n * @param val Variable to test.\n * @return Whether variable is undefined.\n */\nfunction isUndefined(val) {\n    return val === undefined;\n}\nexports.isUndefined = isUndefined;\n/**\n * Returns true if the specified value is undefined.\n * @param val Variable to test.\n * @return Whether variable is undefined.\n */\nfunction isVoid(x) {\n    return x === undefined;\n}\nexports.isVoid = isVoid;\n/**\n * Returns true if the specified value is defined and not null.\n * @param val Variable to test.\n * @return Whether variable is defined and not null.\n */\nfunction isDefAndNotNull(val) {\n    return val != null;\n}\nexports.isDefAndNotNull = isDefAndNotNull;\n/**\n * Returns true if the specified value is null or undefined.\n * @param val Variable to test\n * @return Whether the variable is null or undefined.\n */\nfunction isNullish(val) {\n    return val == null;\n}\nexports.isNullish = isNullish;\n/**\n * Returns true if the specified value is a string.\n * @param val Variable to test.\n * @return Whether variable is a string.\n */\nfunction isString(val) {\n    return typeof val == 'string';\n}\nexports.isString = isString;\n/**\n * Returns true if the specified value is a boolean.\n * @param val Variable to test.\n * @return Whether variable is boolean.\n */\nfunction isBoolean(val) {\n    return typeof val == 'boolean';\n}\nexports.isBoolean = isBoolean;\n/**\n * Returns true if the specified value is a number.\n * @param val Variable to test.\n * @return Whether variable is a number.\n */\nfunction isNumber(val) {\n    return typeof val == 'number';\n}\nexports.isNumber = isNumber;\n/**\n * Returns true if the specified value is an integer.\n * @param val Variable to test.\n * @return Whether variable is an integer.\n */\nfunction isInt(val) {\n    return isNumber(val) && isFinite(val) && val % 1 == 0;\n}\nexports.isInt = isInt;\n/**\n * Returns true if the specified value is either positive or negative infinity.\n * @param val Variable to test.\n * @returns Whether variable is positive or negative infinity.\n */\nfunction isInfinite(val) {\n    return isNumber(val) && !isNaN(val) && !isFinite(val);\n}\nexports.isInfinite = isInfinite;\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\nexports.isFunction = isFunction;\n/**\n * Returns true if the specified value is an object (including arrays and functions) (i.e. it's safe to do property accesses on it).\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isObject(val) {\n    const type = typeof val;\n    return (type == 'object' && val != null) || type == 'function';\n}\nexports.isObject = isObject;\n/**\n * Returns true for objects, includings arrays and functions.\n * Matches the behavior of goog.isObject, with a more permissive type.\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isObjectUnsafe(val) {\n    const type = typeof val;\n    return (type == 'object' && val != null) || type == 'function';\n}\nexports.isObjectUnsafe = isObjectUnsafe;\n/**\n * Returns true for objects, includings arrays and functions.\n * Matches the behavior of goog.isObject, with an extremely permissive type.\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isObjectUnsafer(val) {\n    const type = typeof val;\n    return (type == 'object' && val != null) || type == 'function';\n}\nexports.isObjectUnsafer = isObjectUnsafer;\n/**\n * Returns true if the specified value is an object (i.e. it's safe to do property accesses on it),\n * and every value matches the record type.\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isRecord(typeGuard) {\n    return function (val) {\n        return isObject(val) && Object.values(val).every(typeGuard);\n    };\n}\nexports.isRecord = isRecord;\n/**\n * Returns true if the specified value is an array.\n *\n * This is safer than using Array.isArray directly because it doesn't introduce an `any` type.\n * @param val Variable to test.\n * @return Whether variable is an array.\n */\nfunction isArray(val) {\n    return Array.isArray(val);\n}\nexports.isArray = isArray;\n/**\n * Returns true if the specified value is an array and every element passes the type guard function.\n *\n * @param val Variable to test.\n * @param typeGuard the type guard function to test every element in the array.\n * @return Whether variable is an array of the given type.\n */\nfunction isTypedArray(typeGuard) {\n    return function (val) {\n        return isArray(val) && val.every(typeGuard);\n    };\n}\nexports.isTypedArray = isTypedArray;\n/**\n * Returns true if the specified value is a map.\n *\n * @param val Variable to test.\n * @return Whether variable is a map.\n */\nfunction isMap(val) {\n    return val instanceof Map;\n}\nexports.isMap = isMap;\nfunction isExactLength(arr, exactLength) {\n    return arr.length === exactLength;\n}\nexports.isExactLength = isExactLength;\nfunction isAtLeastLength(arr, minimumLength) {\n    return arr.length >= minimumLength;\n}\nexports.isAtLeastLength = isAtLeastLength;\n/**\n * Returns true if the specified value is a tuple where the first element, T, passes the tGuard function\n * and the second element, U, passes the uGuard function\n * @param tGuard the type guard function to test the first element in the tuple, T\n * @param uGuard the type guard function to test the second element in the tuple, U\n * @returns whether the value is a tuple of the form [T, U]\n */\nfunction isPair(tGuard, uGuard) {\n    return (x) => {\n        return isArray(x) && isExactLength(x, 2) && tGuard(x[0]) && uGuard(x[1]);\n    };\n}\nexports.isPair = isPair;\n/**\n * Returns true if the specified object is either empty or all existing keys map to a nullish value\n *\n * @param val Variable to test\n * @return Whether variable is empty or maps exclusively to nullish values\n */\nfunction isEmptyOrNullishObject(val) {\n    return !(val &&\n        typeof val === 'object' &&\n        Object.keys(val).find((key) => isDefAndNotNull(val[key])));\n}\nexports.isEmptyOrNullishObject = isEmptyOrNullishObject;\n/**\n * @deprecated Prefer isUnknown\n */\nfunction isAny(val) {\n    return true;\n}\nexports.isAny = isAny;\nfunction isUnknown(val) {\n    return true;\n}\nexports.isUnknown = isUnknown;\nfunction isPromise(val) {\n    return isObjectUnsafe(val) && isFunction(val['then']) && isFunction(val['catch']);\n}\nexports.isPromise = isPromise;\nfunction isLiteral(t) {\n    return (x) => x === t;\n}\nexports.isLiteral = isLiteral;\n/**\n * Since `instanceof` should generally be avoided, this function should generally be avoided as well.\n *\n * A valid use case is for native types, like Uint8Array.\n */\nfunction isInstanceOf(klass) {\n    return (x) => x instanceof klass;\n}\nexports.isInstanceOf = isInstanceOf;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/checks.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js":
/*!***************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.alphabet = void 0;\nexports.alphabet = [\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n];\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataSourceType = void 0;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar DataSourceType;\n(function (DataSourceType) {\n    DataSourceType[DataSourceType[\"DeprecatedGoogleSheets\"] = 0] = \"DeprecatedGoogleSheets\";\n    DataSourceType[DataSourceType[\"DeprecatedCSV\"] = 1] = \"DeprecatedCSV\";\n    DataSourceType[DataSourceType[\"DeprecatedExcel\"] = 2] = \"DeprecatedExcel\";\n    DataSourceType[DataSourceType[\"Salesforce\"] = 3] = \"Salesforce\";\n    DataSourceType[DataSourceType[\"Generator\"] = 4] = \"Generator\";\n    DataSourceType[DataSourceType[\"DataService\"] = 5] = \"DataService\";\n    DataSourceType[DataSourceType[\"ForeignKeyOverride\"] = 7] = \"ForeignKeyOverride\";\n    DataSourceType[DataSourceType[\"Extension\"] = 8] = \"Extension\";\n    DataSourceType[DataSourceType[\"Unknown\"] = 9] = \"Unknown\";\n})(DataSourceType || (exports.DataSourceType = DataSourceType = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeSerializedPreviewData = exports.makeSerializedImportedDataSource = exports.makeSerializedImportedCollection = exports.MetadataPK = exports.makeNameReadablyUnique = exports.normalizeName = exports.alphabetize = void 0;\nconst dataupdatefiltertype_1 = __webpack_require__(/*! ../../../data/dataupdatefiltertype */ \"./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js\");\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ../fieldtypedefinition/scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nconst alphabet_1 = __webpack_require__(/*! ./alphabet */ \"./node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js\");\nconst datasourcetype_1 = __webpack_require__(/*! ./datasourcetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\");\nconst spreadsheetpossibledatatypes_1 = __webpack_require__(/*! ./spreadsheetpossibledatatypes */ \"./node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js\");\nconst upstreamupdatetype_1 = __webpack_require__(/*! ./upstreamupdatetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\");\n/** @ignore */\nfunction _alphabetize(n) {\n    if (n == undefined || n < 0) {\n        return '';\n    }\n    else if (n < alphabet_1.alphabet.length) {\n        return alphabet_1.alphabet[n];\n    }\n    else {\n        return alphabetize(Math.floor(n / alphabet_1.alphabet.length) - 1) + alphabetize(n % alphabet_1.alphabet.length);\n    }\n}\n/** @ignore */\nconst memoize = new Map();\n/** @ignore */\nfunction alphabetize(n) {\n    const stored = memoize.get(n);\n    if (stored != null) {\n        return stored;\n    }\n    const value = _alphabetize(n);\n    memoize.set(n, value);\n    return value;\n}\nexports.alphabetize = alphabetize;\n/** @ignore */\nfunction normalizeName(name) {\n    return name.trim().toLowerCase();\n}\nexports.normalizeName = normalizeName;\nconst appendedNumberRegex = /(.*) \\(([0-9]+)\\)$/;\n/** @ignore */\nfunction makeNameReadablyUnique(originalName, usedNamesNormalized, transform = normalizeName) {\n    if (!usedNamesNormalized.has(transform(originalName))) {\n        return originalName;\n    }\n    const match = appendedNumberRegex.exec(originalName);\n    let count = 1;\n    if (match && (0, checks_1.isString)(match[1]) && (0, checks_1.isString)(match[2])) {\n        originalName = match[1];\n        count = Number(match[2]) + 1;\n    }\n    let newName = originalName;\n    do {\n        newName = originalName + ` (${count})`;\n        count++;\n    } while (usedNamesNormalized.has(transform(newName)));\n    return newName;\n}\nexports.makeNameReadablyUnique = makeNameReadablyUnique;\n/** @ignore */\nexports.MetadataPK = '__PK__';\n/** @ignore */\nfunction makePrimaryCollectionSchema(rawSchemaFields, data, schemaFromData) {\n    var _a, _b;\n    const headerRow = (_a = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.headerRow) !== null && _a !== void 0 ? _a : -1;\n    const headerRowData = headerRow >= 0 ? data[headerRow] : undefined;\n    const headerRowAsStringArray = headerRowData &&\n        rawSchemaFields.map((rawSchemaField, index) => {\n            var _a;\n            const headerRowDataAsString = `${(_a = headerRowData[rawSchemaField]) !== null && _a !== void 0 ? _a : ''}`;\n            return headerRowDataAsString.trim() === '' ? alphabetize(index) : headerRowDataAsString;\n        });\n    const schemaFields = headerRowAsStringArray !== null && headerRowAsStringArray !== void 0 ? headerRowAsStringArray : rawSchemaFields;\n    const fields = [];\n    const oldToNewFields = new Map();\n    const usedFieldsNormalized = new Set([normalizeName(exports.MetadataPK)]);\n    schemaFields.forEach((field, index) => {\n        const finalFieldName = makeNameReadablyUnique(field, usedFieldsNormalized);\n        usedFieldsNormalized.add(normalizeName(finalFieldName));\n        fields.push({ 'Name': finalFieldName, 'Type': spreadsheetpossibledatatypes_1.SpreadSheetPossibleDataTypes });\n        oldToNewFields.set(rawSchemaFields[index], finalFieldName);\n    });\n    const oldPrimaryKeys = (_b = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.primaryKey) !== null && _b !== void 0 ? _b : [];\n    const translatedPrimaryKeys = oldPrimaryKeys\n        .map((oldPrimaryKey) => oldToNewFields.get(oldPrimaryKey))\n        .filter(checks_1.isDefAndNotNull); // There should be no untranslatable primary keys, but we need to satisfy the type system\n    return {\n        sheetSchema: {\n            'Fields': fields,\n            'PrimaryKey': translatedPrimaryKeys,\n        },\n        oldToNewFields,\n    };\n}\nfunction getPrimaryKeysForData(oldToNewFields, data, schemaFromData) {\n    if (!schemaFromData || schemaFromData.primaryKey.length === 0) {\n        return data.map((row, index) => `${index + 1}`);\n    }\n    const primaryKey = schemaFromData.primaryKey;\n    const primaryKeyInNewFields = primaryKey.map((oldField) => { var _a; return (_a = oldToNewFields.get(oldField)) !== null && _a !== void 0 ? _a : oldField; });\n    // For reasons I have forgotten, the actual primary key order is determined by the alphabetized name order.\n    const sortedPrimaryKeyInNewFields = primaryKeyInNewFields.slice().sort();\n    const sortedPrimaryKey = sortedPrimaryKeyInNewFields.map((newField) => primaryKey[primaryKeyInNewFields.indexOf(newField)]);\n    const usedNames = new Set();\n    return data.map((serializedField) => {\n        const primaryKeyValues = sortedPrimaryKey.map((key) => serializedField[key]);\n        const compositeValue = JSON.stringify(primaryKeyValues);\n        const nameWithoutContext = compositeValue.slice(1, compositeValue.length - 1);\n        let name = nameWithoutContext;\n        let dupCount = -1;\n        while (usedNames.has(name)) {\n            name = `${nameWithoutContext},${++dupCount}`;\n        }\n        usedNames.add(name);\n        return name;\n    });\n}\n/** @ignore */\nfunction makeMetadataCollection(metadataType, sheetName, dataItems, sheetSchema) {\n    return {\n        'Name': sheetName + '|' + metadataType,\n        'Schema': sheetSchema,\n        'Items': dataItems,\n    };\n}\n/** @ignore */\nfunction makeItemOrderCollection(primaryKeys, sheetName, headerRow) {\n    const itemOrderItems = {};\n    let rowIndex = 0;\n    for (let i = 0; i < primaryKeys.length; i++) {\n        const primaryKey = primaryKeys[i];\n        if (i !== headerRow) {\n            rowIndex++;\n            itemOrderItems[`${rowIndex}`] = { 'Key': `${primaryKey}`, 'Order': rowIndex };\n        }\n    }\n    const itemOrderSchema = {\n        'Fields': [\n            { 'Name': 'Key', 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.STRING },\n            { 'Name': 'Order', 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER },\n        ],\n        'PrimaryKey': ['Order'],\n    };\n    return makeMetadataCollection('ItemOrder', sheetName, itemOrderItems, itemOrderSchema);\n}\n/** @ignore */\nfunction makeHeaderrowMetadataCollection(headerRowPrimaryKey, headerRowData, oldToNewFields, sheetName, schema) {\n    const dataItem = {};\n    for (const [key, field] of Object.entries(headerRowData)) {\n        const newKey = oldToNewFields.get(key);\n        if (newKey) {\n            dataItem[newKey] = field;\n        }\n    }\n    const itemOrderItems = {\n        [headerRowPrimaryKey]: dataItem,\n    };\n    return makeMetadataCollection('HeaderRowMetadata', sheetName, itemOrderItems, schema);\n}\n/** @ignore */\nfunction makeSerializedItems(primaryKeys, rawItems, oldToNewFields, headerRow, isMetadata = false) {\n    const serializedItems = {};\n    rawItems.forEach((rawItem, rowIndex) => {\n        if (isMetadata || rowIndex !== headerRow) {\n            const dataItem = {};\n            for (const [key, field] of Object.entries(rawItem)) {\n                const newKey = oldToNewFields.get(key);\n                if (newKey) {\n                    dataItem[newKey] = field;\n                }\n            }\n            const primaryKey = primaryKeys[rowIndex];\n            if (isMetadata && Object.keys(dataItem).length > 0) {\n                const metadataPrimaryKey = `${primaryKey}`;\n                dataItem[exports.MetadataPK] = metadataPrimaryKey;\n                serializedItems[`${JSON.stringify(metadataPrimaryKey)}`] = dataItem;\n            }\n            else if (!isMetadata) {\n                serializedItems[primaryKey] = dataItem;\n            }\n        }\n    });\n    return serializedItems;\n}\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nfunction makeSerializedImportedCollection(name, rawFieldNames, data, upstreamConfig, dataIsPartial, metadata, schemaFromData) {\n    var _a;\n    const { sheetSchema, oldToNewFields } = makePrimaryCollectionSchema(rawFieldNames, data, schemaFromData);\n    const primaryKeys = getPrimaryKeysForData(oldToNewFields, data, schemaFromData);\n    const headerRow = (_a = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.headerRow) !== null && _a !== void 0 ? _a : -1;\n    const metadataCollections = {};\n    metadataCollections['ItemOrder'] = makeItemOrderCollection(primaryKeys, name, headerRow);\n    if (headerRow > -1 && headerRow < data.length) {\n        const headerRowData = data[headerRow];\n        const headerRowPrimaryKey = primaryKeys[headerRow];\n        metadataCollections['HeaderRowMetadata'] = makeHeaderrowMetadataCollection(headerRowPrimaryKey, headerRowData, oldToNewFields, name, sheetSchema);\n    }\n    if (metadata) {\n        const metadataFields = [{ 'Name': exports.MetadataPK, 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.STRING }];\n        sheetSchema['Fields'].forEach((field) => metadataFields.push({\n            'Name': field['Name'],\n            'Type': [scalarfieldtype_1.ScalarFieldTypeEnum.STRING, scalarfieldtype_1.ScalarFieldTypeEnum.NULL],\n        }));\n        const metadataSchema = { 'Fields': metadataFields, 'PrimaryKey': [exports.MetadataPK] };\n        for (const [type, data] of Object.entries(metadata)) {\n            metadataCollections[type] = makeMetadataCollection(type, name, makeSerializedItems(primaryKeys, data, oldToNewFields, headerRow, true), metadataSchema);\n        }\n    }\n    return {\n        'Name': name,\n        'Schema': sheetSchema,\n        'Items': makeSerializedItems(primaryKeys, data, oldToNewFields, headerRow),\n        'UpstreamConfig': upstreamConfig,\n        'Metadata': metadataCollections,\n        'DataIsPartial': dataIsPartial,\n    };\n}\nexports.makeSerializedImportedCollection = makeSerializedImportedCollection;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nfunction makeSerializedImportedDataSource(id, name, collections) {\n    return {\n        'Properties': {\n            'Name': name,\n            'UpstreamConfig': {\n                'SourceType': datasourcetype_1.DataSourceType.DataService,\n                'UpdateType': upstreamupdatetype_1.UpstreamUpdateType.EVENTPULL,\n                'SourceConfig': {\n                    'spreadsheetId': id,\n                    'UpdateFilterType': dataupdatefiltertype_1.DataUpdateFilterType.CurrentCollectionUpdates,\n                },\n            },\n        },\n        'Collections': collections,\n    };\n}\nexports.makeSerializedImportedDataSource = makeSerializedImportedDataSource;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nfunction makeSerializedPreviewData(id, name, collections) {\n    return {\n        'Properties': {\n            'Name': name,\n            'UpstreamConfig': {\n                'SourceType': datasourcetype_1.DataSourceType.DataService,\n                'UpdateType': upstreamupdatetype_1.UpstreamUpdateType.EVENTPULL,\n                'SourceConfig': {\n                    'spreadsheetId': id,\n                    'UpdateFilterType': dataupdatefiltertype_1.DataUpdateFilterType.CurrentCollectionUpdates,\n                },\n            },\n        },\n        'Collections': collections,\n    };\n}\nexports.makeSerializedPreviewData = makeSerializedPreviewData;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MetadataTypes = void 0;\n// Google Sheets has both notes and comments, we store notes in the comment metadata collection. Comments are not\n// meant to be permanent in Google Sheets whereas they are in Excel, resulting in some confusion with our naming.\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar MetadataTypes;\n(function (MetadataTypes) {\n    MetadataTypes[\"Format\"] = \"Format\";\n    MetadataTypes[\"FillColor\"] = \"FillColor\";\n    MetadataTypes[\"TextColor\"] = \"TextColor\";\n    MetadataTypes[\"Comment\"] = \"Comment\";\n    MetadataTypes[\"Formula\"] = \"Formula\";\n    MetadataTypes[\"HeaderRowMetadata\"] = \"HeaderRowMetadata\";\n    MetadataTypes[\"ExternalLink\"] = \"ExternalLink\";\n})(MetadataTypes || (exports.MetadataTypes = MetadataTypes = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedDataSourceProperties = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializedsourceforeignkey_1 = __webpack_require__(/*! ./serializedsourceforeignkey */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializedsourceforeignkey.js\");\nconst serializedupstreamconfig_1 = __webpack_require__(/*! ./serializedupstreamconfig */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedDataSourceProperties = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'UpstreamConfig': (0, validators_1.nullableOption)(serializedupstreamconfig_1.isSerializedUpstreamConfig),\n    'SourceForeignKeys': (0, validators_1.nullableOption)((0, validators_1.arrayValidator)(serializedsourceforeignkey_1.isSerializedSourceForeignKey)),\n});\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedPreviewData = exports.isSerializedImportedDataSource = exports.isSerializedImportedCollection = exports.isSerializedImportedMetadataCollection = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializeddataitems_1 = __webpack_require__(/*! ../serializedfield/serializeddataitems */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js\");\nconst serializedschema_1 = __webpack_require__(/*! ../serializedfield/serializedschema */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js\");\nconst serializeddatasourceproperties_1 = __webpack_require__(/*! ./serializeddatasourceproperties */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedImportedMetadataCollection = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'Schema': serializedschema_1.isSerializedSchema,\n    'Items': serializeddataitems_1.isSerializedDataItems,\n});\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedImportedCollection = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'Schema': serializedschema_1.isSerializedSchema,\n    'Items': serializeddataitems_1.isSerializedDataItems,\n    'UpstreamConfig': checks_1.isObject,\n    'Metadata': (0, checks_1.isRecord)(exports.isSerializedImportedMetadataCollection),\n    'DataIsPartial': (0, validators_1.option)(validators_1.isTrue),\n});\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedImportedDataSource = (0, validators_1.strictObjectValidator)({\n    'Properties': serializeddatasourceproperties_1.isSerializedDataSourceProperties,\n    'Collections': (0, checks_1.isTypedArray)(exports.isSerializedImportedCollection),\n});\nexports.isSerializedPreviewData = (0, validators_1.strictObjectValidator)({\n    'Properties': serializeddatasourceproperties_1.isSerializedDataSourceProperties,\n    'Collections': (0, checks_1.isTypedArray)((0, validators_1.strictObjectValidator)({\n        'Data': exports.isSerializedImportedCollection,\n        'HeaderRow': (0, validators_1.option)(checks_1.isNumber),\n        'PrimaryKey': (0, validators_1.option)((0, checks_1.isTypedArray)(checks_1.isNumber)),\n    })),\n});\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/serializedsourceforeignkey.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/serializedsourceforeignkey.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedSourceForeignKey = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nexports.isSerializedSourceForeignKey = (0, validators_1.objectValidator)({\n    'Id': checks_1.isString,\n    'SourceFields': (0, validators_1.arrayValidator)(checks_1.isString),\n    'RelationshipType': (0, validators_1.option)(checks_1.isString),\n    'OutwardLabel': checks_1.isString,\n    'InwardLabel': checks_1.isString,\n});\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/serializedsourceforeignkey.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedUpstreamConfig = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst datasourcetype_1 = __webpack_require__(/*! ./datasourcetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\");\nconst upstreampatchtype_1 = __webpack_require__(/*! ./upstreampatchtype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js\");\nconst upstreamupdatetype_1 = __webpack_require__(/*! ./upstreamupdatetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedUpstreamConfig = (0, validators_1.strictObjectValidator)({\n    'SourceType': (0, validators_1.enumValidator)(datasourcetype_1.DataSourceType),\n    'UpdateType': (0, validators_1.enumValidator)(upstreamupdatetype_1.UpstreamUpdateType),\n    'PatchType': (0, validators_1.nullableOption)((0, validators_1.enumValidator)(upstreampatchtype_1.UpstreamPatchType)),\n    'IsSyncingPaused': (0, validators_1.option)((0, checks_1.isLiteral)(true)),\n    'SourceConfig': checks_1.isObject,\n});\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/sourceforeignkeys.js":
/*!************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/sourceforeignkeys.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeSourceForeignKey = exports.serializeSourceForeignKey = void 0;\nfunction serializeSourceForeignKey(foreignKey) {\n    return {\n        'Id': foreignKey.id,\n        'SourceFields': foreignKey.sourceFields,\n        'RelationshipType': foreignKey.relationshipType,\n        'Represents': foreignKey.represents,\n        'OutwardLabel': foreignKey.outwardLabel,\n        'InwardLabel': foreignKey.inwardLabel,\n        'TargetFields': foreignKey.targetFields,\n    };\n}\nexports.serializeSourceForeignKey = serializeSourceForeignKey;\nfunction deserializeSourceForeignKey(foreignKey) {\n    return {\n        'id': foreignKey['Id'],\n        'sourceFields': foreignKey['SourceFields'],\n        'relationshipType': foreignKey['RelationshipType'],\n        'represents': foreignKey['Represents'] === null ? undefined : foreignKey['Represents'],\n        'outwardLabel': foreignKey['OutwardLabel'],\n        'inwardLabel': foreignKey['InwardLabel'],\n        'targetFields': foreignKey['TargetFields'] === null ? undefined : foreignKey['TargetFields'],\n    };\n}\nexports.deserializeSourceForeignKey = deserializeSourceForeignKey;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/sourceforeignkeys.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SpreadSheetPossibleDataTypes = void 0;\nconst scalarfieldtype_1 = __webpack_require__(/*! ../fieldtypedefinition/scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nexports.SpreadSheetPossibleDataTypes = [\n    scalarfieldtype_1.ScalarFieldTypeEnum.BOOLEAN,\n    scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER,\n    scalarfieldtype_1.ScalarFieldTypeEnum.STRING,\n    scalarfieldtype_1.ScalarFieldTypeEnum.NULL,\n    scalarfieldtype_1.ScalarFieldTypeEnum.CURRENCY,\n    scalarfieldtype_1.ScalarFieldTypeEnum.DATE,\n    scalarfieldtype_1.ScalarFieldTypeEnum.DATEONLY,\n    scalarfieldtype_1.ScalarFieldTypeEnum.TIMEONLY,\n    scalarfieldtype_1.ScalarFieldTypeEnum.COLOR,\n];\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedSourceConfig = exports.deserializeUpstreamConfig = exports.serializeUpstreamConfig = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nfunction serializeUpstreamConfig(config) {\n    return {\n        'SourceType': config.dataSourceType,\n        'UpdateType': config.updateType,\n        'PatchType': config.patchType,\n        'IsSyncingPaused': config.isSyncingPaused,\n        'SourceConfig': config.sourceConfig,\n    };\n}\nexports.serializeUpstreamConfig = serializeUpstreamConfig;\nfunction deserializeUpstreamConfig(config) {\n    return Object.assign(Object.assign({ dataSourceType: config['SourceType'], updateType: config['UpdateType'], patchType: config['PatchType'] === null ? undefined : config['PatchType'] }, (config['IsSyncingPaused'] && { isSyncingPaused: true })), { sourceConfig: config['SourceConfig'] });\n}\nexports.deserializeUpstreamConfig = deserializeUpstreamConfig;\nfunction isSerializedSourceConfig(x) {\n    return (0, checks_1.isObject)(x);\n}\nexports.isSerializedSourceConfig = isSerializedSourceConfig;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js":
/*!************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UpstreamPatchType = void 0;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar UpstreamPatchType;\n(function (UpstreamPatchType) {\n    UpstreamPatchType[UpstreamPatchType[\"NONE\"] = 0] = \"NONE\";\n    UpstreamPatchType[UpstreamPatchType[\"MANUAL\"] = 2] = \"MANUAL\";\n    UpstreamPatchType[UpstreamPatchType[\"AUTO\"] = 3] = \"AUTO\";\n})(UpstreamPatchType || (exports.UpstreamPatchType = UpstreamPatchType = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UpstreamUpdateType = void 0;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar UpstreamUpdateType;\n(function (UpstreamUpdateType) {\n    UpstreamUpdateType[UpstreamUpdateType[\"NONE\"] = 0] = \"NONE\";\n    UpstreamUpdateType[UpstreamUpdateType[\"PULL\"] = 1] = \"PULL\";\n    UpstreamUpdateType[UpstreamUpdateType[\"USER\"] = 2] = \"USER\";\n    UpstreamUpdateType[UpstreamUpdateType[\"EVENTPULL\"] = 3] = \"EVENTPULL\";\n})(UpstreamUpdateType || (exports.UpstreamUpdateType = UpstreamUpdateType = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldspecification.js":
/*!**************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldspecification.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FormattedPrimaryKey = exports.declareSchema = void 0;\nfunction isArrayAndAssertReadonly(val) {\n    return Array.isArray(val);\n}\n/**\n * Specifies all the fields that this itegration will be sending to the data-sync service.\n * Give you well typed methods to convert from `YourType[]` to `{[PrimaryKey:string]: YourType}`\n * which is what most of the data sync service calls expect.\n *\n * There is fromItems which does the above will full type information, and fromItems sparse\n * which allows all the fields not part of the primaryKey to be undefined. The former should\n * be used with initial imports, and the latter can be used for updates.\n *\n * If you declare your schema using PrimaryKey values that *exactly* match (case sensitive) the enum values of\n * `collectionenumfieldtype.ts` (e.g. using a key with the value \"id\" for your ID field) you will be opting in to some\n * additional (and valuable) user functionality. This includes better support in the edit panel, and better user facing\n * descriptions of your fields.\n */\nfunction declareSchema({ primaryKey, fields }) {\n    const primaryKeyObj = new FormattedPrimaryKey(...primaryKey);\n    return {\n        example: fields,\n        array: Object.entries(fields).map(([name, { type, constraints, mapping }]) => {\n            return {\n                'name': name,\n                'type': isArrayAndAssertReadonly(type) ? type.slice() : type,\n                'constraints': constraints,\n                'mapping': mapping,\n            };\n        }),\n        primaryKey: primaryKeyObj,\n        fromItemsSparse: (items) => {\n            return new Map(items.map((item) => [primaryKeyObj.forItem(item), item]));\n        },\n        fromItems: (items) => {\n            return new Map(items.map((item) => [primaryKeyObj.forItem(item), item]));\n        },\n    };\n}\nexports.declareSchema = declareSchema;\n/**\n * Generates a mapper that, given a primary key definition is able to produce the primary key for that item.\n **/\nclass FormattedPrimaryKey {\n    constructor(...elements) {\n        this.elements = [...elements].sort();\n    }\n    /**\n     * Generate the serialized form of the item's primary key.\n     *\n     * For single value primary keys, the encoded values are just the json representation of the primary\n     * key. For example, if the primary key is ['id'] the following table shows encodings:\n     *\n     * | type    | value     | encoded                            |\n     * |---------|-----------|------------------------------------|\n     * | number  | `15`      | `new Map([[\"15\", ...], ...])`      |\n     * | boolean | `false`   | `new Map([[\"false\", ...], ...])`   |\n     * | string  | `\"hello\"` | `new Map([['\"hello\"', ...], ...])` |\n     *\n     * Take note of the extra quotes in the string case.\n     *\n     * For primary keys with multiple values, first sort the array of primary keys then join the json encoded values\n     * from of the keys with commas. For example:\n     *\n     * ```\n     * primary key = [\"lastName\", \"firstName\"]\n     * sorted key = [\"firstName\", \"lastName\"]\n     * row = {\"lastName\": \"Smith\", \"firstName\": \"John\", \"age\": 42}\n     * row key = '\"John\",\"Smith\"'\n     * items = new Map([['\"John\",\"Smith\"', {\"lastName\": \"Smith\", \"firstName\": \"John\", \"age\": 42}]])\n     * ```\n     */\n    forItem(item) {\n        return FormattedPrimaryKey.serializeList(this.elements.map((field) => item[field]));\n    }\n    static serializeList(items) {\n        let pk = JSON.stringify(items);\n        pk = pk.substring(1, pk.length - 1);\n        return pk;\n    }\n}\nexports.FormattedPrimaryKey = FormattedPrimaryKey;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldspecification.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedBaseFieldTypeDefinition = exports.deserializeBaseFieldTypeDefinition = exports.serializeBaseFieldTypeDefinition = exports.isBaseFieldTypeDefinition = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst collectionenumfieldtype_1 = __webpack_require__(/*! ./collectionenumfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\");\nconst deserializedmapenumfieldtype_1 = __webpack_require__(/*! ./deserializedmapenumfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/deserializedmapenumfieldtype.js\");\nconst fieldtypearray_1 = __webpack_require__(/*! ./fieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst ndimensionalfieldtypearray_1 = __webpack_require__(/*! ./ndimensionalfieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nfunction isBaseFieldTypeDefinition(fieldType) {\n    return ((0, scalarfieldtype_1.isScalarFieldTypeEnum)(fieldType) ||\n        (0, literalfieldtype_1.isLiteralFieldType)(fieldType) ||\n        fieldType instanceof fieldtypearray_1.FieldTypeArray ||\n        fieldType instanceof ndimensionalfieldtypearray_1.NDimensionalFieldTypeArray ||\n        (0, collectionenumfieldtype_1.isCollectionEnumFieldType)(fieldType) ||\n        (0, deserializedmapenumfieldtype_1.isDeserializedMapEnumFieldType)(fieldType));\n}\nexports.isBaseFieldTypeDefinition = isBaseFieldTypeDefinition;\nfunction serializeBaseFieldTypeDefinition(baseFieldType) {\n    // Unfortunately there's no easy way to do goog.DEBUG checks inside lucid-extension-sdk right now.\n    // if (goog.DEBUG && !isBaseFieldTypeDefinition(baseFieldType)) {\n    //     throw new Error(`Passed non-BaseFieldTypeDefinition into serializeBaseFieldTypeDefinition()!`);\n    // }\n    if (baseFieldType instanceof literalfieldtype_1.LiteralFieldType ||\n        baseFieldType instanceof fieldtypearray_1.FieldTypeArray ||\n        baseFieldType instanceof ndimensionalfieldtypearray_1.NDimensionalFieldTypeArray ||\n        baseFieldType instanceof collectionenumfieldtype_1.CollectionEnumFieldType ||\n        baseFieldType instanceof deserializedmapenumfieldtype_1.DeserializedMapEnumFieldType) {\n        return baseFieldType.toJSON();\n    }\n    return baseFieldType;\n}\nexports.serializeBaseFieldTypeDefinition = serializeBaseFieldTypeDefinition;\nfunction deserializeBaseFieldTypeDefinition(baseFieldType) {\n    if ((0, literalfieldtype_1.isSerializedLiteralFieldType)(baseFieldType)) {\n        return (0, literalfieldtype_1.deserializeLiteralFieldType)(baseFieldType);\n    }\n    if ((0, collectionenumfieldtype_1.isSerializedCollectionEnumFieldType)(baseFieldType)) {\n        return (0, collectionenumfieldtype_1.deserializeCollectionEnumFieldType)(baseFieldType);\n    }\n    if ((0, fieldtypearray_1.isSerializedFieldTypeArray)(baseFieldType, isSerializedBaseFieldTypeDefinition)) {\n        return (0, fieldtypearray_1.deserializeFieldTypeArray)(baseFieldType);\n    }\n    if ((0, ndimensionalfieldtypearray_1.isSerializedNDimensionalFieldTypeArray)(baseFieldType)) {\n        return (0, ndimensionalfieldtypearray_1.deserializeNDimensionalFieldTypeArray)(baseFieldType);\n    }\n    if ((0, deserializedmapenumfieldtype_1.isSerializedMapEnumFieldType)(baseFieldType)) {\n        return deserializedmapenumfieldtype_1.DeserializedMapEnumFieldType.fromJSON(baseFieldType);\n    }\n    return baseFieldType;\n}\nexports.deserializeBaseFieldTypeDefinition = deserializeBaseFieldTypeDefinition;\nfunction isSerializedBaseFieldTypeDefinition(definition) {\n    return ((0, checks_1.isDefAndNotNull)(scalarfieldtype_1.ScalarFieldTypeEnum[definition]) ||\n        (0, literalfieldtype_1.isSerializedLiteralFieldType)(definition) ||\n        (0, collectionenumfieldtype_1.isSerializedCollectionEnumFieldType)(definition) ||\n        (0, fieldtypearray_1.isSerializedFieldTypeArray)(definition, isSerializedBaseFieldTypeDefinition) ||\n        (0, ndimensionalfieldtypearray_1.isSerializedNDimensionalFieldTypeArray)(definition) ||\n        (0, deserializedmapenumfieldtype_1.isSerializedMapEnumFieldType)(definition));\n}\nexports.isSerializedBaseFieldTypeDefinition = isSerializedBaseFieldTypeDefinition;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedCollectionEnumFieldType = exports.deserializeCollectionEnumFieldType = exports.isCollectionEnumFieldType = exports.CollectionEnumFieldType = exports.isCollectionEnumFieldNames = exports.CollectionEnumFieldNames = exports.CollectionEnumFieldTypeKey = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nexports.CollectionEnumFieldTypeKey = 'COLLECTION_ENUM';\n/**\n * Contains the field names of all valid fields for a groovy metadata collection.\n *\n * This should be kept in sync with GroovyFieldNames in FieldType.scala\n */\nvar CollectionEnumFieldNames;\n(function (CollectionEnumFieldNames) {\n    CollectionEnumFieldNames[\"Name\"] = \"name\";\n    CollectionEnumFieldNames[\"Id\"] = \"id\";\n    CollectionEnumFieldNames[\"Description\"] = \"description\";\n    CollectionEnumFieldNames[\"Color\"] = \"color\";\n    CollectionEnumFieldNames[\"IconUrl\"] = \"iconUrl\";\n})(CollectionEnumFieldNames || (exports.CollectionEnumFieldNames = CollectionEnumFieldNames = {}));\nexports.isCollectionEnumFieldNames = (0, validators_1.enumValidator)(CollectionEnumFieldNames);\nclass CollectionEnumFieldType {\n    constructor(collectionId) {\n        this.collectionId = collectionId;\n    }\n    toJSON() {\n        return { [exports.CollectionEnumFieldTypeKey]: this.collectionId };\n    }\n}\nexports.CollectionEnumFieldType = CollectionEnumFieldType;\n/**\n * Specifies which groovy field name is used as the primary key.\n *\n * This should be kept in sync with GroovyFieldNames in FieldType.scala\n */\nCollectionEnumFieldType.PRIMARY_KEY = CollectionEnumFieldNames.Id;\nconst isCollectionEnumFieldType = (fieldType) => {\n    return fieldType instanceof CollectionEnumFieldType;\n};\nexports.isCollectionEnumFieldType = isCollectionEnumFieldType;\nfunction deserializeCollectionEnumFieldType(serializedCollectionEnumFieldType) {\n    return new CollectionEnumFieldType(serializedCollectionEnumFieldType[exports.CollectionEnumFieldTypeKey]);\n}\nexports.deserializeCollectionEnumFieldType = deserializeCollectionEnumFieldType;\nfunction isSerializedCollectionEnumFieldType(fieldType) {\n    return (0, checks_1.isObjectUnsafe)(fieldType) && (0, checks_1.isString)(fieldType[exports.CollectionEnumFieldTypeKey]);\n}\nexports.isSerializedCollectionEnumFieldType = isSerializedCollectionEnumFieldType;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/deserializedmapenumfieldtype.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/deserializedmapenumfieldtype.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeEnumEntry = exports.serializeEnumEntry = exports.isSerializedEnumEntry = exports.isSerializedMapEnumFieldType = exports.isDeserializedMapEnumFieldType = exports.DeserializedMapEnumFieldType = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nclass DeserializedMapEnumFieldType {\n    constructor(validEntries) {\n        this.validEntries = validEntries;\n    }\n    toJSON() {\n        return {\n            'ValidItems': [...this.validEntries.entries()].map(([key, value]) => serializeEnumEntry(key, value)),\n        };\n    }\n    static fromJSON(val) {\n        return new DeserializedMapEnumFieldType(new Map(val['ValidItems'].map(deserializeEnumEntry)));\n    }\n}\nexports.DeserializedMapEnumFieldType = DeserializedMapEnumFieldType;\nfunction isDeserializedMapEnumFieldType(val) {\n    return val instanceof DeserializedMapEnumFieldType;\n}\nexports.isDeserializedMapEnumFieldType = isDeserializedMapEnumFieldType;\nfunction isSerializedMapEnumFieldType(fieldType) {\n    return ((0, checks_1.isObjectUnsafe)(fieldType) &&\n        Array.isArray(fieldType['ValidItems']) &&\n        fieldType['ValidItems'].every(isSerializedEnumEntry));\n}\nexports.isSerializedMapEnumFieldType = isSerializedMapEnumFieldType;\nfunction isSerializedEnumEntry(entry) {\n    return ((0, checks_1.isObjectUnsafe)(entry) &&\n        (0, checks_1.isString)(entry['Id']) &&\n        (0, validators_1.nullableOption)(checks_1.isString)(entry['Name']) &&\n        (0, validators_1.nullableOption)(checks_1.isString)(entry['Description']) &&\n        (0, validators_1.nullableOption)(checks_1.isString)(entry['Color']) &&\n        (0, validators_1.nullableOption)(checks_1.isString)(entry['IconUrl']));\n}\nexports.isSerializedEnumEntry = isSerializedEnumEntry;\nfunction serializeEnumEntry(id, entry) {\n    return {\n        'Id': id,\n        'Name': entry.name,\n        'Description': entry.description,\n        'Color': entry.color,\n        'IconUrl': entry.iconUrl,\n    };\n}\nexports.serializeEnumEntry = serializeEnumEntry;\nfunction deserializeEnumEntry(entry) {\n    return [\n        entry['Id'],\n        {\n            name: entry['Name'],\n            description: entry['Description'],\n            color: entry['Color'],\n            iconUrl: entry['IconUrl'],\n        },\n    ];\n}\nexports.deserializeEnumEntry = deserializeEnumEntry;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/deserializedmapenumfieldtype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeFieldTypeArray = exports.isSerializedFieldTypeArray = exports.FieldTypeArray = exports.BaseFieldTypeArray = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst collectionenumfieldtype_1 = __webpack_require__(/*! ./collectionenumfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\");\nconst deserializedmapenumfieldtype_1 = __webpack_require__(/*! ./deserializedmapenumfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/deserializedmapenumfieldtype.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nclass BaseFieldTypeArray {\n    constructor(validTypesArray) {\n        this.validTypesArray = validTypesArray;\n    }\n    getInnerTypes() {\n        return this.validTypesArray;\n    }\n    getInnerNonArrayTypes() {\n        return this.validTypesArray.filter((innerType) => !(innerType instanceof BaseFieldTypeArray));\n    }\n    toJSON() {\n        return {\n            'ND': false,\n            'validTypes': this.validTypesArray.map((t) => this.serializeType(t)),\n        };\n    }\n}\nexports.BaseFieldTypeArray = BaseFieldTypeArray;\nclass FieldTypeArray extends BaseFieldTypeArray {\n    serializeType(t) {\n        return (0, scalarfieldtype_1.isScalarFieldTypeEnum)(t) ? t : t.toJSON();\n    }\n}\nexports.FieldTypeArray = FieldTypeArray;\nfunction isSerializedFieldTypeArray(fieldType, validateTypeCheck) {\n    return ((0, checks_1.isObjectUnsafe)(fieldType) &&\n        (0, checks_1.isBoolean)(fieldType['ND']) &&\n        fieldType['ND'] === false &&\n        (0, checks_1.isArray)(fieldType['validTypes']) &&\n        fieldType['validTypes'].every((validType) => {\n            return validateTypeCheck(validType);\n        }));\n}\nexports.isSerializedFieldTypeArray = isSerializedFieldTypeArray;\nfunction deserializeFieldTypeArray(serializedFieldTypeArray) {\n    return new FieldTypeArray(serializedFieldTypeArray['validTypes'].map((t) => {\n        if ((0, literalfieldtype_1.isSerializedLiteralFieldType)(t)) {\n            return (0, literalfieldtype_1.deserializeLiteralFieldType)(t);\n        }\n        else if ((0, collectionenumfieldtype_1.isSerializedCollectionEnumFieldType)(t)) {\n            return (0, collectionenumfieldtype_1.deserializeCollectionEnumFieldType)(t);\n        }\n        else if ((0, deserializedmapenumfieldtype_1.isSerializedMapEnumFieldType)(t)) {\n            return deserializedmapenumfieldtype_1.DeserializedMapEnumFieldType.fromJSON(t);\n        }\n        else if ((0, checks_1.isObject)(t)) {\n            return deserializeFieldTypeArray(t);\n        }\n        return t;\n    }));\n}\nexports.deserializeFieldTypeArray = deserializeFieldTypeArray;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFieldTypeDefinition = exports.deserializeFieldTypeDefinition = exports.serializeFieldTypeDefinition = exports.fieldTypesEqual = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst basefieldtypedefinition_1 = __webpack_require__(/*! ./basefieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js\");\nconst collectionenumfieldtype_1 = __webpack_require__(/*! ./collectionenumfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\");\nconst deserializedmapenumfieldtype_1 = __webpack_require__(/*! ./deserializedmapenumfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/deserializedmapenumfieldtype.js\");\nconst fieldtypearray_1 = __webpack_require__(/*! ./fieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst ndimensionalfieldtypearray_1 = __webpack_require__(/*! ./ndimensionalfieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js\");\nfunction fieldTypesEqual(a, b, checkEnumCollectionId = true) {\n    if (a === b) {\n        return true;\n    }\n    if ((0, literalfieldtype_1.isLiteralFieldType)(a) && (0, literalfieldtype_1.isLiteralFieldType)(b)) {\n        return a.getLiteral() === b.getLiteral();\n    }\n    if ((0, collectionenumfieldtype_1.isCollectionEnumFieldType)(a) && (0, collectionenumfieldtype_1.isCollectionEnumFieldType)(b)) {\n        return checkEnumCollectionId ? a.collectionId === b.collectionId : true;\n    }\n    if ((0, deserializedmapenumfieldtype_1.isDeserializedMapEnumFieldType)(a) && (0, deserializedmapenumfieldtype_1.isDeserializedMapEnumFieldType)(b)) {\n        for (const [key, value] of a.validEntries.entries()) {\n            if (!b.validEntries.has(key) || b.validEntries.get(key) !== value) {\n                return false;\n            }\n        }\n        return true;\n    }\n    a = (0, checks_1.isArray)(a) ? a : [a];\n    b = (0, checks_1.isArray)(b) ? b : [b];\n    const setA = new Set(a);\n    const setB = new Set(b);\n    if (setA.size !== setB.size) {\n        return false;\n    }\n    for (const bItem of setB) {\n        if (setA.has(bItem)) {\n            continue;\n        }\n        if ((0, literalfieldtype_1.isLiteralFieldType)(bItem)) {\n            const found = a.some((aItem) => (0, literalfieldtype_1.isLiteralFieldType)(aItem) && fieldTypesEqual(aItem, bItem));\n            if (!found) {\n                return false;\n            }\n        }\n        else if (bItem instanceof fieldtypearray_1.FieldTypeArray) {\n            const found = a.some((aItem) => aItem instanceof fieldtypearray_1.FieldTypeArray && fieldTypesEqual(aItem.validTypesArray, bItem.validTypesArray));\n            if (!found) {\n                return false;\n            }\n        }\n        else if ((0, ndimensionalfieldtypearray_1.isNDimensionalFieldTypeArray)(bItem)) {\n            const aItem = a.find(ndimensionalfieldtypearray_1.isNDimensionalFieldTypeArray);\n            if (!aItem || !fieldTypesEqual(aItem.validTypesArray, bItem.validTypesArray)) {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\nexports.fieldTypesEqual = fieldTypesEqual;\nfunction serializeFieldTypeDefinition(fieldType) {\n    if ((0, checks_1.isArray)(fieldType)) {\n        return fieldType.map(basefieldtypedefinition_1.serializeBaseFieldTypeDefinition);\n    }\n    else {\n        return (0, basefieldtypedefinition_1.serializeBaseFieldTypeDefinition)(fieldType);\n    }\n}\nexports.serializeFieldTypeDefinition = serializeFieldTypeDefinition;\nfunction deserializeFieldTypeDefinition(serializedFieldType) {\n    if ((0, checks_1.isArray)(serializedFieldType)) {\n        return serializedFieldType.map(basefieldtypedefinition_1.deserializeBaseFieldTypeDefinition);\n    }\n    return (0, basefieldtypedefinition_1.deserializeBaseFieldTypeDefinition)(serializedFieldType);\n}\nexports.deserializeFieldTypeDefinition = deserializeFieldTypeDefinition;\nfunction isSerializedFieldTypeDefinition(definition) {\n    if ((0, checks_1.isArray)(definition)) {\n        return definition.every(basefieldtypedefinition_1.isSerializedBaseFieldTypeDefinition);\n    }\n    return (0, basefieldtypedefinition_1.isSerializedBaseFieldTypeDefinition)(definition);\n}\nexports.isSerializedFieldTypeDefinition = isSerializedFieldTypeDefinition;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeLiteralFieldType = exports.isSerializedLiteralFieldType = exports.isLiteralFieldType = exports.LiteralFieldType = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nclass LiteralFieldType {\n    constructor(literal) {\n        this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.ANY;\n        if ((0, checks_1.isString)(literal)) {\n            this.literal = literal.substring(LiteralFieldType.literalStringPrefix.length);\n            this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.STRING;\n        }\n        else if ((0, checks_1.isBoolean)(literal)) {\n            this.literal = literal;\n            this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.BOOLEAN;\n        }\n        else {\n            this.literal = literal;\n            this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER;\n        }\n    }\n    getLiteral() {\n        return this.literal;\n    }\n    getScalarFieldType() {\n        return this.scalarFieldType;\n    }\n    toJSON() {\n        if (this.scalarFieldType === scalarfieldtype_1.ScalarFieldTypeEnum.STRING) {\n            return LiteralFieldType.literalStringPrefix + this.literal;\n        }\n        return this.literal.toString();\n    }\n}\nexports.LiteralFieldType = LiteralFieldType;\nLiteralFieldType.literalStringPrefix = '%';\nfunction isLiteralFieldType(fieldType) {\n    return fieldType instanceof LiteralFieldType;\n}\nexports.isLiteralFieldType = isLiteralFieldType;\nfunction isSerializedLiteralFieldType(definition) {\n    return (0, checks_1.isString)(definition);\n}\nexports.isSerializedLiteralFieldType = isSerializedLiteralFieldType;\n/**\n * String literals without the literalStringPrefix will return the boolean literal false\n */\nfunction deserializeLiteralFieldType(serializedLiteralFieldType) {\n    if (serializedLiteralFieldType.startsWith(LiteralFieldType.literalStringPrefix)) {\n        return new LiteralFieldType(serializedLiteralFieldType);\n    }\n    const numberLiteral = Number(serializedLiteralFieldType);\n    if (isNaN(numberLiteral) ||\n        numberLiteral === Number.POSITIVE_INFINITY ||\n        numberLiteral === Number.NEGATIVE_INFINITY) {\n        return new LiteralFieldType(serializedLiteralFieldType === 'true');\n    }\n    return new LiteralFieldType(numberLiteral);\n}\nexports.deserializeLiteralFieldType = deserializeLiteralFieldType;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/lucidfields.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/lucidfields.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLucidFields = exports.LucidFields = void 0;\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * Lucid Fields serve as standardized categories that transcend individual data source labels, facilitating\n * a uniform way to access and manipulate data. For instance, regardless of the source, data that pertains to \"titles\"\n * or \"user information\" often carries the same kind of information, though it may be labeled differently across systems.\n * Lucid Fields ensure that such data is recognized and treated consistently within the platform,\n * regardless of external labeling conventions.\n *\n * Semantic Mapping is the process through which Lucid aligns these disparate field names to a set of standardized\n * Lucid Fields. By using Lucid Fields like Title, Description, User, and Project, Lucid simplifies the way\n * users access and interact with data brought in from external sources.\n *\n * Benefits of Lucid Fields:\n * Uniformity: Ensures that data from diverse sources is referenced consistently within Lucid.\n * Integration Simplicity: Simplifies the process of integrating new data sources into Lucid by mapping to an established set of Lucid Fields.\n * Feature Compatibility: Allows for seamless use of Lucid’s intelligent features across all data, regardless of its origin.\n * Data Organization: Provides a structured approach to organizing and grouping data within the Lucid ecosystem.\n *\n * Must be kept in sync with src/jvm/com/lucidchart/data/model/fielddefinition/LucidFields.scala\n */\nvar LucidFields;\n(function (LucidFields) {\n    /**\n     * Represents the title or main descriptor of an item.\n     */\n    LucidFields[\"Title\"] = \"title\";\n    /**\n     * Captures detailed information or a summary about an item.\n     */\n    LucidFields[\"Description\"] = \"description\";\n    /**\n     * Refers to the user associated with or assigned to an item.\n     */\n    LucidFields[\"User\"] = \"user\";\n    /**\n     * Specific to the reporting user, typically in the context of a ticketing system.\n     */\n    LucidFields[\"Reporter\"] = \"user.reporter\";\n    /**\n     * Refers to the time associated with an item.\n     */\n    LucidFields[\"Time\"] = \"time\";\n    /**\n     * Pertains to the ending or completion time of an item.\n     */\n    LucidFields[\"EndTime\"] = \"time.endtime\";\n    /**\n     * Contains estimations related to items, like time or resource estimates.\n     */\n    LucidFields[\"Estimate\"] = \"estimate\";\n    /**\n     * Reflects status of an item, typically in the context of a ticketing system.\n     */\n    LucidFields[\"Status\"] = \"status\";\n    /**\n     * Classifies the type of issue or item, typically in the context of a ticketing system.\n     */\n    LucidFields[\"IssueType\"] = \"issuetype\";\n    /**\n     * Indicates the importance or urgency level of an item.\n     */\n    LucidFields[\"Priority\"] = \"priority\";\n    /**\n     * Relates to the project with which an item is associated.\n     */\n    LucidFields[\"Project\"] = \"project\";\n    /**\n     * The unique URL or identifier linking back to the item’s source.\n     */\n    LucidFields[\"SourceItemUrl\"] = \"url\";\n    /**\n     * Refers to the URL of the image associated with this item\n     */\n    LucidFields[\"ImageUrl\"] = \"url.image\";\n    /**\n     * Represents the sprint or time interval this item is assigned to.\n     */\n    LucidFields[\"Sprint\"] = \"sprint\";\n    /**\n     * Refers to the team associated with or responsible for this item.\n     */\n    LucidFields[\"Team\"] = \"team\";\n    /**\n     * Refers to the parent item this item belongs to.\n     */\n    LucidFields[\"Parent\"] = \"parent\";\n})(LucidFields || (exports.LucidFields = LucidFields = {}));\nexports.isLucidFields = (0, validators_1.stringEnumValidator)(LucidFields);\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/lucidfields.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeNDimensionalFieldTypeArray = exports.isSerializedNDimensionalFieldTypeArray = exports.isNDimensionalFieldTypeArray = exports.isValidTypeForNDimensionalFieldTypeArray = exports.NDimensionalFieldTypeArray = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nclass NDimensionalFieldTypeArray {\n    constructor(validTypesArray) {\n        this.validTypesArray = validTypesArray;\n    }\n    getInnerTypes() {\n        return [...this.validTypesArray, this];\n    }\n    getInnerNonArrayTypes() {\n        return this.validTypesArray.filter((innerType) => (0, scalarfieldtype_1.isScalarFieldTypeEnum)(innerType) || (0, literalfieldtype_1.isLiteralFieldType)(innerType));\n    }\n    toJSON() {\n        return {\n            'ND': true,\n            'validTypes': this.validTypesArray.map((t) => ((0, scalarfieldtype_1.isScalarFieldTypeEnum)(t) ? t : t.toJSON())),\n        };\n    }\n}\nexports.NDimensionalFieldTypeArray = NDimensionalFieldTypeArray;\nfunction isValidTypeForNDimensionalFieldTypeArray(fieldType) {\n    return (0, scalarfieldtype_1.isScalarFieldTypeEnum)(fieldType) || (0, literalfieldtype_1.isLiteralFieldType)(fieldType);\n}\nexports.isValidTypeForNDimensionalFieldTypeArray = isValidTypeForNDimensionalFieldTypeArray;\nfunction isNDimensionalFieldTypeArray(fieldType) {\n    return fieldType instanceof NDimensionalFieldTypeArray;\n}\nexports.isNDimensionalFieldTypeArray = isNDimensionalFieldTypeArray;\nfunction isSerializedNDimensionalFieldTypeArray(fieldType) {\n    return ((0, checks_1.isObjectUnsafe)(fieldType) &&\n        (0, checks_1.isBoolean)(fieldType['ND']) &&\n        fieldType['ND'] === true &&\n        (0, checks_1.isTypedArray)(checks_1.isAny)(fieldType['validTypes']) &&\n        fieldType['validTypes'].every((validType) => {\n            return (0, checks_1.isDefAndNotNull)(scalarfieldtype_1.ScalarFieldTypeEnum[validType]) || (0, literalfieldtype_1.isSerializedLiteralFieldType)(validType);\n        }));\n}\nexports.isSerializedNDimensionalFieldTypeArray = isSerializedNDimensionalFieldTypeArray;\nfunction deserializeNDimensionalFieldTypeArray(serializedNDimensionalFieldTypeArray) {\n    return new NDimensionalFieldTypeArray(serializedNDimensionalFieldTypeArray['validTypes'].map((t) => {\n        if ((0, literalfieldtype_1.isSerializedLiteralFieldType)(t)) {\n            return (0, literalfieldtype_1.deserializeLiteralFieldType)(t);\n        }\n        return t;\n    }));\n}\nexports.deserializeNDimensionalFieldTypeArray = deserializeNDimensionalFieldTypeArray;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isScalarFieldTypeEnum = exports.AnyScalarFieldType = exports.ScalarFieldTypeEnum = void 0;\nvar ScalarFieldTypeEnum;\n(function (ScalarFieldTypeEnum) {\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"ANY\"] = 0] = \"ANY\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"NUMBER\"] = 1] = \"NUMBER\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"BOOLEAN\"] = 2] = \"BOOLEAN\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"STRING\"] = 3] = \"STRING\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"COLOR\"] = 4] = \"COLOR\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"DATE\"] = 5] = \"DATE\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"NULL\"] = 6] = \"NULL\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"DICTIONARY\"] = 7] = \"DICTIONARY\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"CURRENCY\"] = 8] = \"CURRENCY\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"DATEONLY\"] = 9] = \"DATEONLY\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"TIMEONLY\"] = 10] = \"TIMEONLY\";\n})(ScalarFieldTypeEnum || (exports.ScalarFieldTypeEnum = ScalarFieldTypeEnum = {}));\nexports.AnyScalarFieldType = [\n    ScalarFieldTypeEnum.ANY,\n    ScalarFieldTypeEnum.NUMBER,\n    ScalarFieldTypeEnum.STRING,\n    ScalarFieldTypeEnum.BOOLEAN,\n    ScalarFieldTypeEnum.COLOR,\n    ScalarFieldTypeEnum.DATE,\n    ScalarFieldTypeEnum.DATEONLY,\n    ScalarFieldTypeEnum.NULL,\n    ScalarFieldTypeEnum.DICTIONARY,\n    ScalarFieldTypeEnum.CURRENCY,\n    ScalarFieldTypeEnum.TIMEONLY,\n];\nconst AnyScalarFieldTypeSet = new Set(exports.AnyScalarFieldType);\nconst isScalarFieldTypeEnum = (fieldType) => {\n    return AnyScalarFieldTypeSet.has(fieldType);\n};\nexports.isScalarFieldTypeEnum = isScalarFieldTypeEnum;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSemanticFields = exports.SemanticFields = void 0;\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * @deprecated use LucidFields instead. SemanticFields has not been removed to ensure backwards compatability.\n */\nvar SemanticFields;\n(function (SemanticFields) {\n    SemanticFields[\"Title\"] = \"title\";\n    SemanticFields[\"Description\"] = \"description\";\n    SemanticFields[\"User\"] = \"user\";\n    SemanticFields[\"Reporter\"] = \"user.reporter\";\n    SemanticFields[\"Time\"] = \"time\";\n    SemanticFields[\"EndTime\"] = \"time.endtime\";\n    SemanticFields[\"Estimate\"] = \"estimate\";\n    SemanticFields[\"Status\"] = \"status\";\n    SemanticFields[\"IssueType\"] = \"issuetype\";\n    SemanticFields[\"Priority\"] = \"priority\";\n    SemanticFields[\"Project\"] = \"project\";\n    SemanticFields[\"SourceItemUrl\"] = \"url\";\n    SemanticFields[\"ImageUrl\"] = \"url.image\";\n})(SemanticFields || (exports.SemanticFields = SemanticFields = {}));\n/**\n * @deprecated use isLucidFields instead\n */\nexports.isSemanticFields = (0, validators_1.stringEnumValidator)(SemanticFields);\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.semanticKindToSemanticFields = exports.semanticKindToLucidFields = exports.isSemanticKind = exports.SemanticKind = void 0;\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst lucidfields_1 = __webpack_require__(/*! ./lucidfields */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/lucidfields.js\");\nconst semanticfields_1 = __webpack_require__(/*! ./semanticfields */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js\");\n/**\n * @deprecated use LucidFields instead. SemanticKind has not been removed to ensure backwards compatability.\n */\nvar SemanticKind;\n(function (SemanticKind) {\n    SemanticKind[\"Id\"] = \"id\";\n    SemanticKind[\"Title\"] = \"title\";\n    SemanticKind[\"Name\"] = \"name\";\n    SemanticKind[\"Image\"] = \"image\";\n    SemanticKind[\"Description\"] = \"description\";\n    SemanticKind[\"Assignee\"] = \"assignee\";\n    SemanticKind[\"Estimate\"] = \"estimate\";\n    SemanticKind[\"Status\"] = \"status\";\n    SemanticKind[\"IssueType\"] = \"issuetype\";\n    SemanticKind[\"Priority\"] = \"priority\";\n    SemanticKind[\"Project\"] = \"project\";\n    SemanticKind[\"Reporter\"] = \"reporter\";\n    SemanticKind[\"StartTime\"] = \"starttime\";\n    SemanticKind[\"EndTime\"] = \"endtime\";\n    SemanticKind[\"GroupByHint\"] = \"groupbyhint\";\n    SemanticKind[\"PrimaryKeyReference\"] = \"primarykeyreference\";\n    SemanticKind[\"URL\"] = \"url\";\n})(SemanticKind || (exports.SemanticKind = SemanticKind = {}));\nexports.isSemanticKind = (0, validators_1.enumValidator)(SemanticKind);\nfunction semanticKindToLucidFields(semanticField) {\n    if ((0, lucidfields_1.isLucidFields)(semanticField)) {\n        return semanticField;\n    }\n    else if ((0, semanticfields_1.isSemanticFields)(semanticField)) {\n        switch (semanticField) {\n            case semanticfields_1.SemanticFields.Title:\n                return lucidfields_1.LucidFields.Title;\n            case semanticfields_1.SemanticFields.Description:\n                return lucidfields_1.LucidFields.Description;\n            case semanticfields_1.SemanticFields.User:\n                return lucidfields_1.LucidFields.User;\n            case semanticfields_1.SemanticFields.Reporter:\n                return lucidfields_1.LucidFields.Reporter;\n            case semanticfields_1.SemanticFields.Time:\n                return lucidfields_1.LucidFields.Time;\n            case semanticfields_1.SemanticFields.EndTime:\n                return lucidfields_1.LucidFields.EndTime;\n            case semanticfields_1.SemanticFields.Estimate:\n                return lucidfields_1.LucidFields.Estimate;\n            case semanticfields_1.SemanticFields.Status:\n                return lucidfields_1.LucidFields.Status;\n            case semanticfields_1.SemanticFields.IssueType:\n                return lucidfields_1.LucidFields.IssueType;\n            case semanticfields_1.SemanticFields.Priority:\n                return lucidfields_1.LucidFields.Priority;\n            case semanticfields_1.SemanticFields.Project:\n                return lucidfields_1.LucidFields.Project;\n            case semanticfields_1.SemanticFields.SourceItemUrl:\n                return lucidfields_1.LucidFields.SourceItemUrl;\n            case semanticfields_1.SemanticFields.ImageUrl:\n                return lucidfields_1.LucidFields.ImageUrl;\n            default:\n                return undefined;\n        }\n    }\n    else {\n        switch (semanticField) {\n            case SemanticKind.Id:\n                return undefined;\n            case SemanticKind.Title:\n                return lucidfields_1.LucidFields.Title;\n            // Name could have been mapped to User or Title but all uses cases outside of the unified viz API use it as Title\n            case SemanticKind.Name:\n                return lucidfields_1.LucidFields.Title;\n            case SemanticKind.Image:\n                return lucidfields_1.LucidFields.ImageUrl;\n            case SemanticKind.Description:\n                return lucidfields_1.LucidFields.Description;\n            case SemanticKind.Assignee:\n                return lucidfields_1.LucidFields.User;\n            case SemanticKind.Estimate:\n                return lucidfields_1.LucidFields.Estimate;\n            case SemanticKind.Status:\n                return lucidfields_1.LucidFields.Status;\n            case SemanticKind.IssueType:\n                return lucidfields_1.LucidFields.IssueType;\n            case SemanticKind.Priority:\n                return lucidfields_1.LucidFields.Priority;\n            case SemanticKind.Project:\n                return lucidfields_1.LucidFields.Project;\n            case SemanticKind.Reporter:\n                return lucidfields_1.LucidFields.Reporter;\n            case SemanticKind.StartTime:\n                return lucidfields_1.LucidFields.Time;\n            case SemanticKind.EndTime:\n                return lucidfields_1.LucidFields.EndTime;\n            case SemanticKind.GroupByHint:\n                return undefined;\n            case SemanticKind.PrimaryKeyReference:\n                return undefined;\n            case SemanticKind.URL:\n                return lucidfields_1.LucidFields.SourceItemUrl;\n            default:\n                return undefined;\n        }\n    }\n}\nexports.semanticKindToLucidFields = semanticKindToLucidFields;\n/**\n * @deprecated use semanticKindToLucidFields instead\n */\nfunction semanticKindToSemanticFields(semanticField) {\n    if ((0, lucidfields_1.isLucidFields)(semanticField)) {\n        return semanticField;\n    }\n    else {\n        switch (semanticField) {\n            case SemanticKind.Id:\n                return undefined;\n            case SemanticKind.Title:\n                return semanticfields_1.SemanticFields.Title;\n            // Name could have been mapped to User or Title but all uses cases outside of the unified viz API use it as Title\n            case SemanticKind.Name:\n                return semanticfields_1.SemanticFields.Title;\n            case SemanticKind.Image:\n                return semanticfields_1.SemanticFields.ImageUrl;\n            case SemanticKind.Description:\n                return semanticfields_1.SemanticFields.Description;\n            case SemanticKind.Assignee:\n                return semanticfields_1.SemanticFields.User;\n            case SemanticKind.Estimate:\n                return semanticfields_1.SemanticFields.Estimate;\n            case SemanticKind.Status:\n                return semanticfields_1.SemanticFields.Status;\n            case SemanticKind.IssueType:\n                return semanticfields_1.SemanticFields.IssueType;\n            case SemanticKind.Priority:\n                return semanticfields_1.SemanticFields.Priority;\n            case SemanticKind.Project:\n                return semanticfields_1.SemanticFields.Project;\n            case SemanticKind.Reporter:\n                return semanticfields_1.SemanticFields.Reporter;\n            case SemanticKind.StartTime:\n                return semanticfields_1.SemanticFields.Time;\n            case SemanticKind.EndTime:\n                return semanticfields_1.SemanticFields.EndTime;\n            case SemanticKind.GroupByHint:\n                return undefined;\n            case SemanticKind.PrimaryKeyReference:\n                return undefined;\n            case SemanticKind.URL:\n                return semanticfields_1.SemanticFields.SourceItemUrl;\n            default:\n                return undefined;\n        }\n    }\n}\nexports.semanticKindToSemanticFields = semanticKindToSemanticFields;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFlattenedReference = exports.isUnTypedSerializedFlattenedReference = exports.isTypedSerializedFlattenedReference = exports.FlattenedReferenceKeyName = exports.FlattenedReferenceKeyId = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nexports.FlattenedReferenceKeyId = '192d0e9f-2f5a-4032-9f03-59bbf1ea5891';\nexports.FlattenedReferenceKeyName = '192d0e9f-2f5a-4032-9f03-59bbf1ea5891_n';\n/** @ignore */\nfunction isTypedSerializedFlattenedReference(data) {\n    return (0, checks_1.isObjectUnsafe)(data) && (0, checks_1.isObject)(data['sc']) && (0, checks_1.isObject)(data['d']);\n}\nexports.isTypedSerializedFlattenedReference = isTypedSerializedFlattenedReference;\n/** @ignore */\nfunction isUnTypedSerializedFlattenedReference(data) {\n    return (0, checks_1.isObjectUnsafe)(data) && data[exports.FlattenedReferenceKeyId] === true;\n}\nexports.isUnTypedSerializedFlattenedReference = isUnTypedSerializedFlattenedReference;\n/** @ignore */\nfunction isSerializedFlattenedReference(data) {\n    return isUnTypedSerializedFlattenedReference(data) || isTypedSerializedFlattenedReference(data);\n}\nexports.isSerializedFlattenedReference = isSerializedFlattenedReference;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedDataItems = void 0;\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializedfields_1 = __webpack_require__(/*! ./serializedfields */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js\");\nexports.isSerializedDataItems = (0, validators_1.objectOfValidator)(serializedfields_1.isSerializedFields);\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFieldDefinition = exports.isSerializedFieldConstraint = exports.isFieldConstraintType = exports.FieldConstraintType = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst lucidfields_1 = __webpack_require__(/*! ../fieldtypedefinition/lucidfields */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/lucidfields.js\");\nconst semantickind_1 = __webpack_require__(/*! ../fieldtypedefinition/semantickind */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js\");\n// The options here must match com.lucidchart.data.model.fielddefinition.FieldConstraintType on the backend\nvar FieldConstraintType;\n(function (FieldConstraintType) {\n    FieldConstraintType[\"REQUIRED\"] = \"required\";\n    FieldConstraintType[\"LOCKED\"] = \"locked\";\n    FieldConstraintType[\"MIN_VALUE\"] = \"minValue\";\n    FieldConstraintType[\"MAX_VALUE\"] = \"maxValue\";\n    FieldConstraintType[\"SINGLE_LINE_ONLY\"] = \"singleLineOnly\";\n    FieldConstraintType[\"NO_WHITESPACE\"] = \"noWhitespace\";\n    FieldConstraintType[\"UNIQUE_EDIT\"] = \"uniqueEditType\";\n    FieldConstraintType[\"MAX_LENGTH\"] = \"maxLength\";\n})(FieldConstraintType || (exports.FieldConstraintType = FieldConstraintType = {}));\nexports.isFieldConstraintType = (0, validators_1.enumValidator)(FieldConstraintType);\nexports.isSerializedFieldConstraint = (0, validators_1.objectValidator)({\n    'Type': (0, validators_1.enumValidator)(FieldConstraintType),\n    'Details': (0, validators_1.option)(checks_1.isAny),\n});\nexports.isSerializedFieldDefinition = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'Type': fieldtypedefinition_1.isSerializedFieldTypeDefinition,\n    'Constraints': (0, validators_1.option)((0, validators_1.arrayValidator)(exports.isSerializedFieldConstraint)),\n    'SyncSchema': (0, validators_1.option)(checks_1.isString),\n    'Mapping': (0, validators_1.option)((0, validators_1.either)((0, validators_1.arrayValidator)(lucidfields_1.isLucidFields), (0, validators_1.arrayValidator)(semantickind_1.isSemanticKind))),\n});\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFields = exports.isSerializedJsonFieldType = exports.isSerializedFieldType = exports.isSerializedTimeObject = exports.isSerializedLucidDateObject = exports.isSerializedIsoDateObject = exports.isSerializedMillisecondsDateObject = exports.isSerializedLucidCurrency = exports.isSerializedLucidDictionary = exports.isJsonSerializedLucidDictionary = exports.isNestedSerializedLucidDictionary = exports.isSerializedColorObjectFieldType = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nfunction isSerializedColorObjectFieldType(value) {\n    return (0, checks_1.isObjectUnsafe)(value) && (0, checks_1.isObject)(value['color']);\n}\nexports.isSerializedColorObjectFieldType = isSerializedColorObjectFieldType;\n/** a dictionary type that has full type support */\nexports.isNestedSerializedLucidDictionary = (0, validators_1.strictObjectValidator)({\n    'dict': (0, validators_1.mapValidator)(isSerializedFieldType),\n});\n/** a dictionary type that only supports raw js, primarily used when external data could be arbritrary js */\nexports.isJsonSerializedLucidDictionary = (0, validators_1.strictObjectValidator)({\n    'js': (0, validators_1.mapValidator)(isSerializedJsonFieldType),\n});\nexports.isSerializedLucidDictionary = (0, validators_1.either)(exports.isNestedSerializedLucidDictionary, exports.isJsonSerializedLucidDictionary);\nexports.isSerializedLucidCurrency = (0, validators_1.objectValidator)({\n    'a': checks_1.isNumber,\n    't': checks_1.isString,\n});\nexports.isSerializedMillisecondsDateObject = (0, validators_1.objectValidator)({\n    'ms': checks_1.isNumber,\n    'isDateOnly': (0, validators_1.option)(checks_1.isBoolean),\n});\nexports.isSerializedIsoDateObject = (0, validators_1.objectValidator)({\n    'isoDate': checks_1.isString,\n    'displayTimezone': (0, validators_1.nullableOption)(checks_1.isString),\n});\nexports.isSerializedLucidDateObject = (0, validators_1.either)(exports.isSerializedMillisecondsDateObject, exports.isSerializedIsoDateObject);\nexports.isSerializedTimeObject = (0, validators_1.objectValidator)({\n    'hours': checks_1.isNumber,\n    'minutes': (0, validators_1.option)(checks_1.isNumber),\n    'seconds': (0, validators_1.option)(checks_1.isNumber),\n});\nfunction isSerializedFieldType(value) {\n    return (value == null ||\n        (0, checks_1.isNumber)(value) ||\n        (0, checks_1.isString)(value) ||\n        (0, checks_1.isBoolean)(value) ||\n        (0, exports.isSerializedLucidDictionary)(value) ||\n        (0, exports.isSerializedLucidCurrency)(value) ||\n        ((0, checks_1.isArray)(value) && value.every(isSerializedFieldType)) ||\n        (0, exports.isSerializedLucidDateObject)(value) ||\n        (0, exports.isSerializedTimeObject)(value) ||\n        isSerializedColorObjectFieldType(value));\n}\nexports.isSerializedFieldType = isSerializedFieldType;\nfunction isSerializedJsonFieldType(value) {\n    return (value == null ||\n        (0, checks_1.isNumber)(value) ||\n        (0, checks_1.isString)(value) ||\n        (0, checks_1.isBoolean)(value) ||\n        ((0, checks_1.isArray)(value) && value.every(isSerializedJsonFieldType)) ||\n        ((0, checks_1.isObject)(value) && Object.values(value).every(isSerializedJsonFieldType)));\n}\nexports.isSerializedJsonFieldType = isSerializedJsonFieldType;\nexports.isSerializedFields = (0, validators_1.objectOfValidator)(isSerializedFieldType);\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedSchema = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializedfielddefinition_1 = __webpack_require__(/*! ./serializedfielddefinition */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\");\nfunction isSerializedSchema(schema) {\n    if (!(0, checks_1.isObjectUnsafe)(schema)) {\n        return false;\n    }\n    const fields = schema['Fields'];\n    const primaryKey = schema['PrimaryKey'];\n    const fieldLabelOverrides = schema['FieldLabelOverrides'];\n    const validOverrides = (0, checks_1.isDefAndNotNull)(fieldLabelOverrides)\n        ? (0, checks_1.isRecord)(checks_1.isString)(fieldLabelOverrides) && !(0, checks_1.isArray)(fieldLabelOverrides)\n        : true; // Optional field\n    return ((0, checks_1.isTypedArray)(serializedfielddefinition_1.isSerializedFieldDefinition)(fields) &&\n        (0, validators_1.arrayValidator)(serializedfielddefinition_1.isSerializedFieldDefinition)(fields) &&\n        (0, checks_1.isArray)(primaryKey) &&\n        primaryKey.every(checks_1.isString) &&\n        validOverrides);\n}\nexports.isSerializedSchema = isSerializedSchema;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/dataerrortype.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/dataerrortype.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/dataerrortype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/defer.js":
/*!********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/defer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defer = void 0;\nfunction checkPromiseExists() {\n    if (typeof Promise !== 'function') {\n        throw new Error('No promise library available');\n    }\n}\nfunction defer() {\n    checkPromiseExists();\n    let resolve = undefined;\n    let reject = undefined;\n    const promise = new Promise((resolveLocal, rejectLocal) => {\n        resolve = resolveLocal;\n        reject = rejectLocal;\n    });\n    if (!resolve || !reject) {\n        throw new Error('Promise constructor does not provide proper arguments to callback');\n    }\n    return {\n        resolve: resolve,\n        reject: reject,\n        promise: promise,\n        then: promise.then.bind(promise),\n        catch: promise.catch.bind(promise),\n        finally: promise.finally.bind(promise),\n        [Symbol.toStringTag]: promise[Symbol.toStringTag],\n    };\n}\nexports.defer = defer;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/defer.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/guards.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/guards.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/guards.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/humanreadableerror.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/humanreadableerror.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HumanReadableError = void 0;\n/**\n * An error carrying a message that is good to be shown directly in the UI.\n * These can be thrown from extensions and caught in core code.\n */\nclass HumanReadableError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'HumanReadableError';\n    }\n}\nexports.HumanReadableError = HumanReadableError;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/humanreadableerror.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseIFrameAttributesFromHTML = exports.generateIFrameHTML = exports.DEFAULT_IFRAME_HEIGHT = exports.DEFAULT_IFRAME_WIDTH = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\n/**\n * Aspect ratio 16:9, wider rectangle\n * This will be the default setting if not provided\n *\n * The values are small since we only use width and height value to calculate aspect ratio\n * So in this case, it will be width/height, which will be 16:9\n * It's the same result as 1600 and 900 as default width and height\n */\nexports.DEFAULT_IFRAME_WIDTH = 16;\nexports.DEFAULT_IFRAME_HEIGHT = 9;\n/**\n * Iframes from external sources are not trustworthy to be embedded directly. They could cause security vulnerability,\n * including XSS attacks. Even if the iframes come from sources with good reputation, it is still a good practice to\n * sanitize their source HTML and restrict their functionality in the sandbox before embedding them to our apps.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe for a list of iframe attributes.\n */\nconst iframeRegExps = {\n    src: /src=\"((https:\\/\\/|\\/\\/).*?)\"/i,\n    height: /height=\"(\\d*?)\"/i,\n    width: /width=\"(\\d*?)\"/i,\n    title: /title=\"(.*?)\"/i,\n};\n/**\n * Generate iframe HTML from the IFrameAttributes object\n * @returns the generated iframe HTML\n * @ignore\n * */\nfunction generateIFrameHTML(iframeAttributes) {\n    let iframeHTML = `<iframe src=\"${iframeAttributes.src}\"`;\n    if (iframeAttributes.width) {\n        iframeHTML += ` width=\"${iframeAttributes.width.toString()}\"`;\n    }\n    if (iframeAttributes.height) {\n        iframeHTML += ` height=\"${iframeAttributes.height.toString()}\"`;\n    }\n    if (iframeAttributes.title) {\n        // Escape all the double quotation marks\n        const title = iframeAttributes.title.replace(/\"/g, '&quot;');\n        iframeHTML += ` title=\"${title}\"`;\n    }\n    iframeHTML += '></iframe>';\n    return iframeHTML;\n}\nexports.generateIFrameHTML = generateIFrameHTML;\n/**\n * Parse the iframe HTML, i.e. <iframe>...</iframe> into the IFrameAttributes object\n * @returns the required attributes to render the target iframe\n * @ignore\n */\nfunction parseIFrameAttributesFromHTML(iframeHTML) {\n    var _a, _b, _c, _d, _e, _f;\n    if (!iframeHTML.startsWith('<iframe')) {\n        return {\n            srcdoc: iframeHTML,\n            height: exports.DEFAULT_IFRAME_HEIGHT,\n            width: exports.DEFAULT_IFRAME_WIDTH,\n        };\n    }\n    const src = (_b = (_a = iframeHTML.match(iframeRegExps.src)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : '';\n    const height = (_c = iframeHTML.match(iframeRegExps.height)) === null || _c === void 0 ? void 0 : _c[1];\n    const width = (_d = iframeHTML.match(iframeRegExps.width)) === null || _d === void 0 ? void 0 : _d[1];\n    const title = (_f = (_e = iframeHTML.match(iframeRegExps.title)) === null || _e === void 0 ? void 0 : _e[1]) !== null && _f !== void 0 ? _f : '';\n    return {\n        src: src,\n        height: !(0, checks_1.isUndefined)(height) ? Number.parseInt(height) : exports.DEFAULT_IFRAME_HEIGHT,\n        width: !(0, checks_1.isUndefined)(width) ? Number.parseInt(width) : exports.DEFAULT_IFRAME_WIDTH,\n        title: title,\n    };\n}\nexports.parseIFrameAttributesFromHTML = parseIFrameAttributesFromHTML;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/jsonserializable.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/jsonserializable.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isJsonObject = exports.isJsonSerializable = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nfunction isJsonSerializable(x) {\n    return (x == null ||\n        (0, checks_1.isString)(x) ||\n        (0, checks_1.isNumber)(x) ||\n        (0, checks_1.isBoolean)(x) ||\n        ((0, checks_1.isArray)(x) && x.every(isJsonSerializable)) ||\n        isJsonObject(x));\n}\nexports.isJsonSerializable = isJsonSerializable;\nfunction isJsonObject(x) {\n    if (!(0, checks_1.isObjectUnsafe)(x)) {\n        return false;\n    }\n    for (const k in x) {\n        if (!isJsonSerializable(x[k])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isJsonObject = isJsonObject;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/jsonserializable.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/lucidproduct.js":
/*!***************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/lucidproduct.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidProduct = void 0;\n/**\n * Lucid products supporting the extension API\n */\nvar LucidProduct;\n(function (LucidProduct) {\n    LucidProduct[\"Chart\"] = \"chart\";\n    LucidProduct[\"Spark\"] = \"spark\";\n    LucidProduct[\"TeamSpaces\"] = \"teamspaces\";\n})(LucidProduct || (exports.LucidProduct = LucidProduct = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/lucidproduct.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/object.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/object.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromEntries = exports.flatten = void 0;\nfunction flatten(a) {\n    const result = [];\n    for (const item of a) {\n        result.push(...item);\n    }\n    return result;\n}\nexports.flatten = flatten;\n// TODO: Placeholder until we adopt ES8 and can use Object.fromEntries(obj)\nfunction fromEntries(entries) {\n    const result = {};\n    for (const [key, value] of entries) {\n        result[key] = value;\n    }\n    return result;\n}\nexports.fromEntries = fromEntries;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/object.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/offsettype.js":
/*!*************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/offsettype.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLinearOffsetType = exports.OffsetType = void 0;\n/**\n * When adjusting the size or location of items on a page, these are the specific operations that are available.\n */\nvar OffsetType;\n(function (OffsetType) {\n    /**\n     * Resize from the northwest (upper-left) corner of the selection, anchoring the lower-right corner in place.\n     */\n    OffsetType[OffsetType[\"NW\"] = 0] = \"NW\";\n    /**\n     * Resize from the northeast (upper-right) corner of the selection, anchoring the lower-left corner in place.\n     */\n    OffsetType[OffsetType[\"NE\"] = 1] = \"NE\";\n    /**\n     * Resize from the southeast (lower-right) corner of the selection, anchoring the upper-left corner in place.\n     */\n    OffsetType[OffsetType[\"SE\"] = 2] = \"SE\";\n    /**\n     * Resize from the southwest (lower-left) corner of the selection, anchoring the upper-right corner in place.\n     */\n    OffsetType[OffsetType[\"SW\"] = 3] = \"SW\";\n    /**\n     * Move the selection without resizing.\n     */\n    OffsetType[OffsetType[\"MOVE\"] = 4] = \"MOVE\";\n    OffsetType[OffsetType[\"ROTATE\"] = 5] = \"ROTATE\";\n    OffsetType[OffsetType[\"SCALE\"] = 6] = \"SCALE\";\n    OffsetType[OffsetType[\"CUSTOM\"] = 7] = \"CUSTOM\";\n    /**\n     * Resize from the north (upper) side of the selection, stretching vertically.\n     */\n    OffsetType[OffsetType[\"N\"] = 8] = \"N\";\n    /**\n     * Resize from the east (right) side of the selection, stretching horizontally.\n     */\n    OffsetType[OffsetType[\"E\"] = 9] = \"E\";\n    /**\n     * Resize from the south (lower) side of the selection, stretching vertically.\n     */\n    OffsetType[OffsetType[\"S\"] = 10] = \"S\";\n    /**\n     * Resize from the west (left) side of the selection, stretching horizontally.\n     */\n    OffsetType[OffsetType[\"W\"] = 11] = \"W\";\n})(OffsetType || (exports.OffsetType = OffsetType = {}));\nfunction isLinearOffsetType(offsetType) {\n    return (offsetType === OffsetType.NW ||\n        offsetType === OffsetType.NE ||\n        offsetType === OffsetType.SE ||\n        offsetType === OffsetType.SW ||\n        offsetType === OffsetType.MOVE ||\n        offsetType === OffsetType.N ||\n        offsetType === OffsetType.E ||\n        offsetType === OffsetType.S ||\n        offsetType === OffsetType.W);\n}\nexports.isLinearOffsetType = isLinearOffsetType;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/offsettype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/optionalkey.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/optionalkey.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/optionalkey.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLayerPos = exports.isVerticalPos = exports.isHorizontalPos = exports.isValidSerializedBadgeEnumPosition = exports.serializeBadgeEnumPositionAsKey = exports.serializeBadgeEnumPosition = exports.deserializeBadgeEnumPosition = exports.badgePositionsEqual = exports.defaultBadgePositionSerialized = exports.defaultBadgePosition = exports.BadgePositionsClockwise = exports.BadgeResponsiveness = exports.BadgeLayerPos = exports.VerticalBadgePos = exports.HorizontalBadgePos = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nvar HorizontalBadgePos;\n(function (HorizontalBadgePos) {\n    HorizontalBadgePos[HorizontalBadgePos[\"LEFT\"] = 0] = \"LEFT\";\n    HorizontalBadgePos[HorizontalBadgePos[\"CENTER\"] = 1] = \"CENTER\";\n    HorizontalBadgePos[HorizontalBadgePos[\"RIGHT\"] = 2] = \"RIGHT\";\n})(HorizontalBadgePos || (exports.HorizontalBadgePos = HorizontalBadgePos = {}));\nvar VerticalBadgePos;\n(function (VerticalBadgePos) {\n    VerticalBadgePos[VerticalBadgePos[\"TOP\"] = 0] = \"TOP\";\n    VerticalBadgePos[VerticalBadgePos[\"CENTER\"] = 1] = \"CENTER\";\n    VerticalBadgePos[VerticalBadgePos[\"BOTTOM\"] = 2] = \"BOTTOM\";\n})(VerticalBadgePos || (exports.VerticalBadgePos = VerticalBadgePos = {}));\nvar BadgeLayerPos;\n(function (BadgeLayerPos) {\n    BadgeLayerPos[BadgeLayerPos[\"INSIDE\"] = 0] = \"INSIDE\";\n    BadgeLayerPos[BadgeLayerPos[\"EDGE\"] = 1] = \"EDGE\";\n    BadgeLayerPos[BadgeLayerPos[\"OUTSIDE\"] = 2] = \"OUTSIDE\";\n})(BadgeLayerPos || (exports.BadgeLayerPos = BadgeLayerPos = {}));\nvar BadgeResponsiveness;\n(function (BadgeResponsiveness) {\n    BadgeResponsiveness[BadgeResponsiveness[\"STATIC\"] = 0] = \"STATIC\";\n    BadgeResponsiveness[BadgeResponsiveness[\"STACK\"] = 1] = \"STACK\";\n})(BadgeResponsiveness || (exports.BadgeResponsiveness = BadgeResponsiveness = {}));\n/*\n * The order of the badge position starting from the top-left corner and going clockwise\n */\nexports.BadgePositionsClockwise = [\n    { horizontalPos: 0, verticalPos: 0 },\n    { horizontalPos: 1, verticalPos: 0 },\n    { horizontalPos: 2, verticalPos: 0 },\n    { horizontalPos: 2, verticalPos: 1 },\n    { horizontalPos: 2, verticalPos: 2 },\n    { horizontalPos: 1, verticalPos: 2 },\n    { horizontalPos: 0, verticalPos: 2 },\n    { horizontalPos: 0, verticalPos: 1 }, // left-center\n];\nexports.defaultBadgePosition = {\n    horizontalPos: HorizontalBadgePos.RIGHT,\n    verticalPos: VerticalBadgePos.TOP,\n    layer: BadgeLayerPos.EDGE,\n    responsive: BadgeResponsiveness.STACK,\n};\nexports.defaultBadgePositionSerialized = {\n    'horiz': HorizontalBadgePos.RIGHT,\n    'vert': VerticalBadgePos.TOP,\n    'layer': BadgeLayerPos.EDGE,\n    'responsive': BadgeResponsiveness.STACK,\n};\nfunction badgePositionsEqual(a, b) {\n    return (a.horizontalPos === b.horizontalPos &&\n        a.verticalPos === b.verticalPos &&\n        a.layer === b.layer &&\n        a.responsive === b.responsive);\n}\nexports.badgePositionsEqual = badgePositionsEqual;\nfunction deserializeBadgeEnumPosition(serialized) {\n    if (serialized == null) {\n        return undefined;\n    }\n    return {\n        horizontalPos: serialized['horiz'] != null ? serialized['horiz'] : exports.defaultBadgePosition.horizontalPos,\n        verticalPos: serialized['vert'] != null ? serialized['vert'] : exports.defaultBadgePosition.verticalPos,\n        layer: serialized['layer'] != null ? serialized['layer'] : exports.defaultBadgePosition.layer,\n        responsive: serialized['responsive'] != null ? serialized['responsive'] : exports.defaultBadgePosition.responsive,\n    };\n}\nexports.deserializeBadgeEnumPosition = deserializeBadgeEnumPosition;\nfunction serializeBadgeEnumPosition(position) {\n    if (position == null) {\n        return {\n            'horiz': exports.defaultBadgePosition.horizontalPos,\n            'vert': exports.defaultBadgePosition.verticalPos,\n            'layer': exports.defaultBadgePosition.layer,\n            'responsive': exports.defaultBadgePosition.responsive,\n        };\n    }\n    return {\n        'horiz': position.horizontalPos,\n        'vert': position.verticalPos,\n        'layer': position.layer,\n        'responsive': position.responsive,\n    };\n}\nexports.serializeBadgeEnumPosition = serializeBadgeEnumPosition;\nfunction serializeBadgeEnumPositionAsKey(position) {\n    return JSON.stringify(position);\n}\nexports.serializeBadgeEnumPositionAsKey = serializeBadgeEnumPositionAsKey;\nfunction isValidSerializedBadgeEnumPosition(val) {\n    // All fields are optional, so it's fine if they're not present\n    const horizValid = val['horiz'] == undefined || Object.values(HorizontalBadgePos).includes(val['horiz']);\n    const vertValid = val['vert'] == undefined || Object.values(VerticalBadgePos).includes(val['vert']);\n    const layerValid = val['layer'] == undefined || Object.values(BadgeLayerPos).includes(val['layer']);\n    const responsiveValid = val['responsive'] == undefined || Object.values(BadgeResponsiveness).includes(val['responsive']);\n    return horizValid && vertValid && layerValid && responsiveValid;\n}\nexports.isValidSerializedBadgeEnumPosition = isValidSerializedBadgeEnumPosition;\nfunction isHorizontalPos(maybePos) {\n    if ((0, checks_1.isNumber)(maybePos)) {\n        return !!HorizontalBadgePos[maybePos];\n    }\n    return false;\n}\nexports.isHorizontalPos = isHorizontalPos;\nfunction isVerticalPos(maybePos) {\n    if ((0, checks_1.isNumber)(maybePos)) {\n        return !!VerticalBadgePos[maybePos];\n    }\n    return false;\n}\nexports.isVerticalPos = isVerticalPos;\nfunction isLayerPos(maybePos) {\n    if ((0, checks_1.isNumber)(maybePos)) {\n        return !!BadgeLayerPos[maybePos];\n    }\n    return false;\n}\nexports.isLayerPos = isLayerPos;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.areDataGraphicImagesEqual = exports.areDataGraphicIconIndexesEqual = exports.DataGraphicIconSets = void 0;\nvar DataGraphicIconSets;\n(function (DataGraphicIconSets) {\n    // Custom icons are a user-defined set of uploaded icons, not a predefined set of icons\n    DataGraphicIconSets[DataGraphicIconSets[\"CUSTOM_ICONS\"] = -1] = \"CUSTOM_ICONS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STATUS_ICONS\"] = 0] = \"STATUS_ICONS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STATUS_CIRCLES\"] = 1] = \"STATUS_CIRCLES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STOPLIGHTS\"] = 2] = \"STOPLIGHTS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"TOGGLES\"] = 3] = \"TOGGLES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"COMPLETION_PIES\"] = 4] = \"COMPLETION_PIES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"TRENDING_ARROWS\"] = 5] = \"TRENDING_ARROWS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STATUS_CHECK_BOXES\"] = 6] = \"STATUS_CHECK_BOXES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"TRENDING_ARROWS_FLIPPED\"] = 7] = \"TRENDING_ARROWS_FLIPPED\";\n})(DataGraphicIconSets || (exports.DataGraphicIconSets = DataGraphicIconSets = {}));\nfunction areDataGraphicIconIndexesEqual(a, b) {\n    return a.set == b.set && a.index == b.index && areDataGraphicImagesEqual(a.iconImage, b.iconImage);\n}\nexports.areDataGraphicIconIndexesEqual = areDataGraphicIconIndexesEqual;\nfunction areDataGraphicImagesEqual(a, b) {\n    if (a == undefined || b == undefined) {\n        return a == b;\n    }\n    return a.w == b.w && a.h == b.h && a.url == b.url;\n}\nexports.areDataGraphicImagesEqual = areDataGraphicImagesEqual;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedSimpleStaticDataGraphicSettings = exports.deserializeSimpleStaticDataGraphicSettings = exports.serializeSimpleStaticDataGraphicSettings = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst badgeposition_1 = __webpack_require__(/*! ./badgeposition */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nfunction serializeSimpleStaticDataGraphicSettings(settings) {\n    return {\n        'icon': settings.icon,\n        'pos': (0, badgeposition_1.serializeBadgeEnumPosition)(settings.position),\n        'color': settings.color,\n    };\n}\nexports.serializeSimpleStaticDataGraphicSettings = serializeSimpleStaticDataGraphicSettings;\nfunction deserializeSimpleStaticDataGraphicSettings(settings) {\n    return {\n        icon: settings['icon'],\n        position: (0, badgeposition_1.deserializeBadgeEnumPosition)(settings['pos']),\n        color: settings['color'],\n    };\n}\nexports.deserializeSimpleStaticDataGraphicSettings = deserializeSimpleStaticDataGraphicSettings;\nfunction isSerializedSimpleStaticDataGraphicSettings(settings) {\n    return ((0, checks_1.isObjectUnsafe)(settings) &&\n        (0, checks_1.isString)(settings['color']) &&\n        (0, checks_1.isObject)(settings['icon']) &&\n        (0, badgeposition_1.isValidSerializedBadgeEnumPosition)(settings['pos']));\n}\nexports.isSerializedSimpleStaticDataGraphicSettings = isSerializedSimpleStaticDataGraphicSettings;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/dependencylinename.js":
/*!********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/dependencylinename.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DependencyLineName = void 0;\nvar DependencyLineName;\n(function (DependencyLineName) {\n    DependencyLineName[\"Parent\"] = \"parent\";\n    DependencyLineName[\"Blocks\"] = \"blocks\";\n    DependencyLineName[\"Duplicates\"] = \"duplicates\";\n    DependencyLineName[\"RelatesTo\"] = \"relates to\";\n    DependencyLineName[\"Clones\"] = \"clones\";\n})(DependencyLineName || (exports.DependencyLineName = DependencyLineName = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/properties/dependencylinename.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/fillcolor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/fillcolor.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeSimpleFill = exports.SimpleImageFillPosition = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\n/**\n * Different ways of laying out the image in the background of the block.\n */\nvar SimpleImageFillPosition;\n(function (SimpleImageFillPosition) {\n    /** The image retains its original aspect ratio, and is as large as possible while still fitting in the block */\n    SimpleImageFillPosition[\"Fit\"] = \"fit\";\n    /** The image retains its original aspect ratio, and is as small as possible while still completely covering the block */\n    SimpleImageFillPosition[\"Fill\"] = \"fill\";\n    /** The image is stretched to the bounding box of the block */\n    SimpleImageFillPosition[\"Stretch\"] = \"stretch\";\n    /** The image is shown in its original size if possible */\n    SimpleImageFillPosition[\"Original\"] = \"original\";\n    /** The image is tiled in its original size vertically and horizontally to fully cover the block */\n    SimpleImageFillPosition[\"Tile\"] = \"tile\";\n    //TODO: 'mask' but mask requires additional settings\n})(SimpleImageFillPosition || (exports.SimpleImageFillPosition = SimpleImageFillPosition = {}));\n/** @ignore */\nfunction serializeSimpleFill(fill) {\n    if ((0, checks_1.isString)(fill)) {\n        return fill;\n    }\n    else {\n        return {\n            'pos': fill.position,\n            'url': fill.url,\n            'polys': null,\n        };\n    }\n}\nexports.serializeSimpleFill = serializeSimpleFill;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/properties/fillcolor.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/shadow.js":
/*!********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/shadow.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeShadow = exports.serializeShadow = void 0;\nfunction serializeShadow(shadow) {\n    return {\n        'x': shadow.distance * Math.cos(shadow.angle),\n        'y': shadow.distance * Math.sin(shadow.angle),\n        'b': shadow.blur,\n        'c': shadow.color,\n        'ang': shadow.angle,\n    };\n}\nexports.serializeShadow = serializeShadow;\nfunction deserializeShadow(shadow) {\n    var _a;\n    return {\n        distance: Math.sqrt(shadow['x'] * shadow['x'] + shadow['y'] * shadow['y']),\n        angle: (_a = shadow['ang']) !== null && _a !== void 0 ? _a : Math.atan2(shadow['y'], shadow['x']),\n        blur: Math.max(shadow['b'], 0),\n        color: shadow['c'],\n    };\n}\nexports.deserializeShadow = deserializeShadow;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/properties/shadow.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/strokestyle.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/strokestyle.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertStrokeStyleToBorder = exports.isStrokeStyle = exports.StrokeStyle = void 0;\nvar StrokeStyle;\n(function (StrokeStyle) {\n    StrokeStyle[\"Solid\"] = \"solid\";\n    StrokeStyle[\"Dashed\"] = \"dashed\";\n    StrokeStyle[\"LongDash\"] = \"longdash\";\n    StrokeStyle[\"DashDot\"] = \"dashdot\";\n    StrokeStyle[\"DashDotDot\"] = \"dashdotdot\";\n    StrokeStyle[\"DashLongDash\"] = \"dashlongdash\";\n    StrokeStyle[\"Dashed32\"] = \"dashed32\";\n    StrokeStyle[\"Dashed44\"] = \"dashed44\";\n    StrokeStyle[\"Dashed24\"] = \"dashed24\";\n    StrokeStyle[\"Dotted\"] = \"dotted\";\n    StrokeStyle[\"DotDotDot\"] = \"dotdotdot\";\n    StrokeStyle[\"StripeThinThin\"] = \"stripethinthin\";\n    StrokeStyle[\"StripeThickThick\"] = \"stripethickthick\";\n    StrokeStyle[\"StripeThickThin\"] = \"stripethickthin\";\n    StrokeStyle[\"StripeThinThick\"] = \"stripethinthick\";\n    StrokeStyle[\"StripeThickThinThick\"] = \"stripethickthinthick\";\n    StrokeStyle[\"StripeThinThickThin\"] = \"stripethinthickthin\";\n    StrokeStyle[\"StripeTriple\"] = \"stripetriple\";\n})(StrokeStyle || (exports.StrokeStyle = StrokeStyle = {}));\nconst strokeStyleSet = new Set(Object.values(StrokeStyle));\nfunction isStrokeStyle(value) {\n    return strokeStyleSet.has(value);\n}\nexports.isStrokeStyle = isStrokeStyle;\nfunction convertStrokeStyleToBorder(strokeStyle) {\n    if (strokeStyle.startsWith('dash') || strokeStyle == StrokeStyle.LongDash) {\n        return 'dashed';\n    }\n    else if (strokeStyle.startsWith('dot')) {\n        return 'dotted';\n    }\n    else {\n        return 'solid';\n    }\n}\nexports.convertStrokeStyleToBorder = convertStrokeStyleToBorder;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/properties/strokestyle.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/result.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/result.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isEqual = exports.groupByResultType = exports.isFailure = exports.isSuccess = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nfunction isSuccess(res) {\n    return (0, checks_1.isDef)(res.value);\n}\nexports.isSuccess = isSuccess;\nfunction isFailure(res) {\n    return (0, checks_1.isDef)(res.error);\n}\nexports.isFailure = isFailure;\nfunction groupByResultType(results) {\n    const successes = [];\n    const failures = [];\n    results.forEach((result) => {\n        if (isSuccess(result)) {\n            successes.push(result);\n        }\n        else {\n            failures.push(result);\n        }\n    });\n    return [successes, failures];\n}\nexports.groupByResultType = groupByResultType;\nfunction isEqual(a, b, valueCompS, valueCompF) {\n    return ((!!a &&\n        !!b &&\n        ((isSuccess(a) && isSuccess(b) && valueCompS(a.value, b.value)) ||\n            (isFailure(a) && isFailure(b) && valueCompF(a.error, b.error)))) ||\n        a == b);\n}\nexports.isEqual = isEqual;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/result.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/rules/conditions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/rules/conditions.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContainmentConditions = exports.ConnectedShapesCondition = exports.ShapeTypeConditions = exports.ShapeDataConditions = exports.TextConditions = exports.ConditionCombination = void 0;\nvar ConditionCombination;\n(function (ConditionCombination) {\n    ConditionCombination[\"AND\"] = \"AND\";\n    ConditionCombination[\"OR\"] = \"OR\";\n})(ConditionCombination || (exports.ConditionCombination = ConditionCombination = {}));\nvar TextConditions;\n(function (TextConditions) {\n    TextConditions[TextConditions[\"TextEmpty\"] = 0] = \"TextEmpty\";\n    TextConditions[TextConditions[\"TextNotEmpty\"] = 1] = \"TextNotEmpty\";\n    TextConditions[TextConditions[\"TextContains\"] = 2] = \"TextContains\";\n    TextConditions[TextConditions[\"TextDoesNotContain\"] = 3] = \"TextDoesNotContain\";\n    TextConditions[TextConditions[\"GreaterThan\"] = 8] = \"GreaterThan\";\n    TextConditions[TextConditions[\"GreaterThanOrEqual\"] = 9] = \"GreaterThanOrEqual\";\n    TextConditions[TextConditions[\"LessThan\"] = 10] = \"LessThan\";\n    TextConditions[TextConditions[\"LessThanOrEqual\"] = 11] = \"LessThanOrEqual\";\n    TextConditions[TextConditions[\"Equal\"] = 12] = \"Equal\";\n    TextConditions[TextConditions[\"NotEqual\"] = 13] = \"NotEqual\";\n    TextConditions[TextConditions[\"Between\"] = 14] = \"Between\";\n    TextConditions[TextConditions[\"NotBetween\"] = 15] = \"NotBetween\";\n})(TextConditions || (exports.TextConditions = TextConditions = {}));\nvar ShapeDataConditions;\n(function (ShapeDataConditions) {\n    ShapeDataConditions[ShapeDataConditions[\"TextEmpty\"] = 0] = \"TextEmpty\";\n    ShapeDataConditions[ShapeDataConditions[\"TextNotEmpty\"] = 1] = \"TextNotEmpty\";\n    ShapeDataConditions[ShapeDataConditions[\"TextContains\"] = 2] = \"TextContains\";\n    ShapeDataConditions[ShapeDataConditions[\"TextDoesNotContain\"] = 3] = \"TextDoesNotContain\";\n    /** @deprecated */ ShapeDataConditions[ShapeDataConditions[\"TextEquals\"] = 4] = \"TextEquals\";\n    /** @deprecated */ ShapeDataConditions[ShapeDataConditions[\"TextNotEqual\"] = 5] = \"TextNotEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"TextStartsWith\"] = 6] = \"TextStartsWith\";\n    ShapeDataConditions[ShapeDataConditions[\"TextEndsWith\"] = 7] = \"TextEndsWith\";\n    ShapeDataConditions[ShapeDataConditions[\"GreaterThan\"] = 8] = \"GreaterThan\";\n    ShapeDataConditions[ShapeDataConditions[\"GreaterThanOrEqual\"] = 9] = \"GreaterThanOrEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"LessThan\"] = 10] = \"LessThan\";\n    ShapeDataConditions[ShapeDataConditions[\"LessThanOrEqual\"] = 11] = \"LessThanOrEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"Equal\"] = 12] = \"Equal\";\n    ShapeDataConditions[ShapeDataConditions[\"NotEqual\"] = 13] = \"NotEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"Between\"] = 14] = \"Between\";\n    ShapeDataConditions[ShapeDataConditions[\"NotBetween\"] = 15] = \"NotBetween\";\n})(ShapeDataConditions || (exports.ShapeDataConditions = ShapeDataConditions = {}));\nvar ShapeTypeConditions;\n(function (ShapeTypeConditions) {\n    ShapeTypeConditions[ShapeTypeConditions[\"TextContains\"] = 2] = \"TextContains\";\n    ShapeTypeConditions[ShapeTypeConditions[\"TextDoesNotContain\"] = 3] = \"TextDoesNotContain\";\n})(ShapeTypeConditions || (exports.ShapeTypeConditions = ShapeTypeConditions = {}));\nvar ConnectedShapesCondition;\n(function (ConnectedShapesCondition) {\n    ConnectedShapesCondition[ConnectedShapesCondition[\"GreaterThan\"] = 8] = \"GreaterThan\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"GreaterThanOrEqual\"] = 9] = \"GreaterThanOrEqual\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"LessThan\"] = 10] = \"LessThan\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"LessThanOrEqual\"] = 11] = \"LessThanOrEqual\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"Equal\"] = 12] = \"Equal\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"NotEqual\"] = 13] = \"NotEqual\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"Between\"] = 14] = \"Between\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"NotBetween\"] = 15] = \"NotBetween\";\n})(ConnectedShapesCondition || (exports.ConnectedShapesCondition = ConnectedShapesCondition = {}));\nvar ContainmentConditions;\n(function (ContainmentConditions) {\n    ContainmentConditions[ContainmentConditions[\"TextContains\"] = 2] = \"TextContains\";\n    ContainmentConditions[ContainmentConditions[\"TextDoesNotContain\"] = 3] = \"TextDoesNotContain\";\n})(ContainmentConditions || (exports.ContainmentConditions = ContainmentConditions = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/rules/conditions.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/rules/conditiontype.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/rules/conditiontype.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConditionType = void 0;\nvar ConditionType;\n(function (ConditionType) {\n    ConditionType[ConditionType[\"Text\"] = 0] = \"Text\";\n    ConditionType[ConditionType[\"ShapeData\"] = 1] = \"ShapeData\";\n    ConditionType[ConditionType[\"Formula\"] = 2] = \"Formula\";\n    ConditionType[ConditionType[\"ShapeType\"] = 3] = \"ShapeType\";\n    ConditionType[ConditionType[\"ConnectedShapes\"] = 4] = \"ConnectedShapes\";\n    ConditionType[ConditionType[\"Containment\"] = 5] = \"Containment\";\n})(ConditionType || (exports.ConditionType = ConditionType = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/rules/conditiontype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/rules/serializedeffect.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/rules/serializedeffect.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RuleFormattingType = void 0;\nvar RuleFormattingType;\n(function (RuleFormattingType) {\n    RuleFormattingType[RuleFormattingType[\"FORMATTING\"] = 0] = \"FORMATTING\";\n    RuleFormattingType[RuleFormattingType[\"DATA_GRAPHICS\"] = 1] = \"DATA_GRAPHICS\";\n    RuleFormattingType[RuleFormattingType[\"STENCIL\"] = 2] = \"STENCIL\";\n})(RuleFormattingType || (exports.RuleFormattingType = RuleFormattingType = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/rules/serializedeffect.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/serializeddataerror.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/serializeddataerror.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedDataError = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nfunction isSerializedDataError(raw) {\n    return (0, checks_1.isObjectUnsafe)(raw) && (0, checks_1.isString)(raw['error']) && (0, checks_1.isNumber)(raw['type']);\n}\nexports.isSerializedDataError = isSerializedDataError;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/serializeddataerror.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/shapedatainheritance.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/shapedatainheritance.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShapeDataInheritance = void 0;\nvar ShapeDataInheritance;\n(function (ShapeDataInheritance) {\n    ShapeDataInheritance[ShapeDataInheritance[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * Really just a UI level of inheritance, where the shape data panel should show the ability for\n     * you to enter a value under this name, and the name isn't editable. Because the default value\n     * for missing data is already empty, there's no need to actually do much down here in the model\n     * layer.\n     */\n    ShapeDataInheritance[ShapeDataInheritance[\"NAME\"] = 1] = \"NAME\";\n    /**\n     * This is true inheritance, where the formula/value of the shape data is available on all\n     * descendant elements. i.e. if a page has a VALUE-inheritable shape data entry, that appears on\n     * every single Element on the page, including all groups and items inside those groups.\n     */\n    ShapeDataInheritance[ShapeDataInheritance[\"VALUE\"] = 2] = \"VALUE\";\n})(ShapeDataInheritance || (exports.ShapeDataInheritance = ShapeDataInheritance = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/shapedatainheritance.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/sharedcardintegration/cardintegrationdefinitions.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/sharedcardintegration/cardintegrationdefinitions.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeCardFieldArrayDefinition = exports.deserializeCardFieldDefinition = exports.isSerializedExtensionCardFieldDefinition = exports.isSerializedFieldOptions = exports.isSerializedFieldOption = exports.deserializeFieldOption = exports.serializeCardFieldArrayDefinition = exports.serializeCardFieldDefinition = exports.serializeCardFieldOption = exports.isSerializedCardUserDataArray = exports.isSerializedCardUserData = exports.deserializeCardUserData = exports.serializeCardUserData = void 0;\nconst schemadefinition_1 = __webpack_require__(/*! ../../data/schemadefinition */ \"./node_modules/lucid-extension-sdk/data/schemadefinition.js\");\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst serializedfielddefinition_1 = __webpack_require__(/*! ../data/serializedfield/serializedfielddefinition */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\");\nconst serializedfields_1 = __webpack_require__(/*! ../data/serializedfield/serializedfields */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/** @ignore */\nfunction serializeCardUserData(userData) {\n    return Object.assign({ 'e': userData.email }, serializeCardFieldOption(userData));\n}\nexports.serializeCardUserData = serializeCardUserData;\n/** @ignore */\nfunction deserializeCardUserData(userData) {\n    return Object.assign({ email: userData['e'] }, deserializeFieldOption(userData));\n}\nexports.deserializeCardUserData = deserializeCardUserData;\nexports.isSerializedCardUserData = (0, validators_1.objectValidator)({\n    'e': (0, validators_1.option)(checks_1.isString),\n    'l': checks_1.isString,\n    'v': serializedfields_1.isSerializedFieldType,\n    'i': (0, validators_1.option)(checks_1.isString),\n});\nexports.isSerializedCardUserDataArray = (0, validators_1.arrayValidator)(exports.isSerializedCardUserData);\n/** @ignore */\nfunction serializeCardFieldOption(option) {\n    return {\n        'l': option.label,\n        'v': option.value,\n        'i': option.iconUrl,\n    };\n}\nexports.serializeCardFieldOption = serializeCardFieldOption;\n/** @ignore */\nfunction serializeCardFieldDefinition(field) {\n    var _a;\n    return Object.assign(Object.assign({}, (0, schemadefinition_1.serializeFieldDefinition)(field)), { 'l': field.label, 'def': field.default, 'd': field.description, 'op': (0, checks_1.isString)(field.options) ? field.options : (_a = field.options) === null || _a === void 0 ? void 0 : _a.map(serializeCardFieldOption), 's': field.search, 'u': field.unsetFieldsWhenChanged });\n}\nexports.serializeCardFieldDefinition = serializeCardFieldDefinition;\n/** @ignore */\nfunction serializeCardFieldArrayDefinition(fields) {\n    return fields.map(serializeCardFieldDefinition);\n}\nexports.serializeCardFieldArrayDefinition = serializeCardFieldArrayDefinition;\n/** @ignore */\nfunction deserializeFieldOption(option) {\n    return {\n        label: option['l'],\n        value: option['v'],\n        iconUrl: option['i'],\n    };\n}\nexports.deserializeFieldOption = deserializeFieldOption;\nexports.isSerializedFieldOption = (0, validators_1.objectValidator)({\n    'l': checks_1.isString,\n    'v': serializedfields_1.isSerializedFieldType,\n    'i': (0, validators_1.option)(checks_1.isString),\n});\nexports.isSerializedFieldOptions = (0, validators_1.arrayValidator)(exports.isSerializedFieldOption);\n/** @ignore */\nexports.isSerializedExtensionCardFieldDefinition = (0, validators_1.objectValidator)({\n    'Name': checks_1.isString,\n    'Type': fieldtypedefinition_1.isSerializedFieldTypeDefinition,\n    'Constraints': (0, validators_1.option)((0, validators_1.arrayValidator)(serializedfielddefinition_1.isSerializedFieldConstraint)),\n    'l': checks_1.isString,\n    'd': (0, validators_1.option)(checks_1.isString),\n    'def': (0, validators_1.option)(serializedfields_1.isSerializedFieldType),\n    'op': (0, validators_1.option)((0, validators_1.either)(checks_1.isString, (0, validators_1.arrayValidator)(exports.isSerializedFieldOption))),\n    's': (0, validators_1.option)(checks_1.isString),\n    'u': (0, validators_1.option)((0, checks_1.isTypedArray)(checks_1.isString)),\n});\n/** @ignore */\nfunction deserializeCardFieldDefinition(field) {\n    var _a;\n    return Object.assign(Object.assign({}, (0, schemadefinition_1.parseFieldDefinition)(field)), { label: field['l'], description: field['d'], default: field['def'], options: (0, checks_1.isString)(field['op']) ? field['op'] : (_a = field['op']) === null || _a === void 0 ? void 0 : _a.map(deserializeFieldOption), search: field['s'], unsetFieldsWhenChanged: field['u'] });\n}\nexports.deserializeCardFieldDefinition = deserializeCardFieldDefinition;\n/** @ignore */\nfunction deserializeCardFieldArrayDefinition(fields) {\n    return fields.map(deserializeCardFieldDefinition);\n}\nexports.deserializeCardFieldArrayDefinition = deserializeCardFieldArrayDefinition;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/sharedcardintegration/cardintegrationdefinitions.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidSpreadsheetIntegration = exports.CustomDetailsChooser = exports.ListChooser = exports.isImportedResults = exports.lucidSpreadsheetIntegrationFailureTypeValidator = exports.LucidSpreadsheetIntegrationFailureType = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializedupstreamconfig_1 = __webpack_require__(/*! ../data/datasource/serializedupstreamconfig */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js\");\nconst serializedschema_1 = __webpack_require__(/*! ../data/serializedfield/serializedschema */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js\");\nconst jsonserializable_1 = __webpack_require__(/*! ../jsonserializable */ \"./node_modules/lucid-extension-sdk/core/jsonserializable.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar LucidSpreadsheetIntegrationFailureType;\n(function (LucidSpreadsheetIntegrationFailureType) {\n    LucidSpreadsheetIntegrationFailureType[\"AuthorizationFailure\"] = \"AuthorizationFailure\";\n    LucidSpreadsheetIntegrationFailureType[\"GenericFailure\"] = \"GenericFailure\";\n    LucidSpreadsheetIntegrationFailureType[\"UserCancelled\"] = \"UserCanceled\";\n    LucidSpreadsheetIntegrationFailureType[\"PopupsNotAllowed\"] = \"PopupsNotAllowed\";\n})(LucidSpreadsheetIntegrationFailureType || (exports.LucidSpreadsheetIntegrationFailureType = LucidSpreadsheetIntegrationFailureType = {}));\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.lucidSpreadsheetIntegrationFailureTypeValidator = (0, validators_1.stringEnumValidator)(LucidSpreadsheetIntegrationFailureType);\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isImportedResults = (0, validators_1.strictObjectValidator)({\n    'upstreamConfig': serializedupstreamconfig_1.isSerializedUpstreamConfig,\n    'collections': (0, validators_1.arrayValidator)((0, validators_1.strictObjectValidator)({\n        'collectionId': checks_1.isString,\n        'headerRow': checks_1.isNumber,\n        'schema': serializedschema_1.isSerializedSchema,\n        'upstreamConfig': jsonserializable_1.isJsonSerializable,\n    })),\n});\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nclass ListChooser {\n    constructor(getList) {\n        this.getList = getList;\n    }\n}\nexports.ListChooser = ListChooser;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nclass CustomDetailsChooser {\n    constructor(getConfig) {\n        this.getConfig = getConfig;\n    }\n}\nexports.CustomDetailsChooser = CustomDetailsChooser;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nclass LucidSpreadsheetIntegration {\n    constructor() {\n        this.addCardsIntegration = true;\n    }\n}\nexports.LucidSpreadsheetIntegration = LucidSpreadsheetIntegration;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidSpreadsheetIntegrationRegistry = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst cardintegrationdefinitions_1 = __webpack_require__(/*! ../sharedcardintegration/cardintegrationdefinitions */ \"./node_modules/lucid-extension-sdk/core/sharedcardintegration/cardintegrationdefinitions.js\");\nconst lucidspreadsheetintegration_1 = __webpack_require__(/*! ./lucidspreadsheetintegration */ \"./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nclass LucidSpreadsheetIntegrationRegistry {\n    static nextHookName() {\n        return '__lucidspreadsheet__hook' + this.nextHookId++;\n    }\n    /**\n     * Register a spreadsheet integration.\n     */\n    static addSpreadsheetIntegration(client, spreadsheetIntegration) {\n        let configChooserActions;\n        const configChooser = spreadsheetIntegration.configChooser;\n        if (configChooser instanceof lucidspreadsheetintegration_1.CustomDetailsChooser) {\n            const actionName = LucidSpreadsheetIntegrationRegistry.nextHookName();\n            configChooserActions = actionName;\n            client.registerAction(actionName, async () => {\n                try {\n                    return await configChooser.getConfig();\n                }\n                catch (error) { }\n                return lucidspreadsheetintegration_1.LucidSpreadsheetIntegrationFailureType.GenericFailure;\n            });\n        }\n        else {\n            const actionName = LucidSpreadsheetIntegrationRegistry.nextHookName();\n            configChooserActions = { 'l': actionName };\n            client.registerAction(actionName, async () => {\n                try {\n                    const result = await configChooser.getList();\n                    if ((0, checks_1.isString)(result)) {\n                        return result;\n                    }\n                    return {\n                        'h': result.header,\n                        'r': result.rows.map(({ icon, id, values }) => ({ 'i': icon, 'd': id, 'l': values })),\n                    };\n                }\n                catch (error) { }\n                return lucidspreadsheetintegration_1.LucidSpreadsheetIntegrationFailureType.GenericFailure;\n            });\n        }\n        const getMultipleSheetsForSpreadsheetDetailsActionName = LucidSpreadsheetIntegrationRegistry.nextHookName();\n        client.registerAction(getMultipleSheetsForSpreadsheetDetailsActionName, async (message) => {\n            try {\n                const result = await spreadsheetIntegration.getMultipleSheetsForSpreadsheetDetails(message['spreadsheetDetails']);\n                if ((0, lucidspreadsheetintegration_1.lucidSpreadsheetIntegrationFailureTypeValidator)(result)) {\n                    return result;\n                }\n                else {\n                    // Serialize the Map\n                    return Array.from(result);\n                }\n            }\n            catch (error) { }\n            return lucidspreadsheetintegration_1.LucidSpreadsheetIntegrationFailureType.GenericFailure;\n        });\n        const serialized = {\n            'ld': spreadsheetIntegration.labelDescription,\n            'li': spreadsheetIntegration.labelIconUrl,\n            'dc': spreadsheetIntegration.dataConnectorName,\n            'c': spreadsheetIntegration.addCardsIntegration,\n            'gs': configChooserActions,\n            'gm': getMultipleSheetsForSpreadsheetDetailsActionName,\n        };\n        if (spreadsheetIntegration.iconConfiguration) {\n            serialized['icu'] = {\n                'pi': spreadsheetIntegration.iconConfiguration.primaryIconUrl,\n                'li': spreadsheetIntegration.iconConfiguration.lightIconUrl,\n                'di': spreadsheetIntegration.iconConfiguration.darkIconUrl,\n            };\n        }\n        if (spreadsheetIntegration.addCard) {\n            const addCard = spreadsheetIntegration.addCard;\n            serialized['ac'] = {\n                'gif': LucidSpreadsheetIntegrationRegistry.nextHookName(),\n                'cc': LucidSpreadsheetIntegrationRegistry.nextHookName(),\n            };\n            client.registerAction(serialized['ac']['gif'], async ({ 'i': inputSoFar }) => {\n                const result = await addCard.getInputFields(new Map(inputSoFar));\n                return (0, cardintegrationdefinitions_1.serializeCardFieldArrayDefinition)(result);\n            });\n            client.registerAction(serialized['ac']['cc'], async ({ 'i': input }) => {\n                const result = await addCard.createCardData(new Map(input));\n                return {\n                    'c': result.collection.id,\n                    'pk': result.primaryKey,\n                };\n            });\n        }\n        if (spreadsheetIntegration.getUpstreamSourceUrl) {\n            const getUpstreamSourceUrl = LucidSpreadsheetIntegrationRegistry.nextHookName();\n            client.registerAction(getUpstreamSourceUrl, async (message) => {\n                try {\n                    if (!spreadsheetIntegration.getUpstreamSourceUrl) {\n                        return lucidspreadsheetintegration_1.LucidSpreadsheetIntegrationFailureType.GenericFailure;\n                    }\n                    const result = await spreadsheetIntegration.getUpstreamSourceUrl(message['spreadsheetDetails'], message['sheetId']);\n                    if ((0, lucidspreadsheetintegration_1.lucidSpreadsheetIntegrationFailureTypeValidator)(result)) {\n                        return result;\n                    }\n                    else {\n                        return result.url;\n                    }\n                }\n                catch (error) { }\n                return lucidspreadsheetintegration_1.LucidSpreadsheetIntegrationFailureType.GenericFailure;\n            });\n            serialized['gu'] = getUpstreamSourceUrl;\n        }\n        client.sendCommand(\"asi\" /* CommandName.AddSpreadsheetIntegration */, serialized);\n    }\n}\nexports.LucidSpreadsheetIntegrationRegistry = LucidSpreadsheetIntegrationRegistry;\nLucidSpreadsheetIntegrationRegistry.nextHookId = 0;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UnfurlCallbackType = void 0;\nvar UnfurlCallbackType;\n(function (UnfurlCallbackType) {\n    UnfurlCallbackType[\"Unfurl\"] = \"u\";\n    UnfurlCallbackType[\"AfterUnfurl\"] = \"a\";\n    UnfurlCallbackType[\"ExpandCallback\"] = \"e\";\n})(UnfurlCallbackType || (exports.UnfurlCallbackType = UnfurlCallbackType = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeUnfurlDetails = exports.deserializeUnfurlDetails = exports.isValidUnfurlDetails = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst unfurliframe_1 = __webpack_require__(/*! ./unfurliframe */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js\");\nconst unfurlthumbnail_1 = __webpack_require__(/*! ./unfurlthumbnail */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js\");\n/** @ignore */\nexports.isValidUnfurlDetails = (0, validators_1.objectValidator)({\n    'ProviderName': checks_1.isString,\n    'ProviderFaviconUrl': checks_1.isString,\n    'UnfurlTitle': (0, validators_1.option)(checks_1.isString),\n    'Iframe': (0, validators_1.option)(unfurliframe_1.isValidUnfurlIframe),\n    'Thumbnails': (0, validators_1.option)((0, validators_1.arrayValidator)(unfurlthumbnail_1.isValidUnfurlThumbnail)),\n    'PreviewImageUrl': (0, validators_1.option)(checks_1.isString),\n});\n/** @ignore */\nfunction deserializeUnfurlDetails(raw) {\n    var _a;\n    return {\n        providerName: raw['ProviderName'],\n        providerFaviconUrl: raw['ProviderFaviconUrl'],\n        unfurlTitle: raw['UnfurlTitle'],\n        iframe: raw['Iframe'] && (0, unfurliframe_1.deserializeUnfurlIframe)(raw['Iframe']),\n        thumbnails: (_a = raw['Thumbnails']) === null || _a === void 0 ? void 0 : _a.map((raw) => (0, unfurlthumbnail_1.deserializeUnfurlThumbnail)(raw)),\n        previewImageUrl: raw['PreviewImageUrl'],\n    };\n}\nexports.deserializeUnfurlDetails = deserializeUnfurlDetails;\n/** @ignore */\nfunction serializeUnfurlDetails(concrete) {\n    var _a;\n    return {\n        'ProviderName': concrete.providerName,\n        'ProviderFaviconUrl': concrete.providerFaviconUrl,\n        'UnfurlTitle': concrete.unfurlTitle,\n        'Iframe': concrete.iframe && (0, unfurliframe_1.serializeUnfurlIframe)(concrete.iframe),\n        'Thumbnails': (_a = concrete.thumbnails) === null || _a === void 0 ? void 0 : _a.map((raw) => (0, unfurlthumbnail_1.serializeUnfurlThumbnail)(raw)),\n        'PreviewImageUrl': concrete.previewImageUrl,\n    };\n}\nexports.serializeUnfurlDetails = serializeUnfurlDetails;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateIframeAttributes = exports.getIFrameWidth = exports.getIFrameHeight = exports.serializeUnfurlIframe = exports.deserializeUnfurlIframe = exports.isValidUnfurlIframe = exports.UnfurlIframeAspectRatio = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst iframeutils_1 = __webpack_require__(/*! ../iframe/iframeutils */ \"./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * An enumeration of of the supported unfurl Iframe aspect ratio.\n * The iframe will be maximized to fit the screen responsively\n */\nvar UnfurlIframeAspectRatio;\n(function (UnfurlIframeAspectRatio) {\n    /**\n     * Aspect ratio 1:1, square\n     */\n    UnfurlIframeAspectRatio[\"Square\"] = \"1:1\";\n    /**\n     * Aspect ratio 16:9, wider rectangle\n     * This will be the default setting if not provided\n     */\n    UnfurlIframeAspectRatio[\"SixteenToNine\"] = \"16:9\";\n    /**\n     * Aspect ratio 9:16, taller rectangle\n     */\n    UnfurlIframeAspectRatio[\"NineToSixteen\"] = \"9:16\";\n    /**\n     * Aspect ratio 4:3, wider rectangle\n     */\n    UnfurlIframeAspectRatio[\"FourToThree\"] = \"4:3\";\n    /**\n     * Aspect ratio 3:4, taller rectangle\n     */\n    UnfurlIframeAspectRatio[\"ThreeToFour\"] = \"3:4\";\n})(UnfurlIframeAspectRatio || (exports.UnfurlIframeAspectRatio = UnfurlIframeAspectRatio = {}));\n/** @ignore */\nexports.isValidUnfurlIframe = (0, validators_1.objectValidator)({\n    'IframeUrl': checks_1.isString,\n    'AspectRatio': (0, validators_1.option)((0, validators_1.stringEnumValidator)(UnfurlIframeAspectRatio)),\n    'IframeTitle': (0, validators_1.option)(checks_1.isString),\n});\n/** @ignore */\nfunction deserializeUnfurlIframe(raw) {\n    return {\n        iframeUrl: raw['IframeUrl'],\n        aspectRatio: raw['AspectRatio'],\n        iframeTitle: raw['IframeTitle'],\n    };\n}\nexports.deserializeUnfurlIframe = deserializeUnfurlIframe;\n/** @ignore */\nfunction serializeUnfurlIframe(concrete) {\n    return {\n        'IframeUrl': concrete.iframeUrl,\n        'AspectRatio': concrete.aspectRatio,\n        'IframeTitle': concrete.iframeTitle,\n    };\n}\nexports.serializeUnfurlIframe = serializeUnfurlIframe;\n/** @ignore */\nfunction getIFrameHeight(unfurlIframeAspectRatio) {\n    switch (unfurlIframeAspectRatio) {\n        case UnfurlIframeAspectRatio.Square:\n            return 1;\n        case UnfurlIframeAspectRatio.SixteenToNine:\n            return 9;\n        case UnfurlIframeAspectRatio.NineToSixteen:\n            return 16;\n        case UnfurlIframeAspectRatio.FourToThree:\n            return 3;\n        case UnfurlIframeAspectRatio.ThreeToFour:\n            return 4;\n        default:\n            return 9;\n    }\n}\nexports.getIFrameHeight = getIFrameHeight;\n/** @ignore */\nfunction getIFrameWidth(unfurlIframeAspectRatio) {\n    switch (unfurlIframeAspectRatio) {\n        case UnfurlIframeAspectRatio.Square:\n            return 1;\n        case UnfurlIframeAspectRatio.SixteenToNine:\n            return 16;\n        case UnfurlIframeAspectRatio.NineToSixteen:\n            return 9;\n        case UnfurlIframeAspectRatio.FourToThree:\n            return 4;\n        case UnfurlIframeAspectRatio.ThreeToFour:\n            return 3;\n        default:\n            return 16;\n    }\n}\nexports.getIFrameWidth = getIFrameWidth;\nfunction generateIframeAttributes(unfurlIframe) {\n    const iframeAttributes = {\n        src: unfurlIframe.iframeUrl,\n        height: unfurlIframe.aspectRatio ? getIFrameHeight(unfurlIframe.aspectRatio) : iframeutils_1.DEFAULT_IFRAME_HEIGHT,\n        width: unfurlIframe.aspectRatio ? getIFrameWidth(unfurlIframe.aspectRatio) : iframeutils_1.DEFAULT_IFRAME_WIDTH,\n        title: unfurlIframe.iframeTitle,\n    };\n    return iframeAttributes;\n}\nexports.generateIframeAttributes = generateIframeAttributes;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js":
/*!********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unfurlRefreshErrorTypeValidator = exports.UnfurlRefreshErrorType = void 0;\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nvar UnfurlRefreshErrorType;\n(function (UnfurlRefreshErrorType) {\n    UnfurlRefreshErrorType[\"AuthorizationFailure\"] = \"Authorization failure\";\n    UnfurlRefreshErrorType[\"GenericFailure\"] = \"Generic failure\";\n})(UnfurlRefreshErrorType || (exports.UnfurlRefreshErrorType = UnfurlRefreshErrorType = {}));\nexports.unfurlRefreshErrorTypeValidator = (0, validators_1.stringEnumValidator)(UnfurlRefreshErrorType);\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeUnfurlThumbnail = exports.deserializeUnfurlThumbnail = exports.isValidUnfurlThumbnail = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/** @ignore */\nexports.isValidUnfurlThumbnail = (0, validators_1.objectValidator)({\n    'url': checks_1.isString,\n    'width': (0, validators_1.nullableOption)(checks_1.isNumber),\n    'height': (0, validators_1.nullableOption)(checks_1.isNumber),\n});\n/** @ignore */\nfunction deserializeUnfurlThumbnail(raw) {\n    var _a, _b;\n    return {\n        url: raw['url'],\n        width: (_a = raw['width']) !== null && _a !== void 0 ? _a : undefined,\n        height: (_b = raw['height']) !== null && _b !== void 0 ? _b : undefined,\n    };\n}\nexports.deserializeUnfurlThumbnail = deserializeUnfurlThumbnail;\n/** @ignore */\nfunction serializeUnfurlThumbnail(concrete) {\n    return {\n        'url': concrete.url,\n        'width': concrete.width,\n        'height': concrete.height,\n    };\n}\nexports.serializeUnfurlThumbnail = serializeUnfurlThumbnail;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/validators/validators.js":
/*!************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/validators/validators.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.asAssertion = exports.validatorWithMessage = exports.minLengthValidator = exports.maxLengthValidator = exports.isDate = exports.isPositiveNumber = exports.isSize = exports.isPanelSize = exports.isBoundingBox = exports.isPointLike = exports.isOpacity = exports.isFalse = exports.isTrue = exports.isFlag = exports.isRestrictions = exports.isStringOrNegativeOne = exports.isBooleanOrEmptyString = exports.isNumberOrEmptyString = exports.isSet = exports.propertyValidator = exports.exclude = exports.bothWithInvalidFieldTracking = exports.both = exports.either = exports.isNullOption = exports.nullableOption = exports.option = exports.nullableValidatorWithInvalidElementTracking = exports.nullable = exports.objectOfValidatorWithInvalidFieldTracking = exports.objectOfValidator = exports.typedRecordValidator = exports.recordValidator = exports.strictObjectValidator = exports.partialObjectValidator = exports.objectValidatorWithInvalidFieldTracking = exports.objectValidator = exports.mapValidator = exports.someValidator = exports.someValue = exports.tupleValidator = exports.arrayValidatorWithInvalidElementTracking = exports.arrayValidator = exports.rangeValidator = exports.enumValidator = exports.stringEnumValidator = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\n/*********************************************************************************\n * Validator generators:  These functions construct new composite validators\n *from elemental validators.\n ********************************************************************************/\n/**\n * Creates a validator which tests if the target is a string\n * and is one of the values in the specified enum (object).\n */\nfunction stringEnumValidator(enumMap) {\n    const enumValues = new Set();\n    for (const key in enumMap) {\n        const enumValue = enumMap[key];\n        if ((0, checks_1.isString)(enumValue)) {\n            enumValues.add(enumValue);\n        }\n    }\n    // this allows using Set:has on unknown type\n    const unknownEnumValues = enumValues;\n    return (x) => {\n        return unknownEnumValues.has(x);\n    };\n}\nexports.stringEnumValidator = stringEnumValidator;\n/**\n * Creates a validator which tests if the target is a value in the specified enum.\n * Note that numbers in enums are reverse-mapped by the TS transpiler, so the specified keys are also values.\n */\nfunction enumValidator(enumMap) {\n    return (x) => {\n        for (const key in enumMap) {\n            if (enumMap[key] === x) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.enumValidator = enumValidator;\n/**\n * Creates a validator which tests if the target is a number\n * and is equal to or between the min and max values.\n *\n */\nfunction rangeValidator(min, max) {\n    return (x) => {\n        return (0, checks_1.isNumber)(x) && x >= min && x <= max;\n    };\n}\nexports.rangeValidator = rangeValidator;\n/**\n * Creates a validator which tests if the target is an array\n * and if all elements of the array satisfy the given\n * sub-validator.\n *\n * @return A validator for the array type\n */\nfunction arrayValidator(subValidator) {\n    return (x) => {\n        return (0, checks_1.isArray)(x) && x.every(subValidator);\n    };\n}\nexports.arrayValidator = arrayValidator;\n/**\n * This validator functions the same as {@link arrayValidator}, with the option of passing in a map\n * which will track all of the elements that were found to be invalid.\n */\nfunction arrayValidatorWithInvalidElementTracking(subValidator) {\n    return (subject, invalidElements, level = 0) => {\n        var _a;\n        if (!(0, checks_1.isArray)(subject)) {\n            return false;\n        }\n        let valid = true;\n        const invalidList = [];\n        subject.forEach((item) => {\n            if (!subValidator(item, invalidElements, level + 1)) {\n                invalidList.push(item);\n                valid = false;\n            }\n        });\n        if ((0, checks_1.isMap)(invalidElements)) {\n            const prevInvalidList = (_a = invalidElements.get(level)) !== null && _a !== void 0 ? _a : [];\n            invalidElements.set(level, prevInvalidList.concat(invalidList));\n        }\n        return valid;\n    };\n}\nexports.arrayValidatorWithInvalidElementTracking = arrayValidatorWithInvalidElementTracking;\n/**\n * Creates a validator for a fixed width array where each entry\n * in the array can have a separate validator\n */\nfunction tupleValidator(...tupleValidators) {\n    return (x) => {\n        return (typeof x === 'object' &&\n            tupleValidators.length === x.length &&\n            tupleValidators.every((subX, index) => subX(x[index])));\n    };\n}\nexports.tupleValidator = tupleValidator;\n/**\n * Creates a validator that the given unknown is one of the supplied values\n */\nfunction someValue(...values) {\n    return (x) => {\n        for (const value of values) {\n            if (x === value) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.someValue = someValue;\n/**\n * Creates a validator that the given unknown matches at least one of the given validators\n */\nfunction someValidator(...validators) {\n    return (x) => {\n        for (const validator of validators) {\n            if (validator(x)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.someValidator = someValidator;\n/**\n * Creates a validator which tests if the target is an object\n * and if all values in the object satisfy the given sub-validator.\n * This does *not* perform any tests on the object keys, which\n * are allowed to be arbitrary strings.\n *\n * @return A validator for the map\n * Note that unlike objectValidator, this performs no validation on the names or\n * number of the keys and treats all values equally\n */\nfunction mapValidator(subValidator) {\n    return (x) => {\n        return (0, checks_1.isObject)(x) && !(0, checks_1.isArray)(x) && Object.entries(x).every(([key, value]) => subValidator(value));\n    };\n}\nexports.mapValidator = mapValidator;\n/**\n * Creates a validator which tests if the target is an object\n * and if the structure of the object matches the structure of the passed-in\n * validator object.  The values in the validator object are in turn\n * validators.  This means that if the validator object has a (key,value)\n * pair of the form ('key', keyValidator), then in order for the target object\n * (x) to match, keyValidator(x['key']) must return true for all keys in the\n * validatorStructure.\n *\n * Note that you can use `lucid.validators.option` to create optional parameters\n * in validation structure.\n */\nfunction objectValidator(validatorStructure) {\n    return (subject) => {\n        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {\n            return false;\n        }\n        else {\n            return Object.entries(validatorStructure).every(([key, validator]) => {\n                return validator(subject[key]);\n            });\n        }\n    };\n}\nexports.objectValidator = objectValidator;\n/**\n * This validator functions the same as {@link objectValidator}, with the option of passing in a map\n * which will track all of the fields that were found to be invalid.\n */\nfunction objectValidatorWithInvalidFieldTracking(validatorStructure) {\n    return (subject, invalidFields, level = 0) => {\n        var _a;\n        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {\n            return false;\n        }\n        else {\n            let valid = true;\n            const invalidList = [];\n            Object.entries(validatorStructure).forEach(([key, validator]) => {\n                if (!validator(subject[key], invalidFields, level + 1)) {\n                    invalidList.push([key, subject[key]]);\n                    valid = false;\n                }\n            });\n            if ((0, checks_1.isMap)(invalidFields)) {\n                const prevInvalidList = (_a = invalidFields.get(level)) !== null && _a !== void 0 ? _a : [];\n                invalidFields.set(level, prevInvalidList.concat(invalidList));\n            }\n            return valid;\n        }\n    };\n}\nexports.objectValidatorWithInvalidFieldTracking = objectValidatorWithInvalidFieldTracking;\n/**\n * Creates a validator which tests if the target is an object\n * and if the structure of the object matches the structure of the passed-in\n * validator object, but with every entry being optional.\n */\nfunction partialObjectValidator(validatorStructure) {\n    return (subject) => {\n        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {\n            return false;\n        }\n        else {\n            return Object.entries(validatorStructure).every(([key, validator]) => {\n                return subject[key] === undefined || validator(subject[key]);\n            });\n        }\n    };\n}\nexports.partialObjectValidator = partialObjectValidator;\n/**\n * Similar to {@link objectValidator}, but if the object has any non-undefined keys, they must also be present in the validator structure.\n * This is useful for things where extra data is unwanted, like Property serialization.\n * the loose version is often prefered because this one makes backwards compatible changes to the data harder,\n * because it requires an additional PR when the data transfers between services:\n * 1. A PR that adds the option() to this validator; 2. A PR that sends the new data; 3. A PR to remove the option();\n * compared to the (non-strict)objectValidator steps:\n * 1. A PR that adds the option() to this validator and sends the new data; 2. A PR to remove the option();\n */\nfunction strictObjectValidator(validatorStructure) {\n    const looseValidator = objectValidator(validatorStructure);\n    return (subject) => {\n        return (looseValidator(subject) &&\n            Object.entries(subject).every(([key, subx]) => subx === undefined || validatorStructure.hasOwnProperty(key)));\n    };\n}\nexports.strictObjectValidator = strictObjectValidator;\nfunction recordValidator(keyList, valueValidator) {\n    return (x) => {\n        return ((0, checks_1.isObject)(x) &&\n            !(0, checks_1.isArray)(x) &&\n            keyList.every((k) => k in x) &&\n            Object.entries(x).every(([key, val]) => {\n                return valueValidator(val);\n            }));\n    };\n}\nexports.recordValidator = recordValidator;\nfunction typedRecordValidator(keyValidator, valueValidator) {\n    return (x) => {\n        if ((0, checks_1.isArray)(x) || !(0, checks_1.isObject)(x)) {\n            return false;\n        }\n        return Object.keys(x).every((key) => keyValidator(key)) && Object.values(x).every((val) => valueValidator(val));\n    };\n}\nexports.typedRecordValidator = typedRecordValidator;\nfunction objectOfValidator(subValidator) {\n    return (x) => {\n        if ((0, checks_1.isArray)(x) || !(0, checks_1.isObject)(x)) {\n            return false;\n        }\n        return Object.values(x).every((val) => subValidator(val));\n    };\n}\nexports.objectOfValidator = objectOfValidator;\n/**\n * This validator functions the same as {@link objectOfValidator}, with the option of passing in a map\n * which will track all of the fields that were found to be invalid.\n */\nfunction objectOfValidatorWithInvalidFieldTracking(subValidator) {\n    return (subject, invalidFields, level = 0) => {\n        var _a;\n        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {\n            return false;\n        }\n        let valid = true;\n        const invalidList = [];\n        Object.entries(subject).forEach(([key, val]) => {\n            if (!subValidator(val, invalidFields, level + 1)) {\n                invalidList.push([key, val]);\n                valid = false;\n            }\n        });\n        if ((0, checks_1.isMap)(invalidFields)) {\n            const prevInvalidList = (_a = invalidFields.get(level)) !== null && _a !== void 0 ? _a : [];\n            invalidFields.set(level, prevInvalidList.concat(invalidList));\n        }\n        return valid;\n    };\n}\nexports.objectOfValidatorWithInvalidFieldTracking = objectOfValidatorWithInvalidFieldTracking;\n/**\n * Create a validator which allows the target to be either null or satisfy the\n * sub-validator.\n *\n * @return A validator for the array type\n */\nfunction nullable(subValidator) {\n    return (x) => {\n        return x === null || subValidator(x);\n    };\n}\nexports.nullable = nullable;\n/**\n * Create a validator which allows the target to be either null or satisfy the\n * sub-validator.\n *\n * @return A validator for the array type\n */\nfunction nullableValidatorWithInvalidElementTracking(subValidator) {\n    return (subject, invalidElements, level = 0) => {\n        return subject === null || subValidator(subject, invalidElements, level);\n    };\n}\nexports.nullableValidatorWithInvalidElementTracking = nullableValidatorWithInvalidElementTracking;\n/**\n * Create a validator which allows the target to be undefined or satisfy the\n * sub-validator.\n *\n * @return A validator for the array type\n */\nfunction option(subValidator) {\n    return (x) => {\n        return x === undefined || subValidator(x);\n    };\n}\nexports.option = option;\n/**\n * Create a validator which allows the target to be undefined, null, or satisfy\n * the sub-validator.\n *\n * @return A validator for the array type\n */\nfunction nullableOption(subValidator) {\n    return (x) => {\n        return x === null || x === undefined || subValidator(x);\n    };\n}\nexports.nullableOption = nullableOption;\nconst isNullOption = (value) => {\n    return value == null;\n};\nexports.isNullOption = isNullOption;\n/**\n * Create a validator that merges two validators.\n * This is useful for validating properties that have 2 disjoint sets of possible values.\n * e.g. {someObject: string}|false\n */\nfunction either(validatorA, validatorB) {\n    return (x) => {\n        return validatorA(x) || validatorB(x);\n    };\n}\nexports.either = either;\n/**\n * Create a validator that combines two validators.\n * This is useful for validating properties that have been composed of a generic and more specific values.\n */\nfunction both(validatorA, validatorB) {\n    return (x) => {\n        return validatorA(x) && validatorB(x);\n    };\n}\nexports.both = both;\nfunction bothWithInvalidFieldTracking(validatorA, validatorB) {\n    return (x, invalidFields, level = 0) => {\n        return validatorA(x, invalidFields, level) && validatorB(x, invalidFields, level);\n    };\n}\nexports.bothWithInvalidFieldTracking = bothWithInvalidFieldTracking;\n/**\n * Create a validator that allows types excluding those that satisfy an excludeValidator.\n */\nfunction exclude(validator, excludeValidator) {\n    return (x) => validator(x) && !excludeValidator(x);\n}\nexports.exclude = exclude;\n/**\n * Get a validator which returns whether the property calculation structure is\n * correct.\n */\nfunction propertyValidator(subValidator, preSaveActions) {\n    const processedValidator = (x) => {\n        const y = preSaveActions.reduce((px, psa) => psa(px), x);\n        return subValidator(y);\n    };\n    return strictObjectValidator({ 'Equation': checks_1.isString, 'StaticValue': processedValidator });\n}\nexports.propertyValidator = propertyValidator;\n/*********************************************************************************\n * Validators:  Some useful predefined validator functions.\n ********************************************************************************/\n/**\n * This validator only allows objects whose values are all booleans set to true.\n *\n * @return A validator for the map\n */\nfunction isSet(x) {\n    return (0, checks_1.isObject)(x) && !(0, checks_1.isArray)(x) && Object.entries(x).every(([key, value]) => (0, checks_1.isBoolean)(value) && !!value);\n}\nexports.isSet = isSet;\n/**\n * This validator validates that value is either number or empty string\n */\nexports.isNumberOrEmptyString = either(checks_1.isNumber, (v) => v === '');\n/**\n * This validator validates that value is either boolean or empty string\n */\nexports.isBooleanOrEmptyString = either(checks_1.isBoolean, (v) => v === '');\n/**\n * This validator validates that value is either string or -1\n */\nexports.isStringOrNegativeOne = either(checks_1.isString, (v) => v === -1);\n/**\n * This validator validates model of lucid.model.restrictions\n */\nexports.isRestrictions = strictObjectValidator({\n    'b': nullableOption(checks_1.isBoolean),\n    'p': nullableOption(checks_1.isBoolean),\n    'c': nullableOption(checks_1.isBoolean),\n    'f': nullableOption(checks_1.isBoolean),\n    'o': nullableOption(checks_1.isBoolean),\n    'e': nullableOption(checks_1.isBoolean),\n    'fc': nullableOption(checks_1.isBoolean),\n    'fs': nullableOption(checks_1.isBoolean),\n    'l': nullableOption(checks_1.isBoolean),\n    'i': nullableOption(checks_1.isBoolean),\n    'u': nullableOption(checks_1.isBoolean),\n    'acap': nullableOption(checks_1.isBoolean),\n    'scap': nullableOption(checks_1.isBoolean),\n    'imageCategory': nullableOption(checks_1.isBoolean),\n    'pcad': nullableOption(checks_1.isBoolean),\n});\n/**\n * Returns true if the target is equal to either zero or one or is a boolean.\n *\n */\nfunction isFlag(x) {\n    return x === 0 || x === 1 || (0, checks_1.isBoolean)(x);\n}\nexports.isFlag = isFlag;\nfunction isTrue(x) {\n    return x === true;\n}\nexports.isTrue = isTrue;\nfunction isFalse(x) {\n    return x === false;\n}\nexports.isFalse = isFalse;\n/**\n * Returns if an object is a number between 0 and 100.\n *\n */\nexports.isOpacity = rangeValidator(0, 100);\n/**\n * Tests if the given target satisfies the PointLike interface.\n *\n */\nexports.isPointLike = objectValidator({ x: checks_1.isNumber, y: checks_1.isNumber });\n/**\n * Tests if the given target is a bounding box.\n *\n */\nexports.isBoundingBox = objectValidator({\n    x: checks_1.isNumber,\n    y: checks_1.isNumber,\n    w: checks_1.isNumber,\n    h: checks_1.isNumber,\n});\n/**\n * Tests if the given target is a panel size.\n *\n */\nexports.isPanelSize = objectValidator({\n    x: checks_1.isNumber,\n    y: checks_1.isNumber,\n    w: checks_1.isNumber,\n    h: checks_1.isNumber,\n    'identifier': nullableOption(checks_1.isString),\n});\nexports.isSize = objectValidator({\n    w: checks_1.isNumber,\n    h: checks_1.isNumber,\n});\nfunction isPositiveNumber(x) {\n    return (0, checks_1.isNumber)(x) && x >= 0;\n}\nexports.isPositiveNumber = isPositiveNumber;\nfunction isDate(x) {\n    return x instanceof Date;\n}\nexports.isDate = isDate;\nfunction maxLengthValidator(max) {\n    return (x) => (0, checks_1.isString)(x) && x.length <= max;\n}\nexports.maxLengthValidator = maxLengthValidator;\nfunction minLengthValidator(min) {\n    return (x) => (0, checks_1.isString)(x) && x.length >= min;\n}\nexports.minLengthValidator = minLengthValidator;\nfunction validatorWithMessage(validator, message, sub) {\n    return (x) => (validator(x) ? (sub ? sub(x) : true) : message);\n}\nexports.validatorWithMessage = validatorWithMessage;\nfunction asAssertion(validator) {\n    return (val) => {\n        if (!validator(val)) {\n            throw new Error();\n        }\n    };\n}\nexports.asAssertion = asAssertion;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/validators/validators.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/xhr.js":
/*!******************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/xhr.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isXHRResponse = exports.isBinaryXHRResponse = exports.isTextXHRResponse = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ./validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst isBaseXHRResponse = (0, validators_1.objectValidator)({\n    url: checks_1.isString,\n    status: checks_1.isNumber,\n    headers: (0, validators_1.objectOfValidator)(checks_1.isString),\n    timeout: (0, validators_1.option)(checks_1.isBoolean),\n});\nexports.isTextXHRResponse = (0, validators_1.both)(isBaseXHRResponse, (0, validators_1.objectValidator)({\n    responseFormat: (0, checks_1.isLiteral)('utf8'),\n    responseText: checks_1.isString,\n}));\nexports.isBinaryXHRResponse = (0, validators_1.both)(isBaseXHRResponse, (0, validators_1.objectValidator)({\n    responseFormat: (0, checks_1.isLiteral)('binary'),\n    responseData: (0, checks_1.isInstanceOf)(Uint8Array),\n}));\nexports.isXHRResponse = (0, validators_1.either)(exports.isTextXHRResponse, exports.isBinaryXHRResponse);\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/core/xhr.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/branchedcollectionid.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/branchedcollectionid.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.patchCollectionIdFromPossibleBranchedCollectionId = exports.branchedCollectionId = void 0;\n/** @ignore */\nfunction branchedCollectionId(upstreamId) {\n    return upstreamId + '_b';\n}\nexports.branchedCollectionId = branchedCollectionId;\n/** @ignore */\nfunction patchCollectionIdFromPossibleBranchedCollectionId(branchId) {\n    if (branchId && branchId.endsWith('_b')) {\n        return branchId.substring(0, branchId.length - 2);\n    }\n    return undefined;\n}\nexports.patchCollectionIdFromPossibleBranchedCollectionId = patchCollectionIdFromPossibleBranchedCollectionId;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/branchedcollectionid.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/collectiondefinition.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/collectiondefinition.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeCollectionDefinition = exports.serializeCollectionDefinition = void 0;\nconst schemadefinition_1 = __webpack_require__(/*! ./schemadefinition */ \"./node_modules/lucid-extension-sdk/data/schemadefinition.js\");\n/** @ignore */\nfunction serializeCollectionDefinition(def) {\n    return {\n        'Schema': (0, schemadefinition_1.serializeSchemaDefinition)(def.schema),\n        'Items': [...def.items.entries()],\n    };\n}\nexports.serializeCollectionDefinition = serializeCollectionDefinition;\n/** @ignore */\nfunction deserializeCollectionDefinition(raw) {\n    return {\n        schema: (0, schemadefinition_1.parseSchemaDefinition)(raw['Schema']),\n        items: new Map(raw['Items']),\n    };\n}\nexports.deserializeCollectionDefinition = deserializeCollectionDefinition;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/collectiondefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/collectionerrortypes.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/collectionerrortypes.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CollectionUpstreamSchemaStatus = void 0;\nexports.CollectionUpstreamSchemaStatus = '__CollectionUpstreamSchemaStatus__';\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/collectionerrortypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/collectionproxy.js":
/*!******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/collectionproxy.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CollectionProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst propertystoreproxy_1 = __webpack_require__(/*! ../document/propertystoreproxy */ \"./node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nconst branchedcollectionid_1 = __webpack_require__(/*! ./branchedcollectionid */ \"./node_modules/lucid-extension-sdk/data/branchedcollectionid.js\");\nconst dataitemproxy_1 = __webpack_require__(/*! ./dataitemproxy */ \"./node_modules/lucid-extension-sdk/data/dataitemproxy.js\");\nconst patchcollectionproxy_1 = __webpack_require__(/*! ./patchcollectionproxy */ \"./node_modules/lucid-extension-sdk/data/patchcollectionproxy.js\");\nconst schemadefinition_1 = __webpack_require__(/*! ./schemadefinition */ \"./node_modules/lucid-extension-sdk/data/schemadefinition.js\");\n/**\n * A collection is a set of data items, each with the same set of fields (though some data items may not have all\n * fields defined).\n */\nclass CollectionProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     *\n     * @param id ID of this collection on the current document\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The data items in this collection, organized by their primary key. The primary key is usually calculated\n         * from the content of the data item, but may differ from the expected value in some circumstances, e.g. if\n         * there are two data items that would have the same primary key.\n         */\n        this.items = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ldi\" /* CommandName.ListDataItems */, { 'id': this.id }), (primaryKey) => new dataitemproxy_1.DataItemProxy(primaryKey, this, this.client));\n    }\n    /**\n     * @returns a human-readable name for this collection\n     */\n    getName() {\n        return this.properties.get('Name');\n    }\n    getSyncCollectionId() {\n        const upstreamConfig = this.properties.get('UpstreamConfig');\n        if ((0, checks_1.isObjectUnsafe)(upstreamConfig) && (0, checks_1.isString)(upstreamConfig['SyncId'])) {\n            return upstreamConfig['SyncId'];\n        }\n        return undefined;\n    }\n    /**\n     * Some data collections may have local branches on the document, to store the set of changes that have been\n     * made by the user since the time the data was last refreshed from its source. For those collections, you\n     * can use this method to get the original data collection as it was last imported or refreshed.\n     *\n     * @returns the original collection from which this collection was branched, or undefined if this collection\n     * is not a branch\n     */\n    getBranchedFrom() {\n        const id = this.properties.get('BranchedFrom');\n        return id ? new CollectionProxy(id, this.client) : undefined;\n    }\n    /**\n     * @returns information about any changes made locally to the collection that have not been synchronized\n     * with the external data source.\n     */\n    getLocalChanges() {\n        const patchCollectionId = (0, branchedcollectionid_1.patchCollectionIdFromPossibleBranchedCollectionId)(this.id);\n        const original = this.getBranchedFrom();\n        if (!patchCollectionId || !original) {\n            return undefined;\n        }\n        return new patchcollectionproxy_1.PatchCollectionProxy(this.client, this, new CollectionProxy(patchCollectionId, this.client), original);\n    }\n    patchItems(patch) {\n        var _a, _b;\n        const changed = {};\n        if (patch.changed) {\n            for (const [primaryKey, record] of patch.changed) {\n                changed[primaryKey] = record;\n            }\n        }\n        return this.client.sendCommand(\"pdi\" /* CommandName.PatchDataItems */, {\n            'id': this.id,\n            'a': (_a = patch.added) !== null && _a !== void 0 ? _a : [],\n            'c': changed,\n            'd': (_b = patch.deleted) !== null && _b !== void 0 ? _b : [],\n        });\n    }\n    /**\n     * @returns an array of field names that are accessible on the items in this collection\n     */\n    getFields() {\n        return this.client.sendCommand(\"lcf\" /* CommandName.ListCollectionFields */, { 'id': this.id });\n    }\n    getSchema() {\n        // we wave to cast as unknown because of readonly being used in the type\n        return (0, schemadefinition_1.parseSchemaDefinition)(this.properties.get('Schema'));\n    }\n}\nexports.CollectionProxy = CollectionProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/collectionproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/dataerror.js":
/*!************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/dataerror.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataError = void 0;\n/**\n * The requested data or formula result couldn't be calculated.\n */\nclass DataError {\n    /**\n     * @param error A human-readable description of the reason why the error occurred\n     * @param type The kind of error that occurred\n     */\n    constructor(error, type) {\n        this.error = error;\n        this.type = type;\n    }\n}\nexports.DataError = DataError;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/dataerror.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/dataitemproxy.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/dataitemproxy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataItemProxy = void 0;\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * One data item in a collection, consisting of key-value pairs\n */\nclass DataItemProxy {\n    /**\n     * @param primaryKey The current primary key of the data item. This may change if the fields on the data item change, rendering this proxy inoperable.\n     * @param collection The collection that contains this data item.\n     * @param client\n     */\n    constructor(primaryKey, collection, client) {\n        this.primaryKey = primaryKey;\n        this.collection = collection;\n        this.client = client;\n        /**\n         * The fields on this data item, organized by their name.\n         */\n        this.fields = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lcf\" /* CommandName.ListCollectionFields */, { 'id': this.collection.id }), (name) => this.client.sendCommand(\"gdif\" /* CommandName.GetDataItemField */, {\n            'c': this.collection.id,\n            'pk': this.primaryKey,\n            'f': name,\n        }));\n    }\n    /**\n     * @returns True if a data item exists in this collection at this primary key\n     */\n    exists() {\n        return this.client.sendCommand(\"die\" /* CommandName.DataItemExists */, { 'c': this.collection.id, 'pk': this.primaryKey });\n    }\n}\nexports.DataItemProxy = DataItemProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/dataitemproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/dataproxy.js":
/*!************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/dataproxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataProxy = void 0;\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst datasourceproxy_1 = __webpack_require__(/*! ./datasourceproxy */ \"./node_modules/lucid-extension-sdk/data/datasourceproxy.js\");\n/**\n * The DataProxy class gives access to the tabular and graph data on the current Lucid document.\n *\n * Data collections are organized into data sources. One data sources is typically produced for\n * each data import, and may contain multiple collections.\n */\nclass DataProxy {\n    constructor(client) {\n        this.client = client;\n        /**\n         * Data sources on the current document, organized by their ID on this document. The ID will\n         * remain stable for as long as the data source exists on this document, but will vary from\n         * the data source ID on other documents if the same data is imported there.\n         */\n        this.dataSources = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lds\" /* CommandName.ListDataSources */, undefined), (dataSourceId) => new datasourceproxy_1.DataSourceProxy(dataSourceId, this.client));\n    }\n    /**\n     * Creates a new empty data source, which you can then add collections of data to.\n     *\n     * @param name Human-readable name of the new data source\n     * @param sourceConfig Any configuration values that might be useful to reference later, such\n     *  as the upstream origin of this data source\n     * @returns the newly created data source\n     */\n    addDataSource(name, sourceConfig) {\n        return new datasourceproxy_1.DataSourceProxy(this.client.sendCommand(\"cds\" /* CommandName.CreateDataSource */, { 'n': name, 's': sourceConfig }), this.client);\n    }\n}\nexports.DataProxy = DataProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/dataproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/datasourceproxy.js":
/*!******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/datasourceproxy.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataSourceProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../core/data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst propertystoreproxy_1 = __webpack_require__(/*! ../document/propertystoreproxy */ \"./node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nconst collectionproxy_1 = __webpack_require__(/*! ./collectionproxy */ \"./node_modules/lucid-extension-sdk/data/collectionproxy.js\");\n/**\n * A data source represents a set of related data collections on a document. Typically one data source\n * is produced for each data import.\n */\nclass DataSourceProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     * @param id ID of the dataSource on the current document\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The set of data collections in this data source, organized by ID on this document. The IDs will\n         * remain stable for as long as the collection exists on this document, but will vary from\n         * the collection ID on other documents if the same data is imported there.\n         */\n        this.collections = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lc\" /* CommandName.ListCollections */, { 'id': this.id }), (id) => new collectionproxy_1.CollectionProxy(id, this.client));\n    }\n    /**\n     * Create a new collection as part of this data source.\n     * @param name\n     * @param schema\n     * @returns The newly created collection\n     */\n    addCollection(name, schema) {\n        return new collectionproxy_1.CollectionProxy(this.client.sendCommand(\"cc\" /* CommandName.CreateCollection */, {\n            's': this.id,\n            'n': name,\n            'f': schema.fields.map((field) => {\n                return { 'n': field.name, 't': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type) };\n            }),\n            'p': schema.primaryKey,\n            'fl': schema.fieldLabels,\n        }), this.client);\n    }\n    /**\n     * @returns A human-readable name for this data source\n     */\n    getName() {\n        return this.properties.get('Name');\n    }\n    /**\n     * @returns The source configuration values set when this data source was created\n     */\n    getSourceConfig() {\n        const upstream = this.properties.get('Upstream');\n        if ((0, checks_1.isObjectUnsafe)(upstream)) {\n            return upstream['SourceConfig'];\n        }\n        return {};\n    }\n}\nexports.DataSourceProxy = DataSourceProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/datasourceproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataUpdateFilterType = void 0;\n/** Allows Lucid documents to determine what updates they will receive when changes happen in the data source */\nvar DataUpdateFilterType;\n(function (DataUpdateFilterType) {\n    /** All updates relevant to the data source will be sent to the document, new items created in the data source will be added to the document. Note that the in the `documentCollections` mapping in the `DataConnectorActionContext` will not have a list of all items in it with the DataUpdateFilterType selected */\n    DataUpdateFilterType[\"AllUpdates\"] = \"AllUpdates\";\n    /** All updates relevant to collections already present on the document will be sent to that document, new items added to those collections in the data source will be added to the document. Note that the `documentCollections` mapping in the `DataConnectorActionContext` will not have a list of all items in it with the DataUpdateFilterType selected */\n    DataUpdateFilterType[\"CurrentCollectionUpdates\"] = \"CurrentCollectionUpdates\";\n    /** All updates to items already present on the document will be sent to the document. New items created in the data source will not be created on the document. */\n    DataUpdateFilterType[\"CurrentItemUpdates\"] = \"CurrentItemUpdates\";\n})(DataUpdateFilterType || (exports.DataUpdateFilterType = DataUpdateFilterType = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/patchcollectionproxy.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/patchcollectionproxy.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PatchCollectionProxy = exports.PatchedDataItemProxy = void 0;\nconst dataitemproxy_1 = __webpack_require__(/*! ./dataitemproxy */ \"./node_modules/lucid-extension-sdk/data/dataitemproxy.js\");\nclass PatchedDataItemProxy extends dataitemproxy_1.DataItemProxy {\n    constructor(primaryKey, collection, \n    /**\n     * The names of all fields that have been changed locally on this data item and\n     * not yet synced back to the external data source.\n     */\n    changedFields, \n    /**\n     * The original data item, before local changes. You can query the original values\n     * for the changedFields from this data item.\n     */\n    original, client) {\n        super(primaryKey, collection, client);\n        this.changedFields = changedFields;\n        this.original = original;\n    }\n}\nexports.PatchedDataItemProxy = PatchedDataItemProxy;\nclass PatchCollectionProxy {\n    /**\n     * Use CollectionProxy.getLocalChanges() to get a PatchCollectionProxy rather\n     * than constructing one directly.\n     */\n    constructor(client, branchedCollection, patchCollection, originalCollection) {\n        this.client = client;\n        this.branchedCollection = branchedCollection;\n        this.patchCollection = patchCollection;\n        this.originalCollection = originalCollection;\n    }\n    /**\n     * @returns all data items that have been added to this collection locally, but that\n     * have not yet been synced back to the external data source.\n     */\n    getAddedItems() {\n        //Note: We could get this list directly from the metadata collection associated with the\n        //patch collection, but at this time we're not sure we want to expose metadata collections\n        //to the extension API, so this somewhat less-performance-optimal solution seems like the\n        //best overall answer.\n        return this.patchCollection.items.filter((item, primaryKey) => !this.originalCollection.items.get(primaryKey).exists());\n    }\n    /**\n     * @returns all data items that were deleted from this collection locally, but that\n     * have not yet been deleted in the external data source.\n     */\n    getDeletedItems() {\n        //See comment in getAddedItems\n        return this.originalCollection.items.filter((item, primaryKey) => !this.branchedCollection.items.get(primaryKey).exists());\n    }\n    /**\n     * @returns all data items that have been changed locally, but that have not\n     * yet been synced back to the external data source.\n     */\n    getChangedItems() {\n        const changed = [];\n        for (const [primaryKey, patchItem] of this.patchCollection.items) {\n            const original = this.originalCollection.items.get(primaryKey);\n            if (original.exists()) {\n                //Not just using .keys() because we want to filter out undefined values,\n                //which the `for...of` iterator on patchItem.fields (MapProxy) does for us.\n                const changedFields = [];\n                for (const [key] of patchItem.fields) {\n                    changedFields.push(key);\n                }\n                changed.push(new PatchedDataItemProxy(primaryKey, this.branchedCollection, changedFields, original, this.client));\n            }\n        }\n        return changed;\n    }\n}\nexports.PatchCollectionProxy = PatchCollectionProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/patchcollectionproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/referencekeydefinition.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/referencekeydefinition.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseReferenceKeyDefinition = exports.serializeReferenceKeyDefinition = exports.isCollectionReferenceKeyDefinition = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializedreferencekey_1 = __webpack_require__(/*! ../core/data/referencekeys/serializedreferencekey */ \"./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js\");\nconst schemadefinition_1 = __webpack_require__(/*! ./schemadefinition */ \"./node_modules/lucid-extension-sdk/data/schemadefinition.js\");\n/** @ignore */\nfunction isCollectionReferenceKeyDefinition(def) {\n    return (0, checks_1.isString)(def.collectionId);\n}\nexports.isCollectionReferenceKeyDefinition = isCollectionReferenceKeyDefinition;\n/** @ignore */\nfunction serializeReferenceKeyDefinition(def) {\n    if (isCollectionReferenceKeyDefinition(def)) {\n        return {\n            'cid': def.collectionId,\n            'pk': def.primaryKey,\n            'wl': def.fieldWhitelist,\n            'ro': def.readonly,\n        };\n    }\n    else {\n        return {\n            'sc': (0, schemadefinition_1.serializeSchemaDefinition)(def.schema),\n            'n': def.name,\n            'd': def.data,\n        };\n    }\n}\nexports.serializeReferenceKeyDefinition = serializeReferenceKeyDefinition;\n/** @ignore */\nfunction parseReferenceKeyDefinition(def) {\n    if ((0, serializedreferencekey_1.isTypedSerializedFlattenedReference)(def)) {\n        return {\n            schema: (0, schemadefinition_1.parseSchemaDefinition)(def['sc']),\n            name: def['n'],\n            data: def['d'],\n        };\n    }\n    else if ((0, serializedreferencekey_1.isUnTypedSerializedFlattenedReference)(def)) {\n        throw new Error('Untyped serialized flattened references not implemented');\n    }\n    else {\n        return {\n            collectionId: def['cid'],\n            primaryKey: def['pk'],\n            fieldWhitelist: def['wl'],\n            readonly: def['ro'],\n        };\n    }\n}\nexports.parseReferenceKeyDefinition = parseReferenceKeyDefinition;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/referencekeydefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/referencekeyproxy.js":
/*!********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/referencekeyproxy.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReferenceKeyProxy = void 0;\nconst serializedreferencekey_1 = __webpack_require__(/*! ../core/data/referencekeys/serializedreferencekey */ \"./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js\");\nconst collectionproxy_1 = __webpack_require__(/*! ./collectionproxy */ \"./node_modules/lucid-extension-sdk/data/collectionproxy.js\");\nconst referencekeydefinition_1 = __webpack_require__(/*! ./referencekeydefinition */ \"./node_modules/lucid-extension-sdk/data/referencekeydefinition.js\");\nclass ReferenceKeyProxy {\n    constructor(elementId, key, client, settings) {\n        this.elementId = elementId;\n        this.key = key;\n        this.client = client;\n        this.settings = settings;\n    }\n    get collectionId() {\n        if ((0, serializedreferencekey_1.isSerializedFlattenedReference)(this.settings)) {\n            return undefined;\n        }\n        return this.settings['cid'];\n    }\n    get primaryKey() {\n        if ((0, serializedreferencekey_1.isSerializedFlattenedReference)(this.settings)) {\n            return undefined;\n        }\n        return this.settings['pk'];\n    }\n    get definition() {\n        return (0, referencekeydefinition_1.parseReferenceKeyDefinition)(this.settings);\n    }\n    getItem() {\n        const collectionId = this.collectionId;\n        if ((0, serializedreferencekey_1.isSerializedFlattenedReference)(this.settings) || !collectionId) {\n            throw new Error('Not implemented for flattened references');\n        }\n        return new collectionproxy_1.CollectionProxy(collectionId, this.client).items.get(this.settings['pk']);\n    }\n}\nexports.ReferenceKeyProxy = ReferenceKeyProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/referencekeyproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/schemadefinition.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/schemadefinition.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseSchemaDefinition = exports.parseFieldDefinition = exports.serializeSchemaDefinition = exports.serializeFieldDefinition = exports.serializeFieldConstraintDefinition = exports.isFieldConstraintDefinition = exports.minMaxFieldConstraintValidator = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../core/data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst serializedfielddefinition_1 = __webpack_require__(/*! ../core/data/serializedfield/serializedfielddefinition */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nfunction minMaxFieldConstraintValidator(val) {\n    return (val === serializedfielddefinition_1.FieldConstraintType.MIN_VALUE ||\n        val === serializedfielddefinition_1.FieldConstraintType.MAX_VALUE ||\n        val === serializedfielddefinition_1.FieldConstraintType.MAX_LENGTH);\n}\nexports.minMaxFieldConstraintValidator = minMaxFieldConstraintValidator;\nexports.isFieldConstraintDefinition = (0, validators_1.both)((0, validators_1.objectValidator)({\n    'type': serializedfielddefinition_1.isFieldConstraintType,\n}), (0, validators_1.either)((0, validators_1.objectValidator)({ 'type': minMaxFieldConstraintValidator, 'value': checks_1.isNumber }), (0, validators_1.objectValidator)({ 'type': (0, validators_1.exclude)(serializedfielddefinition_1.isFieldConstraintType, minMaxFieldConstraintValidator), 'value': checks_1.isUndefined })));\n/** @ignore */\nfunction serializeFieldConstraintDefinition(constraint) {\n    return {\n        'Type': constraint.type,\n        'Details': constraint.value,\n    };\n}\nexports.serializeFieldConstraintDefinition = serializeFieldConstraintDefinition;\n/** @ignore */\nfunction serializeFieldDefinition(field) {\n    const serialized = {\n        'Name': field.name,\n        'Type': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type),\n    };\n    if (field.constraints) {\n        serialized['Constraints'] = field.constraints.map(serializeFieldConstraintDefinition);\n    }\n    if (field.mapping) {\n        serialized['Mapping'] = field.mapping;\n    }\n    return serialized;\n}\nexports.serializeFieldDefinition = serializeFieldDefinition;\n/** @ignore */\nfunction serializeSchemaDefinition(def) {\n    return {\n        'Fields': def.fields.map(serializeFieldDefinition),\n        'PrimaryKey': def.primaryKey,\n        'FieldLabelOverrides': def.fieldLabels,\n    };\n}\nexports.serializeSchemaDefinition = serializeSchemaDefinition;\n/** @ignore */\nfunction parseFieldDefinition(field) {\n    var _a;\n    return {\n        name: field['Name'],\n        type: (0, fieldtypedefinition_1.deserializeFieldTypeDefinition)(field['Type']),\n        constraints: (_a = field['Constraints']) === null || _a === void 0 ? void 0 : _a.map((constraint) => {\n            switch (constraint['Type']) {\n                case serializedfielddefinition_1.FieldConstraintType.MIN_VALUE:\n                case serializedfielddefinition_1.FieldConstraintType.MAX_VALUE:\n                case serializedfielddefinition_1.FieldConstraintType.MAX_LENGTH:\n                    if (!(0, checks_1.isNumber)(constraint['Details'])) {\n                        throw new Error('Invalid constraint format');\n                    }\n                    return { type: constraint['Type'], value: constraint['Details'] };\n                case serializedfielddefinition_1.FieldConstraintType.REQUIRED:\n                case serializedfielddefinition_1.FieldConstraintType.LOCKED:\n                case serializedfielddefinition_1.FieldConstraintType.SINGLE_LINE_ONLY:\n                case serializedfielddefinition_1.FieldConstraintType.NO_WHITESPACE:\n                case serializedfielddefinition_1.FieldConstraintType.UNIQUE_EDIT:\n                    return { type: constraint['Type'] };\n                default:\n                    throw new Error('Invalid constraint format');\n            }\n        }),\n        mapping: field['Mapping'],\n    };\n}\nexports.parseFieldDefinition = parseFieldDefinition;\n/** @ignore */\nfunction parseSchemaDefinition(def) {\n    return {\n        fields: def['Fields'].map(parseFieldDefinition),\n        primaryKey: def['PrimaryKey'],\n        fieldLabels: def['FieldLabelOverrides'],\n    };\n}\nexports.parseSchemaDefinition = parseSchemaDefinition;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/data/schemadefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/action.js":
/*!**************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/action.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataConnectorManageWebhookAction = exports.Webhook = exports.DataConnectorPatchAction = exports.DataConnectorSynchronousAction = exports.DataConnectorAsynchronousAction = exports.DataConnectorAction = exports.DataConnectorActionContext = void 0;\nconst dataconnectoractionkeys_1 = __webpack_require__(/*! ./dataconnectoractionkeys */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js\");\n/**\n * This holds all the contextual information about a give data action.\n */\nclass DataConnectorActionContext {\n    constructor(\n    /** The package ID of the extension that triggered this action */\n    packageId, \n    /** The version of the extension that triggered this action */\n    packageVersion, \n    /** The authorized OAuth2 credential that Lucid has for the 3rd party this extension works with */\n    userCredential, \n    /** @ignore Boolean indicating whether to use a proxy server when making a request to third party */\n    useOutboundProxy, \n    /** The data connector name from manifest.json that triggered this action */\n    dataConnectorName, \n    /** The installation id of the extension/user that triggered this action */\n    installationId, \n    /** Set of items this document is tracking as a `Record<CollectionId, ItemPrimaryKey[]>` */\n    documentCollections, \n    /** Update filter type for this document */\n    updateFilterType) {\n        this.packageId = packageId;\n        this.packageVersion = packageVersion;\n        this.userCredential = userCredential;\n        this.useOutboundProxy = useOutboundProxy;\n        this.dataConnectorName = dataConnectorName;\n        this.installationId = installationId;\n        this.documentCollections = documentCollections;\n        this.updateFilterType = updateFilterType;\n    }\n}\nexports.DataConnectorActionContext = DataConnectorActionContext;\n/** Base class for actions to be performed by data connectors */\nclass DataConnectorAction {\n    constructor(name, context) {\n        this.name = name;\n        this.context = context;\n    }\n}\nexports.DataConnectorAction = DataConnectorAction;\n/**\n * A generic \"asynchronous\" action to be performed by the data connector. This is an action that reports back to Lucid\n * by calling back in the DataSourceClient rather than returning a meaningful value.\n **/\nclass DataConnectorAsynchronousAction extends DataConnectorAction {\n    constructor(name, context, client, data) {\n        super(name, context);\n        this.client = client;\n        this.data = data;\n    }\n}\nexports.DataConnectorAsynchronousAction = DataConnectorAsynchronousAction;\n/**\n * A generic \"synchronous\" action to be performed by the data connector.\n **/\nclass DataConnectorSynchronousAction extends DataConnectorAction {\n    constructor(name, context, data) {\n        super(name, context);\n        this.data = data;\n    }\n}\nexports.DataConnectorSynchronousAction = DataConnectorSynchronousAction;\n/**\n * A patch action is a kind of synchronous style action. It occurs when data is changed in the Lucid editor. All the\n * changes are collected in the patches field.\n **/\nclass DataConnectorPatchAction extends DataConnectorAction {\n    constructor(context, \n    /** changes applied by Lucid */ patches, client, name = dataconnectoractionkeys_1.DataConnectorActionKeys.Patch) {\n        super(name, context);\n        this.patches = patches;\n        this.client = client;\n    }\n}\nexports.DataConnectorPatchAction = DataConnectorPatchAction;\n/**\n * A description of an existing webhook that Lucid is keeping track of.\n **/\nclass Webhook {\n    constructor(\n    /** Set of items this webhook is tracking as a `Record<CollectionId, ItemPrimaryKey[]>` */\n    documentCollections, \n    /** Arbitrary extra data to allow the data connector to better identitify the webhook. */\n    webhookData) {\n        this.documentCollections = documentCollections;\n        this.webhookData = webhookData;\n    }\n}\nexports.Webhook = Webhook;\n/**\n * A \"synchronous\" style action indicating that Lucid would like to setup a webhook in the third party.\n */\nclass DataConnectorManageWebhookAction extends DataConnectorAction {\n    constructor(context, \n    /**\n     * Token to be added to the newly created webhook so that when it fires it will have permissions to make changes\n     * to Lucid documents.\n     */\n    webhookToken, \n    /**\n     * A list of existing webhooks so you can be more granular about what you track. You may also find it useful to\n     * delete some of the existing webhooks. The response back to Lucid should include all existing webhooks (newly\n     * created or any of these that were not deleted).\n     **/\n    webhooks) {\n        super(dataconnectoractionkeys_1.DataConnectorActionKeys.ManageWebhook, context);\n        this.webhookToken = webhookToken;\n        this.webhooks = webhooks;\n    }\n}\nexports.DataConnectorManageWebhookAction = DataConnectorManageWebhookAction;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/actions/action.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/** List of keys that are special kinds of actions and thus have more specific result types than just unknown */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataConnectorActionKeys = void 0;\nvar DataConnectorActionKeys;\n(function (DataConnectorActionKeys) {\n    DataConnectorActionKeys[\"ManageWebhook\"] = \"ManageWebhook\";\n    DataConnectorActionKeys[\"Patch\"] = \"Patch\";\n    DataConnectorActionKeys[\"UnbatchedPatch\"] = \"UnbatchedPatch\";\n})(DataConnectorActionKeys || (exports.DataConnectorActionKeys = DataConnectorActionKeys = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeManageWebhookResponse = void 0;\n/** Convert the ManageWebhookResponse to Lucid's wire format */\nfunction serializeManageWebhookResponse(webhookResponse) {\n    return {\n        'documentCollections': webhookResponse.documentCollections,\n        'webhookData': webhookResponse.webhookData,\n    };\n}\nexports.serializeManageWebhookResponse = serializeManageWebhookResponse;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/patch.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/patch.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.schemaPatchParser = exports.SchemaPatch = exports.areThirdPartyColumnPatchesEqual = exports.ThirdPartyColumnPatch = exports.areThirdPartyColumnsEqual = exports.ThirdPartyColumn = exports.itemPatchParser = exports.ItemPatch = exports.genericPatchParser = exports.Patch = void 0;\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../../core/data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst patchresponsebody_1 = __webpack_require__(/*! ./patchresponsebody */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js\");\nconst serializedpatchtypes_1 = __webpack_require__(/*! ./serializedpatchtypes */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/serializedpatchtypes.js\");\nfunction objMap(obj, f) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = f(obj[key]);\n    }\n    return result;\n}\n/** A patch to be applied against the 3rd party datasource with changes coming from Lucid */\nclass Patch {\n    constructor(\n    /** The id of the patch */\n    id, \n    /** The syncSourceId of the changed data source */\n    syncSourceId, \n    /** The syncCollectionId of the changed collection */\n    syncCollectionId) {\n        this.id = id;\n        this.syncSourceId = syncSourceId;\n        this.syncCollectionId = syncCollectionId;\n    }\n    getChange(collections = [], creationPermission = undefined) {\n        return new patchresponsebody_1.PatchChange(this.id, this.syncSourceId, collections, creationPermission);\n    }\n}\nexports.Patch = Patch;\nconst genericPatchParser = (id, x) => {\n    var _a;\n    return (_a = (0, exports.itemPatchParser)(id, x)) !== null && _a !== void 0 ? _a : (0, exports.schemaPatchParser)(id, x);\n};\nexports.genericPatchParser = genericPatchParser;\nclass ItemPatch extends Patch {\n    constructor(\n    /** The id of the patch */\n    id, \n    /** Mapping of item primary keys to new items introduced by Lucid */\n    itemsAdded, \n    /** Mapping of item primary keys to sparse changesets of pre-existing items changed by Lucid */\n    itemsChanged, \n    /** List of item primary keys deleted by Lucid */\n    itemsDeleted, \n    /** */\n    itemOrderChanged, \n    /** The syncSourceId of the changed data source */\n    syncSourceId, \n    /** The syncCollectionId of the changed collection */\n    syncCollectionId) {\n        super(id, syncSourceId, syncCollectionId);\n        this.itemsAdded = itemsAdded;\n        this.itemsChanged = itemsChanged;\n        this.itemsDeleted = itemsDeleted;\n        this.itemOrderChanged = itemOrderChanged;\n    }\n    toJSON() {\n        return {\n            'Id': this.id,\n            'ItemsAdded': this.itemsAdded,\n            'ItemsChanged': this.itemsChanged,\n            'ItemsDeleted': this.itemsDeleted,\n            'ItemOrderChanged': this.itemOrderChanged,\n            'SyncSourceId': this.syncSourceId,\n            'SyncCollectionId': this.syncCollectionId,\n        };\n    }\n    clone() {\n        return new ItemPatch(this.id, objMap(this.itemsAdded, (item) => objMap(item, (v) => v)), objMap(this.itemsChanged, (item) => objMap(item, (v) => v)), [...this.itemsDeleted], this.itemOrderChanged && [...this.itemOrderChanged], this.syncSourceId, this.syncCollectionId);\n    }\n}\nexports.ItemPatch = ItemPatch;\nfunction _itemPatchParser(id, patch) {\n    var _a;\n    return new ItemPatch(id, patch['itemsAdded'], patch['itemsChanged'], patch['itemsDeleted'], (_a = patch['itemOrderChanged']) !== null && _a !== void 0 ? _a : undefined, patch['syncSourceId'], patch['syncCollectionId']);\n}\nconst itemPatchParser = (id, patch) => {\n    if ((0, serializedpatchtypes_1.patchItemValidator)(patch)) {\n        return _itemPatchParser(id, patch);\n    }\n    return undefined;\n};\nexports.itemPatchParser = itemPatchParser;\nclass ThirdPartyColumn {\n    constructor(name, fieldType) {\n        this.name = name;\n        this.fieldType = fieldType;\n    }\n    clone() {\n        return new ThirdPartyColumn(this.name, this.fieldType);\n    }\n    toJSON() {\n        return { 'Name': this.name, 'FieldType': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(this.fieldType) };\n    }\n    static deserialize(data) {\n        return new ThirdPartyColumn(data['name'], (0, fieldtypedefinition_1.deserializeFieldTypeDefinition)(data['fieldType']));\n    }\n}\nexports.ThirdPartyColumn = ThirdPartyColumn;\nfunction areThirdPartyColumnsEqual(a, b) {\n    return a.name === b.name && (0, fieldtypedefinition_1.fieldTypesEqual)(a.fieldType, b.fieldType);\n}\nexports.areThirdPartyColumnsEqual = areThirdPartyColumnsEqual;\nclass ThirdPartyColumnPatch {\n    constructor(name, fieldType) {\n        this.name = name;\n        this.fieldType = fieldType;\n    }\n    clone() {\n        return new ThirdPartyColumnPatch(this.name, this.fieldType);\n    }\n    toJSON() {\n        return {\n            'Name': this.name,\n            'FieldType': this.fieldType != null ? (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(this.fieldType) : undefined,\n        };\n    }\n    static deserialize(data) {\n        var _a;\n        const result = new ThirdPartyColumnPatch((_a = data['name']) !== null && _a !== void 0 ? _a : undefined, data['fieldType'] != null ? (0, fieldtypedefinition_1.deserializeFieldTypeDefinition)(data['fieldType']) : undefined);\n        return result;\n    }\n}\nexports.ThirdPartyColumnPatch = ThirdPartyColumnPatch;\nfunction areThirdPartyColumnPatchesEqual(a, b) {\n    return (a.name === b.name &&\n        ((a.fieldType === undefined && b.fieldType === undefined) ||\n            (a.fieldType !== undefined && b.fieldType !== undefined && (0, fieldtypedefinition_1.fieldTypesEqual)(a.fieldType, b.fieldType))));\n}\nexports.areThirdPartyColumnPatchesEqual = areThirdPartyColumnPatchesEqual;\nclass SchemaPatch extends Patch {\n    constructor(\n    /** The id of the patch */\n    id, \n    /** Mapping of item primary keys to new items introduced by Lucid */\n    columnsAdded, \n    /** Mapping of item primary keys to sparse changesets of pre-existing items changed by Lucid */\n    columnsChanged, \n    /** List of item primary keys deleted by Lucid */\n    columnsDeleted, \n    /** */\n    columnOrdering, \n    /** The syncSourceId of the changed data source */\n    syncSourceId, \n    /** The syncCollectionId of the changed collection */\n    syncCollectionId) {\n        super(id, syncSourceId, syncCollectionId);\n        this.columnsAdded = columnsAdded;\n        this.columnsChanged = columnsChanged;\n        this.columnsDeleted = columnsDeleted;\n        this.columnOrdering = columnOrdering;\n    }\n    toJSON() {\n        return {\n            'Id': this.id,\n            'ColumnsAdded': this.columnsAdded.map((column) => column.toJSON()),\n            'ColumnsChanged': objMap(this.columnsChanged, (column) => column.toJSON()),\n            'ColumnsDeleted': this.columnsDeleted,\n            'ColumnOrdering': this.columnOrdering,\n            'SyncSourceId': this.syncSourceId,\n            'SyncCollectionId': this.syncCollectionId,\n        };\n    }\n    clone() {\n        return new SchemaPatch(this.id, this.columnsAdded.map((columnAdded) => columnAdded.clone()), objMap(this.columnsChanged, (columnChange) => columnChange.clone()), [...this.columnsDeleted], this.columnOrdering && [\n            ...this.columnOrdering.map(([base, target]) => [base, target]),\n        ], this.syncSourceId, this.syncCollectionId);\n    }\n}\nexports.SchemaPatch = SchemaPatch;\nfunction _schemaPatchParser(id, patch) {\n    var _a;\n    return new SchemaPatch(id, patch['columnsAdded'].map(ThirdPartyColumn.deserialize), objMap(patch['columnsChanged'], ThirdPartyColumnPatch.deserialize), patch['columnsDeleted'], (_a = patch['columnOrdering']) !== null && _a !== void 0 ? _a : undefined, patch['syncSourceId'], patch['syncCollectionId']);\n}\nconst schemaPatchParser = (id, patch) => {\n    if ((0, serializedpatchtypes_1.patchSchemaValidator)(patch)) {\n        return _schemaPatchParser(id, patch);\n    }\n    return undefined;\n};\nexports.schemaPatchParser = schemaPatchParser;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/actions/patch.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializePatchChanges = exports.serializePatchResponse = exports.PatchErrorTooltipField = exports.PatchChange = void 0;\nconst object_1 = __webpack_require__(/*! ../../core/object */ \"./node_modules/lucid-extension-sdk/core/object.js\");\nconst datasourceupdatetypes_1 = __webpack_require__(/*! ../datasourceupdatetypes */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js\");\n/**\n * Reports a completed change back to Lucid\n */\nclass PatchChange {\n    constructor(patchId, syncId, collections, creationPermission) {\n        this.patchId = patchId;\n        this.syncId = syncId;\n        this.collections = collections;\n        this.creationPermission = creationPermission;\n        this.errors = {};\n    }\n    setError(primaryKey, fieldName, error) {\n        if (!(primaryKey in this.errors)) {\n            this.errors[primaryKey] = {};\n        }\n        this.errors[primaryKey][fieldName] = error;\n    }\n    setTooltipError(primaryKey, error) {\n        this.setError(primaryKey, exports.PatchErrorTooltipField, error);\n    }\n    getErrors() {\n        return this.errors;\n    }\n}\nexports.PatchChange = PatchChange;\n/** Placeholder field name for tool tip errors */\nexports.PatchErrorTooltipField = '__canvasTooltipDataSyncError__';\n/** Convert a Patch change to our wire format */\nfunction serializePatchResponse(patchChange) {\n    return {\n        'syncId': patchChange.syncId,\n        'collections': patchChange.collections.map((c) => {\n            return Object.assign({ 'collectionId': c.collectionId, 'itemsPatch': (0, datasourceupdatetypes_1.serializeItemsPatch)(c.itemsPatch) }, (c.schema != null ? { 'schema': (0, datasourceupdatetypes_1.serializeSchemaForApi)(c.schema) } : undefined));\n        }),\n        'creationPermission': patchChange.creationPermission,\n    };\n}\nexports.serializePatchResponse = serializePatchResponse;\nfunction serializePatchChanges(changes) {\n    const joinedErrors = {};\n    for (const changeGroup of changes) {\n        for (const change of changeGroup) {\n            for (const [primaryKey, fieldNames] of Object.entries(change.getErrors())) {\n                for (const [fieldName, error] of Object.entries(fieldNames)) {\n                    if (!(change.patchId in joinedErrors)) {\n                        joinedErrors[change.patchId] = {};\n                    }\n                    const patchErrors = joinedErrors[change.patchId];\n                    if (!(primaryKey in patchErrors)) {\n                        patchErrors[primaryKey] = {};\n                    }\n                    const primaryKeyErrors = patchErrors[primaryKey];\n                    primaryKeyErrors[fieldName] = error;\n                }\n            }\n        }\n    }\n    return {\n        'changes': (0, object_1.flatten)(changes.map((changeList) => changeList.map((change) => serializePatchResponse(change)))),\n        'errors': joinedErrors,\n    };\n}\nexports.serializePatchChanges = serializePatchChanges;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeActions = exports.actionsHeaderValidator = void 0;\nconst checks_1 = __webpack_require__(/*! ../../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst dataupdatefiltertype_1 = __webpack_require__(/*! ../../data/dataupdatefiltertype */ \"./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js\");\nconst action_1 = __webpack_require__(/*! ./action */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/action.js\");\nconst dataconnectoractionkeys_1 = __webpack_require__(/*! ./dataconnectoractionkeys */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js\");\nexports.actionsHeaderValidator = (0, validators_1.objectValidator)({\n    'x-lucid-rsa-nonce': checks_1.isString,\n    'x-lucid-signature': checks_1.isString,\n});\nconst serializedActionsBaseValidator = (0, validators_1.objectValidator)({\n    action: (0, validators_1.objectValidator)({ name: checks_1.isString, data: checks_1.isUnknown }),\n    packageId: checks_1.isString,\n    packageVersion: (0, validators_1.nullableOption)(checks_1.isString),\n    dataConnectorName: checks_1.isString,\n    installationId: (0, validators_1.nullableOption)(checks_1.isString),\n    userCredential: (0, validators_1.nullableOption)(checks_1.isString),\n    useOutboundProxy: (0, validators_1.option)(checks_1.isBoolean),\n    documentUpdateToken: (0, validators_1.nullableOption)(checks_1.isString),\n    documentCollections: (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),\n    updateFilterType: (0, validators_1.enumValidator)(dataupdatefiltertype_1.DataUpdateFilterType),\n});\nconst serializedPatchDataValidator = (0, validators_1.objectValidator)({\n    packageVersion: checks_1.isString,\n    patches: (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({\n        patch: checks_1.isUnknown,\n        id: checks_1.isString,\n    })),\n    userCredential: checks_1.isString,\n    useOutboundProxy: (0, validators_1.option)(checks_1.isBoolean),\n    documentUpdateToken: checks_1.isString,\n});\nconst parseSerializedPatches = (patches, patchParser) => {\n    return patches\n        .map((patch) => {\n        const p = patch['patch'];\n        return patchParser(patch['id'], p);\n    })\n        .filter(checks_1.isDefAndNotNull);\n};\nconst serializedManageWebhookDataValidator = (0, validators_1.objectValidator)({\n    webhooks: (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({\n        documentCollections: (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),\n        webhookData: (0, validators_1.option)(checks_1.isUnknown),\n    })),\n    webhookToken: checks_1.isString,\n});\n/** Function to convert the lucid action wire format into a clean list of actions */\nfunction deserializeActions(client, actions, patchParser) {\n    const parsedActions = typeof actions === 'string' ? JSON.parse(actions) : actions;\n    if (!serializedActionsBaseValidator(parsedActions)) {\n        return;\n    }\n    const name = parsedActions['action']['name'];\n    const data = parsedActions['action']['data'];\n    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.Patch) {\n        if (!(0, validators_1.arrayValidator)(serializedPatchDataValidator)(data)) {\n            console.log(`Failing validation step due to serializedPatchDataValidator`);\n            return;\n        }\n        const parsedData = data\n            .map((item) => {\n            const context = new action_1.DataConnectorActionContext(parsedActions['packageId'], item['packageVersion'], item['userCredential'], item['useOutboundProxy'], // Use from action data and ignores the useOutboundProxy boolean in parsedActions\n            parsedActions['dataConnectorName'], parsedActions['dataConnectorName'], parsedActions['documentCollections'], parsedActions['updateFilterType']);\n            const patches = parseSerializedPatches(item['patches'], patchParser);\n            if (patches.length < item['patches'].length) {\n                return undefined;\n            }\n            return new action_1.DataConnectorPatchAction(context, patches, client.getDataSourceClient(item['documentUpdateToken']));\n        })\n            .filter(checks_1.isDefAndNotNull);\n        if (parsedData.length < data.length) {\n            console.log(`Failing validation step due to mismatched patches length.\\nExpected length: ${data.length}\\nActual length: ${parsedData.length}`);\n            return;\n        }\n        return parsedData;\n    }\n    if (!parsedActions['packageVersion'] || !parsedActions['userCredential']) {\n        return;\n    }\n    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch) {\n        if (!serializedPatchDataValidator(data)) {\n            return;\n        }\n        const context = new action_1.DataConnectorActionContext(parsedActions['packageId'], parsedActions['packageVersion'], parsedActions['userCredential'], parsedActions['useOutboundProxy'], parsedActions['dataConnectorName'], parsedActions['dataConnectorName'], parsedActions['documentCollections'], parsedActions['updateFilterType']);\n        const parsedPatches = parseSerializedPatches(data['patches'], patchParser);\n        if (parsedPatches.length < data['patches'].length) {\n            console.log(`Failing validation step due to mismatched patches length.\\nExpected length: ${data['patches'].length}\\nActual length: ${parsedPatches.length}`);\n            return;\n        }\n        return [\n            new action_1.DataConnectorPatchAction(context, parsedPatches, client.getDataSourceClient(data['documentUpdateToken']), dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch),\n        ];\n    }\n    const context = new action_1.DataConnectorActionContext(parsedActions['packageId'], parsedActions['packageVersion'], parsedActions['userCredential'], parsedActions['useOutboundProxy'], parsedActions['dataConnectorName'], parsedActions['dataConnectorName'], parsedActions['documentCollections'], parsedActions['updateFilterType']);\n    if (name == 'ManageWebhook') {\n        if (!serializedManageWebhookDataValidator(data)) {\n            return;\n        }\n        const webhooks = data['webhooks'].map((webhook) => new action_1.Webhook(webhook['documentCollections'], webhook['webhookData']));\n        return [new action_1.DataConnectorManageWebhookAction(context, data['webhookToken'], webhooks)];\n    }\n    if (parsedActions['documentUpdateToken']) {\n        return [\n            new action_1.DataConnectorAsynchronousAction(name, context, client.getDataSourceClient(parsedActions['documentUpdateToken']), data),\n        ];\n    }\n    return [new action_1.DataConnectorSynchronousAction(name, context, data)];\n}\nexports.deserializeActions = deserializeActions;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/serializedpatchtypes.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/serializedpatchtypes.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.patchValidator = exports.patchSchemaValidator = exports.thirdPartyColumnPatchValidator = exports.thirdPartyColumnValidator = exports.patchItemValidator = void 0;\nconst checks_1 = __webpack_require__(/*! ../../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../../core/data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst validators_1 = __webpack_require__(/*! ../../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nexports.patchItemValidator = (0, validators_1.objectValidator)({\n    itemsAdded: (0, validators_1.objectOfValidator)(checks_1.isObjectUnsafe),\n    itemsChanged: (0, validators_1.objectOfValidator)(checks_1.isObjectUnsafe),\n    itemsDeleted: (0, validators_1.arrayValidator)(checks_1.isString),\n    itemOrderChanged: (0, validators_1.nullableOption)((0, validators_1.arrayValidator)((0, validators_1.tupleValidator)(checks_1.isString, (0, validators_1.nullable)(checks_1.isString)))),\n    syncSourceId: checks_1.isString,\n    syncCollectionId: checks_1.isString,\n    adapterType: (0, checks_1.isLiteral)('EXTENSION_API'),\n    syncSchema: checks_1.isUnknown,\n});\nexports.thirdPartyColumnValidator = (0, validators_1.objectValidator)({\n    name: checks_1.isString,\n    fieldType: fieldtypedefinition_1.isSerializedFieldTypeDefinition,\n});\nexports.thirdPartyColumnPatchValidator = (0, validators_1.objectValidator)({\n    name: (0, validators_1.nullableOption)(checks_1.isString),\n    fieldType: (0, validators_1.nullableOption)(fieldtypedefinition_1.isSerializedFieldTypeDefinition),\n});\nexports.patchSchemaValidator = (0, validators_1.objectValidator)({\n    columnsAdded: (0, validators_1.arrayValidator)(exports.thirdPartyColumnValidator),\n    columnsChanged: (0, validators_1.mapValidator)(exports.thirdPartyColumnPatchValidator),\n    columnsDeleted: (0, validators_1.arrayValidator)(checks_1.isString),\n    columnOrdering: (0, validators_1.nullableOption)((0, validators_1.arrayValidator)((0, validators_1.tupleValidator)(checks_1.isString, (0, validators_1.nullable)(checks_1.isString)))),\n    syncSourceId: checks_1.isString,\n    syncCollectionId: checks_1.isString,\n    adapterType: (0, checks_1.isLiteral)('EXTENSION_API'),\n});\nexports.patchValidator = (0, validators_1.either)(exports.patchItemValidator, exports.patchSchemaValidator);\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/actions/serializedpatchtypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataConnector = exports.DataConnectorResponseError = exports.DataConnectorRequestState = exports.DataConnectorRequestError = exports.DataConnectorRunError = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst action_1 = __webpack_require__(/*! ./actions/action */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/action.js\");\nconst dataconnectoractionkeys_1 = __webpack_require__(/*! ./actions/dataconnectoractionkeys */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js\");\nconst managewebhookresponsebody_1 = __webpack_require__(/*! ./actions/managewebhookresponsebody */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js\");\nconst patch_1 = __webpack_require__(/*! ./actions/patch */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/patch.js\");\nconst patchresponsebody_1 = __webpack_require__(/*! ./actions/patchresponsebody */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js\");\nconst debugserver_1 = __webpack_require__(/*! ./debugserver */ \"./node_modules/lucid-extension-sdk/dataconnector/debugserver.js\");\nconst itemrekeyerandrelabeler_1 = __webpack_require__(/*! ./itemrekeyerandrelabeler */ \"./node_modules/lucid-extension-sdk/dataconnector/itemrekeyerandrelabeler.js\");\n/** Throw this from an action request handler to produce a non-200 response code and not have to return the expected\n * result type */\nclass DataConnectorRunError extends Error {\n    constructor(status, body, message) {\n        super(message !== null && message !== void 0 ? message : JSON.stringify(body));\n        this.status = status;\n        this.body = body;\n    }\n    static withMessage(status, message) {\n        return new DataConnectorRunError(status, { error: message }, message);\n    }\n}\nexports.DataConnectorRunError = DataConnectorRunError;\n/** Thrown by any failable http APIs */\nclass DataConnectorRequestError extends Error {\n    constructor(status, message, response, statusText) {\n        super(message);\n        this.status = status;\n        this.response = response;\n        this.statusText = statusText;\n    }\n    toString() {\n        return `${this.message} ${this.statusText ? this.statusText + ' ' : ''}(${this.status}) ${this.response}`;\n    }\n}\nexports.DataConnectorRequestError = DataConnectorRequestError;\nclass DataConnectorRequestState {\n    constructor(itemRekeyer) {\n        this.itemRekeyer = itemRekeyer;\n    }\n}\nexports.DataConnectorRequestState = DataConnectorRequestState;\n/** Thrown by any APIs the client didn't recognize when parsing */\nclass DataConnectorResponseError extends Error {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n    }\n}\nexports.DataConnectorResponseError = DataConnectorResponseError;\n/** Factory class to define a bunch of action handlers. */\nclass DataConnector {\n    constructor(client, optPatchParser) {\n        this.client = client;\n        this.actions = {};\n        this.routes = {};\n        this.patchParser = optPatchParser !== null && optPatchParser !== void 0 ? optPatchParser : patch_1.itemPatchParser;\n    }\n    /** Factory to define an action request handler */\n    defineAction(name, request, asynchronous = false) {\n        this.actions[name] = {\n            actionResponder: request,\n            asynchronous,\n        };\n        return this;\n    }\n    /** Factory to define an asynchronous action request handler */\n    defineAsynchronousAction(name, request) {\n        return this.defineAction(name, request, true);\n    }\n    /** Factory to define a route handler */\n    defineRoute(name, request) {\n        this.routes[name] = request;\n        return this;\n    }\n    /** Call a defined action handler and gather its serialized response */\n    async runAction(url, headers, body) {\n        const state = new DataConnectorRequestState(new itemrekeyerandrelabeler_1.ItemRekeyerAndRelabeler());\n        const actions = await this.client.parseActions(url, headers, body, this.patchParser);\n        if (!actions) {\n            console.warn('Received bad request', url, headers, body);\n            return { status: 404, body: { error: 'Bad request' } };\n        }\n        const actionName = actions[0].name;\n        try {\n            const responses = [];\n            for (const action of actions) {\n                if (!(action.name in this.actions)) {\n                    throw DataConnectorRunError.withMessage(404, `Action ${action.name} is not implemented`);\n                }\n                const { actionResponder, asynchronous } = this.actions[action.name];\n                const response = (() => {\n                    if (asynchronous) {\n                        if (!(action instanceof action_1.DataConnectorAsynchronousAction)) {\n                            throw DataConnectorRunError.withMessage(400, `Passing uncredentialed action to ${action.name} which is defined to be asynchronous`);\n                        }\n                        return actionResponder(action, state);\n                    }\n                    else {\n                        return actionResponder(action, state);\n                    }\n                })();\n                responses.push(await response);\n            }\n            if (actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.ManageWebhook) {\n                const response = responses[0];\n                // leave the type on this variable because our return type isn't strict. This means that\n                // changes to serializeManageWebhookResponse's return type will need to consider this point\n                const body = (0, managewebhookresponsebody_1.serializeManageWebhookResponse)(response);\n                return { status: 200, body };\n            }\n            if (actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.Patch || actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch) {\n                const responsesCasted = responses;\n                // leave the type on this variable because our return type isn't strict. This means that\n                // changes to serializePatchChanges's return type will need to consider this point\n                const body = (0, patchresponsebody_1.serializePatchChanges)(responsesCasted);\n                return { status: 200, body };\n            }\n            else if (responses.length === 1) {\n                return { status: 200, body: responses[0] };\n            }\n            else {\n                return { status: 200, body: responses };\n            }\n        }\n        catch (e) {\n            const errorLogger = console.error ? console.error : console.log;\n            errorLogger(`Error running ${actionName} action`, e);\n            if (isDataConnectorRunError(e)) {\n                return { status: e.status, body: e.body };\n            }\n            else {\n                return { status: 500, body: { error: `error running ${actionName} action` } };\n            }\n        }\n    }\n    /** Add a route to the given express app (or generate a new app) to serve this data connector */\n    routeDebugServer(options) {\n        return (0, debugserver_1.routeDebugServer)(this, options);\n    }\n    /**\n     * Serve this data connector as a simple express app for debugging purposes\n     */\n    runDebugServer(options) {\n        (0, debugserver_1.runDebugServer)(this, options);\n    }\n}\nexports.DataConnector = DataConnector;\n// instanceof DataConnectorRunError will not work in some environments\nconst isDataConnectorRunError = (0, validators_1.objectValidator)({\n    status: checks_1.isNumber,\n    body: checks_1.isUnknown,\n});\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MockDataConnectorClient = exports.DataConnectorClient = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializedactions_1 = __webpack_require__(/*! ./actions/serializedactions */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js\");\nconst datasourceclient_1 = __webpack_require__(/*! ./datasourceclient */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js\");\nconst defaultfetchfunction_1 = __webpack_require__(/*! ./defaultfetchfunction */ \"./node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js\");\nconst signaturevalidator_1 = __webpack_require__(/*! ./signaturevalidator */ \"./node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js\");\nconst throwunsuccessful_1 = __webpack_require__(/*! ./throwunsuccessful */ \"./node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js\");\nconst LUCID_URLS = { main: 'https://lucid.app/', api: 'https://api.lucid.co/' };\n/**\n * Client for requests to and from Lucid\n */\nclass DataConnectorClient {\n    constructor(cryptoDependencies, urls = LUCID_URLS, fetchMethod = defaultfetchfunction_1.globalFetch) {\n        this.cryptoDependencies = cryptoDependencies;\n        this.urls = urls;\n        this.fetchMethod = fetchMethod;\n        this.cachedPublicKey = undefined;\n    }\n    /** Get a client for DataSource related requests to Lucid */\n    getDataSourceClient(updateToken) {\n        return new datasourceclient_1.DataSourceClient(this.urls, updateToken, this.fetchMethod);\n    }\n    /** Get a validator to prove a given request came from Lucid */\n    async getSignatureValidator() {\n        return new signaturevalidator_1.SignatureValidator(this.cryptoDependencies, await this.getPublicKey());\n    }\n    /** Get Lucid's public key to verify requests came from Lucid if you don't want to use the SignatureValidator. Maybe\n     * you're not running in a NodeJS environment */\n    async getPublicKey() {\n        if (!this.cachedPublicKey) {\n            const url = `${this.urls.main}.well-known/pem/TPCP`;\n            const result = await this.fetchMethod(url);\n            await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting public key');\n            this.cachedPublicKey = await result.text();\n        }\n        return this.cachedPublicKey;\n    }\n    /** Validate and parse an action request from Lucid */\n    async parseActions(url, headers, actions, patchParser) {\n        if (!(0, serializedactions_1.actionsHeaderValidator)(headers)) {\n            return;\n        }\n        if (!(await this.getSignatureValidator()).validate(actions, headers, url)) {\n            return;\n        }\n        return (0, serializedactions_1.deserializeActions)(this, actions, patchParser);\n    }\n    /** @ignore */\n    async getSecretFromWebhook(webhookUpdateToken, WebhookValidationSecret) {\n        // todo: this should be using the public API\n        const result = await this.fetchMethod(`${this.urls.dataSync}webhookAuthorization`, {\n            headers: {\n                'data-update-token': webhookUpdateToken,\n                'webhook-validation-secret': JSON.stringify(WebhookValidationSecret),\n            },\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting secret from webhook');\n        const responseBody = await result.json();\n        if ((0, checks_1.isString)(responseBody)) {\n            return responseBody;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /** @ignore */\n    async getCustomWebhookData(webhookUpdateToken) {\n        const result = await this.fetchMethod(`${this.urls.dataSync}customWebhookData`, {\n            headers: { 'data-update-token': webhookUpdateToken },\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting custom webhook data');\n        return (await result.json());\n    }\n    /** @ignore */\n    async patchCustomWebhookData(webhookUpdateToken, patch) {\n        // todo: this should be using the public API\n        const result = await this.fetchMethod(`${this.urls.dataSync}customWebhookData`, {\n            method: 'PATCH',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': webhookUpdateToken,\n                'Lucid-Api-Version': '1',\n            },\n            body: JSON.stringify(patch),\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'patching custom webhook data');\n        return (await result.json());\n    }\n}\nexports.DataConnectorClient = DataConnectorClient;\n/** Use this for writing automated tests for your data connector */\nclass MockDataConnectorClient extends DataConnectorClient {\n    constructor() {\n        super(undefined);\n        /** set properties on this to modify how data source updates are mocked */\n        this.dataSourceClient = new datasourceclient_1.MockDataSourceClient();\n    }\n    /** @ignore */\n    getDataSourceClient(updateToken) {\n        return this.dataSourceClient;\n    }\n    /** Mocked version just always returns successful */\n    getSignatureValidator() {\n        return Promise.resolve(new signaturevalidator_1.MockSignatureValidator());\n    }\n    /** Mocked version returns an empty string */\n    getPublicKey() {\n        return Promise.resolve('');\n    }\n}\nexports.MockDataConnectorClient = MockDataConnectorClient;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js":
/*!****************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MockDataSourceClient = exports.DataSourceClient = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst datasourcetype_1 = __webpack_require__(/*! ../core/data/datasource/datasourcetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\");\nconst sourceforeignkeys_1 = __webpack_require__(/*! ../core/data/datasource/sourceforeignkeys */ \"./node_modules/lucid-extension-sdk/core/data/datasource/sourceforeignkeys.js\");\nconst upstreamconfig_1 = __webpack_require__(/*! ../core/data/datasource/upstreamconfig */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js\");\nconst upstreamupdatetype_1 = __webpack_require__(/*! ../core/data/datasource/upstreamupdatetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\");\nconst result_1 = __webpack_require__(/*! ../core/result */ \"./node_modules/lucid-extension-sdk/core/result.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst dataconnector_1 = __webpack_require__(/*! ./dataconnector */ \"./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js\");\nconst datasourcemetadatatypes_1 = __webpack_require__(/*! ./datasourcemetadatatypes */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js\");\nconst datasourceupdatetypes_1 = __webpack_require__(/*! ./datasourceupdatetypes */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js\");\nconst defaultfetchfunction_1 = __webpack_require__(/*! ./defaultfetchfunction */ \"./node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js\");\nconst throwunsuccessful_1 = __webpack_require__(/*! ./throwunsuccessful */ \"./node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js\");\nconst QueryParamLengthLimit = 2000;\n/**\n * Authenticated client for DataSource related requests to Lucid.\n */\nclass DataSourceClient {\n    constructor(urls, updateToken, fetchMethod = defaultfetchfunction_1.globalFetch) {\n        this.urls = urls;\n        this.updateToken = updateToken;\n        this.fetchMethod = fetchMethod;\n        const dataSyncUrl = urls.dataSync;\n        this.metadataUrl = (0, checks_1.isString)(dataSyncUrl) ? `${dataSyncUrl}dataSource/metadata` : undefined;\n    }\n    formatBody({ dataSourceName, collections, updateFilterType, dataSourceConfiguration, sourceForeignKeys, creationPermission, }) {\n        const updateData = {};\n        for (const collectionId in collections) {\n            updateData[collectionId] = (0, datasourceupdatetypes_1.serializeCollectionPatch)(collections[collectionId]);\n        }\n        const updateFilterTypeObj = updateFilterType ? { 'UpdateFilterType': updateFilterType } : {};\n        const upstreamConfig = {\n            dataSourceType: datasourcetype_1.DataSourceType.DataService,\n            updateType: upstreamupdatetype_1.UpstreamUpdateType.EVENTPULL,\n            patchType: dataSourceConfiguration === null || dataSourceConfiguration === void 0 ? void 0 : dataSourceConfiguration.patchType,\n            sourceConfig: Object.assign({}, updateFilterTypeObj),\n        };\n        const foreignKeys = sourceForeignKeys ? sourceForeignKeys.map(sourceforeignkeys_1.serializeSourceForeignKey) : [];\n        return {\n            'updateData': updateData,\n            'name': dataSourceName,\n            'upstreamConfig': (0, upstreamconfig_1.serializeUpstreamConfig)(upstreamConfig),\n            'sourceForeignKeys': foreignKeys,\n            'creationPermission': creationPermission,\n        };\n    }\n    /** Create or update a datasource. If you create a new collection it must be fully specified in terms of schema and\n     * and items. If it's just an update then the schema can be omitted (if unchanged) and items that already exist can\n     * be partial.*/\n    async update(request) {\n        const response = await this.fetchMethod(`${this.urls.api}data/dataSource/update`, {\n            'method': 'POST',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': this.updateToken,\n                'Lucid-Api-Version': '1',\n            },\n            'body': JSON.stringify(this.formatBody(request)),\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'updating data source');\n        // webhooks return 200 with an empty body\n        // document updates return valid json\n        // we can't use .json because that will fail for webhooks\n        // if we update the response type for webhook updates\n        // we can handle that here too. We should probably unify the responses\n        // to be meaningful\n        // we could just:\n        // return await response.text();\n        // but lets avoid users trying to interpret the response\n    }\n    /**\n     * When dealing with data, we can often have a very large number of collections in a single data source, and in\n     * turn, we may well end up get the values for a very large number of metadata values per collection.\n     * Because the endpoints for metadata use query params to encode the metadata names, and because metadata value\n     * reads can be easily parallelized, and because URLs have length limits, this function constructs an array of\n     * query params that are certain to be short enough that each individual query will be a safe length, while still\n     * getting *all* of the requested data.\n     * @param keys The metadata keys we are requesting from the data sync service for the corresponding data source.\n     * @param prefixes The metadata prefixes we are requesting from the data sync service for the corresponding data source.\n     * @returns An array of query params such that each query param is short enough to be safe, but all params combined\n     *             cover all requested metadata.\n     */\n    getLengthLimitedQueryParams(keys, prefixes) {\n        const keyQueryParams = keys.map(encodeURIComponent).map((keyVal) => `metadataKeys=${keyVal}`);\n        const prefixQueryParams = prefixes.map(encodeURIComponent).map((prefixVal) => `metadataPrefixes=${prefixVal}`);\n        const fullQueryParams = [];\n        let currentQueryParam = '';\n        let delimiter = '?';\n        [...keyQueryParams, ...prefixQueryParams].forEach((param) => {\n            currentQueryParam = currentQueryParam.concat(`${delimiter}${param}`);\n            if (currentQueryParam.length > QueryParamLengthLimit) {\n                fullQueryParams.push(currentQueryParam);\n                currentQueryParam = '';\n                delimiter = '?';\n            }\n            else {\n                delimiter = '&';\n            }\n        });\n        if (currentQueryParam.length > 0) {\n            fullQueryParams.push(currentQueryParam);\n        }\n        return fullQueryParams;\n    }\n    async getResponseOrError(url) {\n        const response = await this.fetchMethod(url, {\n            'method': 'GET',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': this.updateToken,\n                'Lucid-Api-Version': '1',\n            },\n        });\n        try {\n            await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'getting data source`s metadata');\n        }\n        catch (e) {\n            if (e instanceof dataconnector_1.DataConnectorResponseError) {\n                return { error: { url, body: e.response } };\n            }\n            throw e;\n        }\n        const responseBody = await response.json();\n        if ((0, validators_1.arrayValidator)(datasourcemetadatatypes_1.isSerializedMetadataRecord)(responseBody)) {\n            return {\n                value: responseBody.map((rawResponse) => {\n                    return {\n                        key: rawResponse['key'],\n                        value: rawResponse['value'],\n                    };\n                }),\n            };\n        }\n        else {\n            return {\n                error: { url, body: responseBody },\n            };\n        }\n    }\n    /** @ignore until metadata endpoints are made part of the public API */\n    async getMetadata(keys, prefixes = []) {\n        if (this.metadataUrl == null) {\n            throw new Error('Attempted to access data sync service metadata endpoints in environment where the URL does not exist!');\n        }\n        const queryParamsList = this.getLengthLimitedQueryParams(keys, prefixes);\n        const urlsWithParams = queryParamsList.map((query) => `${this.metadataUrl}${query}`);\n        const responsePromises = urlsWithParams.map((url) => this.getResponseOrError(url));\n        const responses = await Promise.all(responsePromises);\n        const records = [];\n        const errors = [];\n        responses.forEach((response) => {\n            if ((0, result_1.isSuccess)(response)) {\n                records.push(...response.value);\n            }\n            else {\n                errors.push(response.error);\n            }\n        });\n        if (errors.length > 0) {\n            const message = `Error(s) received accessing URL(s): ${errors.map(({ url }) => url).join(',')}`;\n            const allBodies = errors.map(({ body }) => body);\n            throw new dataconnector_1.DataConnectorResponseError(message, JSON.stringify(allBodies));\n        }\n        return records;\n    }\n    /** @ignore until metadata endpoints are made part of the public API */\n    async patchMetadata(patches) {\n        if (this.metadataUrl == null) {\n            throw new Error('Attempted to access data sync service metadata endpoints in environment where the URL does not exist!');\n        }\n        const serializedPatches = patches.map((patch) => {\n            return {\n                'key': patch.key,\n                'oldValue': patch.oldValue,\n                'newValue': patch.newValue,\n            };\n        });\n        const response = await this.fetchMethod(this.metadataUrl, {\n            'method': 'PATCH',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': this.updateToken,\n                'Lucid-Api-Version': '1',\n            },\n            body: JSON.stringify(serializedPatches),\n        });\n        if (response.status === 409) {\n            const responseBody = await response.json();\n            if ((0, validators_1.arrayValidator)(datasourcemetadatatypes_1.isSerializedMetadataRecord)(responseBody)) {\n                return {\n                    status: 'Conflict',\n                    records: responseBody.map((record) => {\n                        return {\n                            key: record['key'],\n                            value: record['value'],\n                        };\n                    }),\n                };\n            }\n            throw new dataconnector_1.DataConnectorResponseError(`Invalid conflict response to query at '${this.metadataUrl}'! Expected an array of serialized metadata records`, JSON.stringify(responseBody));\n        }\n        await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'patching data source`s metadata');\n        return { status: 'NoContent' };\n    }\n}\nexports.DataSourceClient = DataSourceClient;\n/**\n * A version of the DataSourceClient that you can use for any automated tests of your data connector.\n * Modify the `gotUpdate` field to change the behaviour of the update method.\n **/\nclass MockDataSourceClient extends DataSourceClient {\n    constructor() {\n        super({ main: '', api: '' }, '');\n        /** Assign this to your mocked update function */\n        this.gotUpdate = (request) => {\n            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);\n        };\n        /** Assign this to your mocked update function */\n        this.gotMetadata = (request) => {\n            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);\n        };\n        /** Assign this to your mocked update function */\n        this.patchedMetadata = (request) => {\n            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);\n        };\n    }\n    /** @ignore */\n    update(request) {\n        return Promise.resolve(this.gotUpdate(request));\n    }\n    /** @ignore */\n    getMetadata(keys, prefixes = []) {\n        return Promise.resolve(this.gotMetadata(keys, prefixes));\n    }\n    /** @ignore */\n    patchMetadata(patches) {\n        return Promise.resolve(this.patchedMetadata(patches));\n    }\n}\nexports.MockDataSourceClient = MockDataSourceClient;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedMetadataRecord = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nexports.isSerializedMetadataRecord = (0, validators_1.objectValidator)({\n    'key': checks_1.isString,\n    'value': checks_1.isUnknown,\n});\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.schemaOKStatus = exports.schemaOutOfSyncStatus = exports.serializeCollectionPatch = exports.serializeSchemaForApi = exports.serializeFieldDefinitionForApi = exports.serializeItemsPatch = exports.ItemsPatchExhaustive = exports.ItemsPatchInexhaustive = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../core/data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst object_1 = __webpack_require__(/*! ../core/object */ \"./node_modules/lucid-extension-sdk/core/object.js\");\nconst collectionerrortypes_1 = __webpack_require__(/*! ../data/collectionerrortypes */ \"./node_modules/lucid-extension-sdk/data/collectionerrortypes.js\");\nclass ItemsPatchInexhaustive {\n    constructor(\n    /**\n     * Items to be added or changed in the collection. Mapping from item serialized primary key to\n     * the sparse patch of the item. See FormattedPrimaryKey.forItem.\n     **/\n    items, \n    /** Items to remove from the collection, based on the same primary key algorithm. */\n    itemsDeleted, errors) {\n        this.items = items;\n        this.itemsDeleted = itemsDeleted;\n        this.errors = errors;\n        this._brand = ItemsPatchInexhaustive;\n    }\n}\nexports.ItemsPatchInexhaustive = ItemsPatchInexhaustive;\nclass ItemsPatchExhaustive {\n    constructor(items, rekeyingMap, fieldNamesChanged, errors) {\n        this.items = items;\n        this.rekeyingMap = rekeyingMap;\n        this.fieldNamesChanged = fieldNamesChanged;\n        this.errors = errors;\n        this._brand = ItemsPatchExhaustive;\n    }\n}\nexports.ItemsPatchExhaustive = ItemsPatchExhaustive;\nfunction serializeErrors(errors) {\n    return errors && { 'errors': (0, object_1.fromEntries)(errors) };\n}\nfunction serializeRekeyingMap(rekeyingMap) {\n    return rekeyingMap && { 'rekeyingMap': (0, object_1.fromEntries)(rekeyingMap) };\n}\nfunction serializeFieldNamesChanged(fieldNamesChanged) {\n    return fieldNamesChanged && { 'fieldNamesChanged': (0, object_1.fromEntries)(fieldNamesChanged) };\n}\nfunction serializeItemsPatch(patch) {\n    var _a;\n    if (patch instanceof ItemsPatchExhaustive) {\n        return Object.assign(Object.assign(Object.assign({ 'exhaustiveItems': (0, object_1.fromEntries)(patch.items.entries()) }, serializeRekeyingMap(patch.rekeyingMap)), serializeFieldNamesChanged(patch.fieldNamesChanged)), serializeErrors(patch.errors));\n    }\n    else {\n        return Object.assign({ 'items': (0, object_1.fromEntries)(patch.items.entries()), 'itemsDeleted': (_a = patch.itemsDeleted) !== null && _a !== void 0 ? _a : [] }, serializeErrors(patch.errors));\n    }\n}\nexports.serializeItemsPatch = serializeItemsPatch;\nfunction serializeFieldConstraintForApi(constraint) {\n    return {\n        'type': constraint.type,\n        'details': constraint.value,\n    };\n}\n/** @ignore */\nfunction serializeFieldDefinitionForApi(field) {\n    var _a;\n    return {\n        'name': field.name,\n        'type': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type),\n        'constraints': ((_a = field.constraints) !== null && _a !== void 0 ? _a : []).map((x) => serializeFieldConstraintForApi(x)),\n        'mapping': field.mapping,\n    };\n}\nexports.serializeFieldDefinitionForApi = serializeFieldDefinitionForApi;\nfunction serializeSchemaForApi(schema) {\n    return {\n        'fields': schema.fields.map((x) => serializeFieldDefinitionForApi(x)),\n        'primaryKey': schema.primaryKey,\n        'fieldLabelOverrides': schema.fieldLabels,\n    };\n}\nexports.serializeSchemaForApi = serializeSchemaForApi;\nfunction serializeRepresentsAsPropertyForApi(represents) {\n    return {\n        'Represents': represents, // key needs to match 'Represents' key in cake/app/webroot/ts/property/collection/collectionproperties.ts\n    };\n}\nfunction serializeNameAsPropertyForApi(name) {\n    return {\n        'Name': name, // key needs to match 'Name' key in cake/app/webroot/ts/property/collection/collectionproperties.ts\n    };\n}\nfunction serializeHiddenFromDataPanelForApi(hiddenFromDataPanel) {\n    return {\n        'IsHiddenFromDataPanel': hiddenFromDataPanel, // key needs to match 'IsHiddenFromDataPanel' key in cake/app/webroot/ts/property/collection/collectionproperties.ts\n    };\n}\nfunction serializeCollectionPatch(patch) {\n    const representsProperty = patch.represents && serializeRepresentsAsPropertyForApi(patch.represents);\n    const nameProperty = (0, checks_1.isString)(patch.name) ? serializeNameAsPropertyForApi(patch.name) : undefined;\n    const isHiddenFromDataPanelProperty = (0, checks_1.isDef)(patch.hideFromDataPanel)\n        ? serializeHiddenFromDataPanelForApi(patch.hideFromDataPanel)\n        : undefined;\n    const properties = (representsProperty || nameProperty || isHiddenFromDataPanelProperty) && Object.assign(Object.assign(Object.assign({}, representsProperty), nameProperty), isHiddenFromDataPanelProperty);\n    return {\n        'schema': patch.schema && serializeSchemaForApi(patch.schema),\n        'itemsPatch': serializeItemsPatch(patch.patch),\n        'properties': properties,\n    };\n}\nexports.serializeCollectionPatch = serializeCollectionPatch;\n/**\n * For the moment, when the upstream Google Sheet is changed in such a way that the schema has changed, we simply\n * stop updates from happening. We do need to alert the user that this has happened, though. This is a utility function\n * for creating the appropriate entry in the errors map so that the user can be alerted that updates have stopped\n * and what they need to do to fix it.\n *\n * The eventual, proposed fix is to allow schemas to have version numbers so that changes to the schema from Google\n * can simply be folded in to the on-document copies of the data and all following edits.\n *\n * @param oldPrimaryKey The primary key stored in the data sync service and which currently is used to interpret\n * patches.\n * @param newPrimaryKey The primary key as it has been changed in the real Google Sheets.\n * @returns The error map entry which alerts the document that this problem has happened.\n */\nfunction schemaOutOfSyncStatus(oldPrimaryKey, newPrimaryKey) {\n    return [\n        collectionerrortypes_1.CollectionUpstreamSchemaStatus,\n        {\n            'dict': {\n                'status': 'broken',\n                'onDocumentKey': JSON.stringify(oldPrimaryKey),\n                'upstreamKey': JSON.stringify(newPrimaryKey),\n            },\n        },\n    ];\n}\nexports.schemaOutOfSyncStatus = schemaOutOfSyncStatus;\n/**\n * For the moment, when the upstream Google Sheet is changed in such a way that the schema has changed, we simply\n * stop updates from happening. We do need to alert the user that this has happened, though. We also need to know when\n * the updates are happening properly so we can clear the error once the user has resolved the problem. Since the\n * only way to delete errors is to overwrite them, we simply overwrite the error to be OK on every successful\n * import.\n * @returns The error map entry which alerts the document that this problem has been resolved.\n */\nfunction schemaOKStatus() {\n    return [\n        collectionerrortypes_1.CollectionUpstreamSchemaStatus,\n        {\n            'dict': {\n                'status': 'ok',\n                'onDocumentKey': null,\n                'upstreamKey': null,\n            },\n        },\n    ];\n}\nexports.schemaOKStatus = schemaOKStatus;\nconst assertIsJustRenamed = () => undefined;\nassertIsJustRenamed();\nassertIsJustRenamed();\nassertIsJustRenamed();\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/debugserver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/debugserver.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.runDebugServer = exports.routeDebugServer = void 0;\nconst object_1 = __webpack_require__(/*! ../core/object */ \"./node_modules/lucid-extension-sdk/core/object.js\");\n/** @ignore */\nfunction routeDebugServer(dataConnector, options) {\n    var _a, _b;\n    const { express } = options;\n    const app = (_a = options.app) !== null && _a !== void 0 ? _a : options.express();\n    // We can't use Express's JSON parsing because we need to send the string of the request body\n    // directly for the route style flows. Some extensions compute a HMAC of from this data\n    app.use(express.raw({ type: () => true, limit: '100mb' }));\n    // CORS\n    app.use((req, res, next) => {\n        var _a, _b, _c, _d;\n        if (((_b = (_a = req.headers) === null || _a === void 0 ? void 0 : _a.origin) === null || _b === void 0 ? void 0 : _b.match(/.lucid(dev|staging|preprod|gov|govpreprod|).app$/)) ||\n            ((_d = (_c = req.headers) === null || _c === void 0 ? void 0 : _c.origin) === null || _d === void 0 ? void 0 : _d.match(/.luciddev.cloud$/))) {\n            res.header('Access-Control-Allow-Origin', req.headers.origin);\n            res.header('Vary', 'Origin');\n            res.header('Access-Control-Allow-Methods', 'GET, OPTIONS');\n            res.header('Access-Control-Allow-Headers', '*');\n        }\n        next();\n    });\n    const prefix = (_b = options.prefix) !== null && _b !== void 0 ? _b : '/';\n    console.log(`Routing ${prefix} (${Object.keys(dataConnector.actions).join(', ')})`);\n    if (dataConnector.routes) {\n        for (const routeName of Object.keys(dataConnector.routes)) {\n            console.log(`Routing ${prefix}?kind=route&name=${routeName}`);\n        }\n    }\n    app.post(prefix, async (req, res) => {\n        try {\n            const routeKind = req.query['kind'];\n            if (routeKind === 'action' || routeKind == undefined || routeKind === '') {\n                const { body, status } = await dataConnector.runAction(req.url, req.headers, req.body.toString());\n                res.status(status).json(body);\n            }\n            if (routeKind === 'route') {\n                const routeName = req.query['name'];\n                if (typeof routeName === 'string') {\n                    const route = dataConnector.routes[routeName];\n                    const reqHeaders = req.headers;\n                    const { body, status, headers } = await route({\n                        body: req.body.toString(),\n                        headers: reqHeaders,\n                        query: (0, object_1.fromEntries)(Object.entries(req.query).map(([key, value]) => [\n                            key,\n                            typeof value === 'string' ? value : undefined,\n                        ])),\n                    });\n                    for (const [name, value] of Object.entries(headers !== null && headers !== void 0 ? headers : {})) {\n                        if (typeof value === 'string') {\n                            res.setHeader(name, value);\n                        }\n                    }\n                    res.status(status);\n                    res.send(body);\n                }\n            }\n        }\n        catch (e) {\n            console.log(`Error serving Connector: ${prefix} Flow: ${req.query['name']}, Exception:`, e);\n            res.status(500).end();\n        }\n    });\n    return app;\n}\nexports.routeDebugServer = routeDebugServer;\n/** @ignore */\nfunction runDebugServer(dataConnector, options) {\n    var _a;\n    const port = (_a = options.port) !== null && _a !== void 0 ? _a : 3001;\n    const server = routeDebugServer(dataConnector, options).listen(port, () => {\n        const address = server.address();\n        const port = typeof address === 'string' ? address : address === null || address === void 0 ? void 0 : address.port;\n        console.log(`Listening on port ${port}`);\n    });\n}\nexports.runDebugServer = runDebugServer;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/debugserver.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js":
/*!********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.globalFetch = void 0;\n// this is used to allow extensions to compile without fetch existing for them.\n/** @ignore */\nexports.globalFetch = globalThis['fetch'];\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/itemrekeyerandrelabeler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/itemrekeyerandrelabeler.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ItemRekeyerAndRelabeler = exports.RekeyingRelabelingMap = void 0;\nconst fieldspecification_1 = __webpack_require__(/*! ../core/data/fieldspecification */ \"./node_modules/lucid-extension-sdk/core/data/fieldspecification.js\");\nconst object_1 = __webpack_require__(/*! ../core/object */ \"./node_modules/lucid-extension-sdk/core/object.js\");\nconst patch_1 = __webpack_require__(/*! ./actions/patch */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/patch.js\");\nconst datasourceupdatetypes_1 = __webpack_require__(/*! ./datasourceupdatetypes */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js\");\nfunction calculateRekeyingMap(itemsPatch, primaryKey) {\n    var _a, _b;\n    if (itemsPatch instanceof datasourceupdatetypes_1.ItemsPatchExhaustive) {\n        return itemsPatch.rekeyingMap;\n    }\n    else {\n        if (!primaryKey) {\n            return undefined;\n        }\n        const constPrimaryKey = primaryKey;\n        function primaryKeyIfChanged(oldPrimaryKey, item) {\n            const changedParts = constPrimaryKey.elements.map((field) => item[field]);\n            if (changedParts.find((x) => x !== undefined) === undefined) {\n                // this patch didn't touch the primary key\n                return undefined;\n            }\n            // we might need parts of the old primary key if only some of the primary key fields changed.\n            // As an optimization we could only compute this if at least one of the changedParts is\n            // undefined.\n            const oldParts = JSON.parse(`[${oldPrimaryKey}]`);\n            const newParts = changedParts.map((part, index) => (part !== undefined ? part : oldParts[index]));\n            const newPrimaryKey = fieldspecification_1.FormattedPrimaryKey.serializeList(newParts);\n            if (newPrimaryKey !== oldPrimaryKey) {\n                return newPrimaryKey;\n            }\n            else {\n                return undefined;\n            }\n        }\n        const itemsMap = [...itemsPatch.items.entries()]\n            .map(([key, value]) => [key, primaryKeyIfChanged(key, value)])\n            .filter((x) => x[1] !== undefined);\n        const deletedMap = (_b = (_a = itemsPatch.itemsDeleted) === null || _a === void 0 ? void 0 : _a.map((key) => [key, null])) !== null && _b !== void 0 ? _b : [];\n        const theMap = new Map([...itemsMap, ...deletedMap]);\n        return theMap.size > 0 ? theMap : undefined;\n    }\n}\nfunction calculateRelabelingMap(itemsPatch) {\n    if (itemsPatch instanceof datasourceupdatetypes_1.ItemsPatchExhaustive) {\n        return itemsPatch.fieldNamesChanged;\n    }\n    else {\n        return undefined;\n    }\n}\nclass RekeyingRelabelingMap {\n    constructor(keyMap, labelMap) {\n        this.keyMap = keyMap;\n        this.labelMap = labelMap;\n    }\n    getNewKey(key) {\n        var _a;\n        return (_a = this.keyMap.get(key)) !== null && _a !== void 0 ? _a : key;\n    }\n    getNewLabel(label) {\n        var _a;\n        return (_a = this.labelMap.get(label)) !== null && _a !== void 0 ? _a : label;\n    }\n    getRelabeledItem(item) {\n        const newItem = {};\n        for (const key in item) {\n            newItem[this.getNewLabel(key)] = item[key];\n        }\n        return newItem;\n    }\n    getRecordWithNewKeysAndLabels(items) {\n        return (0, object_1.fromEntries)(Object.entries(items).map(([key, value]) => [this.getNewKey(key), this.getRelabeledItem(value)]));\n    }\n    getRelabeledThirdPartyColumn(thirdPartyColumn) {\n        return new patch_1.ThirdPartyColumn(this.getNewLabel(thirdPartyColumn.name), thirdPartyColumn.fieldType);\n    }\n    getRelabeledThirdPartyColumnPatches(thirdPartyColumnPatch) {\n        const newRecord = {};\n        for (const label in thirdPartyColumnPatch) {\n            newRecord[this.getNewLabel(label)] = thirdPartyColumnPatch[label];\n        }\n        return newRecord;\n    }\n    getRekeyedRelabeledPatch(patch) {\n        var _a, _b;\n        if (patch instanceof patch_1.ItemPatch) {\n            return new patch_1.ItemPatch(patch.id, this.getRecordWithNewKeysAndLabels(patch.itemsAdded), this.getRecordWithNewKeysAndLabels(patch.itemsChanged), patch.itemsDeleted.map((key) => this.getNewKey(key)), (_a = patch.itemOrderChanged) === null || _a === void 0 ? void 0 : _a.map(([a, b]) => [this.getNewKey(a), b && this.getNewKey(b)]), patch.syncSourceId, patch.syncCollectionId);\n        }\n        if (patch instanceof patch_1.SchemaPatch) {\n            return new patch_1.SchemaPatch(patch.id, patch.columnsAdded.map((column) => this.getRelabeledThirdPartyColumn(column)), this.getRelabeledThirdPartyColumnPatches(patch.columnsChanged), patch.columnsDeleted.map((columnName) => this.getNewLabel(columnName)), (_b = patch.columnOrdering) === null || _b === void 0 ? void 0 : _b.map(([movedColumn, anchorColumn]) => [\n                this.getNewLabel(movedColumn),\n                anchorColumn != null ? this.getNewLabel(anchorColumn) : anchorColumn,\n            ]), patch.syncSourceId, patch.syncCollectionId);\n        }\n        return patch.clone();\n    }\n}\nexports.RekeyingRelabelingMap = RekeyingRelabelingMap;\nclass ItemRekeyerAndRelabeler {\n    constructor() {\n        this.rekeyingRelabelingMaps = new Map();\n    }\n    addRekeyingsRelabelingsFor(collectionId, itemsPatch, primaryKey) {\n        var _a, _b, _c, _d;\n        const rekeyingMap = calculateRekeyingMap(itemsPatch, primaryKey);\n        const relabelingMap = calculateRelabelingMap(itemsPatch);\n        const existingKeyAndLabelMap = this.rekeyingRelabelingMaps.get(collectionId);\n        const rekeyedExisting = rekeyingMap &&\n            [...((_a = existingKeyAndLabelMap === null || existingKeyAndLabelMap === void 0 ? void 0 : existingKeyAndLabelMap.keyMap.entries()) !== null && _a !== void 0 ? _a : [])].map(([key, value]) => {\n                var _a;\n                return [\n                    key,\n                    value && ((_a = rekeyingMap.get(value)) !== null && _a !== void 0 ? _a : value),\n                ];\n            });\n        const relabeledExisting = relabelingMap &&\n            [...((_b = existingKeyAndLabelMap === null || existingKeyAndLabelMap === void 0 ? void 0 : existingKeyAndLabelMap.labelMap.entries()) !== null && _b !== void 0 ? _b : [])].map(([key, value]) => {\n                var _a;\n                return [\n                    key,\n                    value && ((_a = relabelingMap.get(value)) !== null && _a !== void 0 ? _a : value),\n                ];\n            });\n        this.rekeyingRelabelingMaps.set(collectionId, new RekeyingRelabelingMap(new Map([...((_c = rekeyingMap === null || rekeyingMap === void 0 ? void 0 : rekeyingMap.entries()) !== null && _c !== void 0 ? _c : []), ...(rekeyedExisting !== null && rekeyedExisting !== void 0 ? rekeyedExisting : [])]), new Map([...((_d = relabelingMap === null || relabelingMap === void 0 ? void 0 : relabelingMap.entries()) !== null && _d !== void 0 ? _d : []), ...(relabeledExisting !== null && relabeledExisting !== void 0 ? relabeledExisting : [])])));\n    }\n    getRekeyingRelabelingMap(patch) {\n        return this.rekeyingRelabelingMaps.get(patch.syncCollectionId);\n    }\n}\nexports.ItemRekeyerAndRelabeler = ItemRekeyerAndRelabeler;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/itemrekeyerandrelabeler.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MockSignatureValidator = exports.SignatureValidator = void 0;\n/**\n * Allows validation that requests originated from Lucid. This class can only be instanciated in a NodeJS environment.\n * Technically any environment that provides NodeJS compatible implementations of `globalThis.Buffer` and\n * `globalThis.require('crypto')` will work.\n */\nclass SignatureValidator {\n    constructor(dependencies, publicKey) {\n        this.dependencies = dependencies;\n        this.publicKey = dependencies.crypto.createPublicKey(publicKey);\n    }\n    /**\n     * Validate a given request came from Lucid.\n     * @param body The body of the request as a plain JavaScript object. This should be JSON.parse called on exactly the\n     *             request body that came from Lucid.\n     * @param headers The headers that are associated with the request. Only 'x-lucid-rsa-nonce' and 'x-lucid-signature'\n     *                are required.\n     * @param url     The url of the current endpoint that is being requested.\n     * @returns true if the request is valid\n     */\n    validate(body, headers, url) {\n        const [, params = ''] = url.split('?');\n        const nonce = headers['x-lucid-rsa-nonce'];\n        const signature = this.dependencies.Buffer.from(headers['x-lucid-signature'], 'base64');\n        const stringBody = typeof body === 'string' ? body : JSON.stringify(body);\n        const data = this.dependencies.Buffer.from(stringBody + nonce + params);\n        const verified = this.dependencies.crypto.verify('SHA384', data, this.publicKey, signature);\n        return verified;\n    }\n}\nexports.SignatureValidator = SignatureValidator;\n/** Mock signature validator, always returns true. */\nclass MockSignatureValidator {\n    validate() {\n        return true;\n    }\n}\nexports.MockSignatureValidator = MockSignatureValidator;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.throwUnsuccessful = void 0;\nconst dataconnector_1 = __webpack_require__(/*! ./dataconnector */ \"./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js\");\n/** @ignore */\nasync function throwUnsuccessful(result, message) {\n    if (Math.floor(result.status / 100) !== 2) {\n        throw new dataconnector_1.DataConnectorRequestError(result.status, message, await result.text(), result.statusText);\n    }\n}\nexports.throwUnsuccessful = throwUnsuccessful;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.findProxyClass = void 0;\nconst cardblockproxy_1 = __webpack_require__(/*! ./cardblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js\");\nconst customblockproxy_1 = __webpack_require__(/*! ./customblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js\");\nconst erdblockproxy_1 = __webpack_require__(/*! ./erdblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js\");\nconst legendblockproxy_1 = __webpack_require__(/*! ./legendblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js\");\nconst linkunfurlblockproxy_1 = __webpack_require__(/*! ./linkunfurlblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js\");\nconst swimlaneblockproxy_1 = __webpack_require__(/*! ./swimlaneblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js\");\nconst tableblockproxy_1 = __webpack_require__(/*! ./tableblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js\");\nconst allProxyClasses = [\n    cardblockproxy_1.CardBlockProxy,\n    customblockproxy_1.CustomBlockProxy,\n    erdblockproxy_1.ERDBlockProxy,\n    legendblockproxy_1.LegendBlockProxy,\n    linkunfurlblockproxy_1.LinkUnfurlBlockProxy,\n    swimlaneblockproxy_1.SwimLaneBlockProxy,\n    tableblockproxy_1.TableBlockProxy,\n];\nfunction findProxyClass(className) {\n    return allProxyClasses.find((proxy) => proxy.classNameRegex.test(className));\n}\nexports.findProxyClass = findProxyClass;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CardBlockProxy = void 0;\nconst cardfielddisplaysettings_1 = __webpack_require__(/*! ../../core/cardintegration/cardfielddisplaysettings */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\n/**\n * A generic lucid card block.\n * This shape has all of the base functionality as a BlockProxy, as well as additional card specific properties.\n */\nclass CardBlockProxy extends blockproxy_1.BlockProxy {\n    getSettings() {\n        return this.referenceKeys.get(this.referenceKeys.keys()[0]).definition;\n    }\n    getTitle() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Title];\n    }\n    getDescription() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Description];\n    }\n    getStatus() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Status];\n    }\n    getAssignee() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Assignee];\n    }\n    getStartTime() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.StartTime];\n    }\n    getEndTime() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.EndTime];\n    }\n    getEstimate() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Estimate];\n    }\n    /**\n     * @param title The title that you want to set for this card.\n     */\n    setTitle(title) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Title] = title;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param description The description that you want to set for this card.\n     */\n    setDescription(description) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Description] = description;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param status The status that you want to set for this card.\n     */\n    setStatus(status) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Status] = status;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param assignee The assignee that you want to set for this card.\n     */\n    setAssignee(assignee) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Assignee] = assignee;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param startTime The start time that you want to set for this card.\n     */\n    setStartTime(startTime) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.StartTime] = startTime;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param endTime The end time that you want to set for this card.\n     */\n    setEndTime(endTime) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.EndTime] = endTime;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param estimate The estimate that you want to set for this card.\n     */\n    setEstimate(estimate) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Estimate] = estimate;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n}\nexports.CardBlockProxy = CardBlockProxy;\nCardBlockProxy.classNameRegex = /^LucidCardBlock$/;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js":
/*!************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CustomBlockProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\n/**\n * Custom shapes defined in extension packages (or other stencil-providing means like Visio stencil imports)\n * are represented by a CustomBlockProxy.\n */\nclass CustomBlockProxy extends blockproxy_1.BlockProxy {\n    static registerCustomBlockClass(klass) {\n        let byLibrary = CustomBlockProxy.subclassRegistry.get(klass.library);\n        if (!byLibrary) {\n            byLibrary = new Map();\n            CustomBlockProxy.subclassRegistry.set(klass.library, byLibrary);\n        }\n        byLibrary.set(klass.shape, klass);\n    }\n    /**\n     * @ignore\n     */\n    static getCustomBlockClass(client, id) {\n        if (this.subclassRegistry.size > 0) {\n            const stencil = client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'id': id, 'p': 'Stencil' });\n            if ((0, checks_1.isObjectUnsafe)(stencil)) {\n                const sourceStencil = client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'p': 'Stencil-' + stencil['id'] });\n                if ((0, checks_1.isObjectUnsafe)(sourceStencil) && (0, checks_1.isObjectUnsafe)(sourceStencil['sourcePackage'])) {\n                    if (sourceStencil['sourcePackage']['packageId'] === lucid.getPackageId()) {\n                        const byLibrary = CustomBlockProxy.subclassRegistry.get(String(sourceStencil['sourcePackage']['library']));\n                        const klass = byLibrary === null || byLibrary === void 0 ? void 0 : byLibrary.get(String(sourceStencil['sourcePackage']['shape']));\n                        if (klass) {\n                            return klass;\n                        }\n                    }\n                }\n            }\n        }\n        return CustomBlockProxy;\n    }\n    isFromStencil(library, shape) {\n        const stencil = this.properties.get('Stencil');\n        if ((0, checks_1.isObjectUnsafe)(stencil)) {\n            const sourceStencil = this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'p': 'Stencil-' + stencil['id'] });\n            if ((0, checks_1.isObjectUnsafe)(sourceStencil) && (0, checks_1.isObjectUnsafe)(sourceStencil['sourcePackage'])) {\n                return (sourceStencil['sourcePackage']['packageId'] === lucid.getPackageId() &&\n                    sourceStencil['sourcePackage']['library'] === library &&\n                    sourceStencil['sourcePackage']['shape'] === shape);\n            }\n        }\n        return false;\n    }\n    getCustomShapeType() {\n        const stencil = this.properties.get('Stencil');\n        if ((0, checks_1.isObjectUnsafe)(stencil)) {\n            const sourceStencil = this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'p': 'Stencil-' + stencil['id'] });\n            if ((0, checks_1.isObjectUnsafe)(sourceStencil) && (0, checks_1.isObjectUnsafe)(sourceStencil['sourcePackage'])) {\n                return {\n                    packageId: sourceStencil['sourcePackage']['packageId'],\n                    library: sourceStencil['sourcePackage']['library'],\n                    shape: sourceStencil['sourcePackage']['shape'],\n                };\n            }\n        }\n        throw new Error('Custom shape has no source');\n    }\n    getStencilTextAreaName(stencilTextAreaName) {\n        return this.textAreas.keys().find((name) => name.endsWith('_' + stencilTextAreaName));\n    }\n}\nexports.CustomBlockProxy = CustomBlockProxy;\nCustomBlockProxy.classNameRegex = /^CustomBlock$/;\nCustomBlockProxy.subclassRegistry = new Map();\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ERDBlockProxy = exports.ERDFieldProxy = void 0;\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nclass ERDFieldProxy {\n    constructor(block, index) {\n        this.block = block;\n        this.index = index;\n    }\n    getName() {\n        return this.block.properties.get('Field' + this.index);\n    }\n    getType() {\n        var _a;\n        return (_a = this.block.properties.get('Type' + this.index)) !== null && _a !== void 0 ? _a : '';\n    }\n    getKey() {\n        var _a;\n        return (_a = this.block.properties.get('Key' + this.index)) !== null && _a !== void 0 ? _a : '';\n    }\n}\nexports.ERDFieldProxy = ERDFieldProxy;\nclass ERDBlockProxy extends blockproxy_1.BlockProxy {\n    getName() {\n        return this.properties.get('Name');\n    }\n    getFieldCount() {\n        return this.properties.get('Fields');\n    }\n    getFields() {\n        const fields = [];\n        const fieldCount = this.getFieldCount();\n        for (let i = 1; i <= fieldCount; i++) {\n            //These are 1-indexed in the property store\n            fields.push(new ERDFieldProxy(this, i));\n        }\n        return fields;\n    }\n}\nexports.ERDBlockProxy = ERDBlockProxy;\nERDBlockProxy.classNameRegex = /^ERDEntityBlock(2|3|4)?$/;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js":
/*!************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LegendBlockProxy = exports.ShapeLegendEntryProxy = exports.ColorLegendEntryProxy = exports.LegendEntryProxy = exports.LegendItemType = void 0;\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nvar LegendItemType;\n(function (LegendItemType) {\n    LegendItemType[\"Color\"] = \"color\";\n    LegendItemType[\"Shape\"] = \"shape\";\n})(LegendItemType || (exports.LegendItemType = LegendItemType = {}));\nclass LegendEntryProxy {\n    constructor(legend, index, type) {\n        this.legend = legend;\n        this.index = index;\n        this.type = type;\n    }\n    getText() {\n        return this.legend.textAreas.get('LegendText_' + this.index);\n    }\n    setText(text) {\n        this.legend.textAreas.set('LegendText_' + this.index, text);\n    }\n}\nexports.LegendEntryProxy = LegendEntryProxy;\nclass ColorLegendEntryProxy extends LegendEntryProxy {\n    constructor(legend, index) {\n        super(legend, index, LegendItemType.Color);\n    }\n    getColor() {\n        return this.legend.properties.get('LegendItem_' + this.index)['Value'];\n    }\n}\nexports.ColorLegendEntryProxy = ColorLegendEntryProxy;\nclass ShapeLegendEntryProxy extends LegendEntryProxy {\n    constructor(legend, index) {\n        super(legend, index, LegendItemType.Shape);\n    }\n}\nexports.ShapeLegendEntryProxy = ShapeLegendEntryProxy;\nclass LegendBlockProxy extends blockproxy_1.BlockProxy {\n    getHeader() {\n        return this.textAreas.get('t_header');\n    }\n    getItems() {\n        const itemOrder = this.properties.get('ItemOrder');\n        return itemOrder.map((index) => {\n            const settings = this.properties.get('LegendItem_' + index);\n            switch (settings['Type']) {\n                case LegendItemType.Color:\n                    return new ColorLegendEntryProxy(this, index);\n                case LegendItemType.Shape:\n                    return new ShapeLegendEntryProxy(this, index);\n                default:\n                    return new LegendEntryProxy(this, index, settings['Type']);\n            }\n        });\n    }\n}\nexports.LegendBlockProxy = LegendBlockProxy;\nLegendBlockProxy.classNameRegex = /^LegendBlockV2$/;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExperimentalLinkUnfurlBlockProxy = exports.LinkUnfurlBlockProxy = void 0;\nconst iframeutils_1 = __webpack_require__(/*! ../../core/iframe/iframeutils */ \"./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js\");\nconst unfurliframe_1 = __webpack_require__(/*! ../../core/unfurl/unfurliframe */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\n/**\n * This is the kind of block that appears when a link is pasted onto the canvas of a Lucid editor.\n */\nclass LinkUnfurlBlockProxy extends blockproxy_1.BlockProxy {\n    /**\n     * Returns the title on the block, which is the main text shown on the block.\n     */\n    getTitle() {\n        return this.textAreas.get('t_LinkUnfurlTitle');\n    }\n    /**\n     * Sets the title on the block, which is the main text shown on the block.\n     */\n    setTitle(title) {\n        this.textAreas.set('t_LinkUnfurlTitle', title, { force: true });\n    }\n    /**\n     * Returns the description on the block.\n     */\n    getDescription() {\n        return this.textAreas.get('t_LinkUnfurlDescription');\n    }\n    /**\n     * Sets the description on the block.\n     */\n    setDescription(description) {\n        this.textAreas.set('t_LinkUnfurlDescription', description, { force: true });\n    }\n    /**\n     * Returns the name of the service the link belongs to, such as \"Lucid\" or \"Google\", as displayed below the title on\n     * the block.\n     */\n    getProviderName() {\n        return this.textAreas.get('t_LinkUnfurlProviderName');\n    }\n    /**\n     * Gets the URL the user will be redirected to when the user clicks the \"Pop Out\" action on the block.\n     */\n    getUrl() {\n        return this.properties.get('LinkUnfurlUrl');\n    }\n    /**\n     * Sets the URL the user will be redirected to when the user clicks the \"Pop Out\" action on the block.\n     */\n    setUrl(url) {\n        this.properties.set('LinkUnfurlUrl', url);\n    }\n    /**\n     * Sets the URL to be loaded in an iframe when the user clicks the \"Expand\" action on the block.\n     */\n    setIframe(unfurlIframe) {\n        const iframeAttributes = (0, unfurliframe_1.generateIframeAttributes)(unfurlIframe);\n        this.properties.set('LinkUnfurlIframeHtml', (0, iframeutils_1.generateIFrameHTML)(iframeAttributes));\n        this.properties.set('LinkUnfurlIframeHeight', iframeAttributes.height);\n        this.properties.set('LinkUnfurlIframeWidth', iframeAttributes.width);\n    }\n    /**\n     * Clears the iframe set on the block. The \"Expand\" action will default to the block's thumbnail image.\n     */\n    clearIframe() {\n        this.properties.set('LinkUnfurlIframeHtml', undefined);\n        this.properties.set('LinkUnfurlIframeHeight', undefined);\n        this.properties.set('LinkUnfurlIframeWidth', undefined);\n    }\n    /**\n     * Returns true if there is an iframe URL already set for this unfurl block\n     */\n    hasIframe() {\n        return !!this.properties.get('LinkUnfurlIframeHtml');\n    }\n    /**\n     * Sets the main thumbnail on the block\n     */\n    setPreviewThumbnailUrl(thumbnailUrl) {\n        this.properties.set('LinkUnfurlThumbnailUrl', thumbnailUrl);\n    }\n    /**\n     * Gets the main thumbnail on the block\n     */\n    getPreviewThumbnailUrl() {\n        return this.properties.get('LinkUnfurlThumbnailUrl');\n    }\n    /**\n     * Sets additional thumbnails on the block\n     */\n    setThumbnailUrls(thumbnails) {\n        this.properties.set('LinkUnfurlThumbnailUrls', thumbnails);\n    }\n    /**\n     * Gets the url for the favicon on the block\n     */\n    getFaviconUrl() {\n        return this.properties.get('LinkUnfurlFaviconUrl');\n    }\n    /**\n     * Sets the favicon on the block\n     */\n    setFaviconUrl(faviconUrl) {\n        this.properties.set('LinkUnfurlFaviconUrl', faviconUrl);\n    }\n    /**\n     * @ignore\n     * Initiates the PDF upload for this block. The result includes an uploadUrl which you can use to upload the PDF.\n     * The PDF uploaded at that url will be assocaite with this block (and any copy of it) in the editor until it is refreshed.\n     */\n    async experimentalStartPDFUpload() {\n        const result = await this.client.sendCommand(\"pdf\" /* CommandName.StartPDFUploadRequest */, this.id);\n        return result;\n    }\n}\nexports.LinkUnfurlBlockProxy = LinkUnfurlBlockProxy;\nLinkUnfurlBlockProxy.classNameRegex = /^LinkUnfurlBlock$/;\n/**\n * @ignore\n * @deprecated Use LinkUnfurlBlockProxy instead.\n */\nexports.ExperimentalLinkUnfurlBlockProxy = LinkUnfurlBlockProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SwimLaneBlockProxy = exports.SwimLanePrimaryLaneProxy = void 0;\nconst fillcolor_1 = __webpack_require__(/*! ../../core/properties/fillcolor */ \"./node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nclass SwimLanePrimaryLaneProxy {\n    constructor(swimlane, index) {\n        this.swimlane = swimlane;\n        this.index = index;\n    }\n    /**\n     * For horizontal lanes, the lane height.\n     * For vertical lanes, the lane width.\n     */\n    getSize() {\n        return this.swimlane.getPrimaryLaneSizes()[this.index];\n    }\n    getBoundingBox() {\n        const bb = this.swimlane.getBoundingBox();\n        const sizes = this.swimlane.getPrimaryLaneSizes();\n        if (this.swimlane.getPrimaryLanesVertical()) {\n            return {\n                x: bb.x + sizes.slice(0, this.index).reduce((a, b) => a + b, 0),\n                y: bb.y,\n                w: sizes[this.index],\n                h: bb.h,\n            };\n        }\n        else {\n            return {\n                x: bb.x,\n                y: bb.y + sizes.slice(0, this.index).reduce((a, b) => a + b, 0),\n                w: bb.w,\n                h: sizes[this.index],\n            };\n        }\n    }\n    getTitleTextAreaId() {\n        const existing = this.swimlane.properties.get('PrimaryLaneTextAreaIds')[this.index];\n        if (existing) {\n            return existing;\n        }\n        this.swimlane.updateTextAreaNames();\n        return this.swimlane.properties.get('PrimaryLaneTextAreaIds')[this.index];\n    }\n    getTitle() {\n        return this.swimlane.textAreas.get(this.getTitleTextAreaId());\n    }\n    setTitle(title) {\n        return this.swimlane.textAreas.set(this.getTitleTextAreaId(), title);\n    }\n    setFill(fill) {\n        this.swimlane.properties.set(`CellFill_0,${this.index}`, (0, fillcolor_1.serializeSimpleFill)(fill));\n    }\n}\nexports.SwimLanePrimaryLaneProxy = SwimLanePrimaryLaneProxy;\nclass SwimLaneBlockProxy extends blockproxy_1.BlockProxy {\n    getPrimaryLaneSizes() {\n        return this.properties.get('PrimaryLane');\n    }\n    setPrimaryLaneSizes(sizes) {\n        this.properties.set('PrimaryLane', sizes);\n        this.updateTextAreaNames();\n    }\n    getPrimaryLanes() {\n        return this.getPrimaryLaneSizes().map((size, index) => new SwimLanePrimaryLaneProxy(this, index));\n    }\n    getPrimaryLanesVertical() {\n        return this.properties.get('IsPrimaryLaneVertical');\n    }\n    getMagnetized() {\n        return this.properties.get('Magnetize');\n    }\n    setMagnetized(magnetize) {\n        this.properties.set('Magnetize', magnetize);\n    }\n    /** @ignore */\n    updateTextAreaNames() {\n        this.properties.set('PrimaryLaneTextAreaIds', this.getPrimaryLaneSizes().map((_, index) => 'Primary_' + index));\n    }\n    /**\n     * Swim lanes only use the normal BoundingBox property for location.\n     * For size, it uses the PrimaryLane and SecondaryLane properties.\n     */\n    setBoundingBox(bb) {\n        super.setBoundingBox(bb); //To get position correct\n        const minLaneSize = 40;\n        const oldBB = this.getBoundingBox();\n        const primarySizes = this.getPrimaryLaneSizes();\n        const secondarySizes = this.properties.get('SecondaryLane');\n        const adjustLanesByDelta = (lanes, delta, laneIndex = lanes.length - 1) => {\n            if (laneIndex >= 0 && laneIndex < lanes.length) {\n                lanes[laneIndex] += delta;\n                if (lanes[laneIndex] < minLaneSize) {\n                    const deltaLeft = minLaneSize - lanes[laneIndex];\n                    lanes[laneIndex] = minLaneSize;\n                    adjustLanesByDelta(lanes, deltaLeft, laneIndex - 1);\n                }\n            }\n        };\n        if (bb.w != oldBB.w) {\n            if (this.getPrimaryLanesVertical()) {\n                adjustLanesByDelta(primarySizes, bb.w - oldBB.w);\n                this.setPrimaryLaneSizes(primarySizes);\n            }\n            else {\n                adjustLanesByDelta(secondarySizes, bb.w - oldBB.w);\n                this.properties.set('SecondaryLane', secondarySizes);\n            }\n        }\n        if (bb.h != oldBB.h) {\n            if (this.getPrimaryLanesVertical()) {\n                adjustLanesByDelta(secondarySizes, bb.h - oldBB.h);\n                this.properties.set('SecondaryLane', secondarySizes);\n            }\n            else {\n                adjustLanesByDelta(primarySizes, bb.h - oldBB.h);\n                this.setPrimaryLaneSizes(primarySizes);\n            }\n        }\n    }\n}\nexports.SwimLaneBlockProxy = SwimLaneBlockProxy;\nSwimLaneBlockProxy.classNameRegex = /^AdvancedSwimLaneBlock$/;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TableBlockProxy = exports.TableColumnProxy = exports.TableRowProxy = exports.TableCellProxy = void 0;\nconst fillcolor_1 = __webpack_require__(/*! ../../core/properties/fillcolor */ \"./node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nclass TableCellProxy {\n    constructor(table, row, column) {\n        this.table = table;\n        this.row = row;\n        this.column = column;\n    }\n    getText() {\n        return this.table.textAreas.get(`Cell_${this.row},${this.column}`);\n    }\n    setText(text) {\n        return this.table.textAreas.set(`Cell_${this.row},${this.column}`, text);\n    }\n    getTextStyle() {\n        return this.table.textStyles.get(`Cell_${this.row},${this.column}`);\n    }\n    setTextStyle(style) {\n        this.table.textStyles.set(`Cell_${this.row},${this.column}`, style);\n    }\n    setFill(fill) {\n        this.table.properties.set(`CellFill_${this.row},${this.column}`, (0, fillcolor_1.serializeSimpleFill)(fill));\n    }\n    /**\n     * Cells in a table can be merged together with adjacent cells into one larger cell. In this case, the upper-\n     * left cell remains visible but is enlarged to cover additional cells, and the other cells are hidden.\n     *\n     * @returns the size of this cell, in how many cells horizontally and vertically have been merged into it.\n     * For most cells, this will be {w:1, h:1}, but if it has been merged with the cell to the right of it, it\n     * would be {w:2, h:1}.\n     */\n    getMergedCellSize() {\n        var _a;\n        return ((_a = this.table.properties.get(`CellSize_${this.row},${this.column}`)) !== null && _a !== void 0 ? _a : { w: 1, h: 1 });\n    }\n    /**\n    /**\n     * Cells in a table can be merged together with adjacent cells into one larger cell. In this case, the upper-\n     * left cell remains visible but is enlarged to cover additional cells, and the other cells are hidden.\n     *\n     * @param size the desired size of this cell, in how many cells horizontally and vertically are merged into it.\n     * This normally {w:1, h:1} for a normal cell, or {w:2, h:1} to merge a cell with the one to the right of it, etc.\n     */\n    setMergedCellSize(size) {\n        this.table.properties.set(`CellSize_${this.row},${this.column}`, size);\n    }\n    /**\n     * @returns the pixel width of the cell, including any cells it is merged with.\n     */\n    getWidth() {\n        return this.table\n            .getColumnWidths()\n            .slice(this.column, this.column + this.getMergedCellSize().w)\n            .reduce((a, b) => a + b, 0);\n    }\n    /**\n     * @returns the pixel height of the cell, including any cells it is merged with.\n     */\n    getHeight() {\n        return this.table\n            .getRowHeights()\n            .slice(this.row, this.row + this.getMergedCellSize().h)\n            .reduce((a, b) => a + b, 0);\n    }\n    getBoundingBox() {\n        const tableBB = this.table.getBoundingBox();\n        const x = tableBB.x +\n            this.table\n                .getColumnWidths()\n                .slice(0, this.column)\n                .reduce((a, b) => a + b, 0);\n        const y = tableBB.y +\n            this.table\n                .getRowHeights()\n                .slice(0, this.row)\n                .reduce((a, b) => a + b, 0);\n        return { x, y, w: this.getWidth(), h: this.getHeight() };\n    }\n}\nexports.TableCellProxy = TableCellProxy;\nclass TableRowProxy {\n    constructor(table, row) {\n        this.table = table;\n        this.row = row;\n    }\n    getCells() {\n        return this.table.getColumnWidths().map((_, index) => new TableCellProxy(this.table, this.row, index));\n    }\n    getHeight() {\n        var _a;\n        return (_a = this.table.getRowHeights()[this.row]) !== null && _a !== void 0 ? _a : 1;\n    }\n}\nexports.TableRowProxy = TableRowProxy;\nclass TableColumnProxy {\n    constructor(table, col) {\n        this.table = table;\n        this.col = col;\n    }\n    getCells() {\n        return this.table.getRowHeights().map((_, index) => new TableCellProxy(this.table, this.col, index));\n    }\n    getWidth() {\n        var _a;\n        return (_a = this.table.getColumnWidths()[this.col]) !== null && _a !== void 0 ? _a : 1;\n    }\n}\nexports.TableColumnProxy = TableColumnProxy;\nclass TableBlockProxy extends blockproxy_1.BlockProxy {\n    /**\n     *\n     * @param referenceCell The cell to add the new column before or after.\n     * @param before If true, the new column will be added before the reference cell, otherwise it will be added after.\n     * @returns The TableColumnProxy for the newly added column.\n     */\n    addColumn(referenceCell, before = false) {\n        const col = this.client.sendCommand(\"atc\" /* CommandName.AddTableColumn */, {\n            'id': this.id,\n            'r': referenceCell.row,\n            'c': referenceCell.column,\n            'b': before,\n        });\n        return new TableColumnProxy(this, col);\n    }\n    /**\n     *\n     * @param referenceCell The cell to add the new row before or after.\n     * @param before If true, the new row will be added before the reference cell, otherwise it will be added after.\n     * @returns The TableRowProxy for the newly added row.\n     */\n    addRow(referenceCell, before = false) {\n        const row = this.client.sendCommand(\"atr\" /* CommandName.AddTableRow */, {\n            'id': this.id,\n            'r': referenceCell.row,\n            'c': referenceCell.column,\n            'b': before,\n        });\n        return new TableRowProxy(this, row);\n    }\n    /**\n     * @param column The index of the column to delete.\n     */\n    deleteColumn(column) {\n        return this.client.sendCommand(\"dtc\" /* CommandName.DeleteTableColumn */, { 'id': this.id, 'i': column });\n    }\n    /**\n     * @param row The index of the row to delete.\n     */\n    deleteRow(row) {\n        return this.client.sendCommand(\"dtr\" /* CommandName.DeleteTableRow */, { 'id': this.id, 'i': row });\n    }\n    /**\n     * @param textAreaKey The text area key of a cell in the table\n     * @returns The TableCellProxy represented by the text area key, or undefined if the text area key does not exist in the table.\n     */\n    getCellByTextAreaKey(textAreaKey) {\n        const value = textAreaKey.match(/(\\d+)/g);\n        if (value && value.length === 2) {\n            const row = +value[0];\n            const column = +value[1];\n            return new TableCellProxy(this, row, column);\n        }\n        return undefined;\n    }\n    getRowCount() {\n        return this.getRowHeights().length;\n    }\n    getColumnCount() {\n        return this.getColumnWidths().length;\n    }\n    getRows() {\n        return this.getRowHeights().map((_, index) => new TableRowProxy(this, index));\n    }\n    getRowHeights() {\n        return this.properties.get('RowHeights');\n    }\n    getColumnWidths() {\n        return this.properties.get('ColWidths');\n    }\n    setColumnWidths(widths) {\n        this.properties.set('ColWidths', widths);\n    }\n    setRowHeights(heights) {\n        this.properties.set('RowHeights', heights);\n    }\n    getAutoResizeColumns() {\n        return this.properties.get('AutoColWidth');\n    }\n    getAutoResizeRows() {\n        return this.properties.get('AutoRowHeight');\n    }\n    setAutoResizeColumns(auto) {\n        this.properties.set('AutoColWidth', auto);\n    }\n    setAutoResizeRows(auto) {\n        this.properties.set('AutoRowHeight', auto);\n    }\n    /**\n     * @param margin The inset margin to be used, it control the margin for each table cell.\n     */\n    setInsetMargin(margin) {\n        this.properties.set('InsetMargin', margin);\n    }\n}\nexports.TableBlockProxy = TableBlockProxy;\nTableBlockProxy.classNameRegex = /^DefaultTableBlock$/;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockdefinition.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockdefinition.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/blockdefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockproxy.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockproxy.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlockProxy = void 0;\nconst badgeposition_1 = __webpack_require__(/*! ../core/properties/datagraphic/badgeposition */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nconst staticdatagraphicsettings_1 = __webpack_require__(/*! ../core/properties/datagraphic/staticdatagraphicsettings */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js\");\nconst fillcolor_1 = __webpack_require__(/*! ../core/properties/fillcolor */ \"./node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst shadow_1 = __webpack_require__(/*! ../core/properties/shadow */ \"./node_modules/lucid-extension-sdk/core/properties/shadow.js\");\nconst math_1 = __webpack_require__(/*! ../math */ \"./node_modules/lucid-extension-sdk/math.js\");\nconst itemproxy_1 = __webpack_require__(/*! ./itemproxy */ \"./node_modules/lucid-extension-sdk/document/itemproxy.js\");\n/**\n * A block is a single shape on the document. A BlockProxy provides an interface to\n * read and write the content of an existing block, and is typically accessed through\n * [PageProxy.blocks](#classes_document_pageproxy-PageProxy_blocks) or another\n * similar mechanism.\n */\nclass BlockProxy extends itemproxy_1.ItemProxy {\n    /**\n     * @returns The class name of this block. This name is not necessarily human-readable,\n     * and will remain consistent over time, e.g. \"ProcessBlock\"..\n     */\n    getClassName() {\n        return this.properties.get('ClassName');\n    }\n    /**\n     * @returns The amount this block is rotated around its own center, in radians.\n     */\n    getRotation() {\n        return this.properties.get('Rotation');\n    }\n    /**\n     * @returns An axis-aligned bounding box containing this full item after any rotation it might have\n     */\n    getRotatedBoundingBox() {\n        return (0, math_1.rotatedBoundingBox)(this.getBoundingBox(), this.getRotation());\n    }\n    /**\n     * @param radians Angle the block should be rotated\n     */\n    setRotation(radians) {\n        this.properties.set('Rotation', radians);\n    }\n    /**\n     * @returns The current drop shadow on this block, or undefined if no shadow is set\n     */\n    getShadow() {\n        const raw = this.properties.get('Shadow');\n        if (!raw) {\n            return undefined;\n        }\n        return (0, shadow_1.deserializeShadow)(raw);\n    }\n    /**\n     * @param shadow The drop shadow to set on the block, or undefined to clear the drop shadow\n     */\n    setShadow(shadow) {\n        if (shadow) {\n            this.properties.set('Shadow', (0, shadow_1.serializeShadow)(shadow));\n        }\n        else {\n            this.properties.set('Shadow', null);\n        }\n    }\n    /**\n     * Set the fill style used (by most kinds of blocks) to fill in their main opaque areas.\n     * This can be a string color (e.g. `'#ff00ff80'`) or an image fill.\n     */\n    setFillStyle(fillStyle) {\n        this.properties.set('FillColor', (0, fillcolor_1.serializeSimpleFill)(fillStyle));\n    }\n    /**\n     * @returns An array of lines that have one or both endpoints connected to this block.\n     */\n    getConnectedLines() {\n        const ids = this.client.sendCommand(\"gcl\" /* CommandName.GetConnectedLines */, this.id);\n        return ids.map((id) => this.client.getLineProxy(id));\n    }\n    /**\n     * @param settings Information about the static data graphic icon to set on this block.\n     */\n    setSimpleStaticDataGraphic(settings) {\n        if (settings) {\n            this.properties.set('StaticDataGraphic', (0, staticdatagraphicsettings_1.serializeSimpleStaticDataGraphicSettings)(settings));\n        }\n        else {\n            this.properties.set('StaticDataGraphic', undefined);\n        }\n    }\n    /**\n     * @returns Settings for the simple static data graphic currently set on this block, or undefined\n     * if no simple data graphic is currently set. Note that if a data graphic exists that is not an\n     * icon, this will return undefined. This function will not consider data graphics set via\n     * conditional formatting rules.\n     */\n    getSimpleStaticDataGraphic() {\n        const settings = this.properties.get('StaticDataGraphic');\n        if ((0, staticdatagraphicsettings_1.isSerializedSimpleStaticDataGraphicSettings)(settings)) {\n            return (0, staticdatagraphicsettings_1.deserializeSimpleStaticDataGraphicSettings)(settings);\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Lock this block's aspect ratio to its current value.\n     * This can be reversed with unlockAspectRatio.\n     */\n    lockAspectRatio() {\n        const bb = this.getBoundingBox();\n        this.properties.set('AspectRatio', bb.w / bb.h);\n    }\n    /**\n     * Unlock the aspect ratio of this block, allowing it to be stretched vertically or horizontally independently.\n     */\n    unlockAspectRatio() {\n        this.properties.set('AspectRatio', undefined);\n    }\n    /**\n     * @returns The line width used by most kinds of blocks to render their outline.\n     */\n    getLineWidth() {\n        return this.properties.get('LineWidth');\n    }\n    /**\n     * @param width The line width to be used (by most kinds of blocks) to render this block's outline\n     */\n    setLineWidth(width) {\n        this.properties.set('LineWidth', width);\n    }\n    /**\n     * Link a text area to a data field, so that editing the text area will also update the\n     * associated data, and vice versa.\n     *\n     * To use this, first establish a reference key on this block with\n     * [setReferenceKey](/extension-sdk/#classes_document_blockproxy-BlockProxy_setreferencekey).\n     *\n     * @param textAreaKey\n     * @param referenceKey\n     * @param field\n     */\n    linkText(textAreaKey, referenceKey, field) {\n        if (!this.textAreas.keys().includes(textAreaKey)) {\n            throw new Error('Invalid text area key');\n        }\n        if (!this.referenceKeys.keys().includes(referenceKey)) {\n            throw new Error('Invalid reference key');\n        }\n        this.properties.set(textAreaKey + '_Link', {\n            'ref': referenceKey,\n            'f': field,\n        });\n    }\n    /**\n     * @param position The postion where the data sync state icon should be displayed on the block. If this position is\n     * set to undefined then the state icon position will fallback to the default position for the block.\n     */\n    setDataSyncStateIconPosition(position) {\n        this.properties.set('DataSyncStateIconPosition', position ? (0, badgeposition_1.serializeBadgeEnumPosition)(position) : null);\n    }\n}\nexports.BlockProxy = BlockProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/blockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CardConfigProxy = void 0;\nconst documentelementproxy_1 = __webpack_require__(/*! ./documentelementproxy */ \"./node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js\");\nclass CardConfigProxy extends documentelementproxy_1.DocumentElementProxy {\n    /**\n     * @param id The ID of this card config element\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n    }\n}\nexports.CardConfigProxy = CardConfigProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentElementProxy = void 0;\nconst propertystoreproxy_1 = __webpack_require__(/*! ../propertystoreproxy */ \"./node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nclass DocumentElementProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     * @param id The ID of this document element\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n    }\n}\nexports.DocumentElementProxy = DocumentElementProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentElementType = void 0;\n/**\n * An enumeration of document element types. A Document element represents a collection of data that is stored on a document.\n */\nvar DocumentElementType;\n(function (DocumentElementType) {\n    DocumentElementType[\"DataTransformation\"] = \"DerivedStructure\";\n    DocumentElementType[\"Path\"] = \"Path\";\n    DocumentElementType[\"Tag\"] = \"Tag\";\n    DocumentElementType[\"CommentThreadMetadata\"] = \"ThreadMetadata\";\n    DocumentElementType[\"FontStylePreset\"] = \"FontStylePreset\";\n    DocumentElementType[\"IntraDocumentMutex\"] = \"Mutex\";\n    DocumentElementType[\"Rule\"] = \"Rule\";\n    DocumentElementType[\"DocumentFormula\"] = \"Formula\";\n    DocumentElementType[\"TaskCardFieldsConfig\"] = \"TaskCardFieldsConfig\";\n    DocumentElementType[\"CachedExtensionMetadata\"] = \"CachedExtensionMetadata\";\n    DocumentElementType[\"GeneratorView\"] = \"GeneratorView\";\n    DocumentElementType[\"OutputField\"] = \"OutputField\";\n    DocumentElementType[\"ShapeStylePreset\"] = \"ShapeStylePreset\";\n    DocumentElementType[\"ShapeSpecificDefaultProperties\"] = \"ShapeSpecificDefaultProperties\";\n    DocumentElementType[\"TrackedFormulaLocation\"] = \"TrackedFormulaLocation\";\n    DocumentElementType[\"ElementAlias\"] = \"ElementAlias\";\n})(DocumentElementType || (exports.DocumentElementType = DocumentElementType = {}));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js":
/*!********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RuleProxy = exports.RuleEffect = exports.RuleCondition = void 0;\nconst badgeposition_1 = __webpack_require__(/*! ../../core/properties/datagraphic/badgeposition */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nconst mapproxy_1 = __webpack_require__(/*! ../mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst ruledefinition_1 = __webpack_require__(/*! ../ruledefinition */ \"./node_modules/lucid-extension-sdk/document/ruledefinition.js\");\nconst documentelementproxy_1 = __webpack_require__(/*! ./documentelementproxy */ \"./node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js\");\nclass RuleCondition {\n    constructor(rule, client, key) {\n        this.rule = rule;\n        this.client = client;\n        this.key = key;\n        this.definition = this.rule.properties.get(this.key);\n        /** What kind of condition is this? e.g. a formula evaluation, checking for non-empty text, etc. */\n        this.type = this.definition['Type'];\n        /**\n         * If this.type == ConditionType.Text, this is a TextConditions.\n         * If this.type == ConditionType.ShapeData, this is a ShapeDataConditions.\n         * If this.type == ConditionType.ShapeType, this is a ShapeTypeConditions.\n         * If this.type == ConditionType.ConnectedShapes, this is a ConnectedShapesConditions.\n         */\n        this.condition = this.definition['Condition'];\n        /**\n         * For formula conditions, the formula string.\n         *\n         * For other conditions,the value against which the condition is tested. For example, a condition with\n         *  type = ConditionType.ShapeData\n         *  condition = ShapeDataConditions.GreaterThan\n         *  field = 'TheField'\n         *  value = 14\n         *\n         * will trigger when the shape data field \"TheField\" has a value that is greater than 14.\n         */\n        this.value = this.definition['Value'];\n        /** For shape data conditions, the name of the shape data field to test */\n        this.field = this.definition['Label'];\n        /** For shape data conditions, the name to display to the end user to identify the field name */\n        this.fieldLabel = this.definition['DisplayLabel'];\n    }\n    /** Update this condition to reflect a new definition */\n    update(definition) {\n        this.rule.properties.set(this.key, (0, ruledefinition_1.serializeConditionDefinition)(definition));\n        this.definition = this.rule.properties.get(this.key);\n    }\n}\nexports.RuleCondition = RuleCondition;\nclass RuleEffect {\n    constructor(rule, client, key) {\n        this.rule = rule;\n        this.client = client;\n        this.key = key;\n        this.definition = this.rule.properties.get(this.key);\n        this.conditions = new mapproxy_1.MapProxy(() => this.definition['ConditionOrder'].map((order) => 'Condition_' + order), (key) => new RuleCondition(this.rule, this.client, key));\n        /** How multiple conditions are combined (AND vs OR) */\n        this.combination = this.definition['Combination'];\n        /** What kind of effect is displayed? Formatting vs. icons vs. dynamic stencil, etc. */\n        this.formatType = this.definition['FormatType'];\n        /** For formatType = RuleFormattingType.FORMATTING, what styles are applied to blocks, lines, and pages? */\n        this.formatting = this.definition['Formatting'];\n        /** For formatType = RuleFormattingType.DATA_GRAPHICS, a description of which icon appears and where */\n        this.dataGraphic = this.definition['DataGraphic'] && {\n            set: this.definition['DataGraphic']['Set'],\n            index: this.definition['DataGraphic']['Index'],\n            position: (0, badgeposition_1.deserializeBadgeEnumPosition)(this.definition['DataGraphic']['Position']),\n            color: this.definition['DataGraphic']['Color'],\n            image: this.definition['DataGraphic']['Image'] && {\n                url: this.definition['DataGraphic']['Image']['url'],\n                w: this.definition['DataGraphic']['Image']['w'],\n                h: this.definition['DataGraphic']['Image']['h'],\n            },\n        };\n    }\n    /** Update this effect to reflect a new definition */\n    update(definition) {\n        //Find the maximum used condition index in the entire rule, in case we need to add more.\n        let nextConditionIndex = 1;\n        for (const effect of this.rule.effects.values()) {\n            nextConditionIndex = Math.max(nextConditionIndex, ...effect.definition.ConditionOrder.map((index) => index + 1));\n        }\n        const conditionIndexes = this.definition.ConditionOrder;\n        definition.conditions.forEach((condition, index) => {\n            let conditionIndex = conditionIndexes[index];\n            if (conditionIndex === undefined) {\n                //Added a new condition\n                conditionIndex = nextConditionIndex;\n                conditionIndexes.push(nextConditionIndex++);\n            }\n            const conditionKey = 'Condition_' + conditionIndex;\n            this.rule.properties.set(conditionKey, (0, ruledefinition_1.serializeConditionDefinition)(condition));\n        });\n        this.rule.properties.set(this.key, (0, ruledefinition_1.serializeEffectDefinition)(definition, conditionIndexes.slice(0, definition.conditions.length)));\n    }\n}\nexports.RuleEffect = RuleEffect;\nclass RuleProxy extends documentelementproxy_1.DocumentElementProxy {\n    /**\n     * @param id The ID of this conditional formatting rule\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        this.effects = new mapproxy_1.MapProxy(() => this.properties.get('EffectOrder').map((order) => 'Effect_' + order), (key) => new RuleEffect(this, this.client, key));\n    }\n    getName() {\n        return this.properties.get('Name');\n    }\n    setName(name) {\n        this.properties.set('Name', name);\n    }\n    getOrder() {\n        return this.properties.get('Order');\n    }\n    /**\n     * Delete this conditional formatting rule from the document\n     */\n    delete() {\n        this.client.sendCommand(\"dde\" /* CommandName.DeleteDocumentElement */, this.id);\n    }\n    /** @ignore */\n    static getRuleProperties(definition) {\n        const properties = {\n            'EffectOrder': definition.effects.map((effect, index) => index + 1),\n            'SourceType': 0,\n            'Name': definition.name,\n        };\n        let nextConditionIndex = 1;\n        let nextEffectIndex = 1;\n        for (const effect of definition.effects) {\n            const effectKey = 'Effect_' + nextEffectIndex++;\n            const conditionOrder = [];\n            for (const condition of effect.conditions) {\n                conditionOrder.push(nextConditionIndex);\n                const conditionKey = 'Condition_' + nextConditionIndex++;\n                properties[conditionKey] = (0, ruledefinition_1.serializeConditionDefinition)(condition);\n            }\n            properties[effectKey] = (0, ruledefinition_1.serializeEffectDefinition)(effect, conditionOrder);\n        }\n        return properties;\n    }\n    /** Update this rule to reflect a new definition */\n    update(definition) {\n        const properties = RuleProxy.getRuleProperties(definition);\n        for (const key in properties) {\n            this.properties.set(key, properties[key]);\n        }\n    }\n}\nexports.RuleProxy = RuleProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/documentproxy.js":
/*!********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/documentproxy.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentProxy = void 0;\nconst cardconfigproxy_1 = __webpack_require__(/*! ./documentelement/cardconfigproxy */ \"./node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js\");\nconst documentelementtype_1 = __webpack_require__(/*! ./documentelement/documentelementtype */ \"./node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js\");\nconst ruleproxy_1 = __webpack_require__(/*! ./documentelement/ruleproxy */ \"./node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./elementproxy */ \"./node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst itemproxy_1 = __webpack_require__(/*! ./itemproxy */ \"./node_modules/lucid-extension-sdk/document/itemproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst pageproxy_1 = __webpack_require__(/*! ./pageproxy */ \"./node_modules/lucid-extension-sdk/document/pageproxy.js\");\n/**\n * The currently-open Lucid document\n */\nclass DocumentProxy extends elementproxy_1.ElementProxy {\n    static getNextHookName() {\n        return '__documentproxy__hook' + DocumentProxy.nextHookId++;\n    }\n    constructor(client) {\n        super(client.sendCommand(\"gdid\" /* CommandName.GetDocumentId */, undefined), client);\n        /**\n         * The set of pages on this document, organized by ID\n         */\n        this.pages = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lp\" /* CommandName.ListPages */, undefined), (pageId) => new pageproxy_1.PageProxy(pageId, this.client));\n        this.cardIntegrationConfigs = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lde\" /* CommandName.ListDocumentElements */, { 't': documentelementtype_1.DocumentElementType.TaskCardFieldsConfig }), (id) => new cardconfigproxy_1.CardConfigProxy(id, this.client));\n        this.rules = new mapproxy_1.MapProxy(() => this.client\n            .sendCommand(\"lde\" /* CommandName.ListDocumentElements */, { 't': documentelementtype_1.DocumentElementType.Rule })\n            //Filter down to only the rules with source User (i.e. ones visible in the UI, not ones created internally by the app)\n            .filter((id) => this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'id': id, 'p': 'SourceType' }) === 0), (id) => new ruleproxy_1.RuleProxy(id, this.client));\n    }\n    /**\n     * An iterator over all blocks on all pages of the document\n     */\n    *allBlocks() {\n        for (const page of this.pages.values()) {\n            for (const block of page.blocks.values()) {\n                yield block;\n            }\n        }\n    }\n    /**\n     * An iterator over all lines on all pages of the document\n     */\n    *allLines() {\n        for (const page of this.pages.values()) {\n            for (const line of page.lines.values()) {\n                yield line;\n            }\n        }\n    }\n    /**\n     * Add a new page to the current document\n     * @param def Definition of the page to add\n     * @returns The created page\n     */\n    addPage(def) {\n        const id = this.client.sendCommand(\"cp\" /* CommandName.CreatePage */, undefined);\n        const page = new pageproxy_1.PageProxy(id, this.client);\n        page.setTitle(def.title);\n        return page;\n    }\n    /**\n     * Updates the title of this document\n     * @param title The new title for this document\n     */\n    setTitle(title) {\n        this.properties.set('Title', title);\n    }\n    /**\n     * @returns The title of this document\n     */\n    getTitle() {\n        return this.properties.get('Title');\n    }\n    /** @ignore */\n    getDocumentChunks(types) {\n        const chunks = this.client.sendCommand(\"gdc\" /* CommandName.GetDocumentChunks */, { 't': types });\n        return chunks.map((chunk) => {\n            return {\n                boundingBox: chunk['bb'],\n                items: chunk['i']\n                    .map((id) => this.client.getElementProxy(id))\n                    .filter((element) => element instanceof itemproxy_1.ItemProxy),\n                text: chunk['t'],\n                description: chunk['d'],\n            };\n        });\n    }\n    /**\n     * Infrequently, you may need to watch for *any* changes to the document. These changes may be\n     * the local user adding content, or a data integration sending updated records to a data collection,\n     * or a remote user hitting undo, or any user entering or exiting an intra-document mutex.\n     *\n     * Because these changes may happen rapidly, the callback you provide here will only be called on\n     * a heavily-debounced schedule. The callback will happen between 1-10 seconds after changes are\n     * made to the document, depending on the frequency with which changes are happening.\n     * @param callback\n     * @returns A handle that can be passed into `unhookAllChanges`\n     */\n    hookAllChanges(callback) {\n        const actionName = DocumentProxy.getNextHookName();\n        this.client.registerAction(actionName, () => {\n            callback();\n        });\n        this.client.sendCommand(\"hac\" /* CommandName.HookAllChanges */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * @param handle Return value from `hookAllChanges`\n     */\n    unhookAllChanges(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"uac\" /* CommandName.UnhookAllChanges */, { 'n': handle });\n    }\n    /**\n     * Watch for new blocks, lines, or groups added to this document. The callback will\n     * be called with new items created by the current user, but will not be called with items\n     * created\n     *\n     *  - As part of a generated diagram, e.g. org chart\n     *  - By another user on the same document\n     *\n     * @param callback\n     * @returns A handle that can be passed to `unhookCreateItems`\n     */\n    hookCreateItems(callback) {\n        const actionName = DocumentProxy.getNextHookName();\n        this.client.registerAction(actionName, (msg) => {\n            callback(msg['ids'].map((id) => this.client.getItemProxy(id)));\n        });\n        this.client.sendCommand(\"hci\" /* CommandName.HookCreateItems */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * @param handle Return value from `hookCreateItems`\n     */\n    unhookCreateItems(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"uci\" /* CommandName.UnhookCreateItems */, { 'n': handle });\n    }\n    addRule(definition) {\n        let maxOrder = 0;\n        for (const rule of this.rules.values()) {\n            maxOrder = Math.max(maxOrder, rule.getOrder());\n        }\n        const id = this.client.sendCommand(\"cde\" /* CommandName.CreateDocumentElement */, {\n            't': documentelementtype_1.DocumentElementType.Rule,\n            'p': Object.assign(Object.assign({}, ruleproxy_1.RuleProxy.getRuleProperties(definition)), { 'Order': maxOrder + 1 }),\n        });\n        if (id === undefined) {\n            return undefined;\n        }\n        return new ruleproxy_1.RuleProxy(id, this.client);\n    }\n    /**\n     * Watch for new blocks, lines, or groups deleted from this document. The callback will\n     * be called with items deleted by the current user, but will not be called with items\n     * deleted\n     *\n     *  - As part of a generated diagram, e.g. org chart\n     *  - By another user on the same document\n     *\n     * @param callback\n     * @returns A handle that can be passed to `unhookDeleteItems`\n     */\n    hookDeleteItems(callback) {\n        const actionName = DocumentProxy.getNextHookName();\n        this.client.registerAction(actionName, (msg) => {\n            callback(msg['ids']);\n        });\n        this.client.sendCommand(\"hdi\" /* CommandName.HookDeleteItems */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * @param handle Return value from `hookDeleteItems`\n     */\n    unhookDeleteItems(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"udi\" /* CommandName.UnhookDeleteItems */, { 'n': handle });\n    }\n    async duplicateItems(ids) {\n        return await this.client.sendCommand(\"dis\" /* CommandName.DuplicateItems */, { 'ids': ids });\n    }\n}\nexports.DocumentProxy = DocumentProxy;\nDocumentProxy.nextHookId = 0;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/documentproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/elementproxy.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/elementproxy.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ElementProxy = void 0;\nconst referencekeydefinition_1 = __webpack_require__(/*! ../data/referencekeydefinition */ \"./node_modules/lucid-extension-sdk/data/referencekeydefinition.js\");\nconst referencekeyproxy_1 = __webpack_require__(/*! ../data/referencekeyproxy */ \"./node_modules/lucid-extension-sdk/data/referencekeyproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst propertystoreproxy_1 = __webpack_require__(/*! ./propertystoreproxy */ \"./node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nconst shapedataproxy_1 = __webpack_require__(/*! ./shapedataproxy */ \"./node_modules/lucid-extension-sdk/document/shapedataproxy.js\");\n/**\n * An element is anything on a Lucid document that can have properties and shape data:\n *  * [The document itself](#classes_document_documentproxy-DocumentProxy)\n *  * [Pages](#classes_document_pageproxy-PageProxy)\n *  * [Blocks](#classes_document_blockproxy-BlockProxy)\n *  * [Lines](#classes_document_lineproxy-LineProxy)\n *  * [Groups](#classes_document_groupproxy-GroupProxy)\n */\nclass ElementProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     * Set a reference key on this element, replacing any existing reference at the specified key.\n     *\n     * @param key\n     * @param settings\n     */\n    setReferenceKey(key, settings) {\n        this.client.sendCommand(\"srk\" /* CommandName.SetReferenceKey */, {\n            'id': this.id,\n            'k': key,\n            'v': (0, referencekeydefinition_1.serializeReferenceKeyDefinition)(settings),\n        });\n    }\n    /**\n     * Remove the specified reference key from this element.\n     * @param key\n     */\n    removeReferenceKey(key) {\n        this.client.sendCommand(\"srk\" /* CommandName.SetReferenceKey */, { 'id': this.id, 'k': key });\n    }\n    /**\n     *\n     * @param id ID of this element\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        /**\n         * The shape data set directly on this element (not including any shape data inherited from the page or a containing group).\n         */\n        this.shapeData = new shapedataproxy_1.ShapeDataProxy(this.id, this.client);\n        /**\n         * All shape data accessible on this element, including shape data inherited from the page or a containing group.\n         * This collection is read-only.\n         */\n        this.allShapeData = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lsd\" /* CommandName.ListShapeData */, { 'id': this.id, 'i': true }), (name) => shapedataproxy_1.ShapeDataProxy.parseData(this.client.sendCommand(\"gsd\" /* CommandName.GetShapeData */, {\n            'id': this.id,\n            'n': name,\n        })));\n        /**\n         * The set of reference keys, organized by their ID, which can be either a string or number.\n         *\n         * For more information, see the [Developer Guide](/extension-api#guide-reference-keys).\n         */\n        this.referenceKeys = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lrk\" /* CommandName.ListReferenceKeys */, { 'id': this.id }), (key) => new referencekeyproxy_1.ReferenceKeyProxy(this.id, key, this.client, this.client.sendCommand(\"grk\" /* CommandName.GetReferenceKey */, { 'id': this.id, 'k': key })));\n    }\n    /**\n     * @returns `true` if this element still exists on the document, or `false` otherwise\n     */\n    exists() {\n        return this.client.sendCommand(\"ee\" /* CommandName.ElementExists */, { 'id': this.id });\n    }\n    /**\n     * Execute a formula in the context of this element\n     * @param formula The formula text, e.g. \"@a + @b\" to add together the shape data values a and b.\n     * @returns The result of the formula, or an error.\n     */\n    executeFormula(formula) {\n        return shapedataproxy_1.ShapeDataProxy.parseData(this.client.sendCommand(\"ef\" /* CommandName.ExecuteFormula */, { 'id': this.id || '', 'f': formula }));\n    }\n}\nexports.ElementProxy = ElementProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/elementproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/groupproxy.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/groupproxy.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GroupProxy = void 0;\nconst itemproxy_1 = __webpack_require__(/*! ./itemproxy */ \"./node_modules/lucid-extension-sdk/document/itemproxy.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./lineproxy */ \"./node_modules/lucid-extension-sdk/document/lineproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * A group of items on a page.\n */\nclass GroupProxy extends itemproxy_1.ItemProxy {\n    constructor() {\n        super(...arguments);\n        /**\n         * The blocks that are directly contained in this group, organized by ID.\n         */\n        this.blocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { 'id': this.id }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines that are directly contained in this group, organized by ID.\n         */\n        this.lines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { 'id': this.id }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups that are directly contained in this group, organized by ID.\n         */\n        this.groups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { 'id': this.id }), (id) => new GroupProxy(id, this.client));\n        /**\n         * The blocks that are contained in this group, including those nested in deeper groups, organized by ID.\n         */\n        this.allBlocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { 'id': this.id, 'd': true }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines that are contained in this group, including those nested in deeper groups, organized by ID.\n         */\n        this.allLines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { 'id': this.id, 'd': true }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups that are contained in this group, including those nested in deeper groups, organized by ID.\n         */\n        this.allGroups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { 'id': this.id, 'd': true }), (id) => new GroupProxy(id, this.client));\n    }\n}\nexports.GroupProxy = GroupProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/groupproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/imagedefinition.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/imagedefinition.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.imageToBlockDefinition = void 0;\n/**\n * Turns an image definition into a block definition.\n */\nfunction imageToBlockDefinition(definition) {\n    return {\n        className: 'UserImage2Block',\n        boundingBox: definition.boundingBox,\n        fillStyle: definition.fillStyle,\n        properties: {\n            opactiy: definition.opacity,\n            lineColor: definition.lineColor,\n            lineWidth: definition.lineWidth,\n            strokeStyle: definition.strokeStyle,\n            rounding: definition.rounding,\n            rotation: definition.rotation,\n        },\n    };\n}\nexports.imageToBlockDefinition = imageToBlockDefinition;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/imagedefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/itemproxy.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/itemproxy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ItemProxy = void 0;\nconst offsettype_1 = __webpack_require__(/*! ../core/offsettype */ \"./node_modules/lucid-extension-sdk/core/offsettype.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./elementproxy */ \"./node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * A block, line, or group on a page of the current document.\n */\nclass ItemProxy extends elementproxy_1.ElementProxy {\n    /**\n     * @param id ID of this item\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The plain text in each of the text areas on this item, organized by text area name.\n         */\n        this.textAreas = new mapproxy_1.WriteableMapProxy(() => this.client.sendCommand(\"lta\" /* CommandName.ListTextAreas */, this.id), (name) => this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, {\n            'id': this.id,\n            'p': name,\n        }), (name, plainText, options) => this.client.sendCommand(\"st\" /* CommandName.SetText */, {\n            'id': this.id,\n            'n': name,\n            't': plainText,\n            'f': options === null || options === void 0 ? void 0 : options.force,\n        }));\n        /**\n         * The text style in each of the text areas on this item, organized by text area name.\n         */\n        this.textStyles = new mapproxy_1.WriteableMapProxy(() => this.textAreas.keys(), (name) => this.client.sendCommand(\"gts\" /* CommandName.GetTextStyle */, {\n            'id': this.id,\n            'n': name,\n        }), (name, style) => this.client.sendCommand(\"sts\" /* CommandName.SetTextStyle */, {\n            'id': this.id,\n            'n': name,\n            's': style,\n        }));\n    }\n    /**\n     * @returns The bounding box of this item relative to its containing page. As pages may change size\n     * to fit the content on them, note that these coordinates may be negative or very large.\n     *\n     * If this is a rotated block, the bounding box returned here is where the block would be if it were\n     * unrotated.\n     */\n    getBoundingBox() {\n        return this.properties.get('BoundingBox');\n    }\n    /**\n     * Attempts to move and resize this item to fit into the given bounding box. If this item (or another\n     * item it contains) has size or aspect ratio restrictions, it may not be possible to fit the requested\n     * location exactly.\n     *\n     * This is done by moving this item to the requested location, then attempting to resize it from the\n     * bottom-right corner to the requested size.\n     *\n     * @param bb The bounding box to attempt to make this item fill\n     */\n    setBoundingBox(bb) {\n        const current = this.getBoundingBox();\n        if (current.x !== bb.x || current.y !== bb.y) {\n            this.offset(offsettype_1.OffsetType.MOVE, { x: bb.x - current.x, y: bb.y - current.y });\n        }\n        if (current.w !== bb.w || current.h !== bb.h) {\n            this.offset(offsettype_1.OffsetType.SE, {\n                x: bb.w - current.w,\n                y: bb.h - current.h,\n            });\n        }\n    }\n    /**\n     * @returns The ID of the page containing this item\n     */\n    getPageId() {\n        return this.client.sendCommand(\"gip\" /* CommandName.GetItemPageId */, this.id);\n    }\n    /**\n     * @returns The page containing this item\n     */\n    getPage() {\n        return this.client.getPageProxy(this.getPageId());\n    }\n    /**\n     * @returns The x/y location of this item\n     */\n    getLocation() {\n        const bb = this.getBoundingBox();\n        return { x: bb.x, y: bb.y };\n    }\n    /**\n     * Moves this item so that its upper-left corner is positioned at the given location (prior to any rotation)\n     * @param location The target location\n     */\n    setLocation(location) {\n        const current = this.getBoundingBox();\n        if (current.x !== location.x || current.y !== location.y) {\n            this.offset(offsettype_1.OffsetType.MOVE, { x: location.x - current.x, y: location.y - current.y });\n        }\n    }\n    /**\n     * Offset this item in the given direction by the given amount.\n     * @param type The type of offset to apply to this item\n     * @param offset The amount to offset\n     */\n    offset(type, offset) {\n        this.client.sendCommand(\"oi\" /* CommandName.OffsetItems */, { 'ids': [this.id], 't': type, 'o': offset });\n    }\n    /**\n     * Measure the amount of space necessary to render the text in the given text area, given a\n     * width to measure that text within.\n     * @param name Name of the text area whose content we should measure\n     * @param maxWidth Width of the area in which to measure this text. The result will usually be no wider than this, but if a single word is long enough to go beyond this maxWidth, the width of that word will be returned.\n     * @returns The size of rectangle necessary to render this text area's content.\n     */\n    measureText(name, maxWidth) {\n        return this.client.sendCommand(\"mt\" /* CommandName.MeasureText */, { 'id': this.id, 'n': name, 'w': maxWidth });\n    }\n    /**\n     * Delete this item from the document\n     */\n    delete() {\n        this.client.sendCommand(\"di\" /* CommandName.DeleteItem */, this.id);\n    }\n    /**\n     * @returns An array of blocks whose bounding boxes contain this item's upper-left corner\n     */\n    getContainers() {\n        const containers = this.executeFormula('LABEL(CONTAINEDBY)');\n        return containers.map((id) => this.client.getBlockProxy(id));\n    }\n    /**\n     * @param operation How to adjust the Z order of this item relative to the other items it overlaps on the page\n     */\n    changeZOrder(operation) {\n        this.client.sendCommand(\"z\" /* CommandName.ZOrder */, { 'i': [this.id], 'o': operation });\n    }\n    /**\n     * @param rule Rule to apply to this item\n     */\n    applyRule(rule) {\n        const ids = this.properties.get('RuleList');\n        if (!ids.includes(rule.id)) {\n            ids.push(rule.id);\n            this.properties.set('RuleList', ids);\n        }\n    }\n    /**\n     * @param rule Rule to remove from this item\n     */\n    unapplyRule(rule) {\n        const ids = this.properties.get('RuleList');\n        if (ids.includes(rule.id)) {\n            this.properties.set('RuleList', ids.filter((id) => id !== rule.id));\n        }\n    }\n}\nexports.ItemProxy = ItemProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/itemproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/linedefinition.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/linedefinition.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPositionEndpointDefinition = exports.isLineEndpointDefinition = exports.isBlockEndpointDefinition = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst blockproxy_1 = __webpack_require__(/*! ./blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./lineproxy */ \"./node_modules/lucid-extension-sdk/document/lineproxy.js\");\n/**\n * Checks if the endpoint is a BlockEndpointDefinition.\n */\nfunction isBlockEndpointDefinition(endpoint) {\n    return (0, validators_1.objectValidator)({\n        connection: (0, checks_1.isInstanceOf)(blockproxy_1.BlockProxy),\n        linkX: checks_1.isNumber,\n        linkY: checks_1.isNumber,\n        inside: (0, validators_1.option)(checks_1.isBoolean),\n        autoLink: (0, validators_1.option)(checks_1.isBoolean),\n        padding: (0, validators_1.option)(checks_1.isNumber),\n    })(endpoint);\n}\nexports.isBlockEndpointDefinition = isBlockEndpointDefinition;\n/**\n * Checks if the endpoint is a LineEndpointDefinition.\n */\nfunction isLineEndpointDefinition(endpoint) {\n    return (0, validators_1.objectValidator)({\n        connection: (0, checks_1.isInstanceOf)(lineproxy_1.LineProxy),\n        position: checks_1.isNumber,\n    })(endpoint);\n}\nexports.isLineEndpointDefinition = isLineEndpointDefinition;\n/**\n * Checks if the endpoint is a PositionEndpointDefinition.\n */\nfunction isPositionEndpointDefinition(endpoint) {\n    return (0, validators_1.objectValidator)({\n        x: checks_1.isNumber,\n        y: checks_1.isNumber,\n    })(endpoint);\n}\nexports.isPositionEndpointDefinition = isPositionEndpointDefinition;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/linedefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/lineproxy.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/lineproxy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LineProxy = exports.LineShape = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst blockproxy_1 = __webpack_require__(/*! ./blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nconst itemproxy_1 = __webpack_require__(/*! ./itemproxy */ \"./node_modules/lucid-extension-sdk/document/itemproxy.js\");\nconst linetextareapositioning_1 = __webpack_require__(/*! ./linetextareapositioning */ \"./node_modules/lucid-extension-sdk/document/linetextareapositioning.js\");\nvar LineShape;\n(function (LineShape) {\n    LineShape[\"Curve\"] = \"curve\";\n    LineShape[\"Elbow\"] = \"elbow\";\n    LineShape[\"Diagonal\"] = \"diagonal\";\n})(LineShape || (exports.LineShape = LineShape = {}));\n/**\n * A line on the current Lucid document\n */\nclass LineProxy extends itemproxy_1.ItemProxy {\n    getConnection(ep) {\n        let proxy;\n        if (ep['Block']) {\n            proxy = this.client.getBlockProxy(ep['Block']);\n        }\n        if (ep['Line']) {\n            proxy = this.client.getLineProxy(ep['Line']);\n        }\n        if (proxy && !proxy.exists()) {\n            return undefined;\n        }\n        return proxy;\n    }\n    isBlockEndpointDefinition(ep) {\n        return ep.connection instanceof blockproxy_1.BlockProxy;\n    }\n    isLineEndpointDefinition(ep) {\n        return ep.connection instanceof LineProxy;\n    }\n    parseLineEndpointDefinition(raw) {\n        const connection = this.getConnection(raw);\n        if (connection instanceof LineProxy) {\n            return {\n                connection,\n                style: raw['Style'],\n                position: raw['Position'],\n                x: raw['x'],\n                y: raw['y'],\n            };\n        }\n        else if (connection) {\n            return {\n                connection,\n                style: raw['Style'],\n                linkX: raw['LinkX'],\n                linkY: raw['LinkY'],\n                inside: raw['Inside'],\n                autoLink: raw['AutoLink'],\n                autoLinkMultiPort: raw['AutoLink'],\n                padding: raw['Padding'],\n                x: raw['x'],\n                y: raw['y'],\n            };\n        }\n        else {\n            return {\n                style: raw['Style'],\n                x: raw['x'],\n                y: raw['y'],\n            };\n        }\n    }\n    serializeLineEndpointDefinition(ep) {\n        if (this.isBlockEndpointDefinition(ep)) {\n            const bb = ep.connection.getBoundingBox();\n            return {\n                'Style': ep.style,\n                'x': bb.x + bb.w * ep.linkX,\n                'y': bb.y + bb.h * ep.linkY,\n                'Block': ep.connection.id,\n                'LinkX': ep.linkX,\n                'LinkY': ep.linkY,\n                'Inside': ep.inside,\n                'AutoLink': ep.autoLink,\n                'AutoLinkMultiPort': ep.autoLinkMultiPort,\n                'Padding': ep.padding,\n            };\n        }\n        else if (this.isLineEndpointDefinition(ep)) {\n            return Object.assign({ 'Style': ep.style, 'Line': ep.connection.id, 'LineP': ep.position }, ep.connection.getRelativePosition(ep.position));\n        }\n        else {\n            return {\n                'Style': ep.style,\n                'x': ep.x,\n                'y': ep.y,\n            };\n        }\n    }\n    /**\n     * @returns The definition of the first endpoint of this line\n     */\n    getEndpoint1() {\n        return this.parseLineEndpointDefinition(this.properties.get('Endpoint1'));\n    }\n    /**\n     * @returns The definition of the second endpoint of this line\n     */\n    getEndpoint2() {\n        return this.parseLineEndpointDefinition(this.properties.get('Endpoint2'));\n    }\n    /**\n     * Update the first endpoint of this line\n     * @param endpoint Line endpoint definition\n     */\n    setEndpoint1(endpoint) {\n        this.properties.set('Endpoint1', this.serializeLineEndpointDefinition(endpoint));\n    }\n    /**\n     * Update the second endpoint of this line\n     * @param endpoint Line endpoint definition\n     */\n    setEndpoint2(endpoint) {\n        this.properties.set('Endpoint2', this.serializeLineEndpointDefinition(endpoint));\n    }\n    /**\n     * @returns The block or line connected to the first endpoint of this line, or `undefined` if none\n     */\n    getUpstreamConnection() {\n        return this.getEndpoint1().connection;\n    }\n    /**\n     * @returns The block or line connected to the second endpoint of this line, or `undefined` if none\n     */\n    getDownstreamConnection() {\n        return this.getEndpoint2().connection;\n    }\n    /**\n     * @returns A list of lines whose endpoints are connected to this line\n     */\n    getConnectedLines() {\n        const ids = this.client.sendCommand(\"gcl\" /* CommandName.GetConnectedLines */, this.id);\n        return ids.map((id) => this.client.getLineProxy(id));\n    }\n    /**\n     * @param relative A distance, between 0 and 1, between the first and second endpoint of this line\n     * @returns The coordinate of that relative position, relative to the containing page\n     */\n    getRelativePosition(relative) {\n        return this.client.sendCommand(\"grlp\" /* CommandName.GetRelativeLinePosition */, { 'id': this.id, 'p': relative });\n    }\n    /**\n     *\n     * @param name\n     * @returns The position of the given text area on this line, if it exists, or undefined if it does not exist.\n     */\n    getTextAreaPosition(name) {\n        const serializedTextAreas = this.properties.get('TextAreas');\n        if ((0, checks_1.isObjectUnsafe)(serializedTextAreas)) {\n            const rawEntry = serializedTextAreas[name];\n            if ((0, linetextareapositioning_1.isSerializedLineTextAreaPositioning)(rawEntry)) {\n                return (0, linetextareapositioning_1.deserializeLineTextAreaPositioning)(rawEntry);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Updates the position of the given text area, if it exists. If not, an error is thrown.\n     * @param name\n     * @param position\n     */\n    setTextAreaPosition(name, position) {\n        this.properties.set('TextAreas', { [name]: (0, linetextareapositioning_1.serializeLineTextAreaPositioning)(position) });\n    }\n    /**\n     * Adds a new text area to this line at the given location with the given initial plain text.\n     * The text will be styled with the document theme, if any.\n     * @param text\n     * @param position\n     * @returns The name of the text area added\n     */\n    addTextArea(text, position) {\n        return this.client.sendCommand(\"alta\" /* CommandName.AddLineTextArea */, {\n            'id': this.id,\n            'p': (0, linetextareapositioning_1.serializeLineTextAreaPositioning)(position),\n            't': text,\n        });\n    }\n    /**\n     * Deletes the given text area from the line, if it exists.\n     * @param name\n     */\n    deleteTextArea(name) {\n        this.properties.set('TextAreas', { [name]: null });\n    }\n    getShape() {\n        return this.properties.get('Shape');\n    }\n    setShape(shape) {\n        this.properties.set('Shape', shape);\n    }\n}\nexports.LineProxy = LineProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/lineproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/linetextareapositioning.js":
/*!******************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/linetextareapositioning.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeLineTextAreaPositioning = exports.deserializeLineTextAreaPositioning = exports.isSerializedLineTextAreaPositioning = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\n/** @ignore */\nfunction isSerializedLineTextAreaPositioning(raw) {\n    return ((0, checks_1.isObjectUnsafe)(raw) &&\n        (0, checks_1.isNumber)(raw['Location']) &&\n        (0, checks_1.isNumber)(raw['Side']) &&\n        ((0, checks_1.isBoolean)(raw['AllowOverBlock']) || (0, checks_1.isUndefined)(raw['AllowOverBlock'])));\n}\nexports.isSerializedLineTextAreaPositioning = isSerializedLineTextAreaPositioning;\n/** @ignore */\nfunction deserializeLineTextAreaPositioning(raw) {\n    return {\n        location: raw['Location'],\n        side: raw['Side'],\n        allowOverBlock: raw['AllowOverBlock'],\n    };\n}\nexports.deserializeLineTextAreaPositioning = deserializeLineTextAreaPositioning;\n/** @ignore */\nfunction serializeLineTextAreaPositioning(data) {\n    return {\n        'Location': data.location,\n        'Side': data.side,\n        'AllowOverBlock': data.allowOverBlock,\n    };\n}\nexports.serializeLineTextAreaPositioning = serializeLineTextAreaPositioning;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/linetextareapositioning.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/mapproxy.js":
/*!***************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/mapproxy.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WriteableMapProxy = exports.MapProxy = void 0;\n/**\n * A data structure similar to a normal Map which accesses its data through API\n * commands to the Lucid app. This structure is iterable with `for...of`.\n */\nclass MapProxy {\n    constructor(getKeys, getItem) {\n        this.getKeys = getKeys;\n        this.getItem = getItem;\n    }\n    /** @ignore */\n    *[Symbol.iterator]() {\n        for (const key of this.keys()) {\n            const value = this.get(key);\n            if (value !== undefined) {\n                yield [key, value];\n            }\n        }\n    }\n    *values() {\n        for (const key of this.keys()) {\n            const value = this.get(key);\n            if (value !== undefined) {\n                yield value;\n            }\n        }\n    }\n    find(filter) {\n        for (const [key, value] of this) {\n            if (filter(value, key)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    filter(filter) {\n        const filtered = [];\n        for (const [key, value] of this) {\n            if (filter(value, key)) {\n                filtered.push(value);\n            }\n        }\n        return filtered;\n    }\n    map(callback) {\n        const mapped = [];\n        for (const [key, value] of this) {\n            mapped.push(callback(value, key));\n        }\n        return mapped;\n    }\n    keys() {\n        return this.getKeys();\n    }\n    get size() {\n        return this.keys().length;\n    }\n    get(key) {\n        return this.getItem(key);\n    }\n    first() {\n        const keys = this.keys();\n        if (keys.length == 0) {\n            return undefined;\n        }\n        return this.get(keys[0]);\n    }\n}\nexports.MapProxy = MapProxy;\nclass WriteableMapProxy extends MapProxy {\n    constructor(getKeys, getItem, setter) {\n        super(getKeys, getItem);\n        this.setter = setter;\n    }\n    set(key, value, options = {}) {\n        return this.setter(key, value, options);\n    }\n}\nexports.WriteableMapProxy = WriteableMapProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/mapproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/pagedefinition.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/pagedefinition.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/pagedefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/pageproxy.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/pageproxy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PageProxy = void 0;\nconst commandtypes_1 = __webpack_require__(/*! ../commandtypes */ \"./node_modules/lucid-extension-sdk/commandtypes.js\");\nconst ruleproxy_1 = __webpack_require__(/*! ./documentelement/ruleproxy */ \"./node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./elementproxy */ \"./node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst groupproxy_1 = __webpack_require__(/*! ./groupproxy */ \"./node_modules/lucid-extension-sdk/document/groupproxy.js\");\nconst imagedefinition_1 = __webpack_require__(/*! ./imagedefinition */ \"./node_modules/lucid-extension-sdk/document/imagedefinition.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./lineproxy */ \"./node_modules/lucid-extension-sdk/document/lineproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * One page in the current Lucid document\n */\nclass PageProxy extends elementproxy_1.ElementProxy {\n    /**\n     * @param id The ID of this page\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The blocks contained directly on this page, not including ones inside groups\n         */\n        this.blocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { id: this.id }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines contained directly on this page, not including ones inside groups\n         */\n        this.lines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { id: this.id }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups contained directly on this page, not including ones inside groups\n         */\n        this.groups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { id: this.id }), (id) => new groupproxy_1.GroupProxy(id, this.client));\n        /**\n         * The blocks contained on this page, including ones inside groups\n         */\n        this.allBlocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { id: this.id, d: true }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines contained on this page, including ones inside groups\n         */\n        this.allLines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { id: this.id, d: true }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups contained on this page, including ones inside groups\n         */\n        this.allGroups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { id: this.id, d: true }), (id) => new groupproxy_1.GroupProxy(id, this.client));\n        /**\n         * All blocks, lines, and groups on the page, including ones inside groups\n         */\n        this.allItems = new mapproxy_1.MapProxy(() => [...this.allBlocks.keys(), ...this.allLines.keys(), ...this.allGroups.keys()], (id) => this.client.getItemProxy(id));\n    }\n    /**\n     * @returns All conditional formatting rules that are applied to every item on this page\n     */\n    getRulesAppliedToAllItems() {\n        const ids = this.properties.get('ChildRuleList');\n        return ids.map((id) => new ruleproxy_1.RuleProxy(id, this.client));\n    }\n    /**\n     * @param rule Rule to apply to all items on this page\n     */\n    applyRuleToAllItems(rule) {\n        const ids = this.properties.get('ChildRuleList');\n        if (!ids.includes(rule.id)) {\n            ids.push(rule.id);\n            this.properties.set('ChildRuleList', ids);\n        }\n    }\n    /**\n     * @param rule Rule to remove from the list applied to all items on this page\n     */\n    unapplyRuleToAllItems(rule) {\n        const ids = this.properties.get('ChildRuleList');\n        if (ids.includes(rule.id)) {\n            this.properties.set('ChildRuleList', ids.filter((id) => id !== rule.id));\n        }\n    }\n    /**\n     * Find available space on this page for adding new content.\n     * @param searchX Place to start the search\n     * @param searchY Place to start the search\n     * @param width\n     * @param height\n     * @returns a reference to the page and origin (upper-left point) of the space you can add new\n     * content of the given size to.\n     */\n    findAvailableSpace(searchX, searchY, width, height) {\n        const result = this.client.sendCommand(\"fas\" /* CommandName.FindAvailableSpace */, {\n            'p': this.id,\n            'x': searchX,\n            'y': searchY,\n            'w': width,\n            'h': height,\n        });\n        return {\n            page: this,\n            x: result['x'],\n            y: result['y'],\n        };\n    }\n    /**\n     * Add a new block to this page.\n     *\n     * IMPORTANT: Because code for block classes are loaded incrementally, you MUST call\n     * EditorClient.loadBlockClasses with the given block class name (and wait for it to\n     * resolve) before attempting to create a block. If you don't, an error will be thrown.\n     *\n     * @param def The definition of the new block to add\n     * @returns The added block\n     */\n    addBlock(def) {\n        const id = this.client.sendCommand(\"cb\" /* CommandName.CreateBlock */, {\n            'p': this.id,\n            'c': def.className,\n            's': def.stencil,\n        });\n        const block = this.client.getBlockProxy(id);\n        block.setBoundingBox(def.boundingBox);\n        if (def.properties) {\n            for (const key in def.properties) {\n                block.properties.set(key, def.properties[key]);\n            }\n        }\n        if (def.fillStyle !== undefined) {\n            block.setFillStyle(def.fillStyle);\n        }\n        if (def.lineWidth !== undefined) {\n            block.setLineWidth(def.lineWidth);\n        }\n        return block;\n    }\n    /**\n     * Creates a new group from a list of items.\n     *\n     * @param blocks A non-empty array of items to group\n     * @returns The added group\n     */\n    groupBlocks(blocks) {\n        const id = this.client.sendCommand(\"cg\" /* CommandName.CreateGroup */, {\n            'p': this.id,\n            'i': blocks.map((block) => block.id),\n        });\n        return new groupproxy_1.GroupProxy(id, this.client);\n    }\n    /**\n     * Add a new line to this page.\n     * @param def The definition of the new line to add\n     * @returns The added line\n     */\n    addLine(def) {\n        const id = this.client.sendCommand(\"cl\" /* CommandName.CreateLine */, {\n            'p': this.id,\n        });\n        const line = new lineproxy_1.LineProxy(id, this.client);\n        line.setEndpoint1(def.endpoint1);\n        line.setEndpoint2(def.endpoint2);\n        return line;\n    }\n    /**\n     * Add a new image to this page.\n     * @param def The definition of the new image to add\n     * @returns The added image\n     */\n    async addImage(def) {\n        await this.client.loadBlockClasses(['UserImage2Block']);\n        return this.addBlock((0, imagedefinition_1.imageToBlockDefinition)(def));\n    }\n    /**\n     * Add a diagram described by Mermaid markup to this page.\n     *\n     * See https://mermaid.js.org/intro/syntax-reference.html for information on Mermaid markup syntax.\n     *\n     * @param diagramType The type of the diagram. Note that this is redundant because the Mermaid markup also contains\n     *                         the diagram type.\n     * @param mermaid Mermaid markup text describing the diagram to add.\n     * @param origin Where to place the diagram on the page. If absent some free\n     *                  space within or near the current viewport is automatically chosen.\n     * @param exactPlacement If true and if origin is specified, places the diagram exactly at the specified origin\n     *                          instead of trying to find free space.\n     * @returns An array of the proxies for all the objects in the added diagram.\n     */\n    async addDiagramFromMermaid(diagramType, mermaid, origin, exactPlacement) {\n        return (await this.client.sendCommand(\"adfm\" /* CommandName.AddDiagramFromMermaid */, {\n            't': diagramType,\n            'm': mermaid,\n            'o': origin,\n            'e': exactPlacement,\n        })).map((id) => this.client.getItemProxy(id));\n    }\n    /**\n     * Updates the page of this page\n     * @param title The new title for this page\n     */\n    setTitle(title) {\n        this.properties.set('Title', title);\n    }\n    /**\n     * @returns the title of this page\n     */\n    getTitle() {\n        return this.properties.get('Title');\n    }\n    /**\n     * Delete this page from the document if possible\n     */\n    delete() {\n        this.client.sendCommand(\"dp\" /* CommandName.DeletePage */, this.id);\n    }\n    /**\n     *\n     * @param boundingBox An area of this page to search for blocks, lines, and groups\n     * @param searchType\n     * @returns Items in the given bounding box, based on the search type\n     */\n    findItems(boundingBox, searchType) {\n        return this.client\n            .sendCommand(\"gia\" /* CommandName.GetItemsAt */, { 'p': this.id, 'bb': boundingBox, 's': searchType })\n            .map((id) => this.client.getItemProxy(id));\n    }\n    /**\n     * Import links onto this page as link unfurl blocks\n     *\n     * NOTE: links will be unfurled by Lucid based on extensions installed by user\n     *\n     * @param links links to be imported onto the canvas as link unfurl blocks\n     */\n    async importLinks(links) {\n        return await this.client.sendCommand(\"il\" /* CommandName.ImportLinks */, { 'p': this.id, 'l': links });\n    }\n    /**\n     * @param items\n     * @returns A string representing the content of the items provided, including immediate surrounding context if\n     * necessary, in a format that is easily understandable by LLMs like ChatGPT. Also a map of IDs, from the shortened\n     * IDs provided for the items in the context to the actual Lucid item IDs.\n     */\n    getLLMContextForItems(items, contextType = commandtypes_1.GetLLMContextType.Relational) {\n        //We don't check that the items are on this page here; that is done in the implementation\n        //of the API command. It would be a lot of extra API calls for no benefit.\n        const result = this.client.sendCommand(\"llm\" /* CommandName.GetLLMContextFromItems */, {\n            'p': this.id,\n            'i': items.map((item) => item.id),\n            't': contextType,\n        });\n        return {\n            prompt: result['p'],\n            idToLucidId: new Map(Object.entries(result['id'])),\n        };\n    }\n    /**\n     *\n     * @param items If specified, only include these items in the resulting SVG\n     * @param includeBackground If true, include the background of the page in the SVG. Otherwise the background is transparent.\n     * @param viewBox If specified, crop the resulting SVG to the specified bounding box in page coordinates\n     * @returns A promise resolving to an SVG string\n     */\n    getSvg(items, includeBackground = false, viewBox) {\n        return this.client.sendCommand(\"gsvg\" /* CommandName.GetSvg */, {\n            'p': this.id,\n            'bb': viewBox,\n            'bg': includeBackground,\n            'i': items === null || items === void 0 ? void 0 : items.map((item) => item.id),\n        });\n    }\n    /**\n     * @returns the page number of this page\n     */\n    getPageNumber() {\n        return this.properties.get('Order');\n    }\n    /**\n     * Duplicates the page represented by the page proxy\n     */\n    async duplicate() {\n        await this.client.duplicatePages([this.getPageNumber()]);\n    }\n}\nexports.PageProxy = PageProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/pageproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/propertystoreproxy.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/propertystoreproxy.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PropertyStoreProxy = void 0;\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * Base class for anything on a Lucid document that has an ID and properties.\n */\nclass PropertyStoreProxy {\n    /**\n     *\n     * @param id ID of this element\n     * @param client\n     */\n    constructor(id, client) {\n        this.id = id;\n        this.client = client;\n        /**\n         * All properties available on this element, organized by name.\n         * Not all properties are writeable (e.g. \"ClassName\" on a block).\n         * To move or resize elements, use setLocation() or setBoundingBox() or offset() instead.\n         */\n        this.properties = new mapproxy_1.WriteableMapProxy(() => this.client.sendCommand(\"lpr\" /* CommandName.ListProperties */, { 'id': this.id }), (name) => this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, {\n            'id': this.id,\n            'p': name,\n        }), (name, value) => {\n            if (name === 'BoundingBox') {\n                throw new Error('Do not use properties.set() to move or resize items; use setLocation() or setBoundingBox() or offset()');\n            }\n            this.client.sendCommand(\"sp\" /* CommandName.SetProperty */, {\n                'id': this.id,\n                'p': name,\n                'v': value,\n            });\n        });\n    }\n}\nexports.PropertyStoreProxy = PropertyStoreProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/propertystoreproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/ruledefinition.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/ruledefinition.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeEffectDefinition = exports.serializeConditionDefinition = void 0;\nconst badgeposition_1 = __webpack_require__(/*! ../core/properties/datagraphic/badgeposition */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nconst datagraphicindexes_1 = __webpack_require__(/*! ../core/properties/datagraphic/datagraphicindexes */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js\");\nconst conditiontype_1 = __webpack_require__(/*! ../core/rules/conditiontype */ \"./node_modules/lucid-extension-sdk/core/rules/conditiontype.js\");\nconst serializedeffect_1 = __webpack_require__(/*! ../core/rules/serializedeffect */ \"./node_modules/lucid-extension-sdk/core/rules/serializedeffect.js\");\n/** @ignore */\nfunction serializeConditionDefinition(condition) {\n    switch (condition.type) {\n        case conditiontype_1.ConditionType.Formula:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': 0,\n                'Value': condition.formula,\n            };\n        case conditiontype_1.ConditionType.Text:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': condition.condition,\n                'Value': condition.value,\n            };\n        case conditiontype_1.ConditionType.ShapeData:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': condition.condition,\n                'Value': condition.value,\n                'Label': condition.field,\n                'DisplayLabel': condition.fieldLabel,\n            };\n        case conditiontype_1.ConditionType.ShapeType:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': condition.condition,\n                'Value': condition.classNames,\n            };\n        default:\n            throw new Error('Unsupported ConditionType');\n    }\n}\nexports.serializeConditionDefinition = serializeConditionDefinition;\n/** @ignore */\nfunction serializeEffectDefinition(effect, conditionOrder) {\n    var _a;\n    return {\n        'ConditionOrder': conditionOrder,\n        'Combination': effect.combination,\n        'FormatType': effect.formatType,\n        'Formatting': effect.formatType === serializedeffect_1.RuleFormattingType.FORMATTING\n            ? {\n                'Block': {\n                    'FillColor': JSON.stringify(effect.formatting.fillColor),\n                    'LineColor': JSON.stringify(effect.formatting.borderColor),\n                    'LineWidth': JSON.stringify(effect.formatting.borderWidth),\n                    'StrokeStyle': JSON.stringify(effect.formatting.borderStyle),\n                },\n                'Line': {\n                    'LineColor': JSON.stringify(effect.formatting.lineColor),\n                    'LineWidth': JSON.stringify(effect.formatting.lineWidth),\n                    'StrokeStyle': JSON.stringify(effect.formatting.lineStyle),\n                },\n            }\n            : {},\n        'DataGraphic': effect.formatType === serializedeffect_1.RuleFormattingType.DATA_GRAPHICS\n            ? effect.dataGraphic.set === datagraphicindexes_1.DataGraphicIconSets.CUSTOM_ICONS\n                ? {\n                    'Set': effect.dataGraphic.set,\n                    'Index': 0,\n                    'Position': (0, badgeposition_1.serializeBadgeEnumPosition)(effect.dataGraphic.position),\n                    'Image': {\n                        'url': effect.dataGraphic.image.url,\n                        'w': effect.dataGraphic.image.width,\n                        'h': effect.dataGraphic.image.height,\n                    },\n                }\n                : {\n                    'Set': effect.dataGraphic.set,\n                    'Index': (_a = effect.dataGraphic.index) !== null && _a !== void 0 ? _a : 0,\n                    'Position': (0, badgeposition_1.serializeBadgeEnumPosition)(effect.dataGraphic.position),\n                    'Color': effect.dataGraphic.color,\n                }\n            : undefined,\n        'Tooltip': effect.tooltip,\n    };\n}\nexports.serializeEffectDefinition = serializeEffectDefinition;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/ruledefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/shapedataproxy.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/shapedataproxy.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShapeDataProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializeddataerror_1 = __webpack_require__(/*! ../core/serializeddataerror */ \"./node_modules/lucid-extension-sdk/core/serializeddataerror.js\");\nconst shapedatainheritance_1 = __webpack_require__(/*! ../core/shapedatainheritance */ \"./node_modules/lucid-extension-sdk/core/shapedatainheritance.js\");\nconst dataerror_1 = __webpack_require__(/*! ../data/dataerror */ \"./node_modules/lucid-extension-sdk/data/dataerror.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * The shape data fields on a single element of the current document\n */\nclass ShapeDataProxy extends mapproxy_1.WriteableMapProxy {\n    /**\n     * @param id The ID of the element, or undefined for the document itself\n     * @param client\n     */\n    constructor(id, client) {\n        super(() => this.client.sendCommand(\"lsd\" /* CommandName.ListShapeData */, { 'id': this.id }), (name) => ShapeDataProxy.parseData(this.client.sendCommand(\"gsd\" /* CommandName.GetShapeData */, {\n            'id': this.id,\n            'n': name,\n        })), (name, value) => {\n            if ((0, serializeddataerror_1.isSerializedDataError)(value)) {\n                throw new Error('Cannot store an error value');\n            }\n            if (this.keys().includes(name)) {\n                this.client.sendCommand(\"ssd\" /* CommandName.SetShapeData */, { 'id': this.id, 'n': name, 'v': value });\n            }\n            else {\n                this.client.sendCommand(\"asd\" /* CommandName.AddShapeData */, {\n                    'id': this.id,\n                    'i': shapedatainheritance_1.ShapeDataInheritance.NONE,\n                    'n': name,\n                    'v': value,\n                });\n            }\n        });\n        this.id = id;\n        this.client = client;\n    }\n    /**\n     * Add shape data to this element that is inherited by its descendants.\n     *\n     * If you add an inheritable shape data to a page, whose formula is \"=@Cost * 4\", then\n     * each item on that page will have a new shape data entry (in `allShapeData`) by that\n     * name with the value calculated in the context of that individual item.\n     *\n     * Inheritable shape data on a page affects all items on the page. Inheritable shape\n     * data on a group affects all items inside that group.\n     *\n     * @param name Name of the new shape data\n     * @param value Value (or formula, if starting with \"=\") of the new shape data\n     */\n    addInheritable(name, value) {\n        this.client.sendCommand(\"asd\" /* CommandName.AddShapeData */, {\n            'id': this.id,\n            'i': shapedatainheritance_1.ShapeDataInheritance.VALUE,\n            'n': name,\n            'v': value,\n        });\n    }\n    /**\n     * Delete the specified shape data from this element\n     * @param key\n     */\n    delete(key) {\n        if (this.keys().includes(key)) {\n            this.client.sendCommand(\"dsd\" /* CommandName.DeleteShapeData */, { 'id': this.id, 'n': key });\n        }\n    }\n    /** @ignore */\n    static parseData(raw) {\n        if ((0, serializeddataerror_1.isSerializedDataError)(raw)) {\n            return new dataerror_1.DataError(raw['error'], raw['type']);\n        }\n        //TODO, eventually: parse these\n        return raw;\n    }\n    /**\n     * @param key Name of the shape data to read\n     * @returns The value if it is a string, or an empty string if it does not exist or is not a string.\n     */\n    getString(key) {\n        const val = this.get(key);\n        if (!(0, checks_1.isString)(val)) {\n            return '';\n        }\n        return val;\n    }\n}\nexports.ShapeDataProxy = ShapeDataProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/shapedataproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/text/textstyle.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/text/textstyle.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPartialTextStyle = exports.TextMarkupNames = void 0;\nconst checks_1 = __webpack_require__(/*! ../../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * Text styles that can be read and written with ItemProxy.textStyles.\n */\nvar TextMarkupNames;\n(function (TextMarkupNames) {\n    TextMarkupNames[\"Family\"] = \"font\";\n    TextMarkupNames[\"Bold\"] = \"bold\";\n    TextMarkupNames[\"Italic\"] = \"italic\";\n    TextMarkupNames[\"Underline\"] = \"underline\";\n    TextMarkupNames[\"Size\"] = \"size\";\n    TextMarkupNames[\"Color\"] = \"color\";\n    TextMarkupNames[\"HAlign\"] = \"align\";\n})(TextMarkupNames || (exports.TextMarkupNames = TextMarkupNames = {}));\nexports.isPartialTextStyle = (0, validators_1.partialObjectValidator)({\n    [TextMarkupNames.Family]: checks_1.isString,\n    [TextMarkupNames.Bold]: checks_1.isBoolean,\n    [TextMarkupNames.Italic]: checks_1.isBoolean,\n    [TextMarkupNames.Underline]: checks_1.isBoolean,\n    [TextMarkupNames.Size]: checks_1.isNumber,\n    [TextMarkupNames.Color]: checks_1.isString,\n    [TextMarkupNames.HAlign]: checks_1.isString,\n});\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/document/text/textstyle.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/editorclient.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/editorclient.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EditorClient = exports.getResponseBody = void 0;\nconst commandtypes_1 = __webpack_require__(/*! ./commandtypes */ \"./node_modules/lucid-extension-sdk/commandtypes.js\");\nconst base64_1 = __webpack_require__(/*! ./core/base64 */ \"./node_modules/lucid-extension-sdk/core/base64.js\");\nconst cardintegrationconfig_1 = __webpack_require__(/*! ./core/cardintegration/cardintegrationconfig */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js\");\nconst checks_1 = __webpack_require__(/*! ./core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst unfurldetails_1 = __webpack_require__(/*! ./core/unfurl/unfurldetails */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js\");\nconst unfurlrefresherrortype_1 = __webpack_require__(/*! ./core/unfurl/unfurlrefresherrortype */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js\");\nconst collectionproxy_1 = __webpack_require__(/*! ./data/collectionproxy */ \"./node_modules/lucid-extension-sdk/data/collectionproxy.js\");\nconst blockproxyregistry_1 = __webpack_require__(/*! ./document/blockclasses/blockproxyregistry */ \"./node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js\");\nconst customblockproxy_1 = __webpack_require__(/*! ./document/blockclasses/customblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js\");\nconst linkunfurlblockproxy_1 = __webpack_require__(/*! ./document/blockclasses/linkunfurlblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js\");\nconst blockproxy_1 = __webpack_require__(/*! ./document/blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nconst documentproxy_1 = __webpack_require__(/*! ./document/documentproxy */ \"./node_modules/lucid-extension-sdk/document/documentproxy.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./document/elementproxy */ \"./node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst groupproxy_1 = __webpack_require__(/*! ./document/groupproxy */ \"./node_modules/lucid-extension-sdk/document/groupproxy.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./document/lineproxy */ \"./node_modules/lucid-extension-sdk/document/lineproxy.js\");\nconst pageproxy_1 = __webpack_require__(/*! ./document/pageproxy */ \"./node_modules/lucid-extension-sdk/document/pageproxy.js\");\nconst unfurleventmessage_1 = __webpack_require__(/*! ./message/unfurleventmessage */ \"./node_modules/lucid-extension-sdk/message/unfurleventmessage.js\");\nfunction parseRawXHRResponse(responseFormat, raw) {\n    var _a, _b, _c, _d;\n    return Object.assign({ url: (_a = raw === null || raw === void 0 ? void 0 : raw['url']) !== null && _a !== void 0 ? _a : '', status: (_b = raw === null || raw === void 0 ? void 0 : raw['s']) !== null && _b !== void 0 ? _b : 0, headers: (_c = raw === null || raw === void 0 ? void 0 : raw['h']) !== null && _c !== void 0 ? _c : {}, timeout: raw === null || raw === void 0 ? void 0 : raw['to'] }, (responseFormat === 'utf8'\n        ? {\n            responseFormat,\n            responseText: (_d = raw === null || raw === void 0 ? void 0 : raw['t']) !== null && _d !== void 0 ? _d : 'An unknown error occurred',\n        }\n        : {\n            responseFormat,\n            responseData: (raw === null || raw === void 0 ? void 0 : raw['t']) ? (0, base64_1.decodeBase64)(raw['t']) : new Uint8Array(0),\n        }));\n}\nfunction getResponseBody(response) {\n    if ('json' in response) {\n        return response['json'];\n    }\n    else if ('text' in response) {\n        return response['text'];\n    }\n    else {\n        return '';\n    }\n}\nexports.getResponseBody = getResponseBody;\nclass EditorClient {\n    getUniqueActionName() {\n        while (this.actionExists('a' + this.nextId)) {\n            this.nextId++;\n        }\n        return 'a' + this.nextId;\n    }\n    /**\n     * Get which Lucid product this editor extension has been loaded in.\n     */\n    getProduct() {\n        return this.sendCommand(\"gpr\" /* CommandName.GetProduct */, undefined);\n    }\n    /**\n     * Unload this extension immediately, removing any custom menu items etc., until the user refreshes the browser tab.\n     */\n    killExtension() {\n        this.sendCommand(\"k\" /* CommandName.KillExtension */, undefined);\n    }\n    /**\n     * Unload this extension, and then re-execute it.\n     */\n    reloadExtension() {\n        this.sendCommand(\"r\" /* CommandName.ReloadExtension */, undefined);\n    }\n    /**\n     * Initiate a browser file download of custom content\n     * @param filename Filename of the downloaded file\n     * @param data The content to put into the file, either in plain text or as base64-encoded binary data\n     * @param mime The MIME type to tell the browser it is downloading\n     * @param base64 If true, base64 decode the data before downloading it\n     */\n    download(filename, data, mime, base64) {\n        this.sendCommand(\"d\" /* CommandName.Download */, {\n            'f': filename,\n            'd': data,\n            'm': mime,\n            'b64': base64,\n        });\n    }\n    /**\n     * Upload an image and return a URL that can be used for displaying that image on the canvas. Note: the URL is\n     * public - anyone with the URL can access the image.\n     * @param data The binary image contents, or a base64-encoded string\n     * @param mediaType The media type, e.g. 'image/png'\n     * @returns A promise that resolves with the URL of the created image.\n     *\n     */\n    async createUserImage(mediaType, data) {\n        const result = await this.sendCommand(\"cui\" /* CommandName.CreateUserImage */, {\n            't': mediaType,\n            'd': (0, checks_1.isString)(data) ? data : (0, base64_1.encodeBase64)(data),\n        });\n        return result['u'];\n    }\n    /**\n     * @ignore\n     * @deprecated Use createUserImage instead.\n     */\n    experimentalCreateUserImage(mediaType, data) {\n        return this.createUserImage(mediaType, data);\n    }\n    async performDataAction(options) {\n        if (options.asynchronous === undefined) {\n            options.asynchronous = true;\n        }\n        const result = await this.sendCommand(\"da\" /* CommandName.DataAction */, {\n            'fn': options.actionName,\n            'a': options.asynchronous,\n            's': options.syncDataSourceIdNonce,\n            'fd': options.actionData,\n            'n': options.dataConnectorName,\n        });\n        if ('t' in result) {\n            return {\n                'status': result['c'],\n                'text': result['t'],\n            };\n        }\n        return {\n            'status': result['c'],\n            'json': result['j'],\n        };\n    }\n    /**\n     * If the extension package containing this editor extension has configurable settings,\n     * show a standard modal allowing the user to view or change those settings.\n     *\n     * If the user does not have permission to change settings on this installation of this\n     * extension, or if no settings exist, an error is thrown.\n     *\n     * @returns A promise that resolves when the user closes the settings modal.\n     */\n    async showPackageSettingsModal() {\n        return this.sendCommand(\"spsm\" /* CommandName.ShowPackageSettingsModal */, undefined);\n    }\n    /**\n     * If the extension package containing this editor extension has configurable settings, set the\n     * value of those settings for this installation of this extension. A subset of setting values\n     * can be provided to update those values while leaving others unchanged.\n     *\n     * If the user does not have permission to change settings on this installation of this\n     * extension, or if no settings exist, an error is thrown.\n     */\n    async setPackageSettings(settings) {\n        let settingsAsRecord = {};\n        if (settings instanceof Map) {\n            for (const [key, value] of settings.entries()) {\n                settingsAsRecord[key] = value;\n            }\n        }\n        else {\n            settingsAsRecord = settings;\n        }\n        return this.sendCommand(\"sps\" /* CommandName.SetPackageSettings */, settingsAsRecord);\n    }\n    /**\n     * If the extension package containing this editor extension has configurable settings,\n     * fetch the current values of those settings for this installation of this extension.\n     *\n     * Only settings that have been set by the installing user will have a value in the map,\n     * other settings will be missing.\n     *\n     * @returns A promise that resolves to a map of setting names to current setting values\n     */\n    async getPackageSettings() {\n        return new Map(Object.entries(await this.sendCommand(\"gps\" /* CommandName.GetPackageSettings */, undefined)));\n    }\n    /**\n     * @returns True if the current user is allowed to edit package settings on this installation\n     * of this extension (if any settings exist), or false otherwise.\n     */\n    async canEditPackageSettings() {\n        return this.sendCommand(\"ceps\" /* CommandName.CanEditPackageSettings */, undefined);\n    }\n    async awaitDataImport(dataConnectorName, syncDataSourceId, syncCollectionId, primaryKeys, timeout = 30000) {\n        return new collectionproxy_1.CollectionProxy(await this.sendCommand(\"ai\" /* CommandName.AwaitImport */, {\n            'n': dataConnectorName,\n            's': syncDataSourceId,\n            'c': syncCollectionId,\n            'pk': primaryKeys,\n            't': timeout,\n        }), this);\n    }\n    /** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\n    async awaitDataSourceImport(dataConnectorName, syncDataSourceIdNonce) {\n        return await this.sendCommand(\"adi\" /* CommandName.AwaitDataSourceImport */, {\n            'n': dataConnectorName,\n            's': syncDataSourceIdNonce,\n        });\n    }\n    xhr(request) {\n        let streamCallback;\n        if (request.streamCallback) {\n            streamCallback = this.getUniqueActionName();\n            this.registerAction(streamCallback, (msg) => { var _a; return (_a = request.streamCallback) === null || _a === void 0 ? void 0 : _a.call(request, msg['d']); });\n        }\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"xhr\" /* CommandName.SendXHR */, {\n            'url': request.url,\n            'm': request.method,\n            'd': request.data,\n            'h': request.headers,\n            'ms': request.timeoutMs,\n            'f': responseFormat,\n            's': streamCallback,\n        })\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        })\n            .finally(() => {\n            if (streamCallback) {\n                this.deleteAction(streamCallback);\n            }\n        });\n    }\n    asyncOAuthXhr(providerName, request) {\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"aoauth\" /* CommandName.SendAsyncOAuthRequest */, Object.assign({ 'url': request.url, 'm': request.method, 'd': request.data, 'h': request.headers, 'ms': request.timeoutMs, 'p': providerName, 'f': responseFormat }, (request.postResultTo ? { 'prt': request.postResultTo } : {})))\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        });\n    }\n    oauthXhr(providerName, request) {\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"oauth\" /* CommandName.SendOAuthRequest */, Object.assign({ 'url': request.url, 'm': request.method, 'd': request.data, 'h': request.headers, 'ms': request.timeoutMs, 'p': providerName, 'f': responseFormat }, (request.postResultTo ? { 'prt': request.postResultTo } : {})))\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        });\n    }\n    triggerAuthFlow(providerName) {\n        return this.sendCommand(\"tauth\" /* CommandName.TriggerAuthFlow */, {\n            'p': providerName,\n        });\n    }\n    /**\n     * Returns an OAuth token for the given provider, prompting the user to grant access if necessary\n     *\n     * @param providerName Name of the OAuth provider\n     * @returns An oauth token, or undefined if a valid token cannot be obtained\n     */\n    async getOAuthToken(providerName) {\n        return await this.sendCommand(\"got\" /* CommandName.GetOAuthToken */, { 'p': providerName });\n    }\n    /**\n     * Fetch the OAuth Client Id if there is one\n     *\n     * @param providerName Name of the OAuth provider\n     * @returns A oauth client id or undefined if it doesn't exist\n     */\n    async getOAuthClientId(providerName) {\n        return await this.sendCommand(\"goci\" /* CommandName.GetOAuthClientId */, { 'p': providerName });\n    }\n    permanentTokenXhr(providerName, request) {\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"perm\" /* CommandName.SendPermanentTokenRequest */, {\n            'url': request.url,\n            'm': request.method,\n            'd': request.data,\n            'h': request.headers,\n            'ms': request.timeoutMs,\n            'p': providerName,\n            'f': responseFormat,\n        })\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        });\n    }\n    /**\n     * Register a named action. These actions can be triggered from custom UI, for example as the action of a\n     * custom menu item.\n     *\n     * Some actions may return a value that is used by the core application, e.g. a `visibleAction` for a menu\n     * item. However, if you return a `Promise` from your callback, that value will be discarded and your\n     * action will return `undefined` instead. The ability to provide a callback that returns a Promise is only\n     * a convenience so that you can register actions with `async` callbacks for easy async/await.\n     *\n     * Throws an error if the same action name is registered multiple times.\n     *\n     * @param name name of the action\n     * @param callback function to execute when this action is invoked\n     */\n    registerAction(name, callback) {\n        if (this.actionExists(name)) {\n            throw new Error('Action already exists: ' + name);\n        }\n        this.callbacks.set(name, callback);\n    }\n    /**\n     * Register a named action that receives file upload data. These callbacks can be used in\n     * Menu.addMenuItem as the file action.\n     * @param name The name of the action\n     * @param callback Function to execute when this action is invoked\n     */\n    registerFileUploadAction(name, callback) {\n        this.registerAction(name, (msg) => {\n            callback(msg['f'].map((rawFile) => {\n                if (rawFile['b']) {\n                    return { fileName: rawFile['n'], text: rawFile['t'], binary: (0, base64_1.decodeBase64)(rawFile['b']) };\n                }\n                else {\n                    return { fileName: rawFile['n'], text: rawFile['t'] };\n                }\n            }));\n        });\n    }\n    /**\n     * Registers a handler for link unfurling.\n     * @param domain The domain\n     * @param callbacks The callbacks to call when a link matching the domain is pasted.\n     */\n    registerUnfurlHandler(domain, callbacks) {\n        const unfurlAction = this.getUniqueActionName();\n        let afterUnfurlAction = undefined;\n        let expandAction = undefined;\n        this.registerAction(unfurlAction, async (rawMsg) => {\n            const msg = (0, unfurleventmessage_1.deserializeUnfurlEventMessage)(rawMsg);\n            try {\n                const result = await callbacks.unfurlCallback(msg.url);\n                if (result && !(0, unfurlrefresherrortype_1.unfurlRefreshErrorTypeValidator)(result)) {\n                    return (0, unfurldetails_1.serializeUnfurlDetails)(result);\n                }\n            }\n            catch (err) {\n                return unfurlrefresherrortype_1.UnfurlRefreshErrorType.GenericFailure;\n            }\n            return undefined;\n        });\n        if (callbacks.afterUnfurlCallback) {\n            afterUnfurlAction = this.getUniqueActionName();\n            this.registerAction(afterUnfurlAction, async (rawMsg) => {\n                var _a;\n                const msg = (0, unfurleventmessage_1.deserializeUnfurlEventMessage)(rawMsg);\n                if (msg.blockId) {\n                    const proxy = this.getBlockProxy(msg.blockId);\n                    if (proxy instanceof linkunfurlblockproxy_1.LinkUnfurlBlockProxy) {\n                        await ((_a = callbacks.afterUnfurlCallback) === null || _a === void 0 ? void 0 : _a.call(callbacks, proxy, msg.url));\n                    }\n                }\n                return undefined;\n            });\n        }\n        if (callbacks.expandCallback) {\n            expandAction = this.getUniqueActionName();\n            this.registerAction(expandAction, async (rawMsg) => {\n                var _a;\n                const msg = (0, unfurleventmessage_1.deserializeUnfurlEventMessage)(rawMsg);\n                if (msg.blockId) {\n                    const proxy = this.getBlockProxy(msg.blockId);\n                    if (proxy instanceof linkunfurlblockproxy_1.LinkUnfurlBlockProxy) {\n                        await ((_a = callbacks.expandCallback) === null || _a === void 0 ? void 0 : _a.call(callbacks, proxy, msg.url));\n                    }\n                }\n            });\n        }\n        this.sendCommand(\"ru\" /* CommandName.RegisterUnfurl */, {\n            'd': domain,\n            'ua': unfurlAction,\n            'aua': afterUnfurlAction,\n            'e': expandAction,\n        });\n    }\n    /**\n     * @ignore\n     * @deprecated Use registerUnfurlHandler instead.\n     */\n    experimentalRegisterUnfurlHandler(domain, callbacks) {\n        return this.registerUnfurlHandler(domain, callbacks);\n    }\n    /**\n     * Remove the callback for a given action. If the action is later invoked, nothing will happen.\n     * @param name name of the action to unregister\n     */\n    deleteAction(name) {\n        this.callbacks.delete(name);\n    }\n    /**\n     * @param name name of the action to check\n     * @returns true if a callback has been registered for this action; false otherwise\n     */\n    actionExists(name) {\n        return this.callbacks.has(name);\n    }\n    //Note: UnionToIntersection here fixes the type of params required if you're passing in something that's not a single\n    //specific command name, to require the type of all possible command names you could pass in, intersected. So if you\n    //call this with a CommandName.ListBlocks|CommandName.ListLines it will work as expected but if you just pass in a\n    //CommandName, there won't be any possible params you could pass that would meet all the requirements (string & undefined & ...)\n    /**\n     * Execute an API command. This is the low-level API that most of this SDK wraps. It is not expected that you should\n     * ever need to use this directly.\n     *\n     * @param name name of the API command to execute\n     * @param params data to pass to the API command\n     * @returns the output of the given API command\n     */\n    sendCommand(name, params) {\n        return lucid.executeCommand(name, params);\n    }\n    /**\n     * Create and return a proxy for accessing a block with the given ID. If the block is of a type that has a specific\n     * proxy implementation (e.g. an ERD block) then a specialized subclass of BlockProxy may be returned.\n     *\n     * @param id ID of the block to create a proxy for\n     * @returns the given block\n     */\n    getBlockProxy(id) {\n        const className = this.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'id': id, 'p': 'ClassName' });\n        let proxy = (0, blockproxyregistry_1.findProxyClass)(className);\n        if (proxy === customblockproxy_1.CustomBlockProxy) {\n            proxy = customblockproxy_1.CustomBlockProxy.getCustomBlockClass(this, id);\n        }\n        if (proxy) {\n            return new proxy(id, this);\n        }\n        else {\n            return new blockproxy_1.BlockProxy(id, this);\n        }\n    }\n    /**\n     * Because code for block classes are loaded incrementally, you MUST call\n     * loadBlockClasses with the given block class name (and wait for it to\n     * resolve) before attempting to create a block. If you don't, an error\n     * will be thrown.\n     *\n     * @param classNames the block classes to load\n     * @returns a promise that resolves when the block classes can be used to create new blocks on the document\n     */\n    loadBlockClasses(classNames) {\n        return this.sendCommand(\"lbc\" /* CommandName.LoadBlockClasses */, classNames);\n    }\n    /**\n     * Import one or pages of the specified document or template into the current document\n     * as new pages.\n     * NOTE: The indices of the pages to import will change if the pages are rearranged\n     * on the source document or template.\n     *\n     * @param documentId The ID of the document or template to import\n     * @param pageNums An array of zero-indexed page indices to import from the document or template\n     * @returns a promise that resolves to void when the pages have been imported or the\n     * the import failed\n     */\n    async importPage(documentId, pageNums) {\n        return await this.sendCommand(\"imp\" /* CommandName.ImportPage */, { 'id': documentId, 'n': pageNums });\n    }\n    /**\n     * Duplicates one or more pages of the current document as new pages.\n     *\n     * @param pageNums An array of zero-indexed page indices to duplicate from the current document\n     * @returns a promise that resolves to void when the pages have been duplicated or the\n     * the duplication failed\n     */\n    async duplicatePages(pageNums) {\n        return await this.sendCommand(\"imp\" /* CommandName.ImportPage */, {\n            'id': this.sendCommand(\"gdid\" /* CommandName.GetDocumentId */, undefined),\n            'n': pageNums,\n        });\n    }\n    /**\n     * Load the requested shape library's content, and if it was found, return a block definition ready to be\n     * created.\n     *\n     * Example usage:\n     * ```inline:typescript\n     * const client = new EditorClient();\n     * const viewport = new Viewport(client);\n     *\n     * const page = viewport.getCurrentPage();\n     * if (page) {\n     *     const def = await page.getCustomShapeDefinition('libraryName', 'shapeName');\n     *     if (def) {\n     *         //Customize the shape about to be created\n     *         def.boundingBox.x = 500;\n     *         def.boundingBox.y = 500;\n     *\n     *         //Create the shape itself\n     *         const block = page.addBlock(def);\n     *\n     *         //Set any data fields on the shape as needed\n     *         block.shapeData.set('Value', 50);\n     *     }\n     * }\n     * ```\n     * @param library Name of the shape library in this extension to search for\n     * @param shape Name of the shape within that library to search for\n     * @returns\n     */\n    async getCustomShapeDefinition(library, shape) {\n        await this.loadBlockClasses(['CustomBlock']);\n        const shapeData = await this.sendCommand(\"gcs\" /* CommandName.GetCustomShape */, { 'l': library, 's': shape });\n        if (shapeData) {\n            return {\n                className: 'CustomBlock',\n                boundingBox: shapeData['bb'],\n                stencil: shapeData['s'],\n                properties: shapeData['p'],\n            };\n        }\n        return undefined;\n    }\n    /**\n     * @param callback A callback that processes the bootstrap data, if any, stored on the document and\n     * associated with this editor extension. If this callback is async (returns a promise), then the\n     * bootstrap data is not cleared off of the document until that promise resolves.\n     *\n     * @param markExtensionAsRequired If bootstrap data is available for this editor extension, this will mark the\n     * document as requiring the extension. Once marked, if the extension is not installed the user will be\n     * notified about the extension being required on document load. The minimum extension version required by the\n     * document is the version provided in the request body when creating the document.\n     *\n     * @return a promise that resolves immediately if there is no available bootstrap data, or else after\n     * the callback successfully completes. This promise will reject/throw if the callback throws or\n     * returns a promise that rejects, or if there is another editor session processing the same bootstrap\n     * data at the same time.\n     */\n    async processAndClearBootstrapData(callback, markExtensionAsRequired) {\n        const name = this.getUniqueActionName();\n        this.registerAction(name, (msg) => {\n            return callback(msg['d']);\n        });\n        await this.sendCommand(\"b\" /* CommandName.Bootstrap */, { 'c': name, 'm': markExtensionAsRequired });\n        this.deleteAction(name);\n    }\n    /**\n     * @param id ID of the line to create a proxy for\n     * @returns the given line\n     */\n    getLineProxy(id) {\n        return new lineproxy_1.LineProxy(id, this);\n    }\n    /**\n     * @param id ID of the page to create a proxy for\n     * @returns the given page\n     */\n    getPageProxy(id) {\n        return new pageproxy_1.PageProxy(id, this);\n    }\n    /**\n     * @param id ID of the item to create a proxy for\n     * @returns the given item\n     */\n    getItemProxy(id) {\n        const type = this.sendCommand(\"get\" /* CommandName.GetElementType */, { 'id': id });\n        switch (type) {\n            case 'block':\n                return this.getBlockProxy(id);\n            case 'line':\n                return this.getLineProxy(id);\n            case 'group':\n                return new groupproxy_1.GroupProxy(id, this);\n            default:\n                throw new Error('Element ' + id + ' is not an Item; type found is ' + type);\n        }\n    }\n    /**\n     * @param id ID of the item to create a proxy for\n     * @returns the given item, or undefined if the item does not exist or an error occurs\n     */\n    tryGetItemProxy(id) {\n        try {\n            const item = this.getItemProxy(id);\n            if (item.exists()) {\n                return item;\n            }\n        }\n        catch (_a) { }\n        return undefined;\n    }\n    /**\n     * @param id ID of the element to create a proxy for\n     * @returns the given element\n     */\n    getElementProxy(id) {\n        const type = this.sendCommand(\"get\" /* CommandName.GetElementType */, { 'id': id });\n        switch (type) {\n            case 'block':\n                return this.getBlockProxy(id);\n            case 'line':\n                return this.getLineProxy(id);\n            case 'page':\n                return this.getPageProxy(id);\n            case 'document':\n                return new documentproxy_1.DocumentProxy(this);\n            case 'group':\n                return new groupproxy_1.GroupProxy(id, this);\n            default:\n                return new elementproxy_1.ElementProxy(id, this);\n        }\n    }\n    /**\n     * @hidden\n     */\n    listenToEditor() {\n        lucid.listen((msg) => {\n            var _a;\n            return (_a = this.callbacks.get(msg['id'])) === null || _a === void 0 ? void 0 : _a(msg);\n        });\n    }\n    /**\n     * Display an alert modal to the user\n     * @param text Body text to display in the alert modal\n     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json\n     * @param buttonText Text for the OK button; defaults to \"OK\" (or a translation)\n     * @returns a Promise that resolves true if the user clicks OK, false if they otherwise dismiss the modal\n     */\n    alert(text, title, buttonText) {\n        return this.sendCommand(\"a\" /* CommandName.Alert */, { 't': title, 'b': text, 'bt': buttonText });\n    }\n    /**\n     * Display a confirm modal to the user\n     * @param text Body text to display in the alert modal\n     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json\n     * @param okText Text for the OK button; defaults to \"OK\" (or a translation)\n     * @param cancelText Text for the Cancel button; defaults to \"Cancel\" (or a translation)\n     * @returns a Promise that resolves true if the user clicks OK, false if they click Cancel or otherwise dismiss the modal\n     */\n    confirm(text, title, okText, cancelText) {\n        return this.sendCommand(\"c\" /* CommandName.Confirm */, { 't': title, 'b': text, 'o': okText, 'c': cancelText });\n    }\n    /**\n     * Display a prompt modal to the user\n     * @param text Body text to display in the alert modal\n     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json\n     * @returns a Promise that resolves to a string if a user enters one, or undefined if they cancel\n     */\n    prompt(text, title) {\n        return this.sendCommand(\"p\" /* CommandName.Prompt */, { 't': title, 'b': text });\n    }\n    /**\n     * Executes the given callback within a mutex scoped to the current document, extension, and the given name.\n     * If another editor session currently has the given mutex name locked within the same extension package ID\n     * on this same document, this function's returned promise will resolve to false. Otherwise, the mutex will\n     * be locked for the duration of the callback and the returned promise will resolve to true.\n     * @param name Name of the intra-document mutex to attempt to lock\n     * @param callback Code to execute while the mutex is locked, if it is successfully locked\n     * @returns A promise resolving to a boolean indicating whether the mutex was successfully locked\n     */\n    async withIntraDocumentMutex(name, callback) {\n        const action = this.getUniqueActionName();\n        this.registerAction(action, callback);\n        try {\n            return await this.sendCommand(\"wm\" /* CommandName.WithMutex */, { 'n': name, 'a': action });\n        }\n        finally {\n            this.deleteAction(action);\n        }\n    }\n    /**\n     * @param callback Callback that will be executed with the user's local undo/redo history suppressed. This is\n     * useful when you want to make changes to a document that will not be erased if the user uses undo or redo,\n     * for example adding shape data onto shapes as a result of a background process that collects data from a\n     * remote API.\n     */\n    withSilentActions(callback) {\n        const action = this.getUniqueActionName();\n        this.registerAction(action, () => {\n            const result = callback();\n            if ((0, checks_1.isPromise)(result)) {\n                throw new Error('withSilentActions cannot be used with an async callback');\n            }\n        });\n        try {\n            this.sendCommand(\"wsa\" /* CommandName.WithSilentActions */, { 'a': action });\n        }\n        finally {\n            this.deleteAction(action);\n        }\n    }\n    /**\n     * This method fetches the `CardIntegrationConfig` associated with the given data source ID. If you need to change\n     * the `CardIntegrationConfig`, you can call this method and mutate the returned object, then return it to the\n     * extension API via the `updateCardIntegrationConfig` method. Note that this method has a few best-practices you\n     * should be aware of before using it, as detailed in its comment.\n     */\n    async getCardIntegrationConfig(dataSourceId) {\n        return await this.sendCommand(\"gcic\" /* CommandName.GetCardIntegrationConfig */, dataSourceId);\n    }\n    /**\n     * Update the current `CardIntegrationConfig` associated with the given data source ID with the data from the new\n     * one provided. This will not remove fields form the fieldDisplaySetings, only add new ones or update existing\n     * ones.\n     *\n     * You should only call this method in response to a user action from the current session, and should be careful\n     * when there are multiple collaborators that you are not repeatedly calling this method for all users. Doing so\n     * could lead to undefined or unexpected behavior.\n     */\n    async updateCardIntegrationConfig(dataSourceId, newConfig) {\n        return await this.sendCommand(\"ucic\" /* CommandName.UpdateCardIntegrationConfig */, {\n            'd': dataSourceId,\n            'c': (0, cardintegrationconfig_1.serializeCardIntegrationConfig)(newConfig),\n        });\n    }\n    /**\n     * Hash a particular string using the given algorithm.\n     *\n     * Hashing can be very slow in extensions, so we provide this utility function to instead run hashing algorithms\n     * in the client.\n     *\n     * @param algorithm Which hashing algorithm to apply to the string. We currently only support SHA256.\n     * @param string The raw string we are calculating the hash of.\n     * @returns The hashed string.\n     */\n    /** @ignore because our documentation gets generated incorrectly for an as-yet unknown reason. It seems to refer to the HashAlgorithmEnum with an incorrect link. */\n    hash(algorithm, string) {\n        return this.sendCommand(\"hsh\" /* CommandName.CalculateHash */, { 'a': algorithm, 's': string });\n    }\n    constructor() {\n        this.nextId = 0;\n        this.callbacks = new Map();\n        this.listenToEditor();\n    }\n}\nexports.EditorClient = EditorClient;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/editorclient.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/index.js":
/*!***************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./commandtypes */ \"./node_modules/lucid-extension-sdk/commandtypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/base64 */ \"./node_modules/lucid-extension-sdk/core/base64.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/cardfielddisplaysettings */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/cardintegrationconfig */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/lucidcardintegration */ \"./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/lucidcardintegrationregistry */ \"./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/datasourcetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/datasourceutils */ \"./node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/metadatatypes */ \"./node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/serializeddatasourceproperties */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/serializedimporteddatasource */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/serializedsourceforeignkey */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializedsourceforeignkey.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/serializedupstreamconfig */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/upstreamconfig */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/upstreampatchtype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/upstreamupdatetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldspecification */ \"./node_modules/lucid-extension-sdk/core/data/fieldspecification.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/basefieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/collectionenumfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/fieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/literalfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/ndimensionalfieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/semantickind */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/referencekeys/serializedreferencekey */ \"./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializeddataitems */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializedfielddefinition */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializedfields */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializedschema */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/dataerrortype */ \"./node_modules/lucid-extension-sdk/core/dataerrortype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/guards */ \"./node_modules/lucid-extension-sdk/core/guards.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/humanreadableerror */ \"./node_modules/lucid-extension-sdk/core/humanreadableerror.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/iframe/iframeutils */ \"./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/jsonserializable */ \"./node_modules/lucid-extension-sdk/core/jsonserializable.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/lucidproduct */ \"./node_modules/lucid-extension-sdk/core/lucidproduct.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/object */ \"./node_modules/lucid-extension-sdk/core/object.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/offsettype */ \"./node_modules/lucid-extension-sdk/core/offsettype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/optionalkey */ \"./node_modules/lucid-extension-sdk/core/optionalkey.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/datagraphic/badgeposition */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/datagraphic/datagraphicindexes */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/datagraphic/staticdatagraphicsettings */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/dependencylinename */ \"./node_modules/lucid-extension-sdk/core/properties/dependencylinename.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/fillcolor */ \"./node_modules/lucid-extension-sdk/core/properties/fillcolor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/shadow */ \"./node_modules/lucid-extension-sdk/core/properties/shadow.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/strokestyle */ \"./node_modules/lucid-extension-sdk/core/properties/strokestyle.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/rules/conditions */ \"./node_modules/lucid-extension-sdk/core/rules/conditions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/rules/conditiontype */ \"./node_modules/lucid-extension-sdk/core/rules/conditiontype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/rules/serializedeffect */ \"./node_modules/lucid-extension-sdk/core/rules/serializedeffect.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/serializeddataerror */ \"./node_modules/lucid-extension-sdk/core/serializeddataerror.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/shapedatainheritance */ \"./node_modules/lucid-extension-sdk/core/shapedatainheritance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/sharedcardintegration/cardintegrationdefinitions */ \"./node_modules/lucid-extension-sdk/core/sharedcardintegration/cardintegrationdefinitions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/spreadsheetintegration/lucidspreadsheetintegration */ \"./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/spreadsheetintegration/lucidspreadsheetintegrationregistry */ \"./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurlcallbacks */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurldetails */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurliframe */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurlrefresherrortype */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurlthumbnail */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/xhr */ \"./node_modules/lucid-extension-sdk/core/xhr.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/collectiondefinition */ \"./node_modules/lucid-extension-sdk/data/collectiondefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/collectionproxy */ \"./node_modules/lucid-extension-sdk/data/collectionproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataerror */ \"./node_modules/lucid-extension-sdk/data/dataerror.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataitemproxy */ \"./node_modules/lucid-extension-sdk/data/dataitemproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataproxy */ \"./node_modules/lucid-extension-sdk/data/dataproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/datasourceproxy */ \"./node_modules/lucid-extension-sdk/data/datasourceproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataupdatefiltertype */ \"./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/referencekeydefinition */ \"./node_modules/lucid-extension-sdk/data/referencekeydefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/referencekeyproxy */ \"./node_modules/lucid-extension-sdk/data/referencekeyproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/schemadefinition */ \"./node_modules/lucid-extension-sdk/data/schemadefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/action */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/action.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/managewebhookresponsebody */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/patchresponsebody */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/serializedactions */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/dataconnector */ \"./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/dataconnectorclient */ \"./node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/datasourceclient */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/datasourcemetadatatypes */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/datasourceupdatetypes */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/signaturevalidator */ \"./node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/blockproxyregistry */ \"./node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/cardblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/customblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/erdblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/legendblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/linkunfurlblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/swimlaneblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/tableblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockdefinition */ \"./node_modules/lucid-extension-sdk/document/blockdefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/documentproxy */ \"./node_modules/lucid-extension-sdk/document/documentproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/elementproxy */ \"./node_modules/lucid-extension-sdk/document/elementproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/groupproxy */ \"./node_modules/lucid-extension-sdk/document/groupproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/itemproxy */ \"./node_modules/lucid-extension-sdk/document/itemproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/linedefinition */ \"./node_modules/lucid-extension-sdk/document/linedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/lineproxy */ \"./node_modules/lucid-extension-sdk/document/lineproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/linetextareapositioning */ \"./node_modules/lucid-extension-sdk/document/linetextareapositioning.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/pagedefinition */ \"./node_modules/lucid-extension-sdk/document/pagedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/pageproxy */ \"./node_modules/lucid-extension-sdk/document/pageproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/propertystoreproxy */ \"./node_modules/lucid-extension-sdk/document/propertystoreproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/shapedataproxy */ \"./node_modules/lucid-extension-sdk/document/shapedataproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/text/textstyle */ \"./node_modules/lucid-extension-sdk/document/text/textstyle.js\"), exports);\n__exportStar(__webpack_require__(/*! ./editorclient */ \"./node_modules/lucid-extension-sdk/editorclient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./index */ \"./node_modules/lucid-extension-sdk/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./math */ \"./node_modules/lucid-extension-sdk/math.js\"), exports);\n__exportStar(__webpack_require__(/*! ./message/unfurleventmessage */ \"./node_modules/lucid-extension-sdk/message/unfurleventmessage.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/alertmodal */ \"./node_modules/lucid-extension-sdk/ui/alertmodal.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/iframeui */ \"./node_modules/lucid-extension-sdk/ui/iframeui.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/menu */ \"./node_modules/lucid-extension-sdk/ui/menu.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/modal */ \"./node_modules/lucid-extension-sdk/ui/modal.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/panel */ \"./node_modules/lucid-extension-sdk/ui/panel.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/viewport */ \"./node_modules/lucid-extension-sdk/ui/viewport.js\"), exports);\n__exportStar(__webpack_require__(/*! ./user/userproxy */ \"./node_modules/lucid-extension-sdk/user/userproxy.js\"), exports);\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/index.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/math.js":
/*!**************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/math.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rotateAroundFn = exports.toCornersAsArray = exports.boxFrom4Points = exports.rotateBox = exports.rotatedBoundingBox = exports.boxCenter = exports.clip = exports.percentBoxesOverlap = exports.boxesOverlap = exports.isBoxWithin = exports.padBox = exports.combinedBoundingBox = void 0;\nfunction combinedBoundingBox(boxes) {\n    if (boxes.length == 0) {\n        return undefined;\n    }\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n    for (const box of boxes) {\n        minX = Math.min(minX, box.x);\n        maxX = Math.max(maxX, box.x + box.w);\n        minY = Math.min(minY, box.y);\n        maxY = Math.max(maxY, box.y + box.h);\n    }\n    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };\n}\nexports.combinedBoundingBox = combinedBoundingBox;\nfunction padBox(box, padding) {\n    return { x: box.x - padding, y: box.y - padding, w: box.w + padding * 2, h: box.h + padding * 2 };\n}\nexports.padBox = padBox;\n/**\n * Is box a completely within box b?\n */\nfunction isBoxWithin(a, b) {\n    return a.x >= b.x && a.y >= b.y && a.x + a.w <= b.x + b.w && a.y + a.h <= b.y + b.h;\n}\nexports.isBoxWithin = isBoxWithin;\n/**\n * Do two boxes overlap?\n */\nfunction boxesOverlap(a, b) {\n    return a.x + a.w >= b.x && a.y + a.h >= b.y && b.x + b.w >= a.x && b.y + b.h >= a.y;\n}\nexports.boxesOverlap = boxesOverlap;\n/**\n * return the percentage of a that overlaps with b.\n * if a is entirely within b, it returns 1 (or a number a little less than 1\n * (e.g., 0.99999999999) due to numerical inaccuracy); if a is entirely\n * outside b, it returns 0.\n */\nfunction percentBoxesOverlap(a, b) {\n    const intersection = clip(a, b);\n    // if either dimension is negative return zero\n    if (intersection.w <= 0 || intersection.h <= 0) {\n        return 0;\n    }\n    const area = intersection.w * intersection.h;\n    return area / (a.w * a.h);\n}\nexports.percentBoxesOverlap = percentBoxesOverlap;\n/**\n * Gets the intersection of two boxes\n * @return a clipped to b\n */\nfunction clip(a, b) {\n    const x = Math.max(a.x, b.x);\n    const y = Math.max(a.y, b.y);\n    const w = Math.min(a.x + a.w, b.x + b.w) - x;\n    const h = Math.min(a.y + a.h, b.y + b.h) - y;\n    return { x, y, w, h };\n}\nexports.clip = clip;\nfunction boxCenter(b) {\n    return { x: b.x + b.w / 2, y: b.y + b.h / 2 };\n}\nexports.boxCenter = boxCenter;\n/**\n * Returns the bounding box that would surround the given\n * box when rotated the given amount.\n */\nfunction rotatedBoundingBox(b, angle, center) {\n    if (!angle) {\n        return b;\n    }\n    center = center || boxCenter(b);\n    return boxFrom4Points.apply(null, rotateBox(b, angle, center));\n}\nexports.rotatedBoundingBox = rotatedBoundingBox;\nfunction rotateBox(b, angle, center) {\n    const ret = toCornersAsArray(b);\n    center = center || boxCenter(b);\n    if (angle != 0) {\n        return ret.map(rotateAroundFn(center, angle));\n    }\n    return ret;\n}\nexports.rotateBox = rotateBox;\nfunction boxFrom4Points(a, b, c, d) {\n    const xMin = Math.min(a.x, b.x, c.x, d.x);\n    const xMax = Math.max(a.x, b.x, c.x, d.x);\n    const yMin = Math.min(a.y, b.y, c.y, d.y);\n    const yMax = Math.max(a.y, b.y, c.y, d.y);\n    return { x: xMin, y: yMin, w: xMax - xMin, h: yMax - yMin };\n}\nexports.boxFrom4Points = boxFrom4Points;\n/**\n * @return An array containing the 4 points of the box in this exact order:\n * [top left, top right, bottom right, bottom left].\n */\nfunction toCornersAsArray(box) {\n    return [\n        { x: box.x, y: box.y },\n        { x: box.x + box.w, y: box.y },\n        { x: box.x + box.w, y: box.y + box.h },\n        { x: box.x, y: box.y + box.h },\n    ];\n}\nexports.toCornersAsArray = toCornersAsArray;\nfunction rotateAroundFn(anchor, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    return (p) => {\n        const anchorX = anchor.x;\n        const anchorY = anchor.y;\n        const x = p.x - anchorX;\n        const y = p.y - anchorY;\n        return { x: x * cos - y * sin + anchorX, y: y * cos + x * sin + anchorY };\n    };\n}\nexports.rotateAroundFn = rotateAroundFn;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/math.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/message/unfurleventmessage.js":
/*!************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/message/unfurleventmessage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeUnfurlEventMessage = exports.deserializeUnfurlEventMessage = void 0;\n/** @ignore */\nfunction deserializeUnfurlEventMessage(raw) {\n    return {\n        id: raw['id'],\n        url: raw['u'],\n        unfurlCallbackType: raw['t'],\n        blockId: raw['b'],\n    };\n}\nexports.deserializeUnfurlEventMessage = deserializeUnfurlEventMessage;\n/** @ignore */\nfunction serializeUnfurlEventMessage(concrete) {\n    return {\n        'id': concrete.id,\n        'u': concrete.url,\n        't': concrete.unfurlCallbackType,\n        'b': concrete.blockId,\n    };\n}\nexports.serializeUnfurlEventMessage = serializeUnfurlEventMessage;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/message/unfurleventmessage.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/alertmodal.js":
/*!***********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/alertmodal.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlertModal = void 0;\nconst modal_1 = __webpack_require__(/*! ./modal */ \"./node_modules/lucid-extension-sdk/ui/modal.js\");\n/**\n * A simple example modal that displays a message to the user\n * TODO: Replace with a dedicated command\n * @ignore\n */\nclass AlertModal extends modal_1.Modal {\n    constructor(client, title, message) {\n        super(client, {\n            width: 300,\n            height: 200,\n            title: title,\n            content: `\n<html>\n<head>\n<style type=\"text/css\">\np {\n    font-family: 'Graphik LC Web', sans-serif;\n    font-size:14px;\n    text-align:center;\n}\n</style>\n</head>\n<body>\n<p id=\"message\"></p>\n<script type=\"text/javascript\">\n    var p = document.getElementById('message');\n    p.innerText = ${JSON.stringify(message)};\n</script>\n</body>\n</html>\n            `,\n        });\n    }\n}\nexports.AlertModal = AlertModal;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/ui/alertmodal.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/iframeui.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/iframeui.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IframeUI = exports.IncomingUIMessageType = void 0;\nconst defer_1 = __webpack_require__(/*! ../core/defer */ \"./node_modules/lucid-extension-sdk/core/defer.js\");\n/** @ignore */\nvar IncomingUIMessageType;\n(function (IncomingUIMessageType) {\n    IncomingUIMessageType[IncomingUIMessageType[\"Closed\"] = 1] = \"Closed\";\n    IncomingUIMessageType[IncomingUIMessageType[\"PostMessageFromFrame\"] = 2] = \"PostMessageFromFrame\";\n    IncomingUIMessageType[IncomingUIMessageType[\"FrameLoaded\"] = 3] = \"FrameLoaded\";\n    IncomingUIMessageType[IncomingUIMessageType[\"FramePosition\"] = 4] = \"FramePosition\";\n})(IncomingUIMessageType || (exports.IncomingUIMessageType = IncomingUIMessageType = {}));\n/**\n * Base class for defining and interacting with custom UI elements whose contents are displayed\n * in an iframe.\n */\nclass IframeUI {\n    constructor(client) {\n        this.client = client;\n        this.id = ++IframeUI.nextId;\n        this.messageActionName = IframeUI.uiMessageActionNamePrefix + this.id;\n        /** True after the iframe has fired an onload event (not all scripts are necessarily finished executing) */\n        this.loaded = false;\n        this.frameLoadedPromise = (0, defer_1.defer)();\n        /**\n         * The location of this frame within the top-level browser window. This is always updated immediately before\n         * `messageFromFrame` is called.\n         */\n        this.framePosition = { x: 0, y: 0, w: 1, h: 1 };\n    }\n    /** @ignore */\n    static isUIMessageActionName(name) {\n        return name.startsWith(IframeUI.uiMessageActionNamePrefix);\n    }\n    /**\n     * Subclasses must call hookMessages some time before the UI is displayed. A Modal\n     * will call this when the open() method is called, where a Panel will need to do\n     * this in the constructor to watch for the user opening the panel.\n     */\n    hookMessages() {\n        this.client.registerAction(this.messageActionName, (message) => {\n            switch (message['t']) {\n                case IncomingUIMessageType.Closed:\n                    this.loaded = false;\n                    this.frameClosed();\n                    break;\n                case IncomingUIMessageType.PostMessageFromFrame:\n                    this.messageFromFrame(message['data']);\n                    break;\n                case IncomingUIMessageType.FramePosition:\n                    this.framePosition = message['data'];\n                    break;\n                case IncomingUIMessageType.FrameLoaded:\n                    this.loaded = true;\n                    this.frameLoadedPromise.resolve();\n                    this.frameLoaded();\n                    break;\n            }\n        });\n    }\n    /**\n     * Subclasses must call unhookMessages to allow them to be garbage collected.\n     */\n    unhookMessages() {\n        this.client.deleteAction(this.messageActionName);\n    }\n    /**\n     * Send a message to this UI component's iframe via window.postMessage.\n     * @param data Data to send to the iframe\n     */\n    async sendMessage(data) {\n        await this.frameLoadedPromise;\n        this.client.sendCommand(\"suim\" /* CommandName.SendUIMessage */, {\n            'n': this.messageActionName,\n            'd': data,\n        });\n    }\n    /**\n     * Receives messages sent from the iframe via parent.postMessage(<data>, '*')\n     * @param message data sent from the iframe\n     */\n    messageFromFrame(message) { }\n    /**\n     * Called when the iframe has been constructed, its srcdoc set, and the window loaded event has fired\n     */\n    frameLoaded() { }\n    /**\n     * Called when the iframe has been removed from the DOM\n     */\n    frameClosed() { }\n}\nexports.IframeUI = IframeUI;\nIframeUI.nextId = 0;\nIframeUI.uiMessageActionNamePrefix = '__ui_message__';\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/ui/iframeui.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/menu.js":
/*!*****************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/menu.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Menu = exports.MenuLocation = exports.MenuType = void 0;\n/**\n * Type of menu you're adding.\n * Consider using addDropdownMenuItem, addContextMenuItem, or addContentDockMenuItem for easier to use entrypoints and clearer requirements.\n */\nvar MenuType;\n(function (MenuType) {\n    /** The main drop down menus. */\n    MenuType[MenuType[\"Main\"] = 1] = \"Main\";\n    /** The context menu that appears when the user right-clicks the canvas. */\n    MenuType[MenuType[\"Context\"] = 2] = \"Context\";\n    /** The side dock in Lucidspark and Teamspaces */\n    MenuType[MenuType[\"ContentDock\"] = 3] = \"ContentDock\";\n})(MenuType || (exports.MenuType = MenuType = {}));\n/**\n * Semantic locations to place a new menu item.\n */\nvar MenuLocation;\n(function (MenuLocation) {\n    /** Default location: a new top-level menu entry for this extension, or the end of the context menu */\n    MenuLocation[MenuLocation[\"Extension\"] = 1] = \"Extension\";\n    MenuLocation[MenuLocation[\"Edit\"] = 2] = \"Edit\";\n    MenuLocation[MenuLocation[\"View\"] = 3] = \"View\";\n    MenuLocation[MenuLocation[\"Share\"] = 4] = \"Share\";\n    MenuLocation[MenuLocation[\"Export\"] = 5] = \"Export\";\n    MenuLocation[MenuLocation[\"Import\"] = 6] = \"Import\";\n})(MenuLocation || (exports.MenuLocation = MenuLocation = {}));\nclass Menu {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Generic function to create a new menu item to trigger custom code.\n     * You can use addDropdownMenuItem, addContextMenuItem, or addContentDockMenuItem for easier to use entrypoints.\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addMenuItem(item) {\n        if (item.action && !this.client.actionExists(item.action)) {\n            throw new Error('Unregistered action: ' + item.action);\n        }\n        if (item.visibleAction && !this.client.actionExists(item.visibleAction)) {\n            throw new Error('Unregistered action: ' + item.visibleAction);\n        }\n        if (item.disabledAction && !this.client.actionExists(item.disabledAction)) {\n            throw new Error('Unregistered action: ' + item.disabledAction);\n        }\n        if (item.menuType == MenuType.ContentDock && !item.iconUrl) {\n            throw new Error('MenuType.ContentDock requires icon url');\n        }\n        if (item.menuType == MenuType.ContentDock && !item.action) {\n            throw new Error('MenuType.ContentDock requires action');\n        }\n        this.client.sendCommand(\"ami\" /* CommandName.AddMenuItem */, {\n            'l': item.label,\n            'i': item.iconUrl,\n            'a': item.action,\n            'v': item.visibleAction,\n            'd': item.disabledAction,\n            't': item.menuType,\n            'loc': item.location,\n            'f': item.file\n                ? {\n                    'a': item.file.action,\n                    'ac': item.file.accept,\n                    's': item.file.singleFileOnly,\n                    'b': item.file.binary,\n                }\n                : undefined,\n        });\n    }\n    /**\n     * Create a menu in the basic drop down top menus. In Lucidspark this will just be under the generic menu.\n     * In Lucidchart you can configure this to be in any of the other drop down menus.\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addDropdownMenuItem(item) {\n        var _a;\n        this.addMenuItem({\n            label: item.label,\n            action: item.action,\n            visibleAction: item.visibleAction,\n            disabledAction: item.disabledAction,\n            menuType: MenuType.Main,\n            location: (_a = item.location) !== null && _a !== void 0 ? _a : MenuLocation.Extension,\n            file: item.file,\n        });\n    }\n    /**\n     * Create a menu in the right click context menu. Appears in both Lucidspark and Lucidchart.\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addContextMenuItem(item) {\n        this.addMenuItem({\n            label: item.label,\n            action: item.action,\n            visibleAction: item.visibleAction,\n            disabledAction: item.disabledAction,\n            menuType: MenuType.Context,\n            location: MenuLocation.Extension,\n            file: item.file,\n        });\n    }\n    /**\n     * Create an icon tied to an action (required) that appears in the left toolbar in Lucidspark and Teamspaces (not in Lucidchart).\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addContentDockMenuItem(item) {\n        this.addMenuItem({\n            label: item.label,\n            iconUrl: item.iconUrl,\n            action: item.action,\n            visibleAction: item.visibleAction,\n            disabledAction: item.disabledAction,\n            menuType: MenuType.ContentDock,\n            location: MenuLocation.Extension,\n            file: item.file,\n        });\n    }\n}\nexports.Menu = Menu;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/ui/menu.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/modal.js":
/*!******************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/modal.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Modal = void 0;\nconst iframeui_1 = __webpack_require__(/*! ./iframeui */ \"./node_modules/lucid-extension-sdk/ui/iframeui.js\");\n/**\n * Extend this class to show a custom modal to the user, whose contents are displayed in a sandboxed\n * iframe controlled by your extension.\n *\n * To pass a message to a script running in the modal, call sendMessage. The data you pass in will be\n * sent to the iframe with window.postMessage.\n *\n * To pass messages back from the modal to this class, call parent.postMessage from within the iframe.\n * The data sent will be passed along to the messageFromFrame implementation on your Modal class.\n */\nclass Modal extends iframeui_1.IframeUI {\n    constructor(client, config) {\n        super(client);\n        this.config = config;\n        this.visible = false;\n    }\n    frameClosed() {\n        this.visible = false;\n        this.unhookMessages();\n    }\n    async show() {\n        if (!this.visible) {\n            this.hookMessages();\n            await this.client.sendCommand(\"sm\" /* CommandName.ShowModal */, {\n                'n': this.messageActionName,\n                't': this.config.title,\n                'w': this.config.width,\n                'h': this.config.height,\n                'cl': this.config.chromeless,\n                'fs': this.config.fullScreen,\n                'tb': this.config.transparentBackground,\n                'c': this.config.content,\n                'u': this.config.url,\n            });\n            this.visible = true;\n        }\n    }\n    /**\n     * If this modal is currently visible, close it, destroying the iframe.\n     */\n    hide() {\n        if (this.visible) {\n            this.client.sendCommand(\"hm\" /* CommandName.HideModal */, { 'n': this.messageActionName });\n            this.visible = false;\n        }\n    }\n}\nexports.Modal = Modal;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/ui/modal.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/panel.js":
/*!******************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/panel.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Panel = exports.PanelLocation = void 0;\nconst iframeui_1 = __webpack_require__(/*! ./iframeui */ \"./node_modules/lucid-extension-sdk/ui/iframeui.js\");\n/**\n * Semantic locations to place a new menu item.\n */\nvar PanelLocation;\n(function (PanelLocation) {\n    /** In Lucidchart, create a sibling to the Contextual Panel */\n    PanelLocation[PanelLocation[\"RightDock\"] = 1] = \"RightDock\";\n    /** In Lucidchart, create a sibling to the shape toolbox */\n    PanelLocation[PanelLocation[\"ContentDock\"] = 2] = \"ContentDock\";\n    /** In Lucidchart & Lucidspark, add to the image dock */\n    PanelLocation[PanelLocation[\"ImageSearchTab\"] = 3] = \"ImageSearchTab\";\n})(PanelLocation || (exports.PanelLocation = PanelLocation = {}));\n/**\n * Extend this class to show a custom panel to the user, whose contents are displayed in a sandboxed\n * iframe controlled by your extension.\n *\n * To pass a message to a script running in the panel, call sendMessage. The data you pass in will be\n * sent to the iframe with window.postMessage.\n *\n * To pass messages back from the panel to this class, call parent.postMessage from within the iframe.\n * The data sent will be passed along to the messageFromFrame implementation on your Panel class.\n */\nclass Panel extends iframeui_1.IframeUI {\n    constructor(client, config) {\n        super(client);\n        this.config = config;\n        this.hookMessages();\n        this.client.sendCommand(\"rp\" /* CommandName.RegisterPanel */, {\n            'n': this.messageActionName,\n            't': this.config.title,\n            'l': this.config.location,\n            'c': this.config.content,\n            'u': this.config.url,\n            'v': this.config.visibleAction,\n            'i': this.config.iconUrl,\n            'to': this.config.toolTip,\n            'p': this.config.persist,\n            'w': this.config.width,\n            'h': this.config.height,\n        });\n    }\n    /**\n     * Show this panel if the panel is in the rightDock and it is not already visible.\n     */\n    show() {\n        if (this.config.location == PanelLocation.RightDock) {\n            this.client.sendCommand(\"spn\" /* CommandName.ShowPanel */, { 'n': this.messageActionName });\n        }\n    }\n    /**\n     * Hide this panel if the panel is in the rightDock and it is currently visible.\n     */\n    hide() {\n        if (this.config.location == PanelLocation.RightDock) {\n            this.client.sendCommand(\"hp\" /* CommandName.HidePanel */, { 'n': this.messageActionName });\n        }\n    }\n}\nexports.Panel = Panel;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/ui/panel.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/viewport.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/viewport.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Viewport = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst fillcolor_1 = __webpack_require__(/*! ../core/properties/fillcolor */ \"./node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst imagedefinition_1 = __webpack_require__(/*! ../document/imagedefinition */ \"./node_modules/lucid-extension-sdk/document/imagedefinition.js\");\nconst itemproxy_1 = __webpack_require__(/*! ../document/itemproxy */ \"./node_modules/lucid-extension-sdk/document/itemproxy.js\");\nconst pageproxy_1 = __webpack_require__(/*! ../document/pageproxy */ \"./node_modules/lucid-extension-sdk/document/pageproxy.js\");\nconst math_1 = __webpack_require__(/*! ../math */ \"./node_modules/lucid-extension-sdk/math.js\");\nclass Viewport {\n    constructor(client) {\n        this.client = client;\n    }\n    static nextHookName() {\n        return '__viewport__hook' + Viewport.nextHookId++;\n    }\n    /**\n     * @param deep If true, and groups are selected, include the contents of those groups in the array\n     * @returns An array of currently-selected items on the currently-visible page\n     */\n    getSelectedItems(deep) {\n        const ids = this.client.sendCommand(\"gs\" /* CommandName.GetSelection */, { 'd': deep });\n        return ids\n            .map((id) => this.client.getElementProxy(id))\n            .filter((proxy) => proxy instanceof itemproxy_1.ItemProxy);\n    }\n    /**\n     * Unselect all currently-selected items, and select the subset of the given items that exist on\n     * the currently-visible page.\n     * @param items\n     */\n    setSelectedItems(items) {\n        this.client.sendCommand(\"ss\" /* CommandName.SetSelection */, { 'i': items.map((i) => i.id) });\n    }\n    /**\n     * Find available space on the current page for adding new content.\n     * @param width\n     * @param height\n     * @returns a reference to the page and origin (upper-left point) of the space you can add new\n     * content of the given size to.\n     */\n    findAvailableSpace(width, height) {\n        const result = this.client.sendCommand(\"fas\" /* CommandName.FindAvailableSpace */, { 'w': width, 'h': height });\n        return {\n            page: new pageproxy_1.PageProxy(result['p'], this.client),\n            x: result['x'],\n            y: result['y'],\n        };\n    }\n    /**\n     * @returns the page currently being viewed\n     */\n    getCurrentPage() {\n        const id = this.client.sendCommand(\"gcp\" /* CommandName.GetCurrentPage */, undefined);\n        return id == null ? id : new pageproxy_1.PageProxy(id, this.client);\n    }\n    /**\n     * View the given page in the viewport\n     * @param page The page to view\n     */\n    setCurrentPage(page) {\n        this.client.sendCommand(\"scp\" /* CommandName.SetCurrentPage */, page.id);\n    }\n    /**\n     * @returns the box for the current viewport location\n     */\n    getVisibleRect() {\n        return this.client.sendCommand(\"gvr\" /* CommandName.GetVisibleRect */, undefined);\n    }\n    /**\n     * Switch to the page containing these items, if necessary, and then animate the viewport\n     * to zoom in and focus on these items.\n     * @param items The items the camera should zoom to\n     */\n    focusCameraOnItems(items) {\n        const bb = (0, math_1.combinedBoundingBox)(items.map((e) => e.getBoundingBox()));\n        if (bb && items[0]) {\n            //TODO: A reasonable max zoom level (e.g. 200%)\n            this.client.sendCommand(\"av\" /* CommandName.AnimateViewport */, {\n                'bb': (0, math_1.padBox)(bb, 80),\n                'p': items[0].getPage().id,\n            });\n        }\n    }\n    /**\n     * If {@link callback} returns false, text editing is prevented.\n     * If {@link callback} returns true, text editing continues as normal.\n     *\n     * If {@link callback} returns a {@link TextEditCompletionCallback}(/extension-sdk/#modules_ui_viewport_texteditcompletioncallback),\n     * then text editing is allowed, but that completion callback is called.\n     *\n     * when the user finishes editing that text. That completion callback may return true or false to allow or deny the edit, or\n     * also may return a replacement string to use instead of the text the user actually typed. If replacement text is provided,\n     * it will be styled as close to the original as possible, but styles that apply to only parts of the original text will be\n     * discarded.\n     *\n     * @param callback Called just before the user starts editing text.\n     * @param eager Whether to trigger the callback eagerly during text edit\n     *\n     * @returns A handle representing this hook, which can be passed to unhookTextEdit to remove this hook.\n     */\n    hookTextEdit(callback, eager) {\n        const actionName = Viewport.nextHookName();\n        this.client.registerAction(actionName, async (textHookParam) => {\n            const element = this.client.getElementProxy(textHookParam['i']);\n            if (element instanceof itemproxy_1.ItemProxy) {\n                const result = await callback(element, textHookParam['t'], textHookParam['v']);\n                if ((0, checks_1.isBoolean)(result)) {\n                    return result;\n                }\n                else {\n                    const completeName = Viewport.nextHookName();\n                    this.client.registerAction(completeName, (textCompleteParam) => {\n                        this.client.deleteAction(completeName);\n                        return result(textCompleteParam['v']);\n                    });\n                    return completeName;\n                }\n            }\n            else {\n                //Shouldn't be possible, but just in case allow text editing as normal\n                return true;\n            }\n        });\n        this.client.sendCommand(\"hte\" /* CommandName.HookTextEdit */, { 'n': actionName, 'e': !!eager });\n        return actionName;\n    }\n    /**\n     * Remove a hook set by hookTextEdit.\n     *\n     * @param handle The return value of hookTextEdit.\n     */\n    unhookTextEdit(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"ute\" /* CommandName.UnhookTextEdit */, { 'n': handle });\n    }\n    /**\n     * @param callback Called when the user changes their selection of items\n     *\n     * @returns A handle representing this hook, which can be passed to unhookSelection to remove this hook.\n     */\n    hookSelection(callback) {\n        const actionName = Viewport.nextHookName();\n        this.client.registerAction(actionName, async (param) => {\n            const elements = param['ids']\n                .map((id) => this.client.getElementProxy(id))\n                .filter((element) => element instanceof itemproxy_1.ItemProxy);\n            callback(elements);\n        });\n        this.client.sendCommand(\"hs\" /* CommandName.HookSelection */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * Remove a hook set by hookSelection.\n     *\n     * @param handle The return value of hookSelection.\n     */\n    unhookSelection(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"us\" /* CommandName.UnhookSelection */, { 'n': handle });\n    }\n    /**\n     * Start an interaction of the current user dragging a new block onto the current page, exactly\n     * as if they started dragging that block out of the normal toolbox. At the time this function is\n     * called, the user's primary mouse button should be down (e.g. in a mousedown event handler).\n     *\n     * @param definition Definition of the block to create if and where the user drops it on-canvas\n     * @returns A promise resolving to a reference to the created block, if successfully dropped,\n     *  or undefined if the user cancels the drag interaction.\n     */\n    async startDraggingNewBlock(definition) {\n        var _a;\n        const properties = (_a = definition.properties) !== null && _a !== void 0 ? _a : {};\n        if (definition.fillStyle !== undefined) {\n            properties['FillColor'] = (0, fillcolor_1.serializeSimpleFill)(definition.fillStyle);\n        }\n        if (definition.lineWidth !== undefined) {\n            properties['LineWidth'] = definition.lineWidth;\n        }\n        const maybeBlockId = await this.client.sendCommand(\"sdc\" /* CommandName.StartDragBlockToCanvas */, {\n            'c': definition.className,\n            'sz': {\n                'w': definition.boundingBox.w,\n                'h': definition.boundingBox.h,\n            },\n            'p': properties,\n            's': definition.stencil,\n        });\n        return maybeBlockId ? this.client.getBlockProxy(maybeBlockId) : undefined;\n    }\n    /**\n     * Start an interaction of the current user dragging a new image onto the current page, exactly\n     * as if they started dragging that image out of the normal toolbox. At the time this function is\n     * called, the user's primary mouse button should be down (e.g. in a mousedown event handler).\n     *\n     * @param definition Definition of the image to create if and where the user drops it on-canvas\n     * @returns A promise resolving to a reference to the created image, if successfully dropped,\n     *  or undefined if the user cancels the drag interaction.\n     */\n    async startDraggingNewImage(definition) {\n        await this.client.loadBlockClasses(['UserImage2Block']);\n        return await this.startDraggingNewBlock((0, imagedefinition_1.imageToBlockDefinition)(definition));\n    }\n    /**\n     * If startDraggingNewBlock has been called, and the drag-new-block interaction is still active,\n     * cancel that interaction.\n     */\n    cancelDraggingNewBlock() {\n        this.client.sendCommand(\"cdc\" /* CommandName.CancelDragBlockToCanvas */, undefined);\n    }\n    /**\n     * If startDraggingNewImage has been called, and the drag-new-image interaction is still active,\n     * cancel that interaction.\n     */\n    cancelDraggingNewImage() {\n        this.cancelDraggingNewBlock();\n    }\n    /**\n     * After calling startDraggingNewBlock, call this to simulate the user moving the mouse at the\n     * given location within the top-level browser window.\n     *\n     * This has no effect if the drag-new-block interaction is not active.\n     *\n     * To convert a position in a Panel's iframe to a position in the top-level browser window,\n     * add the IframeUI.framePosition.\n     */\n    dragPointerMove(x, y) {\n        this.client.sendCommand(\"dpm\" /* CommandName.DragPointerMove */, { x, y });\n    }\n    /**\n     * After calling startDraggingNewBlock, call this to simulate the user releasing the mouse\n     * button at the given location within the top-level browser window.\n     *\n     * This has no effect if the drag-new-block interaction is not active.\n     *\n     * To convert a position in a Panel's iframe to a position in the top-level browser window,\n     * add the IframeUI.framePosition.\n     */\n    dragPointerUp(x, y) {\n        this.client.sendCommand(\"dpu\" /* CommandName.DragPointerUp */, { x, y });\n    }\n}\nexports.Viewport = Viewport;\nViewport.nextHookId = 0;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/ui/viewport.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/user/userproxy.js":
/*!************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/user/userproxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UserProxy = void 0;\n/**\n * The UserProxy class gives access to the current user on the current Lucid document.\n */\nclass UserProxy {\n    constructor(client) {\n        this.client = client;\n        this.id = this.client.sendCommand(\"guid\" /* CommandName.GetUserId */, undefined);\n    }\n    /**\n     * @returns the permission the user has on the current document.\n     */\n    getAccessPermssionOnDocument() {\n        return this.client.sendCommand(\"gdap\" /* CommandName.GetDocumentAccessPermission */, undefined);\n    }\n}\nexports.UserProxy = UserProxy;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./node_modules/lucid-extension-sdk/user/userproxy.js?");

/***/ }),

/***/ "./src/core/ModelDefinitionPageBuilder.ts":
/*!************************************************!*\
  !*** ./src/core/ModelDefinitionPageBuilder.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelDefinitionPageBuilder = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nclass ModelDefinitionPageBuilder {\n    constructor(storageAdapter, elementFactory) {\n        this.storageAdapter = storageAdapter;\n        this.elementFactory = elementFactory;\n        this.loggingEnabled = true;\n    }\n    /**\n     * Method to toggle logging\n     */\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    /**\n     * Checks if logging is enabled\n     */\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    /**\n     * Logs a message if logging is enabled\n     */\n    log(message, level = 'log') {\n        if (this.isLoggingEnabled()) {\n            console[level](`[${this.constructor.name}] ${message}`);\n        }\n    }\n    /**\n     * Builds a ModelDefinition from an existing converted page\n     */\n    buildFromConvertedPage(page) {\n        var _a, _b;\n        try {\n            // First validate that we have a valid page\n            if (!page) {\n                this.log('Page is undefined', 'error');\n                return null;\n            }\n            // Log page details\n            this.log('Page details:', 'log');\n            this.log(JSON.stringify({\n                pageExists: !!page,\n                pageId: page.id,\n                pageTitle: (_a = page.getTitle) === null || _a === void 0 ? void 0 : _a.call(page),\n                hasAllBlocks: 'allBlocks' in page,\n                hasGetTitle: 'getTitle' in page,\n                constructor: page.constructor.name\n            }));\n            this.log(`Starting model definition build for page ${page.id}`);\n            // Add explicit type check before creating ModelLucid\n            if (!this.elementFactory.isPageProxy(page)) {\n                this.log('Invalid page proxy provided', 'error');\n                return null;\n            }\n            // Create ModelLucid using the element factory\n            let modelLucid;\n            try {\n                modelLucid = this.elementFactory.createPlatformObject(page, shared_1.SimulationObjectType.Model);\n                if (!modelLucid) {\n                    this.log('Failed to create ModelLucid', 'error');\n                    return null;\n                }\n            }\n            catch (error) {\n                this.log(`Error creating ModelLucid: ${error instanceof Error ? error.message : String(error)}`, 'error');\n                if (error instanceof Error && error.stack) {\n                    this.log(`Stack trace: ${error.stack}`, 'error');\n                }\n                return null;\n            }\n            let modelData;\n            try {\n                modelData = modelLucid.getSimulationObject();\n                if (!modelData) {\n                    this.log('Model data is undefined', 'error');\n                    return null;\n                }\n            }\n            catch (error) {\n                this.log(`Error getting simulation object: ${error instanceof Error ? error.message : String(error)}`, 'error');\n                return null;\n            }\n            // Create initial ModelDefinition\n            const modelDefinition = new shared_1.ModelDefinition(modelData);\n            // Validate ModelDefinition initialization\n            const requiredManagers = [\n                'activities',\n                'connectors',\n                'resources',\n                'resourceRequirements',\n                'generators',\n                'entities'\n            ];\n            const managerKeys = requiredManagers;\n            for (const key of managerKeys) {\n                const manager = modelDefinition[key];\n                if (!manager || typeof manager.add !== 'function') {\n                    this.log(`ModelDefinition ${key} not properly initialized`, 'error');\n                    return null;\n                }\n            }\n            const processingOrder = [\n                shared_1.SimulationObjectType.Resource, // Process resources first to create requirements\n                shared_1.SimulationObjectType.Entity, // Then entities as they might be referenced\n                shared_1.SimulationObjectType.Activity, // Activities that use resources and entities\n                shared_1.SimulationObjectType.Generator // Generators that reference entities\n            ];\n            // Before first pass, pre-initialize the map with empty arrays for expected types\n            const blocksByType = new Map(processingOrder.map(type => [type, []]));\n            // First pass: Organize blocks by type\n            for (const [blockId, block] of page.allBlocks) {\n                const metadata = this.storageAdapter.getMetadata(block);\n                if (!metadata) {\n                    this.log(`No metadata found for block ${blockId}`, 'warn');\n                    continue;\n                }\n                (_b = blocksByType.get(metadata.type)) === null || _b === void 0 ? void 0 : _b.push(block);\n            }\n            // Process types in dependency order\n            // Process each type in order\n            for (const type of processingOrder) {\n                const blocks = blocksByType.get(type) || [];\n                this.log(`Processing ${blocks.length} blocks of type ${type}`);\n                for (const block of blocks) {\n                    try {\n                        const platformObject = this.elementFactory.createPlatformObject(block, type);\n                        const simObject = platformObject.getSimulationObject();\n                        switch (type) {\n                            case shared_1.SimulationObjectType.Resource:\n                                modelDefinition.resources.add(simObject);\n                                const requirement = shared_1.ResourceRequirement.createForSingleResource(simObject);\n                                modelDefinition.resourceRequirements.add(requirement);\n                                this.log(`Added resource and requirement: ${simObject.name}`);\n                                break;\n                            case shared_1.SimulationObjectType.Activity:\n                                modelDefinition.activities.add(simObject);\n                                this.log(`Added activity: ${simObject.name}`);\n                                break;\n                            case shared_1.SimulationObjectType.Generator:\n                                modelDefinition.generators.add(simObject);\n                                this.log(`Added generator: ${simObject.name}`);\n                                break;\n                            case shared_1.SimulationObjectType.Entity:\n                                modelDefinition.entities.add(simObject);\n                                this.log(`Added entity: ${simObject.name}`);\n                                break;\n                        }\n                    }\n                    catch (error) {\n                        this.log(`Error processing block of type ${type}: ${error}`, 'error');\n                    }\n                }\n            }\n            // Process all lines (connectors)\n            this.log(`Processing ${page.allLines.size} lines`);\n            for (const [lineId, line] of page.allLines) {\n                const metadata = this.storageAdapter.getMetadata(line);\n                if (!metadata || metadata.type !== shared_1.SimulationObjectType.Connector)\n                    continue;\n                try {\n                    const platformObject = this.elementFactory.createPlatformObject(line, metadata.type);\n                    const connector = platformObject.getSimulationObject();\n                    // Skip adding self-referencing connectors\n                    if (connector.sourceId && connector.targetId && connector.sourceId === connector.targetId) {\n                        this.log(`Skipping self-referencing connector from ${connector.sourceId} to itself`, 'warn');\n                        continue;\n                    }\n                    modelDefinition.connectors.add(connector);\n                }\n                catch (error) {\n                    this.log(`Error processing line ${lineId}`, 'error');\n                }\n            }\n            // Log summary with more detail\n            this.logModelDefinitionSummary(modelDefinition);\n            return modelDefinition;\n        }\n        catch (error) {\n            this.log(`Error building ModelDefinition: ${error instanceof Error ? error.message : 'Unknown error'}`, 'error');\n            if (error instanceof Error) {\n                this.log(`Error stack: ${error.stack}`, 'error');\n            }\n            return null;\n        }\n    }\n    /**\n     * Logs a summary of the ModelDefinition contents\n     */\n    logModelDefinitionSummary(modelDefinition) {\n        if (!this.isLoggingEnabled())\n            return;\n        this.log('Model Definition Summary:');\n        this.log(`- Model ID: ${modelDefinition.id}`);\n        this.log(`- Model Name: ${modelDefinition.name}`);\n        // Log activities with names\n        const activities = modelDefinition.activities.getAll();\n        this.log(`- Activities: ${activities.length}`);\n        activities.forEach((activity, index) => {\n            this.log(`  ${index + 1}. ${activity.name}`);\n        });\n        this.log(`- Generators: ${modelDefinition.generators.size()}`);\n        this.log(`- Resources: ${modelDefinition.resources.size()}`);\n        this.log(`- Requirements: ${modelDefinition.resourceRequirements.size()}`);\n        this.log(`- Entities: ${modelDefinition.entities.size()}`);\n        this.log(`- Connectors: ${modelDefinition.connectors.size()}`);\n    }\n}\nexports.ModelDefinitionPageBuilder = ModelDefinitionPageBuilder;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/core/ModelDefinitionPageBuilder.ts?");

/***/ }),

/***/ "./src/core/ModelManager.ts":
/*!**********************************!*\
  !*** ./src/core/ModelManager.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelManager = void 0;\n// import { ModelValidationService } from \"@quodsi/shared/src/validation/ModelValidationService\";\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nconst ModelDefinitionPageBuilder_1 = __webpack_require__(/*! ./ModelDefinitionPageBuilder */ \"./src/core/ModelDefinitionPageBuilder.ts\");\nconst ModelStructureBuilder_1 = __webpack_require__(/*! ../services/accordion/ModelStructureBuilder */ \"./src/services/accordion/ModelStructureBuilder.ts\");\nconst LucidElementFactory_1 = __webpack_require__(/*! ../services/LucidElementFactory */ \"./src/services/LucidElementFactory.ts\");\nclass ModelManager {\n    constructor(storageAdapter) {\n        this.loggingEnabled = false;\n        this.modelDefinition = null;\n        this.currentPage = null;\n        this.currentValidationResult = null;\n        // Change tracking\n        this.changeTracker = {\n            modelDefinitionDirty: false,\n            validationDirty: false,\n            lastModelDefinitionUpdate: 0,\n            lastValidationUpdate: 0,\n            pendingChanges: new Set()\n        };\n        this.storageAdapter = storageAdapter;\n        this.validationService = new shared_1.ModelValidationService();\n        this.log('ModelManager initialized');\n    }\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    log(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.log(`${ModelManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    logError(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.error(`${ModelManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    /**\n     * Marks the model as needing rebuild and validation\n     */\n    markModelDirty(elementId) {\n        this.changeTracker.modelDefinitionDirty = true;\n        this.changeTracker.validationDirty = true;\n        if (elementId) {\n            this.changeTracker.pendingChanges.add(elementId);\n        }\n    }\n    /**\n     * Checks if caches are still valid based on timeouts\n     */\n    checkCacheTimeouts() {\n        const now = Date.now();\n        // Check ModelDefinition cache timeout\n        if (now - this.changeTracker.lastModelDefinitionUpdate > ModelManager.MODEL_DEF_CACHE_TIMEOUT) {\n            this.changeTracker.modelDefinitionDirty = true;\n        }\n        // Check validation cache timeout\n        if (now - this.changeTracker.lastValidationUpdate > ModelManager.VALIDATION_CACHE_TIMEOUT) {\n            this.changeTracker.validationDirty = true;\n        }\n    }\n    /**\n     * Gets the current ModelDefinition, rebuilding if necessary\n     */\n    async ensureModelDefinition() {\n        this.checkCacheTimeouts();\n        if (this.changeTracker.modelDefinitionDirty && this.currentPage) {\n            this.log('Rebuilding ModelDefinition due to pending changes:', Array.from(this.changeTracker.pendingChanges));\n            const lucidElementFactory = new LucidElementFactory_1.LucidElementFactory(this.storageAdapter);\n            const builder = new ModelDefinitionPageBuilder_1.ModelDefinitionPageBuilder(this.storageAdapter, lucidElementFactory);\n            try {\n                const newModelDefinition = builder.buildFromConvertedPage(this.currentPage);\n                if (!newModelDefinition) {\n                    throw new Error('Builder returned null ModelDefinition');\n                }\n                if (!(newModelDefinition instanceof shared_1.ModelDefinition)) {\n                    throw new Error(`Invalid ModelDefinition type: ${typeof newModelDefinition}`);\n                }\n                // Verify activities manager\n                if (!newModelDefinition.activities) {\n                    throw new Error('activities property is undefined');\n                }\n                if (!(newModelDefinition.activities instanceof shared_1.ActivityListManager)) {\n                    throw new Error(`activities is not an ActivityListManager: ${typeof newModelDefinition.activities}`);\n                }\n                if (typeof newModelDefinition.activities.add !== 'function') {\n                    throw new Error(`activities.add is not a function: ${typeof newModelDefinition.activities.add}`);\n                }\n                // ModelDefinitionLogger.logModelDefinition(newModelDefinition)\n                this.modelDefinition = newModelDefinition;\n                this.changeTracker.modelDefinitionDirty = false;\n                this.changeTracker.lastModelDefinitionUpdate = Date.now();\n                this.changeTracker.pendingChanges.clear();\n                return this.modelDefinition;\n            }\n            catch (error) {\n                this.logError('Error ensuring ModelDefinition:', error);\n                throw error;\n            }\n        }\n        return this.modelDefinition;\n    }\n    /**\n     * Initializes a new model definition with data from storage\n     */\n    async initializeModel(modelData, pageProxy) {\n        this.currentPage = pageProxy;\n        // Force a rebuild for initialization\n        this.markModelDirty();\n        await this.ensureModelDefinition();\n        // Store the model data\n        this.storageAdapter.setElementData(pageProxy, modelData, shared_1.SimulationObjectType.Model);\n        await this.validateModel();\n    }\n    /**\n     * Registers a simulation element\n     */\n    async registerElement(element, elementProxy) {\n        if (element.type === shared_1.SimulationObjectType.Model) {\n            this.modelDefinition = new shared_1.ModelDefinition(element);\n            this.markModelDirty();\n            return;\n        }\n        const modelDef = await this.ensureModelDefinition();\n        if (!modelDef) {\n            throw new Error('Model not initialized');\n        }\n        // Get default name format\n        const defaultName = `New ${element.type}`;\n        // Register with appropriate list manager and update name if needed\n        switch (element.type) {\n            case shared_1.SimulationObjectType.Activity:\n                if (element.name === defaultName) {\n                    element.name = modelDef.activities.getNextName();\n                }\n                modelDef.activities.add(element);\n                break;\n            case shared_1.SimulationObjectType.Connector:\n                if (element.name === defaultName) {\n                    element.name = modelDef.connectors.getNextName();\n                }\n                modelDef.connectors.add(element);\n                break;\n            case shared_1.SimulationObjectType.Generator:\n                if (element.name === defaultName) {\n                    element.name = modelDef.generators.getNextName();\n                }\n                modelDef.generators.add(element);\n                break;\n            case shared_1.SimulationObjectType.Resource:\n                if (element.name === defaultName) {\n                    element.name = modelDef.resources.getNextName();\n                }\n                const resource = element;\n                modelDef.resources.add(resource);\n                const requirement = shared_1.ResourceRequirement.createForSingleResource(resource);\n                modelDef.resourceRequirements.add(requirement);\n                break;\n            case shared_1.SimulationObjectType.Entity:\n                if (element.name === defaultName) {\n                    element.name = modelDef.entities.getNextName();\n                }\n                modelDef.entities.add(element);\n                break;\n            default:\n                throw new Error(`Unknown element type: ${element.type}`);\n        }\n        this.markModelDirty(element.id);\n        await this.validateModelIfNeeded();\n    }\n    /**\n     * Updates an existing element\n     */\n    async updateElement(element) {\n        const modelDef = await this.ensureModelDefinition();\n        if (!modelDef || !this.currentPage) {\n            throw new Error('Model not initialized');\n        }\n        const elementProxy = this.findElementProxy(element.id);\n        if (!elementProxy) {\n            throw new Error(`No element found for ID: ${element.id}`);\n        }\n        // Update in appropriate list manager\n        switch (element.type) {\n            case shared_1.SimulationObjectType.Activity:\n                modelDef.activities.add(element);\n                break;\n            case shared_1.SimulationObjectType.Connector:\n                modelDef.connectors.add(element);\n                break;\n            case shared_1.SimulationObjectType.Generator:\n                modelDef.generators.add(element);\n                break;\n            case shared_1.SimulationObjectType.Resource:\n                const resource = element;\n                const requirement = shared_1.ResourceRequirement.createForSingleResource(resource);\n                modelDef.resources.add(resource);\n                modelDef.resourceRequirements.add(requirement);\n                break;\n            case shared_1.SimulationObjectType.Entity:\n                modelDef.entities.add(element);\n                break;\n        }\n        // Update storage\n        this.storageAdapter.updateElementData(elementProxy, element);\n        this.markModelDirty(element.id);\n        await this.validateModelIfNeeded();\n    }\n    /**\n     * Removes an element\n     */\n    async removeElement(elementId) {\n        const modelDef = await this.ensureModelDefinition();\n        if (!modelDef || !this.currentPage)\n            return;\n        const elementProxy = this.findElementProxy(elementId);\n        if (!elementProxy) {\n            console.warn(`No element found for ID: ${elementId}`);\n            return;\n        }\n        // Remove from all list managers\n        modelDef.activities.remove(elementId);\n        modelDef.connectors.remove(elementId);\n        modelDef.generators.remove(elementId);\n        modelDef.resources.remove(elementId);\n        modelDef.entities.remove(elementId);\n        modelDef.resourceRequirements.remove(elementId);\n        // Remove from storage\n        this.storageAdapter.clearElementData(elementProxy);\n        this.markModelDirty(elementId);\n        await this.validateModelIfNeeded();\n    }\n    /**\n     * Validates the model only if needed\n     */\n    async validateModelIfNeeded() {\n        this.checkCacheTimeouts();\n        if (!this.changeTracker.validationDirty) {\n            return this.currentValidationResult;\n        }\n        return await this.validateModel();\n    }\n    /**\n     * Forces a model validation\n     */\n    async validateModel() {\n        const modelDef = await this.ensureModelDefinition();\n        if (!modelDef) {\n            this.currentValidationResult = {\n                isValid: false,\n                errorCount: 1,\n                warningCount: 0,\n                messages: [{\n                        type: 'error',\n                        message: 'No model initialized'\n                    }]\n            };\n            return this.currentValidationResult;\n        }\n        const result = await this.validationService.validate(modelDef);\n        const errorCount = result.messages.filter(m => m.type === 'error').length;\n        const warningCount = result.messages.filter(m => m.type === 'warning').length;\n        this.currentValidationResult = Object.assign(Object.assign({}, result), { errorCount,\n            warningCount });\n        this.changeTracker.validationDirty = false;\n        this.changeTracker.lastValidationUpdate = Date.now();\n        return this.currentValidationResult;\n    }\n    // Other helper methods remain the same...\n    findElementProxy(elementId) {\n        if (!this.currentPage)\n            return null;\n        return this.currentPage.allBlocks.get(elementId) ||\n            this.currentPage.allLines.get(elementId);\n    }\n    getModel() {\n        var _a, _b;\n        return (_b = (_a = this.modelDefinition) === null || _a === void 0 ? void 0 : _a.model) !== null && _b !== void 0 ? _b : null;\n    }\n    async getModelDefinition() {\n        return await this.ensureModelDefinition();\n    }\n    getCurrentValidation() {\n        return this.currentValidationResult;\n    }\n    /**\n     * Gets an element by ID from any list manager\n     */\n    getElementById(id) {\n        if (!this.modelDefinition)\n            return undefined;\n        return this.modelDefinition.activities.get(id) ||\n            this.modelDefinition.connectors.get(id) ||\n            this.modelDefinition.generators.get(id) ||\n            this.modelDefinition.resources.get(id) ||\n            this.modelDefinition.resourceRequirements.get(id) ||\n            this.modelDefinition.entities.get(id);\n    }\n    /**\n     * Gets elements by type\n     */\n    getElementsByType(type) {\n        if (!this.modelDefinition)\n            return [];\n        switch (type) {\n            case shared_1.SimulationObjectType.Activity:\n                return this.modelDefinition.activities.getAll();\n            case shared_1.SimulationObjectType.Connector:\n                return this.modelDefinition.connectors.getAll();\n            case shared_1.SimulationObjectType.Generator:\n                return this.modelDefinition.generators.getAll();\n            case shared_1.SimulationObjectType.Resource:\n                return this.modelDefinition.resources.getAll();\n            case shared_1.SimulationObjectType.ResourceRequirement:\n                return this.modelDefinition.resourceRequirements.getAll();\n            case shared_1.SimulationObjectType.Entity:\n                return this.modelDefinition.entities.getAll();\n            default:\n                return [];\n        }\n    }\n    clear() {\n        if (this.modelDefinition && this.currentPage) {\n            for (const [, block] of this.currentPage.allBlocks) {\n                this.storageAdapter.clearElementData(block);\n            }\n            for (const [, line] of this.currentPage.allLines) {\n                this.storageAdapter.clearElementData(line);\n            }\n        }\n        this.modelDefinition = null;\n        this.currentPage = null;\n        this.currentValidationResult = null;\n        // Reset change tracking\n        this.changeTracker = {\n            modelDefinitionDirty: false,\n            validationDirty: false,\n            lastModelDefinitionUpdate: 0,\n            lastValidationUpdate: 0,\n            pendingChanges: new Set()\n        };\n    }\n    isQuodsiModel(page) {\n        return this.storageAdapter.isQuodsiModel(page);\n    }\n    getElementData(element) {\n        return this.storageAdapter.getElementData(element);\n    }\n    getMetadata(element) {\n        return this.storageAdapter.getMetadata(element);\n    }\n    setElementData(element, data, type, metadata) {\n        // Use the metadata if provided, otherwise use default metadata\n        const actualMetadata = metadata || {\n            id: element.id,\n            version: this.storageAdapter.CURRENT_VERSION\n        };\n        this.storageAdapter.setElementData(element, data, type, actualMetadata);\n        this.markModelDirty(element.id);\n    }\n    clearElementData(element) {\n        this.storageAdapter.clearElementData(element);\n        this.markModelDirty(element.id);\n    }\n    get CURRENT_VERSION() {\n        return this.storageAdapter.CURRENT_VERSION;\n    }\n    setExpandedNodes(page, nodes) {\n        this.storageAdapter.setExpandedNodes(page, nodes);\n    }\n    getExpandedNodes(page) {\n        return this.storageAdapter.getExpandedNodes(page);\n    }\n    /**\n     * Removes the model from the specified page and clears manager state\n     */\n    removeModelFromPage(page) {\n        if (!page) {\n            throw new Error('No page provided for model removal');\n        }\n        try {\n            this.storageAdapter.clearAllModelData(page);\n            // Clear all internal state\n            this.clear();\n        }\n        catch (error) {\n            this.logError('[ModelManager] Error removing model:', error);\n            throw new Error(`Failed to remove model: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    getStorageAdapter() {\n        return this.storageAdapter;\n    }\n    findPathToNode(modelStructure, nodeId) {\n        const pathNodes = new Set();\n        this.findPathToNodeRecursive(modelStructure.elements, nodeId, pathNodes);\n        return pathNodes;\n    }\n    findPathToNodeRecursive(elements, targetId, path) {\n        var _a;\n        for (const element of elements) {\n            if (element.id === targetId) {\n                return true;\n            }\n            if ((_a = element.children) === null || _a === void 0 ? void 0 : _a.length) {\n                if (this.findPathToNodeRecursive(element.children, targetId, path)) {\n                    path.add(element.id);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    isUnconvertedElement(element) {\n        return this.getElementData(element) === null;\n    }\n    /**\n     * Handles saving simulation element data and metadata\n     */\n    async saveElementData(element, data, type, page) {\n        // Handle conversion to NONE type (removing simulation data)\n        if (type === shared_1.SimulationObjectType.None) {\n            const existingElement = this.getElementById(element.id);\n            if (existingElement) {\n                this.removeElement(element.id);\n            }\n            return;\n        }\n        // Handle type conversion with no data\n        if (type && (!data || Object.keys(data).length === 0)) {\n            await this.handleTypeConversion(element, type, page);\n            return;\n        }\n        // Handle regular data update\n        await this.handleDataUpdate(element, data, type, page);\n    }\n    /**\n     * Handles converting an element to a new simulation type\n     */\n    async handleTypeConversion(element, newType, page) {\n        // Ensure model exists\n        if (!this.getModel()) {\n            const model = {\n                id: page.id,\n                name: page.getTitle() || 'New Model',\n                type: shared_1.SimulationObjectType.Model\n            };\n            await this.initializeModel(model, page);\n        }\n        // Create initial data\n        const elementName = this.getDefaultElementName(element);\n        const convertedData = {\n            id: element.id,\n            type: newType,\n            name: elementName\n        };\n        // Register and save\n        this.registerElement(convertedData, element);\n        this.setElementData(element, convertedData, newType, {\n            id: element.id,\n            version: this.CURRENT_VERSION\n        });\n    }\n    /**\n     * Handles updating element data\n     */\n    async handleDataUpdate(element, updateData, type, page) {\n        // Ensure model exists\n        if (!this.getModel()) {\n            const model = {\n                id: page.id,\n                name: page.getTitle() || 'New Model',\n                type: shared_1.SimulationObjectType.Model\n            };\n            await this.initializeModel(model, page);\n        }\n        // Preserve or set element name\n        const elementName = this.getDefaultElementName(element);\n        const elementData = Object.assign(Object.assign({ id: element.id, type: type }, updateData), { name: (updateData && typeof updateData === 'object' && !Array.isArray(updateData) && 'name' in updateData)\n                ? updateData.name || elementName\n                : elementName });\n        // Register and save\n        this.registerElement(elementData, element);\n        this.setElementData(element, elementData, type, {\n            id: element.id,\n            version: this.CURRENT_VERSION\n        });\n    }\n    /**\n     * Gets default name for an element based on its type\n     */\n    getDefaultElementName(element) {\n        return element instanceof lucid_extension_sdk_1.BlockProxy ?\n            (element.id || 'Unnamed Block') :\n            'Unnamed Connector';\n    }\n    async getModelStructure() {\n        const modelDef = await this.getModelDefinition();\n        if (modelDef) {\n            return ModelStructureBuilder_1.ModelStructureBuilder.buildModelStructure(modelDef);\n        }\n        return undefined;\n    }\n}\nexports.ModelManager = ModelManager;\nModelManager.LOG_PREFIX = '[ModelManager]';\n// Cache timeouts (in milliseconds)\nModelManager.VALIDATION_CACHE_TIMEOUT = 5000; // 5 seconds\nModelManager.MODEL_DEF_CACHE_TIMEOUT = 10000; // 10 seconds\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/core/ModelManager.ts?");

/***/ }),

/***/ "./src/core/StorageAdapter.ts":
/*!************************************!*\
  !*** ./src/core/StorageAdapter.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageAdapter = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nclass StorageAdapter {\n    constructor() {\n        this.loggingEnabled = false;\n        this.log('StorageAdapter initialized');\n    }\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    log(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.log(`${StorageAdapter.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    logError(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.error(`${StorageAdapter.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    /**\n     * Checks if an element has been converted to a Quodsi model element\n     */\n    isQuodsiModel(element) {\n        try {\n            const meta = this.getMetadata(element);\n            return meta !== null && meta.type === shared_1.SimulationObjectType.Model;\n        }\n        catch (error) {\n            this.logError('Error checking model status:', error);\n            return false;\n        }\n    }\n    /**\n     * Gets the expanded nodes state for a page\n     */\n    getExpandedNodes(page) {\n        try {\n            this.log('Getting expanded nodes for page:', page.id);\n            const expandedNodesStr = page.shapeData.get(StorageAdapter.EXPANDED_NODES_KEY);\n            if (!expandedNodesStr || typeof expandedNodesStr !== 'string') {\n                this.log('No expanded nodes found');\n                return [];\n            }\n            const nodes = JSON.parse(expandedNodesStr);\n            this.log('Retrieved expanded nodes:', nodes);\n            return nodes;\n        }\n        catch (error) {\n            this.logError('Error getting expanded nodes:', error);\n            return [];\n        }\n    }\n    /**\n     * Sets the expanded nodes state for a page\n     */\n    setExpandedNodes(page, nodeIds) {\n        try {\n            this.log('Setting expanded nodes for page:', {\n                pageId: page.id,\n                nodes: nodeIds\n            });\n            const serializedNodes = JSON.stringify(nodeIds);\n            page.shapeData.set(StorageAdapter.EXPANDED_NODES_KEY, serializedNodes);\n            this.log('Successfully set expanded nodes');\n        }\n        catch (error) {\n            this.logError('Error setting expanded nodes:', error);\n            throw error;\n        }\n    }\n    /**\n     * Sets the simulation status for a page\n     */\n    setSimulationStatus(page, status) {\n        try {\n            this.log('Setting simulation status for page:', {\n                pageId: page.id,\n                status\n            });\n            const serializedStatus = JSON.stringify(status);\n            page.shapeData.set(StorageAdapter.SIMULATION_STATUS_KEY, serializedStatus);\n            this.log('Successfully set simulation status');\n        }\n        catch (error) {\n            this.logError('Error setting simulation status:', error);\n            throw error;\n        }\n    }\n    /**\n     * Gets the simulation status for a page\n     */\n    getSimulationStatus(page) {\n        try {\n            this.log('Getting simulation status for page:', page.id);\n            const statusStr = page.shapeData.get(StorageAdapter.SIMULATION_STATUS_KEY);\n            if (!statusStr || typeof statusStr !== 'string') {\n                this.log('No simulation status found');\n                return null;\n            }\n            const status = JSON.parse(statusStr);\n            this.log('Retrieved simulation status:', status);\n            return status;\n        }\n        catch (error) {\n            this.logError('Error getting simulation status:', error);\n            return null;\n        }\n    }\n    /**\n     * Clears the simulation status for a page\n     */\n    clearSimulationStatus(page) {\n        try {\n            page.shapeData.delete(StorageAdapter.SIMULATION_STATUS_KEY);\n            this.log('Successfully cleared simulation status');\n        }\n        catch (error) {\n            this.logError('Error clearing simulation status:', error);\n            throw error;\n        }\n    }\n    /**\n     * Clears the expanded nodes state for a page\n     */\n    clearExpandedNodes(page) {\n        try {\n            page.shapeData.delete(StorageAdapter.EXPANDED_NODES_KEY);\n            this.log('Successfully cleared expanded nodes');\n        }\n        catch (error) {\n            this.logError('Error clearing expanded nodes:', error);\n            throw error;\n        }\n    }\n    /**\n     * Sets both data and metadata for an element, keeping them properly separated\n     */\n    setElementData(element, data, type, options = {}) {\n        try {\n            // Create clean metadata without any data fields\n            const meta = {\n                type,\n                version: options.version || this.CURRENT_VERSION,\n                lastModified: new Date().toISOString(),\n                id: data.id // Use the ID from the data object\n            };\n            // Create a clean data object without metadata fields\n            const cleanData = this.stripMetadataFields(data);\n            // Serialize both separately\n            const serializedData = JSON.stringify(cleanData);\n            const serializedMeta = JSON.stringify(meta);\n            // Store separately\n            element.shapeData.set(StorageAdapter.DATA_KEY, serializedData);\n            element.shapeData.set(StorageAdapter.META_KEY, serializedMeta);\n            this.log('Successfully set element data:', {\n                elementId: data.id,\n                type: type,\n                dataKeys: Object.keys(cleanData)\n            });\n        }\n        catch (error) {\n            this.logError('Error setting element data:', error);\n            throw error;\n        }\n    }\n    /**\n     * Updates only the data portion of an element's storage\n     */\n    updateElementData(element, data) {\n        try {\n            const existingMeta = this.getMetadata(element);\n            if (!existingMeta) {\n                throw new Error('No metadata found for element');\n            }\n            // Clean the data object before storing\n            const cleanData = this.stripMetadataFields(data);\n            const serializedData = JSON.stringify(cleanData);\n            // Update data\n            element.shapeData.set(StorageAdapter.DATA_KEY, serializedData);\n            // Update lastModified in metadata\n            existingMeta.lastModified = new Date().toISOString();\n            const serializedMeta = JSON.stringify(existingMeta);\n            element.shapeData.set(StorageAdapter.META_KEY, serializedMeta);\n            this.log('Successfully updated element data:', {\n                elementId: data.id,\n                type: existingMeta.type\n            });\n        }\n        catch (error) {\n            this.logError('Error updating element data:', error);\n            throw new Error(`Failed to update element data: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n     * Strips metadata fields from a data object\n     */\n    stripMetadataFields(data) {\n        const cleanData = Object.assign({}, data);\n        // Remove metadata fields if they exist, except 'id' which is needed in both\n        const metadataFields = ['version', 'type', 'lastModified'];\n        metadataFields.forEach(field => {\n            delete cleanData[field];\n        });\n        return cleanData;\n    }\n    /**\n     * Retrieves metadata for an element\n     */\n    getMetadata(element) {\n        try {\n            const metaStr = element.shapeData.get(StorageAdapter.META_KEY);\n            if (!metaStr || typeof metaStr !== 'string')\n                return null;\n            return JSON.parse(metaStr);\n        }\n        catch (error) {\n            this.logError('Error getting metadata:', error);\n            return null;\n        }\n    }\n    /**\n     * Retrieves data portion for an element\n     */\n    getElementData(element) {\n        try {\n            this.log('Getting element data:', {\n                elementId: element.id,\n                elementType: typeof element,\n                contextInfo: 'Attempting to retrieve stored data'\n            });\n            const dataStr = element.shapeData.get(StorageAdapter.DATA_KEY);\n            this.log('Raw data string:', {\n                exists: !!dataStr,\n                isString: typeof dataStr === 'string',\n                valueType: typeof dataStr,\n                preview: typeof dataStr === 'string' ?\n                    `${dataStr.slice(0, 100)}${dataStr.length > 100 ? '...' : ''}` :\n                    String(dataStr)\n            });\n            if (!dataStr || typeof dataStr !== 'string') {\n                this.log('No valid data found for element:', element.id);\n                return null;\n            }\n            const parsedData = JSON.parse(dataStr);\n            this.log('Successfully parsed element data:', {\n                elementId: element.id,\n                parsedDataKeys: Object.keys(parsedData),\n                timestamp: new Date().toISOString()\n            });\n            return parsedData;\n        }\n        catch (error) {\n            this.logError('Error getting element data:', {\n                elementId: element.id,\n                error: error instanceof Error ? error.message : 'Unknown error',\n                stack: error instanceof Error ? error.stack : undefined,\n                timestamp: new Date().toISOString()\n            });\n            return null;\n        }\n    }\n    /**\n     * Gets both data and metadata as a complete storage format\n     */\n    getCompleteStorage(element) {\n        try {\n            const meta = this.getMetadata(element);\n            const data = this.getElementData(element);\n            if (!meta || !data)\n                return null;\n            return { data, meta };\n        }\n        catch (error) {\n            this.logError('Error getting complete storage:', error);\n            return null;\n        }\n    }\n    /**\n     * Removes all Quodsi-related data from an element\n     */\n    clearElementData(element) {\n        try {\n            const keys = [StorageAdapter.DATA_KEY, StorageAdapter.META_KEY];\n            for (const key of keys) {\n                // Check if the data exists first\n                const value = element.shapeData.get(key);\n                if (value !== undefined) {\n                    try {\n                        element.shapeData.delete(key);\n                    }\n                    catch (_a) {\n                        // If delete fails, try setting to empty string as fallback\n                        element.shapeData.set(key, '');\n                    }\n                    this.log(`Cleared ${key} from element:`, element.id);\n                }\n                else {\n                    this.log(`No ${key} found on element:`, element.id);\n                }\n            }\n        }\n        catch (error) {\n            this.logError('Error clearing element data:', error);\n            throw new Error(`Failed to clear element data: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n     * Validates that an element has both required storage components\n     */\n    validateStorage(element) {\n        try {\n            const dataStr = element.shapeData.get(StorageAdapter.DATA_KEY);\n            const metaStr = element.shapeData.get(StorageAdapter.META_KEY);\n            return typeof dataStr === 'string' && typeof metaStr === 'string';\n        }\n        catch (error) {\n            this.logError('Error validating storage:', error);\n            return false;\n        }\n    }\n    /**\n     * Gets the current version number used by the storage adapter\n     */\n    get CURRENT_VERSION() {\n        return StorageAdapter.CURRENT_VERSION;\n    }\n    clearLegacyData(element) {\n        for (const key of StorageAdapter.LEGACY_KEYS) {\n            try {\n                const value = element.shapeData.get(key);\n                if (value !== undefined) {\n                    try {\n                        element.shapeData.delete(key);\n                        this.log(`Successfully deleted legacy key '${key}' from element ${element.id}`);\n                    }\n                    catch (_a) {\n                        element.shapeData.set(key, '');\n                        this.log(`Set legacy key '${key}' to empty on element ${element.id} (delete failed)`);\n                    }\n                }\n            }\n            catch (error) {\n                this.logError(`Error handling legacy key '${key}' for element ${element.id}:`, error);\n            }\n        }\n    }\n    clearAllModelData(page) {\n        try {\n            // Clear model data from page\n            this.clearExpandedNodes(page);\n            this.clearElementData(page);\n            this.clearSimulationStatus(page);\n            // Clear data from all blocks\n            for (const [, block] of page.allBlocks) {\n                this.clearElementData(block);\n                this.clearLegacyData(block);\n            }\n            // Clear data from all lines\n            for (const [, line] of page.allLines) {\n                this.clearElementData(line);\n                this.clearLegacyData(line);\n            }\n        }\n        catch (error) {\n            this.logError('Error clearing model data:', error);\n            throw error;\n        }\n    }\n}\nexports.StorageAdapter = StorageAdapter;\nStorageAdapter.LEGACY_KEYS = [\n    'q_objecttype',\n    'q_data',\n    'q_status_current',\n    'q_status_prior'\n];\nStorageAdapter.DATA_KEY = 'q_data';\nStorageAdapter.META_KEY = 'q_meta';\nStorageAdapter.EXPANDED_NODES_KEY = 'q_expanded_nodes';\nStorageAdapter.SIMULATION_STATUS_KEY = 'q_simulation_status';\nStorageAdapter.CURRENT_VERSION = '1.0.0';\nStorageAdapter.LOG_PREFIX = '[StorageAdapter]';\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/core/StorageAdapter.ts?");

/***/ }),

/***/ "./src/data_sources/base/DataSourceReader.ts":
/*!***************************************************!*\
  !*** ./src/data_sources/base/DataSourceReader.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataSourceReader = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\n/**\n * Base class for accessing data sources in LucidChart\n * Provides common methods for accessing data sources and collections\n */\nclass DataSourceReader {\n    constructor(client, dataSourceName) {\n        this.client = client;\n        this.dataProxy = new lucid_extension_sdk_1.DataProxy(client);\n        this.dataSourceName = dataSourceName;\n    }\n    /**\n     * Gets the data source by name\n     * @returns The data source if found, null otherwise\n     */\n    getDataSource() {\n        for (const [key, source] of this.dataProxy.dataSources) {\n            if (source.getName() === this.dataSourceName) {\n                return source;\n            }\n        }\n        console.log(`Data source \"${this.dataSourceName}\" not found`);\n        return null;\n    }\n    /**\n     * Gets a collection from this data source by name\n     * @param collectionName The name of the collection to retrieve\n     * @returns The collection if found, null otherwise\n     */\n    async getCollectionByName(collectionName) {\n        const dataSource = this.getDataSource();\n        if (!dataSource)\n            return null;\n        for (const [collectionId, collection] of dataSource.collections) {\n            if (collection.getName() === collectionName) {\n                return collection;\n            }\n        }\n        console.log(`Collection \"${collectionName}\" not found in data source \"${this.dataSourceName}\"`);\n        return null;\n    }\n    /**\n     * Gets all collections from this data source\n     * @returns A map proxy of all collections in the data source, or null if the data source is not found\n     */\n    async getAllCollections() {\n        const dataSource = this.getDataSource();\n        if (!dataSource)\n            return null;\n        return dataSource.collections;\n    }\n}\nexports.DataSourceReader = DataSourceReader;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/base/DataSourceReader.ts?");

/***/ }),

/***/ "./src/data_sources/index.ts":
/*!***********************************!*\
  !*** ./src/data_sources/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelDataSource = exports.ModelReader = exports.SimulationResultsReader = void 0;\n// Export all data source readers\nvar SimulationResultsReader_1 = __webpack_require__(/*! ./simulation_results/SimulationResultsReader */ \"./src/data_sources/simulation_results/SimulationResultsReader.ts\");\nObject.defineProperty(exports, \"SimulationResultsReader\", ({ enumerable: true, get: function () { return SimulationResultsReader_1.SimulationResultsReader; } }));\nvar model_1 = __webpack_require__(/*! ./model */ \"./src/data_sources/model/index.ts\");\nObject.defineProperty(exports, \"ModelReader\", ({ enumerable: true, get: function () { return model_1.ModelReader; } }));\nObject.defineProperty(exports, \"ModelDataSource\", ({ enumerable: true, get: function () { return model_1.ModelDataSource; } }));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/index.ts?");

/***/ }),

/***/ "./src/data_sources/model/ModelDataSource.ts":
/*!***************************************************!*\
  !*** ./src/data_sources/model/ModelDataSource.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelDataSource = exports.MODEL_COLLECTIONS = void 0;\nconst ModelSchema_1 = __webpack_require__(/*! ./schemas/ModelSchema */ \"./src/data_sources/model/schemas/ModelSchema.ts\");\nconst ActivitySchema_1 = __webpack_require__(/*! ./schemas/ActivitySchema */ \"./src/data_sources/model/schemas/ActivitySchema.ts\");\nconst ResourceSchema_1 = __webpack_require__(/*! ./schemas/ResourceSchema */ \"./src/data_sources/model/schemas/ResourceSchema.ts\");\nconst EntitySchema_1 = __webpack_require__(/*! ./schemas/EntitySchema */ \"./src/data_sources/model/schemas/EntitySchema.ts\");\nconst GeneratorSchema_1 = __webpack_require__(/*! ./schemas/GeneratorSchema */ \"./src/data_sources/model/schemas/GeneratorSchema.ts\");\nconst ConnectorSchema_1 = __webpack_require__(/*! ./schemas/ConnectorSchema */ \"./src/data_sources/model/schemas/ConnectorSchema.ts\");\nconst OperationStepSchema_1 = __webpack_require__(/*! ./schemas/OperationStepSchema */ \"./src/data_sources/model/schemas/OperationStepSchema.ts\");\nconst ResourceRequirementSchema_1 = __webpack_require__(/*! ./schemas/ResourceRequirementSchema */ \"./src/data_sources/model/schemas/ResourceRequirementSchema.ts\");\nconst RequirementClauseSchema_1 = __webpack_require__(/*! ./schemas/RequirementClauseSchema */ \"./src/data_sources/model/schemas/RequirementClauseSchema.ts\");\nconst ResourceRequestSchema_1 = __webpack_require__(/*! ./schemas/ResourceRequestSchema */ \"./src/data_sources/model/schemas/ResourceRequestSchema.ts\");\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nexports.MODEL_COLLECTIONS = {\n    MODEL: \"model\",\n    ACTIVITIES: \"activities\",\n    RESOURCES: \"resources\",\n    ENTITIES: \"entities\",\n    GENERATORS: \"generators\",\n    CONNECTORS: \"connectors\",\n    OPERATION_STEPS: \"operationSteps\",\n    RESOURCE_REQUIREMENTS: \"resourceRequirements\",\n    REQUIREMENT_CLAUSES: \"requirementClauses\",\n    RESOURCE_REQUESTS: \"resourceRequests\"\n};\nclass ModelDataSource extends shared_1.QuodsiLogger {\n    constructor(data) {\n        super();\n        this.data = data;\n        this.LOG_PREFIX = '[ModelDataSource]';\n        this.collectionIds = {};\n        this.setLogging(true);\n    }\n    createModelDataSource(modelId, config = {}) {\n        this.log(`Creating data source for model ${modelId}`);\n        const source = this.data.addDataSource(`model_${modelId}`, config);\n        if (!source) {\n            this.logError('Failed to create data source');\n            return null;\n        }\n        try {\n            this.log(`Adding ${exports.MODEL_COLLECTIONS.MODEL} collection`);\n            const modelCollection = source.addCollection(exports.MODEL_COLLECTIONS.MODEL, ModelSchema_1.ModelSchema);\n            this.collectionIds[exports.MODEL_COLLECTIONS.MODEL] = (modelCollection === null || modelCollection === void 0 ? void 0 : modelCollection.id) || '';\n            this.log(`Model collection created with ID: ${this.collectionIds[exports.MODEL_COLLECTIONS.MODEL]}`);\n            this.log(`Adding ${exports.MODEL_COLLECTIONS.ACTIVITIES} collection`);\n            const activitiesCollection = source.addCollection(exports.MODEL_COLLECTIONS.ACTIVITIES, ActivitySchema_1.ActivitySchema);\n            this.collectionIds[exports.MODEL_COLLECTIONS.ACTIVITIES] = (activitiesCollection === null || activitiesCollection === void 0 ? void 0 : activitiesCollection.id) || '';\n            this.log(`Activities collection created with ID: ${this.collectionIds[exports.MODEL_COLLECTIONS.ACTIVITIES]}`);\n            this.log(`Adding ${exports.MODEL_COLLECTIONS.RESOURCES} collection`);\n            const resourcesCollection = source.addCollection(exports.MODEL_COLLECTIONS.RESOURCES, ResourceSchema_1.ResourceSchema);\n            this.collectionIds[exports.MODEL_COLLECTIONS.RESOURCES] = (resourcesCollection === null || resourcesCollection === void 0 ? void 0 : resourcesCollection.id) || '';\n            this.log(`Resources collection created with ID: ${this.collectionIds[exports.MODEL_COLLECTIONS.RESOURCES]}`);\n            this.log(`Adding ${exports.MODEL_COLLECTIONS.ENTITIES} collection`);\n            const entitiesCollection = source.addCollection(exports.MODEL_COLLECTIONS.ENTITIES, EntitySchema_1.EntitySchema);\n            this.collectionIds[exports.MODEL_COLLECTIONS.ENTITIES] = (entitiesCollection === null || entitiesCollection === void 0 ? void 0 : entitiesCollection.id) || '';\n            this.log(`Entities collection created with ID: ${this.collectionIds[exports.MODEL_COLLECTIONS.ENTITIES]}`);\n            this.log(`Adding ${exports.MODEL_COLLECTIONS.GENERATORS} collection`);\n            const generatorsCollection = source.addCollection(exports.MODEL_COLLECTIONS.GENERATORS, GeneratorSchema_1.GeneratorSchema);\n            this.collectionIds[exports.MODEL_COLLECTIONS.GENERATORS] = (generatorsCollection === null || generatorsCollection === void 0 ? void 0 : generatorsCollection.id) || '';\n            this.log(`Generators collection created with ID: ${this.collectionIds[exports.MODEL_COLLECTIONS.GENERATORS]}`);\n            this.log(`Adding ${exports.MODEL_COLLECTIONS.CONNECTORS} collection`);\n            const connectorsCollection = source.addCollection(exports.MODEL_COLLECTIONS.CONNECTORS, ConnectorSchema_1.ConnectorSchema);\n            this.collectionIds[exports.MODEL_COLLECTIONS.CONNECTORS] = (connectorsCollection === null || connectorsCollection === void 0 ? void 0 : connectorsCollection.id) || '';\n            this.log(`Connectors collection created with ID: ${this.collectionIds[exports.MODEL_COLLECTIONS.CONNECTORS]}`);\n            this.log(`Adding ${exports.MODEL_COLLECTIONS.OPERATION_STEPS} collection`);\n            const operationStepsCollection = source.addCollection(exports.MODEL_COLLECTIONS.OPERATION_STEPS, OperationStepSchema_1.OperationStepSchema);\n            this.collectionIds[exports.MODEL_COLLECTIONS.OPERATION_STEPS] = (operationStepsCollection === null || operationStepsCollection === void 0 ? void 0 : operationStepsCollection.id) || '';\n            this.log(`Operation steps collection created with ID: ${this.collectionIds[exports.MODEL_COLLECTIONS.OPERATION_STEPS]}`);\n            this.log(`Adding ${exports.MODEL_COLLECTIONS.RESOURCE_REQUIREMENTS} collection`);\n            const resourceRequirementsCollection = source.addCollection(exports.MODEL_COLLECTIONS.RESOURCE_REQUIREMENTS, ResourceRequirementSchema_1.ResourceRequirementSchema);\n            this.collectionIds[exports.MODEL_COLLECTIONS.RESOURCE_REQUIREMENTS] = (resourceRequirementsCollection === null || resourceRequirementsCollection === void 0 ? void 0 : resourceRequirementsCollection.id) || '';\n            this.log(`Resource requirements collection created with ID: ${this.collectionIds[exports.MODEL_COLLECTIONS.RESOURCE_REQUIREMENTS]}`);\n            this.log(`Adding ${exports.MODEL_COLLECTIONS.REQUIREMENT_CLAUSES} collection`);\n            const requirementClausesCollection = source.addCollection(exports.MODEL_COLLECTIONS.REQUIREMENT_CLAUSES, RequirementClauseSchema_1.RequirementClauseSchema);\n            this.collectionIds[exports.MODEL_COLLECTIONS.REQUIREMENT_CLAUSES] = (requirementClausesCollection === null || requirementClausesCollection === void 0 ? void 0 : requirementClausesCollection.id) || '';\n            this.log(`Requirement clauses collection created with ID: ${this.collectionIds[exports.MODEL_COLLECTIONS.REQUIREMENT_CLAUSES]}`);\n            this.log(`Adding ${exports.MODEL_COLLECTIONS.RESOURCE_REQUESTS} collection`);\n            const resourceRequestsCollection = source.addCollection(exports.MODEL_COLLECTIONS.RESOURCE_REQUESTS, ResourceRequestSchema_1.ResourceRequestSchema);\n            this.collectionIds[exports.MODEL_COLLECTIONS.RESOURCE_REQUESTS] = (resourceRequestsCollection === null || resourceRequestsCollection === void 0 ? void 0 : resourceRequestsCollection.id) || '';\n            this.log(`Resource requests collection created with ID: ${this.collectionIds[exports.MODEL_COLLECTIONS.RESOURCE_REQUESTS]}`);\n            this.log('Collection IDs:', this.collectionIds);\n        }\n        catch (error) {\n            this.logError('Error creating collections:', error);\n            return null;\n        }\n        return { source, collectionIds: this.collectionIds };\n    }\n    getModelDataSource(modelId) {\n        this.log(`Getting data source for model ${modelId}`);\n        const source = this.data.dataSources.get(`model_${modelId}`);\n        this.log(`Data source found:`, !!source);\n        return source;\n    }\n    getCollectionId(collectionName) {\n        return this.collectionIds[collectionName] || '';\n    }\n}\nexports.ModelDataSource = ModelDataSource;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/ModelDataSource.ts?");

/***/ }),

/***/ "./src/data_sources/model/ModelReader.ts":
/*!***********************************************!*\
  !*** ./src/data_sources/model/ModelReader.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelReader = void 0;\nconst DataSourceReader_1 = __webpack_require__(/*! ../base/DataSourceReader */ \"./src/data_sources/base/DataSourceReader.ts\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"./src/data_sources/model/schemas/index.ts\");\n/**\n * A class for reading Quodsi model data from LucidChart documents\n */\nclass ModelReader extends DataSourceReader_1.DataSourceReader {\n    /**\n     * Creates a new ModelReader instance\n     * @param client The EditorClient instance\n     * @param modelId Optional model ID to specify which model to read\n     */\n    constructor(client, modelId) {\n        super(client, modelId ? `model_${modelId}` : '');\n        this.modelId = modelId;\n    }\n    /**\n     * Sets the model ID to read\n     * @param modelId The model ID\n     */\n    setModelId(modelId) {\n        this.dataSourceName = `model_${modelId}`;\n        this.modelId = modelId;\n    }\n    /**\n     * Gets the current model ID\n     * @returns The current model ID or undefined if not set\n     */\n    getModelId() {\n        return this.modelId;\n    }\n    /**\n     * Checks if the model data source exists\n     * @returns True if the model data source exists, false otherwise\n     */\n    async hasModelDataSource() {\n        if (!this.modelId)\n            return false;\n        const dataSource = this.getDataSource();\n        return dataSource !== null;\n    }\n    /**\n     * Gets model data\n     * @returns Array of model data or empty array if not found\n     */\n    async getModelData() {\n        const collection = await this.getCollectionByName(schemas_1.MODEL_COLLECTIONS.MODEL);\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push(this.mapToModelData(item));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets all activities in the model\n     * @returns Array of activity data or empty array if not found\n     */\n    async getActivities() {\n        const collection = await this.getCollectionByName(schemas_1.MODEL_COLLECTIONS.ACTIVITIES);\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push(this.mapToActivityData(item));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets a specific activity by ID\n     * @param id The activity ID\n     * @returns The activity data or null if not found\n     */\n    async getActivity(id) {\n        const collection = await this.getCollectionByName(schemas_1.MODEL_COLLECTIONS.ACTIVITIES);\n        if (!collection)\n            return null;\n        const item = collection.items.get(id);\n        if (!item)\n            return null;\n        return this.mapToActivityData(item);\n    }\n    /**\n     * Gets all resources in the model\n     * @returns Array of resource data or empty array if not found\n     */\n    async getResources() {\n        const collection = await this.getCollectionByName(schemas_1.MODEL_COLLECTIONS.RESOURCES);\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push(this.mapToResourceData(item));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets all entities in the model\n     * @returns Array of entity data or empty array if not found\n     */\n    async getEntities() {\n        const collection = await this.getCollectionByName(schemas_1.MODEL_COLLECTIONS.ENTITIES);\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push(this.mapToEntityData(item));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets all generators in the model\n     * @returns Array of generator data or empty array if not found\n     */\n    async getGenerators() {\n        const collection = await this.getCollectionByName(schemas_1.MODEL_COLLECTIONS.GENERATORS);\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push(this.mapToGeneratorData(item));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets all connectors in the model\n     * @returns Array of connector data or empty array if not found\n     */\n    async getConnectors() {\n        const collection = await this.getCollectionByName(schemas_1.MODEL_COLLECTIONS.CONNECTORS);\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push(this.mapToConnectorData(item));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets all operation steps in the model\n     * @returns Array of operation step data or empty array if not found\n     */\n    async getOperationSteps() {\n        const collection = await this.getCollectionByName(schemas_1.MODEL_COLLECTIONS.OPERATION_STEPS);\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push(this.mapToOperationStepData(item));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets all resource requirements in the model\n     * @returns Array of resource requirement data or empty array if not found\n     */\n    async getResourceRequirements() {\n        const collection = await this.getCollectionByName(schemas_1.MODEL_COLLECTIONS.RESOURCE_REQUIREMENTS);\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push(this.mapToResourceRequirementData(item));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets all connectors that have a specific activity as source\n     * @param activityId The activity ID\n     * @returns Array of connectors or empty array if none found\n     */\n    async getOutgoingConnectors(activityId) {\n        const allConnectors = await this.getConnectors();\n        return allConnectors.filter(connector => connector.sourceId === activityId);\n    }\n    /**\n     * Gets all connectors that have a specific activity as target\n     * @param activityId The activity ID\n     * @returns Array of connectors or empty array if none found\n     */\n    async getIncomingConnectors(activityId) {\n        const allConnectors = await this.getConnectors();\n        return allConnectors.filter(connector => connector.targetId === activityId);\n    }\n    /**\n     * Gets all operation steps for a specific activity\n     * @param activityId The activity ID\n     * @returns Array of operation steps or empty array if none found\n     */\n    async getActivityOperationSteps(activityId) {\n        const allSteps = await this.getOperationSteps();\n        return allSteps.filter(step => step.activityId === activityId);\n    }\n    // Helper methods to map from DataItemProxy to strongly-typed objects\n    mapToModelData(item) {\n        return {\n            id: item.fields.get('id'),\n            name: item.fields.get('name'),\n            reps: item.fields.get('reps'),\n            forecastDays: item.fields.get('forecastDays'),\n            seed: item.fields.get('seed'),\n            oneClockUnit: item.fields.get('oneClockUnit'),\n            simulationTimeType: item.fields.get('simulationTimeType'),\n            warmupClockPeriod: item.fields.get('warmupClockPeriod'),\n            warmupClockPeriodUnit: item.fields.get('warmupClockPeriodUnit'),\n            runClockPeriod: item.fields.get('runClockPeriod'),\n            runClockPeriodUnit: item.fields.get('runClockPeriodUnit'),\n            warmupDateTime: item.fields.get('warmupDateTime'),\n            startDateTime: item.fields.get('startDateTime'),\n            finishDateTime: item.fields.get('finishDateTime'),\n            type: item.fields.get('type')\n        };\n    }\n    mapToActivityData(item) {\n        return {\n            id: item.fields.get('id'),\n            name: item.fields.get('name'),\n            capacity: item.fields.get('capacity'),\n            inputBufferCapacity: item.fields.get('inputBufferCapacity'),\n            outputBufferCapacity: item.fields.get('outputBufferCapacity'),\n            type: item.fields.get('type')\n        };\n    }\n    mapToResourceData(item) {\n        return {\n            id: item.fields.get('id'),\n            name: item.fields.get('name'),\n            capacity: item.fields.get('capacity'),\n            type: item.fields.get('type')\n        };\n    }\n    mapToEntityData(item) {\n        return {\n            id: item.fields.get('id'),\n            name: item.fields.get('name'),\n            type: item.fields.get('type')\n        };\n    }\n    mapToGeneratorData(item) {\n        return {\n            id: item.fields.get('id'),\n            name: item.fields.get('name'),\n            entityId: item.fields.get('entityId'),\n            creationMode: item.fields.get('creationMode'),\n            quantity: item.fields.get('quantity'),\n            timeBetweenArrivals: item.fields.get('timeBetweenArrivals'),\n            maxBatches: item.fields.get('maxBatches'),\n            type: item.fields.get('type')\n        };\n    }\n    mapToConnectorData(item) {\n        return {\n            id: item.fields.get('id'),\n            name: item.fields.get('name'),\n            sourceId: item.fields.get('sourceId'),\n            targetId: item.fields.get('targetId'),\n            type: item.fields.get('type')\n        };\n    }\n    mapToOperationStepData(item) {\n        return {\n            id: item.fields.get('id'),\n            activityId: item.fields.get('activityId'),\n            requirementId: item.fields.get('requirementId'),\n            duration: item.fields.get('duration'),\n            quantity: item.fields.get('quantity')\n        };\n    }\n    mapToResourceRequirementData(item) {\n        return {\n            id: item.fields.get('id'),\n            name: item.fields.get('name'),\n            type: item.fields.get('type')\n        };\n    }\n}\nexports.ModelReader = ModelReader;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/ModelReader.ts?");

/***/ }),

/***/ "./src/data_sources/model/index.ts":
/*!*****************************************!*\
  !*** ./src/data_sources/model/index.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelReader = exports.ModelDataSource = void 0;\n// Export the ModelDataSource and ModelReader classes\nvar ModelDataSource_1 = __webpack_require__(/*! ./ModelDataSource */ \"./src/data_sources/model/ModelDataSource.ts\");\nObject.defineProperty(exports, \"ModelDataSource\", ({ enumerable: true, get: function () { return ModelDataSource_1.ModelDataSource; } }));\nvar ModelReader_1 = __webpack_require__(/*! ./ModelReader */ \"./src/data_sources/model/ModelReader.ts\");\nObject.defineProperty(exports, \"ModelReader\", ({ enumerable: true, get: function () { return ModelReader_1.ModelReader; } }));\n// Export schemas and collection names\n__exportStar(__webpack_require__(/*! ./schemas */ \"./src/data_sources/model/schemas/index.ts\"), exports);\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/index.ts?");

/***/ }),

/***/ "./src/data_sources/model/schemas/ActivitySchema.ts":
/*!**********************************************************!*\
  !*** ./src/data_sources/model/schemas/ActivitySchema.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ActivitySchema = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.ActivitySchema = {\n    fields: [\n        { name: \"id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"name\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"capacity\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"inputBufferCapacity\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"outputBufferCapacity\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"type\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING }\n    ],\n    primaryKey: [\"id\"],\n    fieldLabels: {\n        id: \"ID\",\n        name: \"Name\",\n        capacity: \"Capacity\",\n        inputBufferCapacity: \"Input Buffer Capacity\",\n        outputBufferCapacity: \"Output Buffer Capacity\",\n        type: \"Type\"\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/schemas/ActivitySchema.ts?");

/***/ }),

/***/ "./src/data_sources/model/schemas/ConnectorSchema.ts":
/*!***********************************************************!*\
  !*** ./src/data_sources/model/schemas/ConnectorSchema.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectorSchema = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.ConnectorSchema = {\n    fields: [\n        { name: \"id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"name\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"sourceId\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"targetId\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"probability\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"connectType\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"type\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING }\n    ],\n    primaryKey: [\"id\"],\n    fieldLabels: {\n        id: \"ID\",\n        name: \"Name\",\n        sourceId: \"Source\",\n        targetId: \"Target\",\n        probability: \"Probability\",\n        connectType: \"Connection Type\",\n        type: \"Type\"\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/schemas/ConnectorSchema.ts?");

/***/ }),

/***/ "./src/data_sources/model/schemas/EntitySchema.ts":
/*!********************************************************!*\
  !*** ./src/data_sources/model/schemas/EntitySchema.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntitySchema = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.EntitySchema = {\n    fields: [\n        { name: \"id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"name\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"type\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING }\n    ],\n    primaryKey: [\"id\"],\n    fieldLabels: {\n        id: \"ID\",\n        name: \"Name\",\n        type: \"Type\"\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/schemas/EntitySchema.ts?");

/***/ }),

/***/ "./src/data_sources/model/schemas/GeneratorSchema.ts":
/*!***********************************************************!*\
  !*** ./src/data_sources/model/schemas/GeneratorSchema.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GeneratorSchema = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.GeneratorSchema = {\n    fields: [\n        { name: \"id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"name\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"activityKeyId\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"entityId\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"periodicOccurrences\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"periodIntervalDuration\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"entitiesPerCreation\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"periodicStartDuration\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"maxEntities\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"type\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING }\n    ],\n    primaryKey: [\"id\"],\n    fieldLabels: {\n        id: \"ID\",\n        name: \"Name\",\n        activityKeyId: \"Activity Key\",\n        entityId: \"Entity\",\n        periodicOccurrences: \"Periodic Occurrences\",\n        periodIntervalDuration: \"Period Interval\",\n        entitiesPerCreation: \"Entities Per Creation\",\n        periodicStartDuration: \"Periodic Start Duration\",\n        maxEntities: \"Max Entities\",\n        type: \"Type\"\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/schemas/GeneratorSchema.ts?");

/***/ }),

/***/ "./src/data_sources/model/schemas/ModelSchema.ts":
/*!*******************************************************!*\
  !*** ./src/data_sources/model/schemas/ModelSchema.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelSchema = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.ModelSchema = {\n    fields: [\n        { name: \"id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"name\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"reps\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"forecastDays\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"seed\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"oneClockUnit\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"simulationTimeType\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"warmupClockPeriod\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"warmupClockPeriodUnit\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"runClockPeriod\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"runClockPeriodUnit\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"warmupDateTime\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"startDateTime\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"finishDateTime\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"type\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING }\n    ],\n    primaryKey: [\"id\"],\n    fieldLabels: {\n        id: \"ID\",\n        name: \"Name\",\n        reps: \"Repetitions\",\n        forecastDays: \"Forecast Days\",\n        seed: \"Random Seed\",\n        oneClockUnit: \"Clock Unit\",\n        simulationTimeType: \"Time Type\",\n        warmupClockPeriod: \"Warmup Period\",\n        warmupClockPeriodUnit: \"Warmup Period Unit\",\n        runClockPeriod: \"Run Period\",\n        runClockPeriodUnit: \"Run Period Unit\",\n        warmupDateTime: \"Warmup Date/Time\",\n        startDateTime: \"Start Date/Time\",\n        finishDateTime: \"Finish Date/Time\",\n        type: \"Type\"\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/schemas/ModelSchema.ts?");

/***/ }),

/***/ "./src/data_sources/model/schemas/OperationStepSchema.ts":
/*!***************************************************************!*\
  !*** ./src/data_sources/model/schemas/OperationStepSchema.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OperationStepSchema = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.OperationStepSchema = {\n    fields: [\n        { name: \"id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"requirementId\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"quantity\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"duration\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"activityId\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING }\n    ],\n    primaryKey: [\"id\"],\n    fieldLabels: {\n        id: \"ID\",\n        requirementId: \"Requirement\",\n        quantity: \"Quantity\",\n        duration: \"Duration\",\n        activityId: \"Activity\"\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/schemas/OperationStepSchema.ts?");

/***/ }),

/***/ "./src/data_sources/model/schemas/RequirementClauseSchema.ts":
/*!*******************************************************************!*\
  !*** ./src/data_sources/model/schemas/RequirementClauseSchema.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RequirementClauseSchema = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.RequirementClauseSchema = {\n    fields: [\n        { name: \"id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"mode\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"parentClauseId\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"requirementId\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING } // Foreign key to ResourceRequirement\n    ],\n    primaryKey: [\"id\"],\n    fieldLabels: {\n        id: \"ID\",\n        mode: \"Mode\",\n        parentClauseId: \"Parent Clause\",\n        requirementId: \"Resource Requirement\"\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/schemas/RequirementClauseSchema.ts?");

/***/ }),

/***/ "./src/data_sources/model/schemas/ResourceRequestSchema.ts":
/*!*****************************************************************!*\
  !*** ./src/data_sources/model/schemas/ResourceRequestSchema.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResourceRequestSchema = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.ResourceRequestSchema = {\n    fields: [\n        { name: \"id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"resourceId\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"quantity\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"priority\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"keepResource\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.BOOLEAN },\n        { name: \"clauseId\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING } // Foreign key to RequirementClause\n    ],\n    primaryKey: [\"id\"],\n    fieldLabels: {\n        id: \"ID\",\n        resourceId: \"Resource\",\n        quantity: \"Quantity\",\n        priority: \"Priority\",\n        keepResource: \"Keep Resource\",\n        clauseId: \"Requirement Clause\"\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/schemas/ResourceRequestSchema.ts?");

/***/ }),

/***/ "./src/data_sources/model/schemas/ResourceRequirementSchema.ts":
/*!*********************************************************************!*\
  !*** ./src/data_sources/model/schemas/ResourceRequirementSchema.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResourceRequirementSchema = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.ResourceRequirementSchema = {\n    fields: [\n        { name: \"id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"name\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"type\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING }\n    ],\n    primaryKey: [\"id\"],\n    fieldLabels: {\n        id: \"ID\",\n        name: \"Name\",\n        type: \"Type\"\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/schemas/ResourceRequirementSchema.ts?");

/***/ }),

/***/ "./src/data_sources/model/schemas/ResourceSchema.ts":
/*!**********************************************************!*\
  !*** ./src/data_sources/model/schemas/ResourceSchema.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResourceSchema = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.ResourceSchema = {\n    fields: [\n        { name: \"id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"name\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"capacity\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"type\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING }\n    ],\n    primaryKey: [\"id\"],\n    fieldLabels: {\n        id: \"ID\",\n        name: \"Name\",\n        capacity: \"Capacity\",\n        type: \"Type\"\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/schemas/ResourceSchema.ts?");

/***/ }),

/***/ "./src/data_sources/model/schemas/index.ts":
/*!*************************************************!*\
  !*** ./src/data_sources/model/schemas/index.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MODEL_COLLECTIONS = exports.ResourceSchema = exports.ResourceRequirementSchema = exports.ResourceRequestSchema = exports.RequirementClauseSchema = exports.OperationStepSchema = exports.ModelSchema = exports.GeneratorSchema = exports.EntitySchema = exports.ConnectorSchema = exports.ActivitySchema = void 0;\n// Export all schema definitions\nvar ActivitySchema_1 = __webpack_require__(/*! ./ActivitySchema */ \"./src/data_sources/model/schemas/ActivitySchema.ts\");\nObject.defineProperty(exports, \"ActivitySchema\", ({ enumerable: true, get: function () { return ActivitySchema_1.ActivitySchema; } }));\nvar ConnectorSchema_1 = __webpack_require__(/*! ./ConnectorSchema */ \"./src/data_sources/model/schemas/ConnectorSchema.ts\");\nObject.defineProperty(exports, \"ConnectorSchema\", ({ enumerable: true, get: function () { return ConnectorSchema_1.ConnectorSchema; } }));\nvar EntitySchema_1 = __webpack_require__(/*! ./EntitySchema */ \"./src/data_sources/model/schemas/EntitySchema.ts\");\nObject.defineProperty(exports, \"EntitySchema\", ({ enumerable: true, get: function () { return EntitySchema_1.EntitySchema; } }));\nvar GeneratorSchema_1 = __webpack_require__(/*! ./GeneratorSchema */ \"./src/data_sources/model/schemas/GeneratorSchema.ts\");\nObject.defineProperty(exports, \"GeneratorSchema\", ({ enumerable: true, get: function () { return GeneratorSchema_1.GeneratorSchema; } }));\nvar ModelSchema_1 = __webpack_require__(/*! ./ModelSchema */ \"./src/data_sources/model/schemas/ModelSchema.ts\");\nObject.defineProperty(exports, \"ModelSchema\", ({ enumerable: true, get: function () { return ModelSchema_1.ModelSchema; } }));\nvar OperationStepSchema_1 = __webpack_require__(/*! ./OperationStepSchema */ \"./src/data_sources/model/schemas/OperationStepSchema.ts\");\nObject.defineProperty(exports, \"OperationStepSchema\", ({ enumerable: true, get: function () { return OperationStepSchema_1.OperationStepSchema; } }));\nvar RequirementClauseSchema_1 = __webpack_require__(/*! ./RequirementClauseSchema */ \"./src/data_sources/model/schemas/RequirementClauseSchema.ts\");\nObject.defineProperty(exports, \"RequirementClauseSchema\", ({ enumerable: true, get: function () { return RequirementClauseSchema_1.RequirementClauseSchema; } }));\nvar ResourceRequestSchema_1 = __webpack_require__(/*! ./ResourceRequestSchema */ \"./src/data_sources/model/schemas/ResourceRequestSchema.ts\");\nObject.defineProperty(exports, \"ResourceRequestSchema\", ({ enumerable: true, get: function () { return ResourceRequestSchema_1.ResourceRequestSchema; } }));\nvar ResourceRequirementSchema_1 = __webpack_require__(/*! ./ResourceRequirementSchema */ \"./src/data_sources/model/schemas/ResourceRequirementSchema.ts\");\nObject.defineProperty(exports, \"ResourceRequirementSchema\", ({ enumerable: true, get: function () { return ResourceRequirementSchema_1.ResourceRequirementSchema; } }));\nvar ResourceSchema_1 = __webpack_require__(/*! ./ResourceSchema */ \"./src/data_sources/model/schemas/ResourceSchema.ts\");\nObject.defineProperty(exports, \"ResourceSchema\", ({ enumerable: true, get: function () { return ResourceSchema_1.ResourceSchema; } }));\n// Export collection names as a constant for use in both ModelDataSource and ModelReader\nexports.MODEL_COLLECTIONS = {\n    MODEL: \"model\",\n    ACTIVITIES: \"activities\",\n    RESOURCES: \"resources\",\n    ENTITIES: \"entities\",\n    GENERATORS: \"generators\",\n    CONNECTORS: \"connectors\",\n    OPERATION_STEPS: \"operationSteps\",\n    RESOURCE_REQUIREMENTS: \"resourceRequirements\",\n    REQUIREMENT_CLAUSES: \"requirementClauses\",\n    RESOURCE_REQUESTS: \"resourceRequests\"\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/model/schemas/index.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/DynamicSimulationResultsTableGenerator.ts":
/*!***************************************************************************************!*\
  !*** ./src/data_sources/simulation_results/DynamicSimulationResultsTableGenerator.ts ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// DynamicSimulationResultsTableGenerator.ts\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DynamicSimulationResultsTableGenerator = void 0;\n// Import schemas from the schemas directory\nconst activityUtilizationSchema_1 = __webpack_require__(/*! ./schemas/activityUtilizationSchema */ \"./src/data_sources/simulation_results/schemas/activityUtilizationSchema.ts\");\nconst activityRepSummarySchema_1 = __webpack_require__(/*! ./schemas/activityRepSummarySchema */ \"./src/data_sources/simulation_results/schemas/activityRepSummarySchema.ts\");\n/**\n * Default configuration for table generation\n */\nconst DEFAULT_CONFIG = {\n    position: { x: 100, y: 100 },\n    width: 600,\n    height: 300,\n    formatNumbers: true,\n    percentDecimals: 1,\n    numberDecimals: 2,\n    styleHeader: true,\n    headerBackgroundColor: '#f0f0f0',\n    headerTextBold: true,\n    dynamicColumns: true,\n    maxColumns: 8,\n    columnOrder: 'schema',\n    columnTypePriority: ['mean', 'max', 'min']\n};\n/**\n * Dynamic generator class for creating tables from simulation results\n * that uses schema information to build tables\n */\nclass DynamicSimulationResultsTableGenerator {\n    constructor(resultsReader, config) {\n        this.resultsReader = resultsReader;\n        this.config = Object.assign(Object.assign({}, DEFAULT_CONFIG), config);\n        // Initialize schema mappings\n        this.schemaMapping = this.initializeSchemaMapping();\n    }\n    /**\n     * Initialize schema mappings with type information\n     */\n    initializeSchemaMapping() {\n        return {\n            'activity_utilization': {\n                schema: activityUtilizationSchema_1.ActivityUtilizationSchema,\n                identifierFields: ['Id', 'Name'],\n                percentageFields: ['utilization_mean', 'utilization_max', 'utilization_std_dev'],\n                priorityFields: ['Name', 'utilization_mean', 'utilization_max', 'capacity_mean', 'queue_length_mean']\n            },\n            'activity_rep_summary': {\n                schema: activityRepSummarySchema_1.ActivityRepSummarySchema,\n                identifierFields: ['rep', 'activity_id'],\n                percentageFields: ['utilization_percentage', 'operational_efficiency', 'cycle_time_efficiency'],\n                priorityFields: ['rep', 'activity_id', 'utilization_percentage', 'throughput_rate', 'capacity']\n            }\n            // Add more schema mappings as needed\n        };\n    }\n    /**\n     * Creates a table for activity utilization data\n     * @param page The page to add the table to\n     * @param client The editor client\n     * @param config Optional configuration overrides for this table\n     */\n    async createActivityUtilizationTable(page, client, config) {\n        console.log('[TableGenerator] Creating activity utilization table...');\n        // Merge config with instance config and defaults\n        const tableConfig = Object.assign(Object.assign({}, this.config), config);\n        // Get activity utilization data\n        const data = await this.resultsReader.getActivityUtilizationData();\n        console.log('[TableGenerator] Activity utilization data:', data);\n        if (!data || data.length === 0) {\n            console.warn('[TableGenerator] No activity utilization data available');\n            return null;\n        }\n        // Create schema-based columns\n        const columns = this.createColumnsFromSchema('activity_utilization', data[0], tableConfig);\n        const title = tableConfig.title || 'Activity Utilization';\n        // Generate the table with exactly the rows and columns needed\n        return this.generateDynamicTable(page, client, data, columns, title, tableConfig);\n    }\n    /**\n     * Creates a table for activity replication summary data\n     * @param page The page to add the table to\n     * @param client The editor client\n     * @param config Optional configuration overrides for this table\n     */\n    async createActivityRepSummaryTable(page, client, config) {\n        console.log('[TableGenerator] Creating activity replication summary table...');\n        // Merge config with instance config and defaults\n        const tableConfig = Object.assign(Object.assign({}, this.config), config);\n        // Get activity replication summary data\n        const data = await this.resultsReader.getActivityRepSummaryData();\n        console.log('[TableGenerator] Activity replication summary data:', data);\n        if (!data || data.length === 0) {\n            console.warn('[TableGenerator] No activity replication summary data available');\n            return null;\n        }\n        // Create schema-based columns\n        const columns = this.createColumnsFromSchema('activity_rep_summary', data[0], tableConfig);\n        const title = tableConfig.title || 'Activity Replication Summary';\n        // Generate the table with exactly the rows and columns needed\n        return this.generateDynamicTable(page, client, data, columns, title, tableConfig);\n    }\n    /**\n     * Create column definitions from a schema and sample data\n     * @param schemaType The type of schema to use\n     * @param sampleData Sample data object to check for available fields\n     * @param config Table configuration\n     * @returns Array of column definitions\n     */\n    createColumnsFromSchema(schemaType, sampleData, config) {\n        if (!this.schemaMapping[schemaType]) {\n            console.warn(`[TableGenerator] No schema mapping found for type: ${schemaType}`);\n            // Return basic columns based on the object keys\n            return Object.keys(sampleData).map(key => ({\n                header: key,\n                field: key,\n                formatter: (val) => this.formatValue(val, false, config.numberDecimals)\n            }));\n        }\n        const schemaInfo = this.schemaMapping[schemaType];\n        const schema = schemaInfo.schema;\n        const identifierFields = schemaInfo.identifierFields || [];\n        const percentageFields = schemaInfo.percentageFields || [];\n        const priorityFields = schemaInfo.priorityFields || [];\n        // Create all possible columns\n        let allColumns = [];\n        // Add fields from schema\n        if (schema && schema.fields) {\n            allColumns = schema.fields.map(field => {\n                var _a;\n                const fieldName = field.name;\n                const displayName = ((_a = schema.fieldLabels) === null || _a === void 0 ? void 0 : _a[fieldName]) || fieldName;\n                const isPercentage = percentageFields.includes(fieldName);\n                const isIdentifier = identifierFields.includes(fieldName);\n                // Determine sort order for prioritization\n                let sortOrder = priorityFields.indexOf(fieldName);\n                if (sortOrder === -1) {\n                    sortOrder = 1000; // Non-priority fields go to the end\n                }\n                // Check if field matches type priority (mean, max, etc.)\n                if (config.columnTypePriority && !Array.isArray(config.columnOrder)) {\n                    for (let i = 0; i < config.columnTypePriority.length; i++) {\n                        const priorityType = config.columnTypePriority[i];\n                        if (fieldName.includes(priorityType)) {\n                            // Adjust sort order based on type priority\n                            sortOrder = sortOrder - 100 + i;\n                            break;\n                        }\n                    }\n                }\n                return {\n                    header: displayName,\n                    field: fieldName,\n                    formatter: (val) => this.formatValue(val, isPercentage, config.numberDecimals),\n                    displayName: displayName,\n                    sortOrder: sortOrder,\n                    isIdentifier: isIdentifier,\n                    isPercentage: isPercentage\n                };\n            });\n        }\n        // Apply column exclusions if specified\n        if (config.excludeColumns && config.excludeColumns.length > 0) {\n            allColumns = allColumns.filter(col => { var _a; return !((_a = config.excludeColumns) === null || _a === void 0 ? void 0 : _a.includes(col.field)); });\n        }\n        // Apply custom column order if provided as string array\n        if (Array.isArray(config.columnOrder)) {\n            const customOrder = config.columnOrder;\n            // Sort columns based on the custom order\n            allColumns.sort((a, b) => {\n                const indexA = customOrder.indexOf(a.field);\n                const indexB = customOrder.indexOf(b.field);\n                // If both columns are in the custom order, sort by their position\n                if (indexA >= 0 && indexB >= 0) {\n                    return indexA - indexB;\n                }\n                // If only one column is in the custom order, it comes first\n                if (indexA >= 0)\n                    return -1;\n                if (indexB >= 0)\n                    return 1;\n                // If neither column is in the custom order, maintain their relative positions\n                return (a.sortOrder || 1000) - (b.sortOrder || 1000);\n            });\n        }\n        else {\n            // Use standard sorting methods\n            this.sortColumns(allColumns, typeof config.columnOrder === 'string' ? config.columnOrder : 'schema');\n        }\n        // Filter columns based on dynamic data\n        if (config.dynamicColumns) {\n            allColumns = this.filterColumnsWithData(allColumns, [sampleData]);\n        }\n        // Limit columns if maxColumns is specified\n        if (config.maxColumns && config.maxColumns > 0 && allColumns.length > config.maxColumns) {\n            // Always include identifier columns unless they're explicitly excluded\n            const identifiers = allColumns.filter(col => col.isIdentifier);\n            const nonIdentifiers = allColumns.filter(col => !col.isIdentifier);\n            // Sort non-identifiers by sortOrder\n            nonIdentifiers.sort((a, b) => (a.sortOrder || 1000) - (b.sortOrder || 1000));\n            // Take only enough non-identifiers to reach maxColumns\n            const remainingSlots = config.maxColumns - identifiers.length;\n            const selectedNonIdentifiers = remainingSlots > 0\n                ? nonIdentifiers.slice(0, remainingSlots)\n                : [];\n            // Combine and resort by original sort order\n            allColumns = [...identifiers, ...selectedNonIdentifiers];\n            // Reapply custom ordering if provided\n            if (Array.isArray(config.columnOrder)) {\n                // Sort columns based on the custom order\n                allColumns.sort((a, b) => {\n                    var _a, _b, _c, _d;\n                    const indexA = (_b = (_a = config.columnOrder) === null || _a === void 0 ? void 0 : _a.indexOf(a.field)) !== null && _b !== void 0 ? _b : -1;\n                    const indexB = (_d = (_c = config.columnOrder) === null || _c === void 0 ? void 0 : _c.indexOf(b.field)) !== null && _d !== void 0 ? _d : -1;\n                    // If both columns are in the custom order, sort by their position\n                    if (indexA >= 0 && indexB >= 0) {\n                        return indexA - indexB;\n                    }\n                    // If only one column is in the custom order, it comes first\n                    if (indexA >= 0)\n                        return -1;\n                    if (indexB >= 0)\n                        return 1;\n                    // If neither column is in the custom order, maintain their relative positions\n                    return (a.sortOrder || 1000) - (b.sortOrder || 1000);\n                });\n            }\n            else {\n                this.sortColumns(allColumns, typeof config.columnOrder === 'string' ? config.columnOrder : 'schema');\n            }\n        }\n        console.log(`[TableGenerator] Created ${allColumns.length} columns for schema type: ${schemaType}`);\n        return allColumns;\n    }\n    /**\n     * Sort columns based on the specified order\n     * @param columns Columns to sort\n     * @param order Sort order strategy\n     */\n    sortColumns(columns, order) {\n        switch (order) {\n            case 'alphabetical':\n                columns.sort((a, b) => a.header.localeCompare(b.header));\n                break;\n            case 'numerical-first':\n                columns.sort((a, b) => {\n                    // First by identifier status\n                    if (a.isIdentifier && !b.isIdentifier)\n                        return -1;\n                    if (!a.isIdentifier && b.isIdentifier)\n                        return 1;\n                    // Then by type (put numerical values first)\n                    if (a.isPercentage !== b.isPercentage) {\n                        return a.isPercentage ? -1 : 1;\n                    }\n                    // Finally by sort order\n                    return (a.sortOrder || 1000) - (b.sortOrder || 1000);\n                });\n                break;\n            case 'schema':\n            default:\n                // Sort by sort order (which is based on priority)\n                columns.sort((a, b) => (a.sortOrder || 1000) - (b.sortOrder || 1000));\n                break;\n        }\n    }\n    /**\n     * Filter columns to only include those that have data in at least one row\n     * @param columns All possible column definitions\n     * @param data Array of data objects to check for column values\n     * @returns Filtered array of column definitions\n     */\n    filterColumnsWithData(columns, data) {\n        if (!data || data.length === 0) {\n            return columns;\n        }\n        return columns.filter(column => {\n            // Always include identifier columns\n            if (column.isIdentifier) {\n                return true;\n            }\n            // Check if any row has data for this column\n            return data.some(item => {\n                const value = item[column.field];\n                // Consider the column valid if it has a non-null, non-undefined, non-empty value\n                return value !== null && value !== undefined && value !== '' && value !== 0;\n            });\n        });\n    }\n    /**\n     * Format a value based on its type\n     * @param value The value to format\n     * @param isPercentage Whether this is a percentage value\n     * @param decimals Number of decimal places to use\n     * @returns Formatted string value\n     */\n    formatValue(value, isPercentage = false, decimals) {\n        if (value === null || value === undefined || value === '') {\n            return '';\n        }\n        if (typeof value === 'number') {\n            if (isPercentage) {\n                // Handle percentage values (may already be in percentage or in decimal)\n                const percentValue = value > 1 ? value : value * 100;\n                return this.formatPercent(percentValue, decimals);\n            }\n            else {\n                return this.formatNumber(value, decimals);\n            }\n        }\n        return String(value);\n    }\n    // Corrected generateDynamicTable method for DynamicSimulationResultsTableGenerator.ts\n    async generateDynamicTable(page, client, data, columns, title, config) {\n        var _a, _b;\n        try {\n            console.log(`[TableGenerator] Generating dynamic table: ${title}...`);\n            console.log(`[TableGenerator] Using ${columns.length} columns for ${data.length} rows`);\n            // Create header row data\n            const headerRow = columns.map(col => col.header);\n            // Create data rows\n            const dataRows = data.map(item => columns.map(col => {\n                const value = item[col.field];\n                return col.formatter ? col.formatter(value) : String(value);\n            }));\n            // Calculate row and column counts\n            const rowCount = dataRows.length + 1; // +1 for header row\n            const columnCount = headerRow.length;\n            // Load Table block class\n            console.log('[TableGenerator] Loading DefaultTableBlock class...');\n            await client.loadBlockClasses(['DefaultTableBlock']);\n            // Calculate table height based on row count or use configured height\n            const tableHeight = config.height || calculateDynamicTableHeight(rowCount);\n            // Create table block\n            const blockDef = {\n                className: \"DefaultTableBlock\",\n                boundingBox: {\n                    x: ((_a = config.position) === null || _a === void 0 ? void 0 : _a.x) || 100,\n                    y: ((_b = config.position) === null || _b === void 0 ? void 0 : _b.y) || 100,\n                    w: config.width || 600,\n                    h: tableHeight,\n                }\n            };\n            console.log('[TableGenerator] Adding TableBlock to page...');\n            const tableBlock = page.addBlock(blockDef);\n            // Now we need to build the table to the exact dimensions we need\n            console.log('[TableGenerator] Setting up table dimensions...');\n            // Get the initial rows (usually just 1 row with 1 cell)\n            const initialRows = tableBlock.getRows();\n            // Add rows until we have enough rows\n            console.log(`[TableGenerator] Ensuring table has ${rowCount} rows...`);\n            let lastCell = initialRows[0].getCells()[0];\n            // Add additional rows if needed\n            while (tableBlock.getRowCount() < rowCount) {\n                const newRow = tableBlock.addRow(lastCell);\n                lastCell = newRow.getCells()[0];\n            }\n            // Add columns until we have enough columns\n            console.log(`[TableGenerator] Ensuring table has ${columnCount} columns...`);\n            // Start with the first cell of the first row\n            lastCell = tableBlock.getRows()[0].getCells()[0];\n            // Add additional columns if needed\n            while (tableBlock.getColumnCount() < columnCount) {\n                tableBlock.addColumn(lastCell);\n                // No need to update lastCell here as we're always adding columns at the end\n            }\n            // Populate table data\n            console.log('[TableGenerator] Populating table data...');\n            const updatedRows = tableBlock.getRows();\n            // Set header row\n            const headerCells = updatedRows[0].getCells();\n            headerRow.forEach((headerText, colIndex) => {\n                if (colIndex < headerCells.length) {\n                    const cell = headerCells[colIndex];\n                    cell.setText(headerText);\n                    // Style header\n                    if (config.styleHeader) {\n                        if (config.headerBackgroundColor) {\n                            cell.setFill(config.headerBackgroundColor);\n                        }\n                        if (config.headerTextBold) {\n                            cell.setTextStyle({ bold: true });\n                        }\n                    }\n                }\n            });\n            // Set data rows\n            dataRows.forEach((rowData, rowIndex) => {\n                if (rowIndex + 1 < updatedRows.length) {\n                    const row = updatedRows[rowIndex + 1]; // +1 to skip header\n                    const cells = row.getCells();\n                    rowData.forEach((cellValue, colIndex) => {\n                        if (colIndex < cells.length) {\n                            const cell = cells[colIndex];\n                            cell.setText(String(cellValue));\n                        }\n                    });\n                }\n            });\n            // Remove any extra rows if we happened to have more than we need\n            while (tableBlock.getRowCount() > rowCount) {\n                // Use deleteRow instead of removeRow (which doesn't exist)\n                tableBlock.deleteRow(tableBlock.getRowCount() - 1);\n            }\n            console.log(`[TableGenerator] Table \"${title}\" created successfully with ${rowCount} rows and ${columnCount} columns`);\n            return tableBlock;\n        }\n        catch (error) {\n            console.error(`[TableGenerator] Error creating table \"${title}\":`, error);\n            return null;\n        }\n    }\n    /**\n     * Format a number as a percentage\n     * @param value The number value (0-100)\n     * @param decimals Number of decimal places\n     * @returns Formatted percentage string\n     */\n    formatPercent(value, decimals = 1) {\n        // Ensure decimals is defined and valid\n        const places = typeof decimals === 'number' ? decimals : 1;\n        // Format with specified decimal places and add % symbol\n        return value.toFixed(places) + '%';\n    }\n    /**\n     * Format a number with the specified number of decimal places\n     * @param value The number value\n     * @param decimals Number of decimal places\n     * @returns Formatted number string\n     */\n    formatNumber(value, decimals = 2) {\n        // Ensure decimals is defined and valid\n        const places = typeof decimals === 'number' ? decimals : 2;\n        // Format with specified decimal places\n        return value.toFixed(places);\n    }\n}\nexports.DynamicSimulationResultsTableGenerator = DynamicSimulationResultsTableGenerator;\n/**\n * Calculate a reasonable table height based on the number of rows\n * @param rowCount Number of rows in the table\n * @returns Calculated height in pixels\n */\nfunction calculateDynamicTableHeight(rowCount) {\n    // Estimate row height and header margin\n    const estimatedRowHeight = 30;\n    const headerMargin = 10;\n    // Calculate based on row count with some padding\n    return (rowCount * estimatedRowHeight) + headerMargin;\n}\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/DynamicSimulationResultsTableGenerator.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/SimulationResultsDashboard.ts":
/*!***************************************************************************!*\
  !*** ./src/data_sources/simulation_results/SimulationResultsDashboard.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// SimulationResultsDashboard.ts\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimulationResultsDashboard = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nconst SimulationResultsReader_1 = __webpack_require__(/*! ./SimulationResultsReader */ \"./src/data_sources/simulation_results/SimulationResultsReader.ts\");\nconst DynamicSimulationResultsTableGenerator_1 = __webpack_require__(/*! ./DynamicSimulationResultsTableGenerator */ \"./src/data_sources/simulation_results/DynamicSimulationResultsTableGenerator.ts\");\n/**\n * Default dashboard configuration\n */\nconst DEFAULT_DASHBOARD_CONFIG = {\n    title: 'Simulation Results Dashboard',\n    tableSpacing: 50,\n    initialX: 50,\n    initialY: 50,\n    tableWidth: 800,\n    tableConfig: {\n        formatNumbers: true,\n        percentDecimals: 1,\n        numberDecimals: 2,\n        styleHeader: true,\n        dynamicColumns: true,\n        maxColumns: 6\n    },\n    includedDataTypes: {\n        activityUtilization: true,\n        activityRepSummary: true,\n        activityTiming: true,\n        entityThroughput: true,\n        resourceRepSummary: true,\n        entityState: true\n    },\n    customColumnConfig: {\n        activityUtilization: {\n            columnOrder: [\n                'Name',\n                'utilization_mean',\n                'utilization_max',\n                'capacity_mean',\n                'capacity_max'\n            ],\n            excludeColumns: ['Id']\n        },\n        activityRepSummary: {\n            columnOrder: [\n                'activity_id',\n                'rep',\n                'utilization_percentage',\n                'throughput_rate',\n                'capacity'\n            ]\n        }\n    }\n};\n/**\n * A dashboard generator for simulation results\n * Creates a comprehensive view of all available simulation data\n */\nclass SimulationResultsDashboard {\n    constructor(client, config) {\n        this.client = client;\n        this.config = Object.assign(Object.assign({}, DEFAULT_DASHBOARD_CONFIG), config);\n        this.resultsReader = new SimulationResultsReader_1.SimulationResultsReader(client);\n        // Initialize the table generator with default config\n        this.tableGenerator = new DynamicSimulationResultsTableGenerator_1.DynamicSimulationResultsTableGenerator(this.resultsReader, this.config.tableConfig);\n    }\n    /**\n     * Create a new dashboard page with tables for all available simulation data\n     * @param pageName Name for the new page\n     * @returns Promise with dashboard creation result\n     */\n    async createDashboard(pageName) {\n        var _a, _b, _c, _d, _e, _f;\n        console.log(`[Dashboard] Creating new dashboard page: ${pageName}`);\n        // Check if simulation results exist\n        const hasResults = await this.resultsReader.hasSimulationResults();\n        if (!hasResults) {\n            throw new Error('No simulation results available');\n        }\n        // Create a new page for the dashboard\n        const document = new lucid_extension_sdk_1.DocumentProxy(this.client);\n        const def = {\n            title: pageName,\n        };\n        const page = document.addPage(def);\n        console.log(`[Dashboard] Created new page with ID: ${page.id}`);\n        // Initialize tracking variables\n        let currentY = this.config.initialY || 50;\n        const tables = [];\n        const emptyDataTypes = [];\n        const errors = [];\n        // Generate all requested tables\n        if ((_a = this.config.includedDataTypes) === null || _a === void 0 ? void 0 : _a.activityUtilization) {\n            try {\n                const result = await this.addTableToDashboard(page, 'activityUtilization', 'Activity Utilization', currentY);\n                if (result) {\n                    tables.push({\n                        type: 'activityUtilization',\n                        table: result.table,\n                        position: { x: this.config.initialX || 50, y: currentY }\n                    });\n                    currentY = result.nextY;\n                }\n                else {\n                    emptyDataTypes.push('activityUtilization');\n                }\n            }\n            catch (error) {\n                console.error('[Dashboard] Error creating activity utilization table:', error);\n                errors.push({ type: 'activityUtilization', error });\n            }\n        }\n        if ((_b = this.config.includedDataTypes) === null || _b === void 0 ? void 0 : _b.activityRepSummary) {\n            try {\n                const result = await this.addTableToDashboard(page, 'activityRepSummary', 'Activity Replication Summary', currentY);\n                if (result) {\n                    tables.push({\n                        type: 'activityRepSummary',\n                        table: result.table,\n                        position: { x: this.config.initialX || 50, y: currentY }\n                    });\n                    currentY = result.nextY;\n                }\n                else {\n                    emptyDataTypes.push('activityRepSummary');\n                }\n            }\n            catch (error) {\n                console.error('[Dashboard] Error creating activity rep summary table:', error);\n                errors.push({ type: 'activityRepSummary', error });\n            }\n        }\n        if ((_c = this.config.includedDataTypes) === null || _c === void 0 ? void 0 : _c.activityTiming) {\n            try {\n                const result = await this.addTableToDashboard(page, 'activityTiming', 'Activity Timing', currentY);\n                if (result) {\n                    tables.push({\n                        type: 'activityTiming',\n                        table: result.table,\n                        position: { x: this.config.initialX || 50, y: currentY }\n                    });\n                    currentY = result.nextY;\n                }\n                else {\n                    emptyDataTypes.push('activityTiming');\n                }\n            }\n            catch (error) {\n                console.error('[Dashboard] Error creating activity timing table:', error);\n                errors.push({ type: 'activityTiming', error });\n            }\n        }\n        if ((_d = this.config.includedDataTypes) === null || _d === void 0 ? void 0 : _d.entityThroughput) {\n            try {\n                const result = await this.addTableToDashboard(page, 'entityThroughput', 'Entity Throughput', currentY);\n                if (result) {\n                    tables.push({\n                        type: 'entityThroughput',\n                        table: result.table,\n                        position: { x: this.config.initialX || 50, y: currentY }\n                    });\n                    currentY = result.nextY;\n                }\n                else {\n                    emptyDataTypes.push('entityThroughput');\n                }\n            }\n            catch (error) {\n                console.error('[Dashboard] Error creating entity throughput table:', error);\n                errors.push({ type: 'entityThroughput', error });\n            }\n        }\n        if ((_e = this.config.includedDataTypes) === null || _e === void 0 ? void 0 : _e.resourceRepSummary) {\n            try {\n                const result = await this.addTableToDashboard(page, 'resourceRepSummary', 'Resource Summary', currentY);\n                if (result) {\n                    tables.push({\n                        type: 'resourceRepSummary',\n                        table: result.table,\n                        position: { x: this.config.initialX || 50, y: currentY }\n                    });\n                    currentY = result.nextY;\n                }\n                else {\n                    emptyDataTypes.push('resourceRepSummary');\n                }\n            }\n            catch (error) {\n                console.error('[Dashboard] Error creating resource summary table:', error);\n                errors.push({ type: 'resourceRepSummary', error });\n            }\n        }\n        if ((_f = this.config.includedDataTypes) === null || _f === void 0 ? void 0 : _f.entityState) {\n            try {\n                const result = await this.addTableToDashboard(page, 'entityState', 'Entity State Summary', currentY);\n                if (result) {\n                    tables.push({\n                        type: 'entityState',\n                        table: result.table,\n                        position: { x: this.config.initialX || 50, y: currentY }\n                    });\n                    currentY = result.nextY;\n                }\n                else {\n                    emptyDataTypes.push('entityState');\n                }\n            }\n            catch (error) {\n                console.error('[Dashboard] Error creating entity state table:', error);\n                errors.push({ type: 'entityState', error });\n            }\n        }\n        console.log(`[Dashboard] Created ${tables.length} tables on dashboard`);\n        if (emptyDataTypes.length > 0) {\n            console.log(`[Dashboard] No data available for: ${emptyDataTypes.join(', ')}`);\n        }\n        if (errors.length > 0) {\n            console.warn(`[Dashboard] Encountered ${errors.length} errors during dashboard creation`);\n        }\n        // Make the viewport show the new page\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        viewport.setCurrentPage(page);\n        return {\n            page,\n            tables,\n            emptyDataTypes,\n            errors\n        };\n    }\n    /**\n     * Add a specific table type to the dashboard\n     * @param page Page to add the table to\n     * @param tableType Type of table to add\n     * @param title Title for the table\n     * @param yPosition Vertical position for the table\n     * @returns The created table and the next Y position, or null if no data available\n     */\n    async addTableToDashboard(page, tableType, title, yPosition) {\n        var _a;\n        console.log(`[Dashboard] Adding ${tableType} table at y=${yPosition}`);\n        let table = null;\n        // Apply custom column config if available for this table type\n        const customConfig = (_a = this.config.customColumnConfig) === null || _a === void 0 ? void 0 : _a[tableType];\n        const tableConfig = Object.assign({ position: { x: this.config.initialX || 50, y: yPosition }, width: this.config.tableWidth || 800, title: title }, customConfig);\n        // Create table based on type\n        switch (tableType) {\n            case 'activityUtilization':\n                table = await this.tableGenerator.createActivityUtilizationTable(page, this.client, tableConfig);\n                break;\n            case 'activityRepSummary':\n                table = await this.tableGenerator.createActivityRepSummaryTable(page, this.client, tableConfig);\n                break;\n            // case 'activityTiming':\n            //     table = await this.tableGenerator.createActivityTimingTable(page, this.client, tableConfig);\n            //     break;\n            // case 'entityThroughput':\n            //     table = await this.tableGenerator.createEntityThroughputTable(page, this.client, tableConfig);\n            //     break;\n            // Add other table types as they are implemented in the generator\n            default:\n                console.warn(`[Dashboard] Unsupported table type: ${tableType}`);\n                return null;\n        }\n        if (!table) {\n            console.log(`[Dashboard] No data available for ${tableType}`);\n            return null;\n        }\n        // Get the table height from the bounding box (available via ItemProxy)\n        const boundingBox = table.getBoundingBox();\n        const tableHeight = boundingBox.h;\n        // Calculate the next Y position based on table height and spacing\n        const nextY = yPosition + tableHeight + (this.config.tableSpacing || 50);\n        return { table, nextY };\n    }\n}\nexports.SimulationResultsDashboard = SimulationResultsDashboard;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/SimulationResultsDashboard.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/SimulationResultsReader.ts":
/*!************************************************************************!*\
  !*** ./src/data_sources/simulation_results/SimulationResultsReader.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimulationResultsReader = void 0;\nconst DataSourceReader_1 = __webpack_require__(/*! ../base/DataSourceReader */ \"./src/data_sources/base/DataSourceReader.ts\");\nconst models_1 = __webpack_require__(/*! ./models */ \"./src/data_sources/simulation_results/models/index.ts\");\n/**\n * Reader for the simulation_results data source\n * Provides methods for accessing simulation results data in LucidChart\n */\nclass SimulationResultsReader extends DataSourceReader_1.DataSourceReader {\n    constructor(client) {\n        super(client, 'simulation_results');\n    }\n    /**\n     * Gets the model data for a specific page\n     * @param pageId ID of the page to get model data for\n     * @returns The model data for the page if found, null otherwise\n     */\n    async getModelDataForPage(pageId) {\n        const modelsCollection = await this.getCollectionByName('Models');\n        if (!modelsCollection)\n            return null;\n        // Try to find the model data for the specified page ID\n        const modelItem = modelsCollection.items.get(`\"${pageId}\"`);\n        if (!modelItem)\n            return null;\n        return (0, models_1.mapToModelData)(modelItem.fields);\n    }\n    /**\n     * Gets activity utilization data collection\n     * @returns The activity utilization collection if found, null otherwise\n     */\n    async getActivityUtilizationCollection() {\n        return this.getCollectionByName('activity_utilization');\n    }\n    /**\n     * Gets activity utilization data as strongly typed objects\n     * @returns Array of ActivityUtilization objects\n     */\n    async getActivityUtilizationData() {\n        const collection = await this.getActivityUtilizationCollection();\n        if (!collection)\n            return [];\n        const result = [];\n        // Use for...of directly on the items MapProxy\n        // This works because MapProxy implements Symbol.iterator\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push((0, models_1.mapToActivityUtilization)(item.fields));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets activity replication summary collection\n     * @returns The activity replication summary collection if found, null otherwise\n     */\n    async getActivityRepSummaryCollection() {\n        return this.getCollectionByName('activity_rep_summary');\n    }\n    /**\n     * Gets activity replication summary data as strongly typed objects\n     * @returns Array of ActivityRepSummary objects\n     */\n    async getActivityRepSummaryData() {\n        const collection = await this.getActivityRepSummaryCollection();\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push((0, models_1.mapToActivityRepSummary)(item.fields));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets activity timing collection\n     * @returns The activity timing collection if found, null otherwise\n     */\n    async getActivityTimingCollection() {\n        return this.getCollectionByName('activity_timing');\n    }\n    /**\n     * Gets activity timing data as strongly typed objects\n     * @returns Array of ActivityTiming objects\n     */\n    async getActivityTimingData() {\n        const collection = await this.getActivityTimingCollection();\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push((0, models_1.mapToActivityTiming)(item.fields));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets entity state replication summary collection\n     * @returns The entity state replication summary collection if found, null otherwise\n     */\n    async getEntityStateRepSummaryCollection() {\n        return this.getCollectionByName('entity_state_rep_summary');\n    }\n    /**\n     * Gets entity state replication summary data as strongly typed objects\n     * @returns Array of EntityStateRepSummary objects\n     */\n    async getEntityStateRepSummaryData() {\n        const collection = await this.getEntityStateRepSummaryCollection();\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push((0, models_1.mapToEntityStateRepSummary)(item.fields));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets entity throughput replication summary collection\n     * @returns The entity throughput replication summary collection if found, null otherwise\n     */\n    async getEntityThroughputRepSummaryCollection() {\n        return this.getCollectionByName('entity_throughput_rep_summary');\n    }\n    /**\n     * Gets entity throughput replication summary data as strongly typed objects\n     * @returns Array of EntityThroughputRepSummary objects\n     */\n    async getEntityThroughputRepSummaryData() {\n        const collection = await this.getEntityThroughputRepSummaryCollection();\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push((0, models_1.mapToEntityThroughputRepSummary)(item.fields));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets resource replication summary collection\n     * @returns The resource replication summary collection if found, null otherwise\n     */\n    async getResourceRepSummaryCollection() {\n        return this.getCollectionByName('resource_rep_summary');\n    }\n    /**\n     * Gets resource replication summary data as strongly typed objects\n     * @returns Array of ResourceRepSummary objects\n     */\n    async getResourceRepSummaryData() {\n        const collection = await this.getResourceRepSummaryCollection();\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push((0, models_1.mapToResourceRepSummary)(item.fields));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets complete activity metrics collection\n     * @returns The complete activity metrics collection if found, null otherwise\n     */\n    async getCompleteActivityMetricsCollection() {\n        return this.getCollectionByName('complete_activity_metrics');\n    }\n    /**\n     * Gets complete activity metrics data as strongly typed objects\n     * @returns Array of CompleteActivityMetrics objects\n     */\n    async getCompleteActivityMetricsData() {\n        const collection = await this.getCompleteActivityMetricsCollection();\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push((0, models_1.mapToCompleteActivityMetrics)(item.fields));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets custom metrics collection\n     * @returns The custom metrics collection if found, null otherwise\n     */\n    async getCustomMetricsCollection() {\n        return this.getCollectionByName('custom_metrics');\n    }\n    /**\n     * Gets custom metrics data as strongly typed objects\n     * @returns Array of CustomMetrics objects\n     */\n    async getCustomMetricsData() {\n        const collection = await this.getCustomMetricsCollection();\n        if (!collection)\n            return [];\n        const result = [];\n        for (const [_, item] of collection.items) {\n            if (item) {\n                result.push((0, models_1.mapToCustomMetrics)(item.fields));\n            }\n        }\n        return result;\n    }\n    /**\n     * Gets activity data by ID\n     * @param activityId The ID of the activity to get\n     * @returns The activity data or null if not found\n     */\n    async getActivityById(activityId) {\n        const collection = await this.getActivityUtilizationCollection();\n        if (!collection)\n            return null;\n        const item = collection.items.get(activityId);\n        if (!item)\n            return null;\n        return (0, models_1.mapToActivityUtilization)(item.fields);\n    }\n    /**\n     * Checks if simulation results exist for the current document\n     * @returns True if any simulation results collections exist, false otherwise\n     */\n    async hasSimulationResults() {\n        const collections = await this.getAllCollections();\n        return collections !== null && collections.size > 0;\n    }\n}\nexports.SimulationResultsReader = SimulationResultsReader;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/SimulationResultsReader.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/models/ActivityRepSummary.ts":
/*!**************************************************************************!*\
  !*** ./src/data_sources/simulation_results/models/ActivityRepSummary.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToActivityRepSummary = mapToActivityRepSummary;\n/**\n * Converts raw collection item data to a strongly typed ActivityRepSummary object\n * @param itemFields MapProxy of field name to field value from the collection item\n * @returns Strongly typed ActivityRepSummary object\n */\nfunction mapToActivityRepSummary(itemFields) {\n    return {\n        rep: itemFields.get('rep'),\n        activity_id: itemFields.get('activity_id'),\n        capacity: itemFields.get('capacity'),\n        total_available_clock: itemFields.get('total_available_clock'),\n        total_arrivals: itemFields.get('total_arrivals'),\n        total_requests: itemFields.get('total_requests'),\n        total_captures: itemFields.get('total_captures'),\n        total_releases: itemFields.get('total_releases'),\n        total_time_in_capture: itemFields.get('total_time_in_capture'),\n        total_time_blocked: itemFields.get('total_time_blocked'),\n        total_time_waiting: itemFields.get('total_time_waiting'),\n        average_contents: itemFields.get('average_contents'),\n        maximum_contents: itemFields.get('maximum_contents'),\n        current_contents: itemFields.get('current_contents'),\n        utilization_percentage: itemFields.get('utilization_percentage'),\n        throughput_rate: itemFields.get('throughput_rate'),\n        average_time_per_entry: itemFields.get('average_time_per_entry'),\n        average_queue_length: itemFields.get('average_queue_length'),\n        input_buffer_utilization: itemFields.get('input_buffer_utilization'),\n        output_buffer_utilization: itemFields.get('output_buffer_utilization'),\n        input_buffer_queue_time: itemFields.get('input_buffer_queue_time'),\n        output_buffer_queue_time: itemFields.get('output_buffer_queue_time'),\n        min_service_time: itemFields.get('min_service_time'),\n        max_service_time: itemFields.get('max_service_time'),\n        avg_service_time: itemFields.get('avg_service_time'),\n        service_time_variance: itemFields.get('service_time_variance'),\n        total_time_blocked_upstream: itemFields.get('total_time_blocked_upstream'),\n        total_time_blocked_downstream: itemFields.get('total_time_blocked_downstream'),\n        blocking_frequency: itemFields.get('blocking_frequency'),\n        resource_starvation_time: itemFields.get('resource_starvation_time'),\n        resource_conflict_count: itemFields.get('resource_conflict_count'),\n        operational_efficiency: itemFields.get('operational_efficiency'),\n        cycle_time_efficiency: itemFields.get('cycle_time_efficiency'),\n        first_time_through: itemFields.get('first_time_through')\n    };\n}\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/models/ActivityRepSummary.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/models/ActivityTiming.ts":
/*!**********************************************************************!*\
  !*** ./src/data_sources/simulation_results/models/ActivityTiming.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToActivityTiming = mapToActivityTiming;\n/**\n * Converts raw collection item data to a strongly typed ActivityTiming object\n * @param itemFields MapProxy of field name to field value from the collection item\n * @returns Strongly typed ActivityTiming object\n */\nfunction mapToActivityTiming(itemFields) {\n    return {\n        Id: itemFields.get('Id'),\n        Name: itemFields.get('Name'),\n        cycle_time_mean: itemFields.get('cycle_time_mean'),\n        cycle_time_median: itemFields.get('cycle_time_median'),\n        cycle_time_cv: itemFields.get('cycle_time_cv'),\n        cycle_time_std_dev: itemFields.get('cycle_time_std_dev'),\n        service_time_mean: itemFields.get('service_time_mean'),\n        service_time_median: itemFields.get('service_time_median'),\n        service_time_cv: itemFields.get('service_time_cv'),\n        service_time_std_dev: itemFields.get('service_time_std_dev'),\n        waiting_time_mean: itemFields.get('waiting_time_mean'),\n        waiting_time_median: itemFields.get('waiting_time_median'),\n        waiting_time_cv: itemFields.get('waiting_time_cv'),\n        waiting_time_std_dev: itemFields.get('waiting_time_std_dev'),\n        blocked_time_mean: itemFields.get('blocked_time_mean'),\n        blocked_time_median: itemFields.get('blocked_time_median'),\n        blocked_time_cv: itemFields.get('blocked_time_cv'),\n        blocked_time_std_dev: itemFields.get('blocked_time_std_dev')\n    };\n}\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/models/ActivityTiming.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/models/ActivityUtilization.ts":
/*!***************************************************************************!*\
  !*** ./src/data_sources/simulation_results/models/ActivityUtilization.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToActivityUtilization = mapToActivityUtilization;\n/**\n * Converts raw collection item data to a strongly typed ActivityUtilization object\n * @param itemFields MapProxy of field name to field value from the collection item\n * @returns Strongly typed ActivityUtilization object\n */\nfunction mapToActivityUtilization(itemFields) {\n    return {\n        Id: itemFields.get('Id'),\n        Name: itemFields.get('Name'),\n        utilization_mean: itemFields.get('utilization_mean'),\n        utilization_max: itemFields.get('utilization_max'),\n        utilization_std_dev: itemFields.get('utilization_std_dev'),\n        capacity_mean: itemFields.get('capacity_mean'),\n        capacity_max: itemFields.get('capacity_max'),\n        capacity_std_dev: itemFields.get('capacity_std_dev'),\n        contents_mean: itemFields.get('contents_mean'),\n        contents_max: itemFields.get('contents_max'),\n        contents_std_dev: itemFields.get('contents_std_dev'),\n        queue_length_mean: itemFields.get('queue_length_mean'),\n        queue_length_max: itemFields.get('queue_length_max'),\n        queue_length_std_dev: itemFields.get('queue_length_std_dev')\n    };\n}\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/models/ActivityUtilization.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/models/CompleteActivityMetrics.ts":
/*!*******************************************************************************!*\
  !*** ./src/data_sources/simulation_results/models/CompleteActivityMetrics.ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToCompleteActivityMetrics = mapToCompleteActivityMetrics;\n/**\n * Converts raw collection item data to a strongly typed CompleteActivityMetrics object\n * @param itemFields MapProxy of field name to field value from the collection item\n * @returns Strongly typed CompleteActivityMetrics object\n */\nfunction mapToCompleteActivityMetrics(itemFields) {\n    return {\n        Id: itemFields.get('Id'),\n        Name: itemFields.get('Name'),\n        // Arrivals metrics\n        arrivals_mean: itemFields.get('arrivals_mean'),\n        arrivals_median: itemFields.get('arrivals_median'),\n        // Available Time metrics\n        available_time_mean: itemFields.get('available_time_mean'),\n        available_time_median: itemFields.get('available_time_median'),\n        // Blocked Time metrics\n        blocked_time_mean: itemFields.get('blocked_time_mean'),\n        blocked_time_median: itemFields.get('blocked_time_median'),\n        // Capacity metrics\n        capacity_mean: itemFields.get('capacity_mean'),\n        capacity_median: itemFields.get('capacity_median'),\n        // Capture Time metrics\n        capture_time_mean: itemFields.get('capture_time_mean'),\n        capture_time_median: itemFields.get('capture_time_median'),\n        // Captures metrics\n        captures_mean: itemFields.get('captures_mean'),\n        captures_median: itemFields.get('captures_median'),\n        // Contents metrics\n        contents_mean: itemFields.get('contents_mean'),\n        contents_median: itemFields.get('contents_median'),\n        // Cycle Time metrics\n        cycle_time_mean: itemFields.get('cycle_time_mean'),\n        cycle_time_median: itemFields.get('cycle_time_median'),\n        // Cycle Time Efficiency metrics\n        cycle_time_efficiency_mean: itemFields.get('cycle_time_efficiency_mean'),\n        cycle_time_efficiency_median: itemFields.get('cycle_time_efficiency_median'),\n        // Downstream Blocking metrics\n        downstream_blocking_mean: itemFields.get('downstream_blocking_mean'),\n        downstream_blocking_median: itemFields.get('downstream_blocking_median'),\n        // First Time Through metrics\n        first_time_through_mean: itemFields.get('first_time_through_mean'),\n        first_time_through_median: itemFields.get('first_time_through_median'),\n        // Input Buffer Stats metrics\n        input_buffer_stats_mean: itemFields.get('input_buffer_stats_mean'),\n        input_buffer_stats_median: itemFields.get('input_buffer_stats_median'),\n        // Max Contents metrics\n        max_contents_mean: itemFields.get('max_contents_mean'),\n        max_contents_median: itemFields.get('max_contents_median'),\n        // Operational Efficiency metrics\n        operational_efficiency_mean: itemFields.get('operational_efficiency_mean'),\n        operational_efficiency_median: itemFields.get('operational_efficiency_median'),\n        // Output Buffer Stats metrics\n        output_buffer_stats_mean: itemFields.get('output_buffer_stats_mean'),\n        output_buffer_stats_median: itemFields.get('output_buffer_stats_median'),\n        // Queue Length metrics\n        queue_length_mean: itemFields.get('queue_length_mean'),\n        queue_length_median: itemFields.get('queue_length_median'),\n        // Releases metrics\n        releases_mean: itemFields.get('releases_mean'),\n        releases_median: itemFields.get('releases_median'),\n        // Resource Conflicts metrics\n        resource_conflicts_mean: itemFields.get('resource_conflicts_mean'),\n        resource_conflicts_median: itemFields.get('resource_conflicts_median'),\n        // Resource Starvation metrics\n        resource_starvation_mean: itemFields.get('resource_starvation_mean'),\n        resource_starvation_median: itemFields.get('resource_starvation_median'),\n        // Service Time metrics\n        service_time_mean: itemFields.get('service_time_mean'),\n        service_time_median: itemFields.get('service_time_median'),\n        // Service Time Variance metrics\n        service_time_variance_mean: itemFields.get('service_time_variance_mean'),\n        service_time_variance_median: itemFields.get('service_time_variance_median'),\n        // Throughput metrics\n        throughput_mean: itemFields.get('throughput_mean'),\n        throughput_median: itemFields.get('throughput_median'),\n        // Upstream Blocking metrics\n        upstream_blocking_mean: itemFields.get('upstream_blocking_mean'),\n        upstream_blocking_median: itemFields.get('upstream_blocking_median'),\n        // Utilization metrics\n        utilization_mean: itemFields.get('utilization_mean'),\n        utilization_median: itemFields.get('utilization_median'),\n        // Waiting Time metrics\n        waiting_time_mean: itemFields.get('waiting_time_mean'),\n        waiting_time_median: itemFields.get('waiting_time_median'),\n        // Summary statistics\n        average_cycle_time: itemFields.get('average_cycle_time'),\n        average_utilization: itemFields.get('average_utilization'),\n        bottleneck_frequency: itemFields.get('bottleneck_frequency'),\n        capacity_loss_breakdown: itemFields.get('capacity_loss_breakdown'),\n        improvement_opportunities: itemFields.get('improvement_opportunities'),\n        peak_utilization: itemFields.get('peak_utilization'),\n        total_activities: itemFields.get('total_activities'),\n        total_throughput: itemFields.get('total_throughput')\n    };\n}\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/models/CompleteActivityMetrics.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/models/CustomMetrics.ts":
/*!*********************************************************************!*\
  !*** ./src/data_sources/simulation_results/models/CustomMetrics.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToCustomMetrics = mapToCustomMetrics;\n/**\n * Converts raw collection item data to a strongly typed CustomMetrics object\n * @param itemFields MapProxy of field name to field value from the collection item\n * @returns Strongly typed CustomMetrics object\n */\nfunction mapToCustomMetrics(itemFields) {\n    return {\n        Id: itemFields.get('Id'),\n        Name: itemFields.get('Name'),\n        utilization_mean: itemFields.get('utilization_mean'),\n        utilization_std_dev: itemFields.get('utilization_std_dev'),\n        throughput_mean: itemFields.get('throughput_mean'),\n        throughput_std_dev: itemFields.get('throughput_std_dev'),\n        bottleneck_frequency: itemFields.get('bottleneck_frequency')\n    };\n}\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/models/CustomMetrics.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/models/EntityStateRepSummary.ts":
/*!*****************************************************************************!*\
  !*** ./src/data_sources/simulation_results/models/EntityStateRepSummary.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToEntityStateRepSummary = mapToEntityStateRepSummary;\n/**\n * Converts raw collection item data to a strongly typed EntityStateRepSummary object\n * @param itemFields MapProxy of field name to field value from the collection item\n * @returns Strongly typed EntityStateRepSummary object\n */\nfunction mapToEntityStateRepSummary(itemFields) {\n    return {\n        rep: itemFields.get('rep'),\n        entity_type: itemFields.get('entity_type'),\n        count: itemFields.get('count'),\n        avg_time_in_system: itemFields.get('avg_time_in_system'),\n        avg_time_waiting: itemFields.get('avg_time_waiting'),\n        avg_time_blocked: itemFields.get('avg_time_blocked'),\n        avg_time_in_operation: itemFields.get('avg_time_in_operation'),\n        avg_time_connecting: itemFields.get('avg_time_connecting'),\n        percent_waiting: itemFields.get('percent_waiting'),\n        percent_blocked: itemFields.get('percent_blocked'),\n        percent_operation: itemFields.get('percent_operation'),\n        percent_connecting: itemFields.get('percent_connecting')\n    };\n}\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/models/EntityStateRepSummary.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/models/EntityThroughputRepSummary.ts":
/*!**********************************************************************************!*\
  !*** ./src/data_sources/simulation_results/models/EntityThroughputRepSummary.ts ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToEntityThroughputRepSummary = mapToEntityThroughputRepSummary;\n/**\n * Converts raw collection item data to a strongly typed EntityThroughputRepSummary object\n * @param itemFields MapProxy of field name to field value from the collection item\n * @returns Strongly typed EntityThroughputRepSummary object\n */\nfunction mapToEntityThroughputRepSummary(itemFields) {\n    return {\n        rep: itemFields.get('rep'),\n        entity_type: itemFields.get('entity_type'),\n        count: itemFields.get('count'),\n        completed_count: itemFields.get('completed_count'),\n        in_progress_count: itemFields.get('in_progress_count'),\n        first_exit: itemFields.get('first_exit'),\n        last_exit: itemFields.get('last_exit'),\n        avg_interval: itemFields.get('avg_interval'),\n        min_interval: itemFields.get('min_interval'),\n        max_interval: itemFields.get('max_interval'),\n        throughput_rate: itemFields.get('throughput_rate')\n    };\n}\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/models/EntityThroughputRepSummary.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/models/ModelData.ts":
/*!*****************************************************************!*\
  !*** ./src/data_sources/simulation_results/models/ModelData.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToModelData = mapToModelData;\n/**\n * Converts raw collection item data to a strongly typed ModelData object\n * @param itemFields MapProxy of field name to field value from the collection item\n * @returns Strongly typed ModelData object\n */\nfunction mapToModelData(itemFields) {\n    return {\n        documentId: itemFields.get('documentId'),\n        userId: itemFields.get('userId'),\n        pageId: itemFields.get('pageId')\n    };\n}\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/models/ModelData.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/models/ResourceRepSummary.ts":
/*!**************************************************************************!*\
  !*** ./src/data_sources/simulation_results/models/ResourceRepSummary.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToResourceRepSummary = mapToResourceRepSummary;\n/**\n * Converts raw collection item data to a strongly typed ResourceRepSummary object\n * @param itemFields MapProxy of field name to field value from the collection item\n * @returns Strongly typed ResourceRepSummary object\n */\nfunction mapToResourceRepSummary(itemFields) {\n    return {\n        rep: itemFields.get('rep'),\n        resource_id: itemFields.get('resource_id'),\n        total_requests: itemFields.get('total_requests'),\n        total_captures: itemFields.get('total_captures'),\n        total_releases: itemFields.get('total_releases'),\n        avg_capture_time: itemFields.get('avg_capture_time'),\n        utilization_rate: itemFields.get('utilization_rate'),\n        total_time_waiting: itemFields.get('total_time_waiting'),\n        avg_queue_time: itemFields.get('avg_queue_time'),\n        max_queue_length: itemFields.get('max_queue_length'),\n        avg_contents: itemFields.get('avg_contents')\n    };\n}\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/models/ResourceRepSummary.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/models/index.ts":
/*!*************************************************************!*\
  !*** ./src/data_sources/simulation_results/models/index.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToCustomMetrics = exports.mapToCompleteActivityMetrics = exports.mapToResourceRepSummary = exports.mapToEntityThroughputRepSummary = exports.mapToEntityStateRepSummary = exports.mapToActivityTiming = exports.mapToActivityRepSummary = exports.mapToActivityUtilization = exports.mapToModelData = void 0;\n// Export all simulation results models\nvar ModelData_1 = __webpack_require__(/*! ./ModelData */ \"./src/data_sources/simulation_results/models/ModelData.ts\");\nObject.defineProperty(exports, \"mapToModelData\", ({ enumerable: true, get: function () { return ModelData_1.mapToModelData; } }));\nvar ActivityUtilization_1 = __webpack_require__(/*! ./ActivityUtilization */ \"./src/data_sources/simulation_results/models/ActivityUtilization.ts\");\nObject.defineProperty(exports, \"mapToActivityUtilization\", ({ enumerable: true, get: function () { return ActivityUtilization_1.mapToActivityUtilization; } }));\nvar ActivityRepSummary_1 = __webpack_require__(/*! ./ActivityRepSummary */ \"./src/data_sources/simulation_results/models/ActivityRepSummary.ts\");\nObject.defineProperty(exports, \"mapToActivityRepSummary\", ({ enumerable: true, get: function () { return ActivityRepSummary_1.mapToActivityRepSummary; } }));\nvar ActivityTiming_1 = __webpack_require__(/*! ./ActivityTiming */ \"./src/data_sources/simulation_results/models/ActivityTiming.ts\");\nObject.defineProperty(exports, \"mapToActivityTiming\", ({ enumerable: true, get: function () { return ActivityTiming_1.mapToActivityTiming; } }));\nvar EntityStateRepSummary_1 = __webpack_require__(/*! ./EntityStateRepSummary */ \"./src/data_sources/simulation_results/models/EntityStateRepSummary.ts\");\nObject.defineProperty(exports, \"mapToEntityStateRepSummary\", ({ enumerable: true, get: function () { return EntityStateRepSummary_1.mapToEntityStateRepSummary; } }));\nvar EntityThroughputRepSummary_1 = __webpack_require__(/*! ./EntityThroughputRepSummary */ \"./src/data_sources/simulation_results/models/EntityThroughputRepSummary.ts\");\nObject.defineProperty(exports, \"mapToEntityThroughputRepSummary\", ({ enumerable: true, get: function () { return EntityThroughputRepSummary_1.mapToEntityThroughputRepSummary; } }));\nvar ResourceRepSummary_1 = __webpack_require__(/*! ./ResourceRepSummary */ \"./src/data_sources/simulation_results/models/ResourceRepSummary.ts\");\nObject.defineProperty(exports, \"mapToResourceRepSummary\", ({ enumerable: true, get: function () { return ResourceRepSummary_1.mapToResourceRepSummary; } }));\nvar CompleteActivityMetrics_1 = __webpack_require__(/*! ./CompleteActivityMetrics */ \"./src/data_sources/simulation_results/models/CompleteActivityMetrics.ts\");\nObject.defineProperty(exports, \"mapToCompleteActivityMetrics\", ({ enumerable: true, get: function () { return CompleteActivityMetrics_1.mapToCompleteActivityMetrics; } }));\nvar CustomMetrics_1 = __webpack_require__(/*! ./CustomMetrics */ \"./src/data_sources/simulation_results/models/CustomMetrics.ts\");\nObject.defineProperty(exports, \"mapToCustomMetrics\", ({ enumerable: true, get: function () { return CustomMetrics_1.mapToCustomMetrics; } }));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/models/index.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/schemas/activityRepSummarySchema.ts":
/*!*********************************************************************************!*\
  !*** ./src/data_sources/simulation_results/schemas/activityRepSummarySchema.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ActivityRepSummarySchema = void 0;\n// schemas/activityRepSummary.ts\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.ActivityRepSummarySchema = {\n    fields: [\n        { name: \"rep\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"activity_id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"capacity\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"total_available_clock\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"total_arrivals\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"total_requests\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"total_captures\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"total_releases\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"total_time_in_capture\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"total_time_blocked\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"total_time_waiting\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"average_contents\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"maximum_contents\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"current_contents\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"utilization_percentage\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"throughput_rate\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"average_time_per_entry\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"average_queue_length\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"input_buffer_utilization\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"output_buffer_utilization\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"input_buffer_queue_time\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"output_buffer_queue_time\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"min_service_time\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"max_service_time\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"avg_service_time\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"service_time_variance\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"total_time_blocked_upstream\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"total_time_blocked_downstream\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"blocking_frequency\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"resource_starvation_time\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"resource_conflict_count\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"operational_efficiency\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"cycle_time_efficiency\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"first_time_through\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER }\n    ],\n    primaryKey: [\"rep\", \"activity_id\"],\n    fieldLabels: {\n        'rep': 'Replication',\n        'activity_id': 'Activity ID',\n        'capacity': 'Capacity',\n        'total_available_clock': 'Total Available Clock',\n        'total_arrivals': 'Total Arrivals',\n        'total_requests': 'Total Requests',\n        'total_captures': 'Total Captures',\n        'total_releases': 'Total Releases',\n        'total_time_in_capture': 'Total Time in Capture',\n        'total_time_blocked': 'Total Time Blocked',\n        'total_time_waiting': 'Total Time Waiting',\n        'average_contents': 'Average Contents',\n        'maximum_contents': 'Maximum Contents',\n        'current_contents': 'Current Contents',\n        'utilization_percentage': 'Utilization Percentage',\n        'throughput_rate': 'Throughput Rate',\n        'average_time_per_entry': 'Average Time Per Entry',\n        'average_queue_length': 'Average Queue Length',\n        'input_buffer_utilization': 'Input Buffer Utilization',\n        'output_buffer_utilization': 'Output Buffer Utilization',\n        'input_buffer_queue_time': 'Input Buffer Queue Time',\n        'output_buffer_queue_time': 'Output Buffer Queue Time',\n        'min_service_time': 'Min Service Time',\n        'max_service_time': 'Max Service Time',\n        'avg_service_time': 'Avg Service Time',\n        'service_time_variance': 'Service Time Variance',\n        'total_time_blocked_upstream': 'Total Time Blocked Upstream',\n        'total_time_blocked_downstream': 'Total Time Blocked Downstream',\n        'blocking_frequency': 'Blocking Frequency',\n        'resource_starvation_time': 'Resource Starvation Time',\n        'resource_conflict_count': 'Resource Conflict Count',\n        'operational_efficiency': 'Operational Efficiency',\n        'cycle_time_efficiency': 'Cycle Time Efficiency',\n        'first_time_through': 'First Time Through'\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/schemas/activityRepSummarySchema.ts?");

/***/ }),

/***/ "./src/data_sources/simulation_results/schemas/activityUtilizationSchema.ts":
/*!**********************************************************************************!*\
  !*** ./src/data_sources/simulation_results/schemas/activityUtilizationSchema.ts ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ActivityUtilizationSchema = void 0;\n// schemas/activityUtilization.ts\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nexports.ActivityUtilizationSchema = {\n    fields: [\n        { name: \"Id\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"Name\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.STRING },\n        { name: \"utilization_mean\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"utilization_max\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"utilization_std_dev\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"capacity_mean\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"capacity_max\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"capacity_std_dev\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"contents_mean\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"contents_max\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"contents_std_dev\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"queue_length_mean\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"queue_length_max\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER },\n        { name: \"queue_length_std_dev\", type: lucid_extension_sdk_1.ScalarFieldTypeEnum.NUMBER }\n    ],\n    primaryKey: [\"Id\"],\n    fieldLabels: {\n        'Id': 'ID',\n        'Name': 'Activity Name',\n        'utilization_mean': 'Mean Utilization',\n        'utilization_max': 'Max Utilization',\n        'utilization_std_dev': 'Utilization Std Dev',\n        'capacity_mean': 'Mean Capacity',\n        'capacity_max': 'Max Capacity',\n        'capacity_std_dev': 'Capacity Std Dev',\n        'contents_mean': 'Mean Contents',\n        'contents_max': 'Max Contents',\n        'contents_std_dev': 'Contents Std Dev',\n        'queue_length_mean': 'Mean Queue Length',\n        'queue_length_max': 'Max Queue Length',\n        'queue_length_std_dev': 'Queue Length Std Dev'\n    }\n};\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/data_sources/simulation_results/schemas/activityUtilizationSchema.ts?");

/***/ }),

/***/ "./src/extension.ts":
/*!**************************!*\
  !*** ./src/extension.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nconst ModelManager_1 = __webpack_require__(/*! ./core/ModelManager */ \"./src/core/ModelManager.ts\");\nconst ModelPanel_1 = __webpack_require__(/*! ./panels/ModelPanel */ \"./src/panels/ModelPanel.ts\");\nconst StorageAdapter_1 = __webpack_require__(/*! ./core/StorageAdapter */ \"./src/core/StorageAdapter.ts\");\nconst client = new lucid_extension_sdk_1.EditorClient();\nconst viewport = new lucid_extension_sdk_1.Viewport(client);\n// Initialize storage adapter\nconst storageAdapter = new StorageAdapter_1.StorageAdapter();\n// Initialize the messaging singleton\n// const messaging = ExtensionMessaging.getInstance(); \n// Initialize core model management with storage adapter\nconst modelManager = new ModelManager_1.ModelManager(storageAdapter);\n// Initialize panel with model manager instance\nconsole.info('[extension] About to create ModelPanel');\nconst modelPanel = new ModelPanel_1.ModelPanel(client, modelManager);\nmodelPanel.setLogging(true);\nconsole.info('[extension] Created ModelPanel2');\n// Hook selection changes\nviewport.hookSelection((items) => {\n    modelPanel.handleSelectionChange(items);\n});\n/*\n    This code needs to be refactoring into the workflow\n*/\nconst menu = new lucid_extension_sdk_1.Menu(client);\nclient.registerAction(\"import\", async () => {\n    // Temporary workaround. You must call oauthXhr once before performDataAction will work\n    const triggerOauth = await client.oauthXhr(\"lucid\", {\n        url: \"https://api.lucid.co/folders/search\",\n        headers: {\n            \"Lucid-Api-Version\": \"1\",\n            \"Content-Type\": \"application/json\",\n        },\n        data: \"{}\",\n        method: \"POST\",\n    });\n    const result = await client.performDataAction({\n        dataConnectorName: \"data-connector-1\",\n        actionName: \"Import\",\n        actionData: { message: \"ImportFolders\" },\n        asynchronous: true,\n    });\n    console.log(result);\n});\nmenu.addMenuItem({\n    label: \"Import\",\n    action: \"import\",\n    menuType: lucid_extension_sdk_1.MenuType.Main,\n});\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/extension.ts?");

/***/ }),

/***/ "./src/managers/SelectionManager.ts":
/*!******************************************!*\
  !*** ./src/managers/SelectionManager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SelectionManager = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nclass SelectionManager {\n    constructor(modelManager) {\n        this.selectionChangeListeners = [];\n        this.loggingEnabled = false;\n        this.modelManager = modelManager;\n        this.currentSelection = {\n            pageId: '',\n            selectedIds: [],\n            selectionType: shared_1.SelectionType.NONE\n        };\n        this.log('SelectionManager initialized');\n    }\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    log(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.log(`${SelectionManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    logError(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.error(`${SelectionManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    async determineSelectionState(currentPage, items) {\n        this.log('Determining selection state', {\n            pageId: currentPage.id,\n            itemCount: items.length,\n            items: items.map(i => i.id)\n        });\n        const type = await this.determineSelectionType(items);\n        const state = {\n            pageId: currentPage.id,\n            selectedIds: items.map(item => item.id),\n            selectionType: type\n        };\n        this.log('Selection state determined', state);\n        return state;\n    }\n    async determineSelectionType(items) {\n        this.log('Determining selection type', { itemCount: items.length });\n        if (items.length === 0) {\n            this.log('No items selected, returning NONE');\n            return shared_1.SelectionType.NONE;\n        }\n        if (items.length > 1) {\n            this.log('Multiple items selected, returning MULTIPLE');\n            return shared_1.SelectionType.MULTIPLE;\n        }\n        const item = items[0];\n        this.log('Processing single item selection', { itemId: item.id });\n        if (this.modelManager.isUnconvertedElement(item)) {\n            this.log('Item is unconverted', { itemId: item.id });\n            return shared_1.SelectionType.UNCONVERTED_ELEMENT;\n        }\n        const metadata = await this.modelManager.getMetadata(item);\n        this.log('Retrieved metadata', { itemId: item.id, metadata });\n        if (!(metadata === null || metadata === void 0 ? void 0 : metadata.type) || metadata.type === shared_1.SimulationObjectType.None) {\n            this.log('Invalid or None type metadata, treating as unconverted', { itemId: item.id });\n            return shared_1.SelectionType.UNCONVERTED_ELEMENT;\n        }\n        const selectionType = this.mapElementTypeToSelectionType(metadata.type);\n        this.log('Mapped element type to selection type', {\n            itemId: item.id,\n            elementType: metadata.type,\n            selectionType\n        });\n        return selectionType;\n    }\n    mapElementTypeToSelectionType(elementType) {\n        var _a;\n        this.log('Mapping element type to selection type', { elementType });\n        // Create a type-safe mapping object\n        const mapping = {\n            [shared_1.SimulationObjectType.Activity]: shared_1.SelectionType.ACTIVITY,\n            [shared_1.SimulationObjectType.Connector]: shared_1.SelectionType.CONNECTOR,\n            [shared_1.SimulationObjectType.Entity]: shared_1.SelectionType.ENTITY,\n            [shared_1.SimulationObjectType.Generator]: shared_1.SelectionType.GENERATOR,\n            [shared_1.SimulationObjectType.Resource]: shared_1.SelectionType.RESOURCE,\n            [shared_1.SimulationObjectType.Model]: shared_1.SelectionType.MODEL\n        };\n        const result = (_a = mapping[elementType]) !== null && _a !== void 0 ? _a : shared_1.SelectionType.UNKNOWN_BLOCK;\n        this.log('Type mapping result', { elementType, result });\n        return result;\n    }\n    validateSelection(selection) {\n        this.log('Validating selection state', selection);\n        const isValid = (selection &&\n            typeof selection.pageId === 'string' &&\n            Array.isArray(selection.selectedIds) &&\n            typeof selection.selectionType === 'number');\n        if (!isValid) {\n            this.logError('Invalid selection state', selection);\n        }\n        return isValid;\n    }\n    onSelectionChange(listener) {\n        this.log('Adding selection change listener');\n        this.selectionChangeListeners.push(listener);\n    }\n    getCurrentSelection() {\n        this.log('Getting current selection', this.currentSelection);\n        return this.currentSelection;\n    }\n    setCurrentSelection(selection) {\n        this.log('Setting current selection', selection);\n        if (!this.validateSelection(selection)) {\n            this.logError('Invalid selection state, not updating', selection);\n            return;\n        }\n        this.currentSelection = selection;\n        this.notifySelectionChange();\n    }\n    notifySelectionChange() {\n        this.log('Notifying selection change listeners', {\n            listenerCount: this.selectionChangeListeners.length\n        });\n        this.selectionChangeListeners.forEach((listener, index) => {\n            try {\n                this.log(`Executing listener ${index}`);\n                listener(this.currentSelection);\n            }\n            catch (error) {\n                this.logError(`Error in selection change listener ${index}:`, error);\n            }\n        });\n    }\n}\nexports.SelectionManager = SelectionManager;\nSelectionManager.LOG_PREFIX = '[SelectionManager]';\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/managers/SelectionManager.ts?");

/***/ }),

/***/ "./src/managers/TreeStateManager.ts":
/*!******************************************!*\
  !*** ./src/managers/TreeStateManager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TreeStateManager = void 0;\nclass TreeStateManager {\n    constructor(modelManager) {\n        this.expandedNodes = new Set();\n        this.stateChangeListeners = [];\n        this.loggingEnabled = false;\n        this.modelManager = modelManager;\n        this.log('TreeStateManager initialized');\n    }\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    log(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.log(`${TreeStateManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    logError(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.error(`${TreeStateManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    handleNodeToggle(nodeId, expanded, currentPage) {\n        this.log('Handling node toggle', { nodeId, expanded, pageId: currentPage === null || currentPage === void 0 ? void 0 : currentPage.id });\n        try {\n            if (!nodeId) {\n                throw new Error('Node ID is required');\n            }\n            if (!currentPage) {\n                throw new Error('Current page is required');\n            }\n            if (expanded) {\n                this.expandedNodes.add(nodeId);\n                this.log('Node expanded', { nodeId });\n            }\n            else {\n                this.expandedNodes.delete(nodeId);\n                this.log('Node collapsed', { nodeId });\n            }\n            const expandedNodesArray = Array.from(this.expandedNodes);\n            this.log('Saving expanded nodes to storage', { nodes: expandedNodesArray });\n            this.modelManager.setExpandedNodes(currentPage, expandedNodesArray);\n            this.notifyStateChange(expandedNodesArray);\n        }\n        catch (error) {\n            this.logError('Error handling node toggle:', error);\n            throw error;\n        }\n    }\n    updateTreeState(expandedNodes, currentPage) {\n        this.log('Updating tree state', {\n            nodeCount: expandedNodes.length,\n            pageId: currentPage === null || currentPage === void 0 ? void 0 : currentPage.id\n        });\n        try {\n            if (!this.validateState(expandedNodes)) {\n                throw new Error('Invalid expanded nodes state');\n            }\n            if (!currentPage) {\n                throw new Error('Current page is required');\n            }\n            this.expandedNodes = new Set(expandedNodes);\n            this.log('Tree state updated', { nodes: expandedNodes });\n            this.modelManager.setExpandedNodes(currentPage, expandedNodes);\n            this.notifyStateChange(expandedNodes);\n        }\n        catch (error) {\n            this.logError('Error updating tree state:', error);\n            throw error;\n        }\n    }\n    expandPath(modelStructure, nodeId) {\n        this.log('Expanding path to node', { nodeId });\n        const pathNodes = this.modelManager.findPathToNode(modelStructure, nodeId);\n        this.log('Found path nodes', { pathNodes });\n        pathNodes.forEach(id => {\n            this.expandedNodes.add(id);\n            this.log('Added node to expanded set', { nodeId: id });\n        });\n    }\n    validateState(nodes) {\n        this.log('Validating tree state', { nodeCount: nodes === null || nodes === void 0 ? void 0 : nodes.length });\n        const isValid = Array.isArray(nodes) && nodes.every(node => typeof node === 'string');\n        if (!isValid) {\n            this.logError('Invalid tree state', nodes);\n        }\n        return isValid;\n    }\n    getExpandedNodes() {\n        const nodes = Array.from(this.expandedNodes);\n        this.log('Getting expanded nodes', { nodes });\n        return nodes;\n    }\n    loadSavedState(page) {\n        this.log('Loading saved state', { pageId: page === null || page === void 0 ? void 0 : page.id });\n        const savedNodes = this.modelManager.getExpandedNodes(page);\n        this.log('Retrieved saved nodes', { savedNodes });\n        if (savedNodes === null || savedNodes === void 0 ? void 0 : savedNodes.length) {\n            this.expandedNodes = new Set(savedNodes);\n            this.log('Restored expanded nodes', { nodes: savedNodes });\n        }\n        else {\n            this.log('No saved nodes found');\n        }\n    }\n    onStateChange(listener) {\n        this.log('Adding state change listener');\n        this.stateChangeListeners.push(listener);\n    }\n    notifyStateChange(nodes) {\n        this.log('Notifying state change listeners', {\n            listenerCount: this.stateChangeListeners.length\n        });\n        this.stateChangeListeners.forEach((listener, index) => {\n            try {\n                this.log(`Executing listener ${index}`);\n                listener(nodes);\n            }\n            catch (error) {\n                this.logError(`Error in state change listener ${index}:`, error);\n            }\n        });\n    }\n}\nexports.TreeStateManager = TreeStateManager;\nTreeStateManager.LOG_PREFIX = '[TreeStateManager]';\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/managers/TreeStateManager.ts?");

/***/ }),

/***/ "./src/managers/index.ts":
/*!*******************************!*\
  !*** ./src/managers/index.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./SelectionManager */ \"./src/managers/SelectionManager.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./TreeStateManager */ \"./src/managers/TreeStateManager.ts\"), exports);\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/managers/index.ts?");

/***/ }),

/***/ "./src/panels/ModelPanel.ts":
/*!**********************************!*\
  !*** ./src/panels/ModelPanel.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelPanel = void 0;\n// panels/ModelPanel.ts\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst shared_2 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst managers_1 = __webpack_require__(/*! ../managers */ \"./src/managers/index.ts\");\nconst PageSchemaConversionService_1 = __webpack_require__(/*! ../services/conversion/PageSchemaConversionService */ \"./src/services/conversion/PageSchemaConversionService.ts\");\nconst ModelDataSource_1 = __webpack_require__(/*! ../data_sources/model/ModelDataSource */ \"./src/data_sources/model/ModelDataSource.ts\");\nconst LucidElementFactory_1 = __webpack_require__(/*! ../services/LucidElementFactory */ \"./src/services/LucidElementFactory.ts\");\nconst LucidPageConversionService_1 = __webpack_require__(/*! ../services/conversion/LucidPageConversionService */ \"./src/services/conversion/LucidPageConversionService.ts\");\nconst StorageAdapter_1 = __webpack_require__(/*! ../core/StorageAdapter */ \"./src/core/StorageAdapter.ts\");\nconst versioning_1 = __webpack_require__(/*! ../versioning */ \"./src/versioning/index.ts\");\nconst data_sources_1 = __webpack_require__(/*! ../data_sources */ \"./src/data_sources/index.ts\");\nconst DynamicSimulationResultsTableGenerator_1 = __webpack_require__(/*! ../data_sources/simulation_results/DynamicSimulationResultsTableGenerator */ \"./src/data_sources/simulation_results/DynamicSimulationResultsTableGenerator.ts\");\nconst SimulationResultsDashboard_1 = __webpack_require__(/*! ../data_sources/simulation_results/SimulationResultsDashboard */ \"./src/data_sources/simulation_results/SimulationResultsDashboard.ts\");\nclass ModelPanel extends lucid_extension_sdk_1.Panel {\n    constructor(client, modelManager) {\n        super(client, {\n            title: 'Quodsi Model',\n            url: 'quodsim-react/index.html',\n            location: lucid_extension_sdk_1.PanelLocation.RightDock,\n            iconUrl: 'https://lucid.app/favicon.ico',\n            width: 300\n        });\n        this.loggingEnabled = false;\n        this.reactAppReady = false;\n        this.expandedNodes = new Set();\n        this.currentModelStructure = undefined;\n        this.currentSelection = {\n            pageId: '',\n            selectedIds: [],\n            selectionType: shared_1.SelectionType.NONE\n        };\n        this.isHandlingSelectionChange = false;\n        this.versionManager = new versioning_1.default();\n        // Initialize services and managers but don't perform any operations yet\n        this.messaging = shared_1.ExtensionMessaging.getInstance();\n        this.modelManager = modelManager;\n        this.selectionManager = new managers_1.SelectionManager(modelManager);\n        this.treeStateManager = new managers_1.TreeStateManager(modelManager);\n        // Set up event handlers\n        this.setupModelMessageHandlers();\n        this.log('Model Panel initialized');\n    }\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    log(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.log(`${ModelPanel.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    logError(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.error(`${ModelPanel.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    setupModelMessageHandlers() {\n        this.logError('Setting up message handlers START');\n        // React App Ready - already handled by BasePanel\n        // Model Operations\n        this.messaging.onMessage(shared_1.MessageTypes.REACT_APP_READY, () => {\n            this.logError('REACT_APP_READY message received in handler');\n            this.handleReactReady();\n        });\n        this.messaging.onMessage(shared_1.MessageTypes.SIMULATE_MODEL, () => this.handleSimulateModel());\n        this.messaging.onMessage(shared_1.MessageTypes.SIMULATION_STATUS_UPDATE, (data) => this.handleSimulationStatusUpdate(data));\n        // Setup error handler\n        this.messaging.onMessage(shared_1.MessageTypes.ERROR, (payload) => {\n            this.logError('Error received:', payload);\n        });\n        this.messaging.onMessage(shared_1.MessageTypes.CONVERT_ELEMENT, (data) => this.handleConvertElement(data));\n        this.messaging.onMessage(shared_1.MessageTypes.REMOVE_MODEL, () => this.handleRemoveModel());\n        this.messaging.onMessage(shared_1.MessageTypes.CONVERT_PAGE, () => this.handlePageConvertRequest());\n        this.messaging.onMessage(shared_1.MessageTypes.VALIDATE_MODEL, () => this.handleValidateModel());\n        // Element Operations\n        this.messaging.onMessage(shared_1.MessageTypes.UPDATE_ELEMENT_DATA, (data) => this.handleUpdateElementData(data));\n        // Tree State Management\n        this.messaging.onMessage(shared_1.MessageTypes.TREE_NODE_TOGGLE, (data) => this.handleTreeNodeToggle(data.nodeId, data.expanded));\n        this.messaging.onMessage(shared_1.MessageTypes.TREE_STATE_UPDATE, (data) => this.handleTreeStateUpdate(data.expandedNodes));\n        this.messaging.onMessage(shared_1.MessageTypes.TREE_NODE_EXPAND_PATH, (data) => this.handleExpandPath(data.nodeId));\n        this.messaging.onMessage(shared_1.MessageTypes.OUTPUT_CREATE_PAGE, (data) => {\n            this.handleOutputCreatePage(data);\n        });\n        this.logError('Setting up message handlers END');\n    }\n    async handleOutputCreatePage(data) {\n        console.log('[ModelPanel] Output page creation requested:', data.pageName);\n        try {\n            const document = new lucid_extension_sdk_1.DocumentProxy(this.client);\n            // Create new page\n            const def = {\n                title: data.pageName,\n            };\n            const page = document.addPage(def);\n            // this.addActivityUtilizationTable(page)\n            this.handleOutputCreateDashboard();\n            console.log('[SimulationResultsTableGenerator] Successfully called addActivityUtilizationTable');\n        }\n        catch (error) {\n            console.error('[SimulationResultsTableGenerator] Error creating output page:', error);\n            this.messaging.sendMessage(shared_1.MessageTypes.ERROR, {\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            });\n        }\n    }\n    async handleOutputCreatePage2(data) {\n        var _a;\n        console.log('[ModelPanel] Output page creation requested:', data.pageName);\n        try {\n            const document = new lucid_extension_sdk_1.DocumentProxy(this.client);\n            const user = new lucid_extension_sdk_1.UserProxy(this.client);\n            const docId = document.id;\n            const userId = user.id;\n            if (!docId || !userId) {\n                throw new Error('Document ID or User ID is missing');\n            }\n            const validationResult = await this.modelManager.validateModel();\n            if (validationResult.isValid || !validationResult.isValid) {\n                try {\n                    const modelDefinition = await this.modelManager.getModelDefinition();\n                    if (modelDefinition) {\n                        // Create a serializer using the factory (will use latest version by default)\n                        const serializer = shared_1.ModelSerializerFactory.create(modelDefinition);\n                        // Attempt serialization\n                        const serializedModel = serializer.serialize(modelDefinition);\n                        this.log('serializedModel:', JSON.stringify(serializedModel));\n                        // Create new page\n                        const def = {\n                            title: data.pageName,\n                        };\n                        const page = document.addPage(def);\n                        this.addTableBlock(page);\n                        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n                        const currentPage = viewport.getCurrentPage();\n                    }\n                }\n                catch (error) {\n                    // Handle serialization errors\n                    this.log('Model serialization failed:', error);\n                }\n            }\n            else {\n                this.log('validationResult:', validationResult);\n            }\n            const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n            await this.client.performDataAction({\n                dataConnectorName: 'quodsi_data_connector',\n                actionName: 'ImportSimulationResults',\n                actionData: { documentId: docId, userId: userId, pageId: (_a = viewport.getCurrentPage()) === null || _a === void 0 ? void 0 : _a.id },\n                asynchronous: true\n            });\n            console.log('[ModelPanel] Successfully called ImportSimulationResults');\n            // Add code to test SimulationResultsReader\n            try {\n                console.log('[ModelPanel2] Testing SimulationResultsReader...');\n                const resultsReader = new data_sources_1.SimulationResultsReader(this.client);\n                // Get current page ID\n                const currentPage = viewport.getCurrentPage();\n                if (!currentPage) {\n                    console.log('[ModelPanel] No current page found');\n                    return;\n                }\n                // Try to get model data for the current page\n                const modelData = await resultsReader.getModelDataForPage(currentPage.id);\n                console.log('[ModelPanel2] Model data for current page:', modelData);\n                // Check if we have simulation results\n                const hasResults = await resultsReader.hasSimulationResults();\n                console.log('[ModelPanel2] Has simulation results:', hasResults);\n                // Try to get activity utilization data\n                const activityUtilization = await resultsReader.getActivityUtilizationData();\n                console.log('[ModelPanel2] Activity Utilization data count:', activityUtilization.length);\n                if (activityUtilization.length > 0) {\n                    console.log('[ModelPanel2] First activity utilization:', {\n                        name: activityUtilization[0].Name,\n                        meanUtilization: activityUtilization[0].utilization_mean,\n                        maxUtilization: activityUtilization[0].utilization_max\n                    });\n                }\n            }\n            catch (error) {\n                console.error('[ModelPanel] Error testing SimulationResultsReader:', error);\n            }\n        }\n        catch (error) {\n            console.error('[ModelPanel] Error creating output page:', error);\n            this.messaging.sendMessage(shared_1.MessageTypes.ERROR, {\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            });\n        }\n    }\n    async handleOutputCreateDashboard() {\n        try {\n            console.log('[ModelPanel] Creating simulation results dashboard...');\n            // Create dashboard instance with custom configuration\n            const dashboard = new SimulationResultsDashboard_1.SimulationResultsDashboard(this.client, {\n                title: 'Simulation Results Overview',\n                tableSpacing: 60, // Extra space between tables\n                initialX: 50,\n                initialY: 50,\n                tableWidth: 900, // Wider tables\n                tableConfig: {\n                    formatNumbers: true,\n                    percentDecimals: 1,\n                    numberDecimals: 2,\n                    styleHeader: true,\n                    dynamicColumns: true,\n                    maxColumns: 6 // Limit columns for readability\n                },\n                // Customize which data types to include\n                includedDataTypes: {\n                    activityUtilization: true,\n                    activityRepSummary: true,\n                    activityTiming: true,\n                    entityThroughput: true,\n                    resourceRepSummary: true,\n                    entityState: true\n                },\n                // Custom column configurations for specific table types\n                customColumnConfig: {\n                    activityUtilization: {\n                        columnOrder: [\n                            'Name',\n                            'utilization_mean',\n                            'utilization_max',\n                            'capacity_mean',\n                            'capacity_max'\n                        ],\n                        excludeColumns: ['Id']\n                    },\n                    activityRepSummary: {\n                        columnOrder: [\n                            'activity_id',\n                            'rep',\n                            'utilization_percentage',\n                            'throughput_rate',\n                            'capacity'\n                        ]\n                    }\n                }\n            });\n            // Generate a dashboard with the current date/time in the name\n            const timestamp = new Date().toLocaleString().replace(/[/\\\\:]/g, '-');\n            const result = await dashboard.createDashboard(`Simulation Results - ${timestamp}`);\n            console.log(`[ModelPanel] Dashboard created with ${result.tables.length} tables`);\n            // Optional: You could add additional elements to the page here\n            // For example, add a title or description text block\n            if (result.emptyDataTypes.length > 0) {\n                console.log(`[ModelPanel] The following data types had no data: ${result.emptyDataTypes.join(', ')}`);\n            }\n            if (result.errors.length > 0) {\n                console.warn(`[ModelPanel] ${result.errors.length} errors occurred while creating the dashboard`);\n                result.errors.forEach(err => {\n                    console.error(`[ModelPanel] Error creating ${err.type} table:`, err.error);\n                });\n            }\n        }\n        catch (error) {\n            console.error('[ModelPanel] Error creating simulation results dashboard:', error);\n        }\n    }\n    async addActivityUtilizationTable(page) {\n        try {\n            console.log('[ModelPanel2] Testing SimulationResultsReader...');\n            const resultsReader = new data_sources_1.SimulationResultsReader(this.client);\n            // Get current page ID\n            const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n            const currentPage = viewport.getCurrentPage();\n            if (!currentPage) {\n                console.log('[ModelPanel] No current page found');\n                return;\n            }\n            // Try to get model data for the current page\n            const modelData = await resultsReader.getModelDataForPage(currentPage.id);\n            console.log('[ModelPanel2] Model data for current page:', modelData);\n            // Check if we have simulation results\n            const hasResults = await resultsReader.hasSimulationResults();\n            console.log('[ModelPanel2] Has simulation results:', hasResults);\n            // Try to get activity utilization data\n            const activityUtilization = await resultsReader.getActivityUtilizationData();\n            console.log('[ModelPanel2] Activity Utilization data count:', activityUtilization.length);\n            if (activityUtilization.length > 0) {\n                console.log('[ModelPanel2] First activity utilization:', {\n                    name: activityUtilization[0].Name,\n                    meanUtilization: activityUtilization[0].utilization_mean,\n                    maxUtilization: activityUtilization[0].utilization_max\n                });\n            }\n            // Initialize the generator\n            const tableGenerator = new DynamicSimulationResultsTableGenerator_1.DynamicSimulationResultsTableGenerator(resultsReader, {\n                formatNumbers: true,\n                percentDecimals: 1,\n                numberDecimals: 2,\n                styleHeader: true,\n                dynamicColumns: true, // Only include columns with data\n                maxColumns: 6, // Limit number of columns\n                columnOrder: [\n                    'Id',\n                    'Name',\n                    'utilization_mean',\n                    'utilization_max',\n                    'capacity_mean',\n                    'capacity_max'\n                ],\n                excludeColumns: ['Id'], // Don't show the ID column\n            });\n            // Create an activity utilization table\n            const currentY = 0;\n            const activityUtilizationTable = await tableGenerator.createActivityUtilizationTable(page, this.client, {\n                position: { x: 50, y: currentY },\n                width: 700,\n                title: 'Activity Utilization'\n            });\n        }\n        catch (error) {\n            console.error('[ModelPanel] Error testing SimulationResultsReader:', error);\n        }\n    }\n    async addTableBlock(page) {\n        var _a;\n        console.log('[ModelPanel] Starting addTableBlock method...');\n        try {\n            // Create mock data for testing\n            console.log('[ModelPanel] Creating mock CSV data...');\n            const mockCsvData = [\n                [\"Activity\", \"Utilization\", \"Capacity\"],\n                [\"Production\", \"85.4%\", \"100\"],\n                [\"Packaging\", \"72.1%\", \"150\"],\n                [\"Quality Control\", \"63.8%\", \"75\"]\n            ];\n            console.log('[ModelPanel] Mock data created:', mockCsvData);\n            // Calculate table dimensions\n            console.log('[ModelPanel] Calculating table dimensions...');\n            const { width, height } = (0, shared_2.calculateTableDimensions)(mockCsvData);\n            console.log('[ModelPanel] Table dimensions calculated: width =', width, 'height =', height);\n            // Load Table block class\n            console.log('[ModelPanel] Loading TableBlock class...');\n            await this.client.loadBlockClasses(['DefaultTableBlock']);\n            console.log('[ModelPanel] TableBlock class loaded successfully');\n            // Create table block\n            console.log('[ModelPanel] Creating TableBlock definition...');\n            const blockDef = {\n                className: \"DefaultTableBlock\",\n                boundingBox: {\n                    x: 100,\n                    y: 100,\n                    w: 400,\n                    h: 300,\n                },\n            };\n            console.log('[ModelPanel] BlockDefinition created:', blockDef);\n            console.log('[ModelPanel] Adding TableBlock to page...');\n            const tableBlock = page.addBlock(blockDef);\n            console.log('[ModelPanel] TableBlock added to page successfully');\n            // Get row and column counts\n            const rowCount = mockCsvData.length;\n            const columnCount = ((_a = mockCsvData[0]) === null || _a === void 0 ? void 0 : _a.length) || 0;\n            console.log('[ModelPanel] Table dimensions from data: rows =', rowCount, 'columns =', columnCount);\n            // Get the initial cell to use as reference\n            console.log('[ModelPanel] Getting initial rows from table...');\n            const rows = tableBlock.getRows();\n            console.log('[ModelPanel] Retrieved', rows.length, 'initial rows');\n            let lastCell = rows[0].getCells()[0];\n            console.log('[ModelPanel] Got reference to first cell');\n            // Add rows as needed\n            console.log('[ModelPanel] Starting to add', (rowCount - 1), 'additional rows...');\n            for (let i = 1; i < rowCount; i++) {\n                console.log('[ModelPanel] Adding row', i);\n                const newRow = tableBlock.addRow(lastCell);\n                lastCell = newRow.getCells()[0];\n                console.log('[ModelPanel] Row', i, 'added successfully');\n            }\n            console.log('[ModelPanel] All rows added successfully');\n            // Reset to use first row for column additions\n            console.log('[ModelPanel] Resetting reference cell for column additions');\n            lastCell = rows[0].getCells()[0];\n            // Add columns as needed\n            console.log('[ModelPanel] Starting to add', (columnCount - 1), 'additional columns...');\n            for (let i = 1; i < columnCount; i++) {\n                console.log('[ModelPanel] Adding column', i);\n                const newColumn = tableBlock.addColumn(lastCell);\n                lastCell = newColumn.getCells()[0];\n                console.log('[ModelPanel] Column', i, 'added successfully');\n            }\n            console.log('[ModelPanel] All columns added successfully');\n            // Populate table data\n            console.log('[ModelPanel] Starting to populate table data...');\n            const updatedRows = tableBlock.getRows();\n            console.log('[ModelPanel] Retrieved', updatedRows.length, 'rows for populating data');\n            mockCsvData.forEach((rowData, rowIndex) => {\n                console.log('[ModelPanel] Populating row', rowIndex, 'with data:', rowData);\n                const row = updatedRows[rowIndex];\n                const cells = row.getCells();\n                console.log('[ModelPanel] Row', rowIndex, 'has', cells.length, 'cells');\n                rowData.forEach((cellValue, colIndex) => {\n                    console.log('[ModelPanel] Setting cell [', rowIndex, ',', colIndex, '] to value:', cellValue);\n                    const cell = cells[colIndex];\n                    cell.setText(String(cellValue));\n                    // Style header row\n                    // if (rowIndex === 0) {\n                    //     console.log('[ModelPanel] Styling header cell at column', colIndex);\n                    //     cell.setBackgroundColor('#f0f0f0');\n                    //     cell.setBold(true);\n                    // }\n                });\n                console.log('[ModelPanel] Finished populating row', rowIndex);\n            });\n            console.log('[ModelPanel] Table data population completed successfully');\n            console.log('[ModelPanel] Table block creation and configuration completed successfully');\n        }\n        catch (error) {\n            console.error('[ModelPanel] ❌ Error creating table block:', error);\n            console.error('[ModelPanel] Error details:', error instanceof Error ? error.stack : 'Unknown error');\n            this.messaging.sendMessage(shared_1.MessageTypes.ERROR, {\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            });\n        }\n    }\n    async handleSimulationStatusUpdate(data) {\n        try {\n            const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n            const currentPage = viewport.getCurrentPage();\n            if (!currentPage) {\n                throw new Error('No active page found');\n            }\n            // Update the simulation status using StorageAdapter\n            this.modelManager.getStorageAdapter().setSimulationStatus(currentPage, data.pageStatus);\n            // Send a success message back to React\n            this.sendTypedMessage(shared_1.MessageTypes.SIMULATION_STATUS_UPDATE, {\n                pageStatus: data.pageStatus\n            });\n        }\n        catch (error) {\n            this.logError('Failed to update page status:', error);\n            this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                error: `Failed to update simulation status: ${error instanceof Error ? error.message : String(error)}`\n            });\n        }\n    }\n    async updateModelStructure() {\n        // Get model structure from ModelManager\n        this.currentModelStructure = await this.modelManager.getModelStructure();\n        this.log('Model structure updated:', this.currentModelStructure);\n        // Validate model\n        const validationResult = await this.modelManager.validateModel();\n        this.log('Model validation result:', validationResult);\n        // If we're not in a selection change context, notify the React app of the validation update\n        if (!this.isHandlingSelectionChange) {\n            this.sendTypedMessage(shared_1.MessageTypes.VALIDATION_RESULT, validationResult);\n        }\n    }\n    async createSimulationObjectPayload(page, // Keep this as PageProxy for the actual page\n    item, // Change this to ItemProxy to accept both ElementProxy and PageProxy\n    basePayload) {\n        const metadata = this.modelManager.getMetadata(item);\n        if (!metadata) {\n            throw new Error('No metadata found for item');\n        }\n        const modelItemData = await this.buildModelItemData(item);\n        const simulationSelection = {\n            pageId: page.id, // Use the page parameter here\n            selectedId: item.id,\n            objectType: metadata.type,\n            diagramElementType: item instanceof lucid_extension_sdk_1.BlockProxy ? shared_1.DiagramElementType.BLOCK : shared_1.DiagramElementType.LINE\n        };\n        // Create referenceData if it's a Generator\n        this.log(\"DEBUG - Before Generator check:\", {\n            itemId: item.id,\n            metadata,\n            type: metadata === null || metadata === void 0 ? void 0 : metadata.type,\n            isGenerator: (metadata === null || metadata === void 0 ? void 0 : metadata.type) === shared_1.SimulationObjectType.Generator\n        });\n        let referenceData = {};\n        if (metadata.type === shared_1.SimulationObjectType.Generator) {\n            const modelDef = await this.modelManager.getModelDefinition();\n            if (modelDef) {\n                const allEntities = modelDef.entities.getAll();\n                referenceData.entities = allEntities.map(e => {\n                    this.log(\"Mapping entity:\", e);\n                    return {\n                        id: e.id,\n                        name: e.name\n                    };\n                });\n            }\n        }\n        if (metadata.type === shared_1.SimulationObjectType.Activity || metadata.type === shared_1.SimulationObjectType.Connector) {\n            const modelDef = await this.modelManager.getModelDefinition();\n            if (modelDef) {\n                const requirements = modelDef.resourceRequirements.getAll();\n                referenceData.resourceRequirements = requirements;\n            }\n        }\n        return Object.assign(Object.assign({}, basePayload), { simulationSelection,\n            modelItemData, modelStructure: this.currentModelStructure, referenceData });\n    }\n    async handleConvertElement(data) {\n        try {\n            const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n            const currentPage = viewport.getCurrentPage();\n            if (!currentPage) {\n                throw new Error('No active page found');\n            }\n            // Get the element from viewport\n            const selectedItems = viewport.getSelectedItems();\n            const element = selectedItems.find(item => item.id === data.elementId);\n            if (!element) {\n                throw new Error(`Element not found in selection: ${data.elementId}`);\n            }\n            // Get model definition (might be needed by some conversions)\n            const modelDef = await this.modelManager.getModelDefinition();\n            if (!modelDef) {\n                throw new Error('Model definition not found');\n            }\n            // Create the platform object with conversion flag\n            // This will handle all the data creation and storage internally\n            const elementFactory = new LucidElementFactory_1.LucidElementFactory(this.modelManager.getStorageAdapter());\n            const platformObject = elementFactory.createPlatformObject(element, data.type, true // isConversion flag\n            );\n            await this.updateModelStructure();\n            if (!this.currentModelStructure) {\n                throw new Error('Failed to update model structure after conversion');\n            }\n            const payload = await this.createSimulationObjectPayload(currentPage, element, {\n                selectionState: {\n                    pageId: currentPage.id,\n                    selectedIds: [data.elementId],\n                    selectionType: shared_1.SelectionType.ACTIVITY\n                }\n            });\n            this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_SIMULATION_OBJECT, payload);\n        }\n        catch (error) {\n            this.logError('Error converting element:', error);\n            this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                error: `Failed to convert element: ${error instanceof Error ? error.message : String(error)}`\n            });\n        }\n    }\n    /**\n     * Handles tree node expansion state changes\n     */\n    handleTreeNodeToggle(nodeId, expanded) {\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        if (!currentPage)\n            return;\n        this.treeStateManager.handleNodeToggle(nodeId, expanded, currentPage);\n        this.sendTreeStateUpdate();\n    }\n    /**\n     * Handles bulk tree state updates\n     */\n    handleTreeStateUpdate(expandedNodes) {\n        this.log('Tree state update:', { expandedNodes });\n        this.expandedNodes = new Set(expandedNodes);\n        // Get current page and save to storage\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        if (currentPage) {\n            this.log('Saving expanded nodes to storage:', expandedNodes);\n            this.modelManager.setExpandedNodes(currentPage, expandedNodes);\n        }\n        this.sendTreeStateUpdate();\n    }\n    /**\n     * Expands the path to a specific node\n     */\n    handleExpandPath(nodeId) {\n        if (!this.currentModelStructure)\n            return;\n        // Get path nodes from ModelManager\n        const pathNodes = this.modelManager.findPathToNode(this.currentModelStructure, nodeId);\n        // Add all nodes in path to expanded set\n        pathNodes.forEach(id => this.expandedNodes.add(id));\n        this.sendTreeStateUpdate();\n    }\n    /**\n     * Sends current tree state to React app\n     */\n    sendTreeStateUpdate() {\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        if (!currentPage)\n            return;\n        this.sendTypedMessage(shared_1.MessageTypes.TREE_STATE_SYNC, {\n            expandedNodes: Array.from(this.expandedNodes),\n            pageId: currentPage.id\n        });\n    }\n    async initializeModelManager() {\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        if (!currentPage || !this.modelManager.isQuodsiModel(currentPage)) {\n            this.log('Page is not a Quodsi model, skipping initialization');\n            return;\n        }\n        try {\n            const modelData = this.modelManager.getElementData(currentPage);\n            if (modelData) {\n                await this.modelManager.initializeModel(modelData, currentPage);\n                this.log('Model initialization complete');\n            }\n        }\n        catch (error) {\n            this.logError('Error initializing model:', error);\n            throw new Error(`Failed to initialize model: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n     * Shows the panel\n     */\n    show() {\n        this.log('Show called');\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        this.log('Current page at show:', currentPage);\n        this.initializeModelManager(); // Re-initialize when panel is shown\n        super.show();\n    }\n    /**\n     * Hides the panel\n     */\n    hide() {\n        this.log('Hide called');\n        super.hide();\n    }\n    async handleValidateRequest() {\n        const validationResult = await this.modelManager.validateModel();\n        // Send separate validation result message for explicit validation requests\n        this.sendTypedMessage(shared_1.MessageTypes.VALIDATION_RESULT, validationResult);\n    }\n    async handleSelectionChange(items) {\n        this.isHandlingSelectionChange = true;\n        try {\n            const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n            const currentPage = viewport.getCurrentPage();\n            if (!currentPage)\n                return;\n            await this.updateModelStructure();\n            const selectionState = await this.selectionManager.determineSelectionState(currentPage, items);\n            this.selectionManager.setCurrentSelection(selectionState);\n            if (this.reactAppReady) {\n                await this.sendSelectionBasedMessage(selectionState, items, currentPage);\n            }\n        }\n        catch (error) {\n            this.handleError('Error handling selection change:', error);\n        }\n        finally {\n            this.isHandlingSelectionChange = false;\n        }\n    }\n    async sendSelectionBasedMessage(selectionState, items, currentPage) {\n        this.log(\"DEBUG - sendSelectionBasedMessage START - Selection Type:\", selectionState.selectionType);\n        if (items.length === 1) {\n            const item = items[0];\n            this.log(\"DEBUG - Item metadata:\", this.modelManager.getMetadata(item));\n        }\n        // Convert ElementProxy to PageProxy if needed\n        const page = new lucid_extension_sdk_1.PageProxy(currentPage.id, this.client);\n        // Early check - if page is not a model, always send PAGE_NO_MODEL\n        if (!this.modelManager.isQuodsiModel(page)) {\n            this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_PAGE_NO_MODEL, {\n                pageId: page.id\n            });\n            return;\n        }\n        const modelStructure = this.currentModelStructure || { elements: [], hierarchy: {} };\n        const expandedNodes = this.treeStateManager.getExpandedNodes();\n        const validationResult = await this.modelManager.validateModel();\n        const document = new lucid_extension_sdk_1.DocumentProxy(this.client);\n        const documentId = document.id;\n        const basePayload = {\n            selectionState,\n            modelStructure,\n            expandedNodes,\n            validationResult,\n            documentId\n        };\n        switch (selectionState.selectionType) {\n            case shared_1.SelectionType.NONE: {\n                // Build model item data for the page since it's a model\n                const modelItemData = await this.buildModelItemData(page);\n                const payload = Object.assign(Object.assign({}, basePayload), { pageSelection: {\n                        pageId: currentPage.id\n                    }, modelStructure, // Already in basePayload\n                    modelItemData // Add the page's model data\n                 });\n                this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_PAGE_WITH_MODEL, payload);\n                break;\n            }\n            case shared_1.SelectionType.MULTIPLE: {\n                const modelItemData = await Promise.all(items.map(item => this.buildModelItemData(item)));\n                const payload = Object.assign(Object.assign({}, basePayload), { multipleSelection: {\n                        pageId: currentPage.id,\n                        selectedIds: items.map(item => item.id)\n                    }, modelItemData });\n                this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_MULTIPLE, payload);\n                break;\n            }\n            case shared_1.SelectionType.UNCONVERTED_ELEMENT: {\n                if (items.length === 1) {\n                    const item = items[0];\n                    const modelItemData = await this.buildModelItemData(item);\n                    modelItemData.isUnconverted = true;\n                    const unconvertedSelection = {\n                        pageId: currentPage.id,\n                        selectedId: item.id,\n                        diagramElementType: item instanceof lucid_extension_sdk_1.BlockProxy ? shared_1.DiagramElementType.BLOCK : shared_1.DiagramElementType.LINE\n                    };\n                    const payload = Object.assign(Object.assign({}, basePayload), { unconvertedSelection,\n                        modelItemData });\n                    this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_UNCONVERTED, payload);\n                }\n                break;\n            }\n            case shared_1.SelectionType.ACTIVITY:\n            case shared_1.SelectionType.CONNECTOR:\n            case shared_1.SelectionType.ENTITY:\n            case shared_1.SelectionType.GENERATOR:\n            case shared_1.SelectionType.RESOURCE:\n            case shared_1.SelectionType.MODEL: {\n                if (items.length === 1) {\n                    const item = items[0];\n                    const metadata = this.modelManager.getMetadata(item);\n                    if (metadata) {\n                        const payload = await this.createSimulationObjectPayload(currentPage, // Pass the page\n                        item, // Pass the selected item\n                        basePayload);\n                        this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_SIMULATION_OBJECT, payload);\n                    }\n                }\n                break;\n            }\n            default: {\n                // Build model item data for the page since it's a model\n                const modelItemData = await this.buildModelItemData(page);\n                const payload = Object.assign(Object.assign({}, basePayload), { pageSelection: {\n                        pageId: currentPage.id\n                    }, modelStructure, // Already in basePayload\n                    modelItemData // Add the page's model data\n                 });\n                this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_PAGE_WITH_MODEL, payload);\n                break;\n            }\n        }\n    }\n    handleError(message, error) {\n        this.logError(`${message}`, error);\n        this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n    // Keep this as the primary builder\n    async buildModelItemData(item) {\n        const rawData = this.modelManager.getElementData(item);\n        const metadata = this.modelManager.getMetadata(item);\n        // Determine name based on item type\n        let name;\n        if (item instanceof lucid_extension_sdk_1.PageProxy) {\n            name = item.getTitle() || 'Untitled Model';\n        }\n        else if (item instanceof lucid_extension_sdk_1.BlockProxy) {\n            name = item.id || 'Unnamed Block';\n        }\n        else {\n            name = 'Unnamed Connector';\n        }\n        // Ensure metadata has all required fields\n        const defaultMetadata = Object.assign({ type: item instanceof lucid_extension_sdk_1.PageProxy ? shared_1.SimulationObjectType.Model : shared_1.SimulationObjectType.None, version: this.modelManager.CURRENT_VERSION, lastModified: new Date().toISOString(), id: item.id }, (metadata || {}));\n        // Handle unconverted elements\n        if (item instanceof lucid_extension_sdk_1.ItemProxy && this.modelManager.isUnconvertedElement(item)) {\n            defaultMetadata.isUnconverted = true;\n        }\n        // Convert Lucid JsonObject to shared JsonObject type\n        const convertedData = rawData ? JSON.parse(JSON.stringify(rawData)) : {};\n        return {\n            id: item.id,\n            data: convertedData,\n            metadata: defaultMetadata,\n            name\n        };\n    }\n    // Helper method for building multiple items\n    async buildModelItemDataArray(items) {\n        return Promise.all(items.map(item => this.buildModelItemData(item)));\n    }\n    /**\n     * Handles model removal request\n     */\n    async handleRemoveModel() {\n        try {\n            const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n            const currentPage = viewport.getCurrentPage();\n            if (!currentPage)\n                return;\n            // Remove the model data from the page\n            await this.modelManager.removeModelFromPage(currentPage);\n            // Since the model was just removed, we know this is now a non-model page\n            // Directly send PAGE_NO_MODEL state - no need for modelRemoved message\n            this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_PAGE_NO_MODEL, {\n                pageId: currentPage.id\n            });\n        }\n        catch (error) {\n            this.handleError('Error removing model:', error);\n        }\n    }\n    async handleReactReady() {\n        if (this.reactAppReady) {\n            this.logError('React app already ready, skipping initialization');\n            return;\n        }\n        this.logError('handleReactReady');\n        this.reactAppReady = true;\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        const document = new lucid_extension_sdk_1.DocumentProxy(this.client);\n        if (!currentPage) {\n            this.logError('No active page found during React ready');\n            return;\n        }\n        try {\n            // Check for and handle any needed version upgrades\n            // await this.versionManager.handlePageLoad(currentPage);\n            // Now initialize the model in response to a user-triggered event\n            await this.initializeModelManager();\n            // Get current selection state and send appropriate message\n            const selectedItems = viewport.getSelectedItems();\n            await this.handleSelectionChange(selectedItems);\n        }\n        catch (error) {\n            this.handleError('Error during React ready initialization:', error);\n        }\n    }\n    /**\n     * Handles page conversion request\n     */\n    async handlePageConvertRequest() {\n        this.log('Handling convert request');\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        const document = new lucid_extension_sdk_1.DocumentProxy(this.client);\n        if (!currentPage) {\n            this.sendTypedMessage(shared_1.MessageTypes.CONVERSION_ERROR, {\n                error: 'No active page found'\n            });\n            return;\n        }\n        try {\n            this.log('Creating dataProxy');\n            const dataProxy = new lucid_extension_sdk_1.DataProxy(this.client);\n            this.log('Creating modelDataSource');\n            const modelDataSource = new ModelDataSource_1.ModelDataSource(dataProxy);\n            this.log('Creating pageSchemaConversionService');\n            const pageSchemaConversionService = new PageSchemaConversionService_1.PageSchemaConversionService(modelDataSource);\n            this.log('pageSchemaConversionService.convertPage');\n            // const result2 = await pageSchemaConversionService.convertPage(currentPage);\n            const storageAdapter = new StorageAdapter_1.StorageAdapter();\n            const lucidElementFactory = new LucidElementFactory_1.LucidElementFactory(storageAdapter);\n            const lucidPageConversionService = new LucidPageConversionService_1.LucidPageConversionService(this.modelManager, lucidElementFactory, storageAdapter);\n            lucidPageConversionService.convertPage(currentPage);\n            const selectedItems = viewport.getSelectedItems();\n            await this.handleSelectionChange(selectedItems);\n        }\n        catch (error) {\n            this.logError('Conversion error:', error);\n            this.sendTypedMessage(shared_1.MessageTypes.CONVERSION_ERROR, {\n                error: error instanceof Error ? error.message : 'Unknown error'\n            });\n        }\n    }\n    /**\n     * Handles element data update\n     */\n    async handleUpdateElementData(updateData) {\n        this.log('Received element update data:', updateData);\n        try {\n            const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n            const currentPage = viewport.getCurrentPage();\n            if (!currentPage) {\n                throw new Error('No active page found');\n            }\n            // Get the element from viewport\n            const selectedItems = viewport.getSelectedItems();\n            if (updateData.type == 'Model') {\n                this.log('Received element type of Model:', updateData.type);\n                this.modelManager.setElementData(currentPage, updateData.data, shared_1.SimulationObjectType.Model);\n                // this.modelManager.updateElement({\n                //     id: currentPage.id,\n                //     type: SimulationObjectType.Model,\n                //     ...updateData.data\n                // });\n            }\n            else {\n                // Update current selection first\n                this.currentSelection = {\n                    pageId: currentPage.id,\n                    selectedIds: selectedItems.map(item => item.id),\n                    selectionType: this.currentSelection.selectionType\n                };\n                const element = selectedItems.find(item => item.id === updateData.elementId);\n                if (!element) {\n                    throw new Error(`Element not found in selection: ${updateData.elementId}`);\n                }\n                // Save element data using ModelManager\n                await this.modelManager.saveElementData(element, updateData.data, updateData.type, currentPage);\n            }\n            // Send success message\n            this.sendTypedMessage(shared_1.MessageTypes.UPDATE_SUCCESS, {\n                elementId: updateData.elementId\n            });\n            // Debug logging\n            this.log('Debug - Selection state:', {\n                currentSelectionIds: this.currentSelection.selectedIds,\n                updatedElementId: updateData.elementId,\n                isElementInSelection: this.currentSelection.selectedIds.includes(updateData.elementId),\n                selectedItems: selectedItems.map(item => item.id)\n            });\n            // Update validation and selection state\n            await this.modelManager.validateModel();\n            // Only update selection if this element is selected\n            if (this.currentSelection.selectedIds.includes(updateData.elementId)) {\n                await this.handleSelectionChange(selectedItems);\n            }\n        }\n        catch (error) {\n            this.logError('Error updating element:', error);\n            this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                error: `Failed to update element: ${error instanceof Error ? error.message : String(error)}`\n            });\n        }\n    }\n    async handleSimulateModel() {\n        this.log('Handling simulate model request');\n        try {\n            // Get the document ID using DocumentProxy\n            const documentId = new lucid_extension_sdk_1.DocumentProxy(this.client).id;\n            const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n            const userId = new lucid_extension_sdk_1.UserProxy(this.client).id;\n            // const activePageProxy = viewport.getCurrentPage();\n            const activePageProxy = viewport.getCurrentPage();\n            let pageId = 'undefined';\n            if (activePageProxy) {\n                pageId = activePageProxy.id;\n            }\n            else {\n                this.log('No active page');\n                this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                    error: `Failed to start simulation: No active page`\n                });\n                return;\n            }\n            this.log(`Extension: docId=${documentId}, pageId=${pageId}, userId=${userId}`);\n            const modelDefinition = await this.modelManager.getModelDefinition();\n            if (modelDefinition) {\n                const serializer = shared_1.ModelSerializerFactory.create(modelDefinition);\n                // Attempt serialization\n                const serializedModel = serializer.serialize(modelDefinition);\n                this.log('serializedModel:', JSON.stringify(serializedModel));\n                // Trigger simulation using the data connector\n                await this.client.performDataAction({\n                    dataConnectorName: 'quodsi_data_connector',\n                    actionName: 'SaveAndSubmitSimulation',\n                    actionData: { 'documentId': documentId, 'pageId': pageId, 'userId': userId, 'model': serializedModel },\n                    asynchronous: true\n                });\n                // Send success message back to React app\n                this.sendTypedMessage(shared_1.MessageTypes.SIMULATION_STARTED, {\n                    documentId: documentId\n                });\n            }\n        }\n        catch (error) {\n            this.logError('Error starting simulation:', error);\n            this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                error: `Failed to start simulation: ${error instanceof Error ? error.message : String(error)}`\n            });\n        }\n    }\n    /**\n     * Handles model validation request\n     */\n    async handleValidateModel() {\n        this.log('Handling validate model');\n        const validationResult = await this.modelManager.validateModel();\n        this.log('validationResult:', validationResult);\n        // Send separate validation result message for explicit validation requests\n        this.sendTypedMessage(shared_1.MessageTypes.VALIDATION_RESULT, validationResult);\n        // If validation succeeded, try to serialize\n        if (validationResult.isValid || !validationResult.isValid) {\n            try {\n                // Get the model definition from the model manager\n                const modelDefinition = await this.modelManager.getModelDefinition();\n                if (modelDefinition) {\n                    // Create a serializer using the factory (will use latest version by default)\n                    const serializer = shared_1.ModelSerializerFactory.create(modelDefinition);\n                    // Attempt serialization\n                    const serializedModel = serializer.serialize(modelDefinition);\n                    this.log('serializedModel:', serializedModel);\n                    try {\n                        // Prepare the request payload\n                        const document = new lucid_extension_sdk_1.DocumentProxy(this.client);\n                        const documentId = document.id;\n                        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n                        const user = new lucid_extension_sdk_1.UserProxy(this.client);\n                        // const activePageProxy = viewport.getCurrentPage();\n                        const activePageProxy = viewport.getCurrentPage();\n                        let pageId = 'undefined';\n                        let userId = 'undefined';\n                        if (user) {\n                            userId = user.id;\n                        }\n                        if (activePageProxy) {\n                            pageId = activePageProxy.id;\n                        }\n                        // Make the request to upload the model definition\n                        await this.client.performDataAction({\n                            dataConnectorName: 'quodsi_data_connector',\n                            actionName: 'UploadModelDefinition',\n                            actionData: { documentId: documentId, userId: userId, pageId: pageId, model: serializedModel },\n                            asynchronous: true\n                        });\n                        // Send a message to the React app about the successful upload\n                        // this.sendTypedMessage(MessageTypes.MODEL_UPLOAD_SUCCESS, {\n                        //     blobUrl: response.data.blobUrl,\n                        //     uploadDateTime: response.data.uploadDateTime,\n                        //     batchJob: response.data.batchJob\n                        // });\n                    }\n                    catch (uploadError) {\n                        this.log('Model upload failed:', uploadError);\n                        // Send error message to the React app\n                        // this.sendTypedMessage(MessageTypes.MODEL_UPLOAD_ERROR, {\n                        //     error: uploadError.message || 'Failed to upload model'\n                        // });\n                    }\n                    // Log success of serialization\n                    this.log('Model serialization successful');\n                }\n                else {\n                    this.log('No model definition available');\n                }\n            }\n            catch (error) {\n                // Handle serialization errors\n                this.log('Model serialization failed:', error);\n            }\n        }\n    }\n    /**\n     * Handles model saved message\n     */\n    handleModelSaved(data) {\n        this.log('Handling model saved');\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        if (currentPage) {\n            try {\n                this.modelManager.setElementData(currentPage, data, shared_1.SimulationObjectType.Model);\n                this.modelManager.updateElement(Object.assign({ id: currentPage.id, type: shared_1.SimulationObjectType.Model }, data));\n                this.sendTypedMessage(shared_1.MessageTypes.UPDATE_SUCCESS, {\n                    elementId: currentPage.id\n                });\n            }\n            catch (error) {\n                this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                    error: `Failed to save model: ${error}`\n                });\n            }\n        }\n    }\n    sendTypedMessage(type, payload) {\n        const message = {\n            messagetype: type,\n            data: payload !== null && payload !== void 0 ? payload : null\n        };\n        this.sendMessage(message);\n    }\n    // Message frame handling\n    messageFromFrame(message) {\n        if (!(0, shared_1.isValidMessage)(message)) {\n            this.logError('Invalid message format:', message);\n            this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                error: 'Invalid message format'\n            });\n            return;\n        }\n        this.messaging.handleIncomingMessage(message);\n    }\n}\nexports.ModelPanel = ModelPanel;\nModelPanel.LOG_PREFIX = '[ModelPanel]';\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/panels/ModelPanel.ts?");

/***/ }),

/***/ "./src/services/LucidElementFactory.ts":
/*!*********************************************!*\
  !*** ./src/services/LucidElementFactory.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidElementFactory = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types/index.ts\");\n/**\n * Factory for creating platform-specific simulation objects from Lucid elements.\n */\nclass LucidElementFactory {\n    constructor(storageAdapter) {\n        this.storageAdapter = storageAdapter;\n    }\n    /**\n     * Creates the appropriate platform-specific simulation object based on the element type\n     */\n    createPlatformObject(element, type, isConversion = false) {\n        console.log(`[LucidElementFactory] Creating platform object`, {\n            elementId: element.id,\n            type: type,\n            elementType: element.constructor.name,\n            isConversion: isConversion\n        });\n        try {\n            switch (type) {\n                case shared_1.SimulationObjectType.Model:\n                    console.log(`[LucidElementFactory] Checking PageProxy for Model`);\n                    if (this.isPageProxy(element)) {\n                        console.log(`[LucidElementFactory] Creating ModelLucid`);\n                        return new types_1.ModelLucid(element, this.storageAdapter);\n                    }\n                    console.error(`[LucidElementFactory] Element is not a PageProxy for Model`);\n                    break;\n                case shared_1.SimulationObjectType.Activity:\n                    console.log(`[LucidElementFactory] Checking BlockProxy for Activity`);\n                    if (this.isBlockProxy(element)) {\n                        console.log(`[LucidElementFactory] Creating ActivityLucid`);\n                        return isConversion\n                            ? types_1.ActivityLucid.createFromConversion(element, this.storageAdapter)\n                            : new types_1.ActivityLucid(element, this.storageAdapter);\n                    }\n                    console.error(`[LucidElementFactory] Element is not a BlockProxy for Activity`);\n                    break;\n                case shared_1.SimulationObjectType.Connector:\n                    console.log(`[LucidElementFactory] Checking LineProxy for Connector`);\n                    if (this.isLineProxy(element)) {\n                        console.log(`[LucidElementFactory] Creating ConnectorLucid`);\n                        return isConversion\n                            ? types_1.ConnectorLucid.createFromConversion(element, this.storageAdapter)\n                            : new types_1.ConnectorLucid(element, this.storageAdapter);\n                    }\n                    console.error(`[LucidElementFactory] Element is not a LineProxy for Connector`);\n                    break;\n                case shared_1.SimulationObjectType.Entity:\n                    console.log(`[LucidElementFactory] Checking BlockProxy for Entity`);\n                    if (this.isBlockProxy(element)) {\n                        console.log(`[LucidElementFactory] Creating EntityLucid`);\n                        return isConversion\n                            ? types_1.EntityLucid.createFromConversion(element, this.storageAdapter)\n                            : new types_1.EntityLucid(element, this.storageAdapter);\n                    }\n                    console.error(`[LucidElementFactory] Element is not a BlockProxy for Entity`);\n                    break;\n                case shared_1.SimulationObjectType.Generator:\n                    console.log(`[LucidElementFactory] Checking BlockProxy for Generator`);\n                    if (this.isBlockProxy(element)) {\n                        console.log(`[LucidElementFactory] Creating GeneratorLucid`);\n                        return isConversion\n                            ? types_1.GeneratorLucid.createFromConversion(element, this.storageAdapter)\n                            : new types_1.GeneratorLucid(element, this.storageAdapter);\n                    }\n                    console.error(`[LucidElementFactory] Element is not a BlockProxy for Generator`);\n                    break;\n                case shared_1.SimulationObjectType.Resource:\n                    console.log(`[LucidElementFactory] Checking BlockProxy for Resource`);\n                    if (this.isBlockProxy(element)) {\n                        console.log(`[LucidElementFactory] Creating ResourceLucid`);\n                        return isConversion\n                            ? types_1.ResourceLucid.createFromConversion(element, this.storageAdapter)\n                            : new types_1.ResourceLucid(element, this.storageAdapter);\n                    }\n                    console.error(`[LucidElementFactory] Element is not a BlockProxy for Resource`);\n                    break;\n                case shared_1.SimulationObjectType.ResourceRequirement:\n                    console.log(`[LucidElementFactory] Checking BlockProxy for ResourceRequirement`);\n                    if (this.isBlockProxy(element)) {\n                        console.log(`[LucidElementFactory] Creating ResourceRequirementLucid`);\n                        return isConversion\n                            ? types_1.ResourceRequirementLucid.createFromConversion(element, this.storageAdapter)\n                            : new types_1.ResourceRequirementLucid(element, this.storageAdapter);\n                    }\n                    console.error(`[LucidElementFactory] Element is not a BlockProxy for ResourceRequirement`);\n                    break;\n                default:\n                    console.error(`[LucidElementFactory] Unsupported simulation object type: ${type}`);\n            }\n            throw new Error(`Cannot create platform object for type ${type} from element ${element.id}`);\n        }\n        catch (error) {\n            console.error(`[LucidElementFactory] Error creating platform object:`, {\n                type: type,\n                elementId: element.id,\n                error: error instanceof Error ? error.message : String(error)\n            });\n            if (error instanceof Error) {\n                console.error(`[LucidElementFactory] Error stack:`, error.stack);\n            }\n            throw error;\n        }\n    }\n    // Rest of the class remains the same...\n    /**\n     * Creates a ResourceRequirement from a Resource\n     */\n    createResourceRequirement(element, resource) {\n        return types_1.ResourceRequirementLucid.createFromResource(element, this.storageAdapter, resource);\n    }\n    /**\n     * Type guard for BlockProxy\n     */\n    isBlockProxy(element) {\n        const isBlock = 'getClassName' in element && 'textAreas' in element;\n        console.log(`[LucidElementFactory] isBlockProxy check:`, {\n            elementId: element.id,\n            result: isBlock,\n            hasGetClassName: 'getClassName' in element,\n            hasTextAreas: 'textAreas' in element\n        });\n        return isBlock;\n    }\n    /**\n     * Type guard for LineProxy\n     */\n    isLineProxy(element) {\n        const isLine = 'getEndpoint1' in element && 'getEndpoint2' in element;\n        console.log(`[LucidElementFactory] isLineProxy check:`, {\n            elementId: element.id,\n            result: isLine,\n            hasGetEndpoint1: 'getEndpoint1' in element,\n            hasGetEndpoint2: 'getEndpoint2' in element\n        });\n        return isLine;\n    }\n    /**\n     * Type guard for PageProxy\n     */\n    isPageProxy(element) {\n        const isPage = element && 'getTitle' in element && 'allBlocks' in element;\n        console.log(`[LucidElementFactory] isPageProxy check:`, {\n            elementId: element === null || element === void 0 ? void 0 : element.id,\n            result: isPage,\n            element: element,\n            hasGetTitle: element && 'getTitle' in element,\n            hasAllBlocks: element && 'allBlocks' in element\n        });\n        return isPage;\n    }\n}\nexports.LucidElementFactory = LucidElementFactory;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/services/LucidElementFactory.ts?");

/***/ }),

/***/ "./src/services/NotificationService.ts":
/*!*********************************************!*\
  !*** ./src/services/NotificationService.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NotificationService = void 0;\n/**\n * Service for managing user notifications in the LucidChart environment\n */\nclass NotificationService {\n    constructor() { }\n    /**\n     * Get the singleton instance\n     */\n    static getInstance() {\n        if (!NotificationService.instance) {\n            NotificationService.instance = new NotificationService();\n        }\n        return NotificationService.instance;\n    }\n    /**\n     * Shows an informational message\n     */\n    showMessage(message) {\n        console.log('Info:', message);\n        // TODO: Implement actual LucidChart notification\n    }\n    /**\n     * Shows a warning message\n     */\n    showWarning(message) {\n        console.warn('Warning:', message);\n        // TODO: Implement actual LucidChart notification\n    }\n    /**\n     * Shows an error message\n     */\n    showError(message) {\n        console.error('Error:', message);\n        // TODO: Implement actual LucidChart notification\n    }\n}\nexports.NotificationService = NotificationService;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/services/NotificationService.ts?");

/***/ }),

/***/ "./src/services/accordion/ModelStructureBuilder.ts":
/*!*********************************************************!*\
  !*** ./src/services/accordion/ModelStructureBuilder.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelStructureBuilder = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nclass ModelStructureBuilder {\n    static buildModelStructure(modelData) {\n        console.group('ModelStructureBuilder.buildModelStructure');\n        if (!modelData) {\n            console.warn('Empty model data');\n            console.groupEnd();\n            return { elements: [], hierarchy: {} };\n        }\n        const elements = [];\n        const hierarchy = {};\n        // Create root node for ModelDefinition\n        const rootElement = {\n            id: modelData.id,\n            name: modelData.name,\n            type: shared_1.SimulationObjectType.Model,\n            hasChildren: true,\n            children: []\n        };\n        elements.push(rootElement);\n        // Create nodes for each manager type\n        const managerTypes = [\n            { id: 'activities', name: 'Activities', type: shared_1.SimulationObjectType.Activity, items: modelData.activities },\n            { id: 'connectors', name: 'Connectors', type: shared_1.SimulationObjectType.Connector, items: modelData.connectors },\n            { id: 'resources', name: 'Resources', type: shared_1.SimulationObjectType.Resource, items: modelData.resources },\n            { id: 'generators', name: 'Generators', type: shared_1.SimulationObjectType.Generator, items: modelData.generators },\n            { id: 'entities', name: 'Entities', type: shared_1.SimulationObjectType.Entity, items: modelData.entities },\n            { id: 'requirements', name: 'Requirements', type: shared_1.SimulationObjectType.ResourceRequirement, items: modelData.resourceRequirements }\n        ];\n        // Add manager nodes and their items\n        managerTypes.forEach(manager => {\n            const managerId = `${modelData.id}_${manager.id}`;\n            const managerElement = {\n                id: managerId,\n                name: manager.name,\n                type: manager.type,\n                hasChildren: manager.items.getAll().length > 0,\n                children: []\n            };\n            elements.push(managerElement);\n            hierarchy[modelData.id] = hierarchy[modelData.id] || [];\n            hierarchy[modelData.id].push(managerId);\n            // Add individual items under each manager\n            manager.items.getAll().forEach(item => {\n                const itemElement = {\n                    id: item.id,\n                    name: item.name,\n                    type: manager.type,\n                    hasChildren: false,\n                    children: []\n                };\n                elements.push(itemElement);\n                hierarchy[managerId] = hierarchy[managerId] || [];\n                hierarchy[managerId].push(item.id);\n            });\n        });\n        console.debug('Build complete:', { totalElements: elements.length });\n        console.groupEnd();\n        return { elements, hierarchy };\n    }\n}\nexports.ModelStructureBuilder = ModelStructureBuilder;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/services/accordion/ModelStructureBuilder.ts?");

/***/ }),

/***/ "./src/services/conversion/LucidPageAnalyzer.ts":
/*!******************************************************!*\
  !*** ./src/services/conversion/LucidPageAnalyzer.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidPageAnalyzer = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nclass LucidPageAnalyzer extends shared_1.QuodsiLogger {\n    constructor() {\n        super();\n        this.LOG_PREFIX = '[LucidPageAnalyzer]';\n        this.setLogging(false);\n    }\n    analyzePage(page) {\n        this.log('Analyzing page structure');\n        const blockAnalysis = new Map();\n        // Log all blocks first\n        this.log('All blocks:', Array.from(page.allBlocks.keys()));\n        this.log('All lines:', Array.from(page.allLines.keys()));\n        // First pass: Initialize all blocks and analyze connections\n        this.initializeBlocks(page, blockAnalysis);\n        this.analyzeConnections(page, blockAnalysis);\n        // Second pass: Determine types based on connection patterns\n        this.determineTypesFromConnections(blockAnalysis);\n        // Third pass: Apply block-specific overrides only if needed\n        this.applyBlockSpecificLogic(page, blockAnalysis);\n        // Log final results\n        this.logFinalAnalysis(blockAnalysis);\n        return { blockAnalysis };\n    }\n    initializeBlocks(page, blockAnalysis) {\n        for (const [blockId] of page.allBlocks) {\n            blockAnalysis.set(blockId, {\n                incomingCount: 0,\n                outgoingCount: 0,\n                elementType: undefined\n            });\n        }\n    }\n    analyzeConnections(page, blockAnalysis) {\n        var _a, _b;\n        for (const [lineId, line] of page.allLines) {\n            const endpoint1 = line.getEndpoint1();\n            const endpoint2 = line.getEndpoint2();\n            this.log(`Analyzing line ${lineId}:`, {\n                hasEndpoint1Connection: !!(endpoint1 === null || endpoint1 === void 0 ? void 0 : endpoint1.connection),\n                hasEndpoint2Connection: !!(endpoint2 === null || endpoint2 === void 0 ? void 0 : endpoint2.connection),\n                endpoint1Id: (_a = endpoint1 === null || endpoint1 === void 0 ? void 0 : endpoint1.connection) === null || _a === void 0 ? void 0 : _a.id,\n                endpoint2Id: (_b = endpoint2 === null || endpoint2 === void 0 ? void 0 : endpoint2.connection) === null || _b === void 0 ? void 0 : _b.id\n            });\n            if (endpoint1.connection && endpoint2.connection) {\n                const sourceId = endpoint1.connection.id;\n                const targetId = endpoint2.connection.id;\n                this.updateBlockAnalysis(blockAnalysis, sourceId, 'outgoing');\n                this.updateBlockAnalysis(blockAnalysis, targetId, 'incoming');\n            }\n        }\n    }\n    updateBlockAnalysis(analysis, blockId, connectionType) {\n        const blockInfo = analysis.get(blockId);\n        if (!blockInfo) {\n            return; // Should never happen due to initialization\n        }\n        if (connectionType === 'incoming') {\n            blockInfo.incomingCount++;\n        }\n        else {\n            blockInfo.outgoingCount++;\n        }\n    }\n    determineTypesFromConnections(blockAnalysis) {\n        this.log('Determining types from connection patterns');\n        for (const [blockId, analysis] of blockAnalysis) {\n            // Determine type based on connection patterns\n            if (analysis.incomingCount === 0 && analysis.outgoingCount > 0) {\n                analysis.elementType = shared_1.SimulationObjectType.Generator;\n                this.log(`Block ${blockId} set as Generator based on connections`, {\n                    incomingCount: analysis.incomingCount,\n                    outgoingCount: analysis.outgoingCount\n                });\n            }\n            else if (analysis.incomingCount > 0) {\n                analysis.elementType = shared_1.SimulationObjectType.Activity;\n                this.log(`Block ${blockId} set as Activity based on connections`, {\n                    incomingCount: analysis.incomingCount,\n                    outgoingCount: analysis.outgoingCount\n                });\n            }\n        }\n    }\n    applyBlockSpecificLogic(page, blockAnalysis) {\n        this.log('Applying block-specific logic');\n        for (const [blockId, block] of page.allBlocks) {\n            const analysis = blockAnalysis.get(blockId);\n            if (!analysis)\n                continue;\n            const blockClass = block.getClassName();\n            const previousType = analysis.elementType;\n            // Only override in specific cases\n            if (blockClass === 'TerminatorBlockV2') {\n                analysis.elementType = shared_1.SimulationObjectType.Generator;\n            }\n            // Add other specific overrides if needed\n            if (previousType !== analysis.elementType) {\n                this.log(`Block ${blockId} type changed by block-specific logic`, {\n                    blockClass,\n                    from: previousType,\n                    to: analysis.elementType\n                });\n            }\n        }\n    }\n    logFinalAnalysis(blockAnalysis) {\n        this.log('Final Analysis Results:');\n        for (const [blockId, analysis] of blockAnalysis) {\n            this.log(`Block ${blockId}:`, {\n                elementType: analysis.elementType,\n                incomingCount: analysis.incomingCount,\n                outgoingCount: analysis.outgoingCount\n            });\n        }\n    }\n}\nexports.LucidPageAnalyzer = LucidPageAnalyzer;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/services/conversion/LucidPageAnalyzer.ts?");

/***/ }),

/***/ "./src/services/conversion/LucidPageConversionService.ts":
/*!***************************************************************!*\
  !*** ./src/services/conversion/LucidPageConversionService.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidPageConversionService = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst LucidPageAnalyzer_1 = __webpack_require__(/*! ./LucidPageAnalyzer */ \"./src/services/conversion/LucidPageAnalyzer.ts\");\nclass LucidPageConversionService extends shared_1.QuodsiLogger {\n    constructor(modelManager, elementFactory, storageAdapter) {\n        super();\n        this.modelManager = modelManager;\n        this.elementFactory = elementFactory;\n        this.storageAdapter = storageAdapter;\n        this.LOG_PREFIX = '[LucidPageConversionService]';\n        this.setLogging(false);\n        this.pageAnalyzer = new LucidPageAnalyzer_1.LucidPageAnalyzer();\n    }\n    /**\n     * Checks if a page can be converted to a model\n     */\n    canConvertPage(page) {\n        if (!page || !page.allBlocks || !page.allLines) {\n            return false;\n        }\n        // Check if page already has model data\n        if (this.storageAdapter.isQuodsiModel(page)) {\n            return false;\n        }\n        // Must have at least one block to be convertible\n        return page.allBlocks.size > 0;\n    }\n    /**\n     * Converts a LucidChart page to a Quodsi simulation model\n     */\n    async convertPage(page) {\n        this.log('Starting page conversion');\n        try {\n            // First, remove any existing model data\n            if (this.storageAdapter.isQuodsiModel(page)) {\n                this.log('Removing existing model data');\n                this.modelManager.removeModelFromPage(page);\n            }\n            // Create model using LucidElementFactory\n            const modelLucid = this.elementFactory.createPlatformObject(page, shared_1.SimulationObjectType.Model, true // isConversion\n            );\n            // Get the model object from the platform object\n            const model = modelLucid.getSimulationObject();\n            // Initialize in the model manager\n            await this.modelManager.initializeModel(model, page);\n            // Verify model was initialized\n            if (!this.storageAdapter.isQuodsiModel(page)) {\n                throw new Error('Failed to initialize model on page');\n            }\n            // Analyze the page to determine element types\n            const analysis = this.pageAnalyzer.analyzePage(page);\n            // Convert blocks and connections\n            const convertedBlocks = await this.convertBlocks(page, analysis);\n            this.log('Blocks converted:', convertedBlocks);\n            const convertedConnectors = await this.convertConnections(page, analysis);\n            this.log('Connectors converted:', convertedConnectors);\n            // Validate the converted model\n            const validationResult = await this.modelManager.validateModel();\n            this.log('Validation result:', validationResult);\n            return {\n                success: true,\n                modelId: page.id,\n                elementCount: {\n                    activities: convertedBlocks.activities,\n                    generators: convertedBlocks.generators,\n                    resources: convertedBlocks.resources,\n                    connectors: convertedConnectors\n                }\n            };\n        }\n        catch (error) {\n            this.logError('Conversion failed:', error);\n            throw error;\n        }\n    }\n    /**\n     * Converts blocks to simulation elements\n     */\n    async convertBlocks(page, analysis) {\n        this.log('Starting block conversion');\n        let activities = 0;\n        let generators = 0;\n        let resources = 0;\n        for (const [blockId, block] of page.allBlocks) {\n            const blockAnalysis = analysis.blockAnalysis.get(blockId);\n            if (!(blockAnalysis === null || blockAnalysis === void 0 ? void 0 : blockAnalysis.elementType)) {\n                this.logError(`Missing element type for block ${blockId}`);\n                continue;\n            }\n            try {\n                this.log(`Creating element for block ${blockId}:`, {\n                    type: blockAnalysis.elementType,\n                    blockClass: block.getClassName()\n                });\n                // Create platform object using factory with conversion flag\n                const platformObject = this.elementFactory.createPlatformObject(block, blockAnalysis.elementType, true // isConversion\n                );\n                // Get the simulation object\n                const element = platformObject.getSimulationObject();\n                // Register with model manager\n                await this.modelManager.registerElement(element, block);\n                // Update counts\n                switch (blockAnalysis.elementType) {\n                    case shared_1.SimulationObjectType.Activity:\n                        activities++;\n                        break;\n                    case shared_1.SimulationObjectType.Generator:\n                        generators++;\n                        break;\n                    case shared_1.SimulationObjectType.Resource:\n                        resources++;\n                        break;\n                }\n                this.log(`Successfully converted block ${blockId}:`, {\n                    type: element.type,\n                    name: element.name\n                });\n            }\n            catch (error) {\n                this.logError(`Failed to convert block ${blockId}:`, error);\n                throw error;\n            }\n        }\n        return { activities, generators, resources };\n    }\n    /**\n     * Converts connections to simulation connectors\n     */\n    async convertConnections(page, analysis) {\n        this.log('Converting connections');\n        let connectorCount = 0;\n        // Calculate outgoing connections per block for probability calculation\n        const outgoingConnectionCounts = new Map();\n        for (const [lineId, line] of page.allLines) {\n            const endpoint1 = line.getEndpoint1();\n            if (endpoint1 === null || endpoint1 === void 0 ? void 0 : endpoint1.connection) {\n                const sourceId = endpoint1.connection.id;\n                outgoingConnectionCounts.set(sourceId, (outgoingConnectionCounts.get(sourceId) || 0) + 1);\n            }\n        }\n        for (const [lineId, line] of page.allLines) {\n            try {\n                this.log(`Processing line ${lineId}`);\n                const endpoint1 = line.getEndpoint1();\n                const endpoint2 = line.getEndpoint2();\n                if (!(endpoint1 === null || endpoint1 === void 0 ? void 0 : endpoint1.connection) || !(endpoint2 === null || endpoint2 === void 0 ? void 0 : endpoint2.connection)) {\n                    this.log(`Line ${lineId} has invalid endpoints`);\n                    continue;\n                }\n                const sourceId = endpoint1.connection.id;\n                const outgoingCount = outgoingConnectionCounts.get(sourceId) || 1;\n                const probability = 1.0 / outgoingCount;\n                // Create platform object using factory with conversion flag\n                const platformObject = this.elementFactory.createPlatformObject(line, shared_1.SimulationObjectType.Connector, true // isConversion\n                );\n                // Get the simulation object and set connection-specific properties\n                const connector = platformObject.getSimulationObject();\n                connector.sourceId = sourceId;\n                connector.targetId = endpoint2.connection.id;\n                connector.probability = probability;\n                connector.connectType = shared_1.ConnectType.Probability;\n                // Update the platform object to save changes\n                platformObject.updateFromPlatform();\n                // Register with model manager\n                await this.modelManager.registerElement(connector, line);\n                connectorCount++;\n            }\n            catch (error) {\n                this.logError(`Failed to convert connection ${lineId}:`, error);\n                throw error;\n            }\n        }\n        this.log(`Converted ${connectorCount} connections`);\n        return connectorCount;\n    }\n}\nexports.LucidPageConversionService = LucidPageConversionService;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/services/conversion/LucidPageConversionService.ts?");

/***/ }),

/***/ "./src/services/conversion/PageSchemaConversionService.ts":
/*!****************************************************************!*\
  !*** ./src/services/conversion/PageSchemaConversionService.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PageSchemaConversionService = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst ModelDataSource_1 = __webpack_require__(/*! ../../data_sources/model/ModelDataSource */ \"./src/data_sources/model/ModelDataSource.ts\");\nclass PageSchemaConversionService extends shared_1.QuodsiLogger {\n    constructor(modelDataSource) {\n        super();\n        this.modelDataSource = modelDataSource;\n        this.LOG_PREFIX = '[PageSchemaConversionService]';\n        this.collectionIds = {};\n        this.setLogging(true);\n    }\n    analyzePage(page) {\n        this.log('Starting page analysis');\n        const blockAnalysis = new Map();\n        // Analyze connections and compute incoming/outgoing counts\n        for (const [lineId, line] of page.allLines) {\n            const endpoint1 = line.getEndpoint1();\n            const endpoint2 = line.getEndpoint2();\n            if (endpoint1.connection && endpoint2.connection) {\n                const sourceId = endpoint1.connection.id;\n                const targetId = endpoint2.connection.id;\n                this.log(`Line ${lineId}: ${sourceId} -> ${targetId}`);\n                this.updateBlockAnalysis(blockAnalysis, sourceId, 'outgoing');\n                this.updateBlockAnalysis(blockAnalysis, targetId, 'incoming');\n            }\n        }\n        // Determine element types\n        this.determineElementTypes(blockAnalysis, page);\n        return { blockAnalysis };\n    }\n    canConvertPage(page) {\n        this.log('Checking if page can be converted');\n        if (!page || !page.allBlocks || !page.allLines) {\n            this.log('Page invalid - missing required properties');\n            return false;\n        }\n        const blockCount = page.allBlocks.size;\n        this.log(`Page has ${blockCount} blocks`);\n        return blockCount > 0;\n    }\n    async convertPage(page) {\n        var _a;\n        this.log('========== Starting Page Conversion ==========');\n        this.log(`Page ID: ${page.id}`);\n        try {\n            const result = this.modelDataSource.createModelDataSource(page.id);\n            if (!(result === null || result === void 0 ? void 0 : result.source)) {\n                throw new Error('Failed to create model data source');\n            }\n            const { source, collectionIds } = result;\n            this.collectionIds = collectionIds;\n            this.log('Collection IDs:', this.collectionIds);\n            const model = shared_1.Model.createDefault(page.id);\n            this.log('Model defaults created:', model);\n            this.log('Adding model to collection');\n            const modelCollectionId = this.collectionIds[ModelDataSource_1.MODEL_COLLECTIONS.MODEL];\n            this.log(`Using model collection ID: ${modelCollectionId}`);\n            await ((_a = source.collections.get(modelCollectionId)) === null || _a === void 0 ? void 0 : _a.patchItems({\n                added: [{\n                        id: model.id,\n                        name: model.name,\n                        reps: model.reps,\n                        forecastDays: model.forecastDays,\n                        seed: model.seed,\n                        oneClockUnit: model.oneClockUnit,\n                        simulationTimeType: model.simulationTimeType,\n                        warmupClockPeriod: model.warmupClockPeriod,\n                        warmupClockPeriodUnit: model.warmupClockPeriodUnit,\n                        runClockPeriod: model.runClockPeriod,\n                        runClockPeriodUnit: model.runClockPeriodUnit,\n                        type: shared_1.SimulationObjectType.Model\n                    }]\n            }));\n            const analysis = this.analyzePage(page);\n            const convertedBlocks = await this.convertBlocks(page, analysis, source);\n            const convertedConnectors = await this.convertConnections(page, analysis, source);\n            return {\n                success: true,\n                modelId: page.id,\n                elementCount: {\n                    activities: convertedBlocks.activities,\n                    generators: convertedBlocks.generators,\n                    resources: convertedBlocks.resources,\n                    connectors: convertedConnectors\n                }\n            };\n        }\n        catch (error) {\n            this.logError('========== Conversion Failed ==========');\n            this.logError('Error details:', error);\n            throw error;\n        }\n    }\n    async createOperationSteps(objectId, operationSteps, source) {\n        var _a;\n        const stepsCollectionId = this.collectionIds[ModelDataSource_1.MODEL_COLLECTIONS.OPERATION_STEPS];\n        this.log(`Adding operation steps for ${objectId}`, { steps: operationSteps });\n        const formattedSteps = operationSteps.map((step, index) => ({\n            id: `${objectId}_step_${index}`,\n            activityId: objectId,\n            requirementId: step.requirementId,\n            quantity: step.quantity,\n            duration: JSON.stringify(step.duration)\n        }));\n        await ((_a = source.collections.get(stepsCollectionId)) === null || _a === void 0 ? void 0 : _a.patchItems({\n            added: formattedSteps\n        }));\n        this.log(`Added ${formattedSteps.length} operation steps`);\n    }\n    async convertBlocks(page, analysis, source) {\n        var _a, _b, _c;\n        let activities = 0, generators = 0, resources = 0;\n        for (const [blockId, block] of page.allBlocks) {\n            const blockAnalysis = analysis.blockAnalysis.get(blockId);\n            if (!(blockAnalysis === null || blockAnalysis === void 0 ? void 0 : blockAnalysis.elementType))\n                continue;\n            try {\n                const name = this.getBlockName(block);\n                const element = shared_1.SimulationObjectTypeFactory.createElement(blockAnalysis.elementType, blockId);\n                element.name = name;\n                switch (blockAnalysis.elementType) {\n                    case shared_1.SimulationObjectType.Activity: {\n                        const activity = element;\n                        const collectionId = this.collectionIds[ModelDataSource_1.MODEL_COLLECTIONS.ACTIVITIES];\n                        await ((_a = source.collections.get(collectionId)) === null || _a === void 0 ? void 0 : _a.patchItems({\n                            added: [{\n                                    id: activity.id,\n                                    name: activity.name,\n                                    capacity: activity.capacity,\n                                    inputBufferCapacity: activity.inputBufferCapacity,\n                                    outputBufferCapacity: activity.outputBufferCapacity,\n                                    type: shared_1.SimulationObjectType.Activity\n                                }]\n                        }));\n                        await this.createOperationSteps(activity.id, activity.operationSteps, source);\n                        block.setReferenceKey('simulation_object', {\n                            collectionId,\n                            primaryKey: activity.id,\n                            readonly: true\n                        });\n                        activities++;\n                        break;\n                    }\n                    case shared_1.SimulationObjectType.Generator: {\n                        const generator = element;\n                        const collectionId = this.collectionIds[ModelDataSource_1.MODEL_COLLECTIONS.GENERATORS];\n                        await ((_b = source.collections.get(collectionId)) === null || _b === void 0 ? void 0 : _b.patchItems({\n                            added: [{\n                                    id: generator.id,\n                                    name: generator.name,\n                                    activityKeyId: generator.activityKeyId,\n                                    entityId: generator.entityId,\n                                    periodicOccurrences: generator.periodicOccurrences,\n                                    periodIntervalDuration: JSON.stringify(generator.periodIntervalDuration),\n                                    entitiesPerCreation: generator.entitiesPerCreation,\n                                    periodicStartDuration: JSON.stringify(generator.periodicStartDuration),\n                                    maxEntities: generator.maxEntities,\n                                    type: shared_1.SimulationObjectType.Generator\n                                }]\n                        }));\n                        block.setReferenceKey('simulation_object', {\n                            collectionId,\n                            primaryKey: generator.id,\n                            readonly: true\n                        });\n                        generators++;\n                        break;\n                    }\n                    case shared_1.SimulationObjectType.Resource: {\n                        const resource = element;\n                        const collectionId = this.collectionIds[ModelDataSource_1.MODEL_COLLECTIONS.RESOURCES];\n                        await ((_c = source.collections.get(collectionId)) === null || _c === void 0 ? void 0 : _c.patchItems({\n                            added: [{\n                                    id: resource.id,\n                                    name: resource.name,\n                                    capacity: resource.capacity,\n                                    type: shared_1.SimulationObjectType.Resource\n                                }]\n                        }));\n                        block.setReferenceKey('simulation_object', {\n                            collectionId,\n                            primaryKey: resource.id,\n                            readonly: true\n                        });\n                        resources++;\n                        break;\n                    }\n                }\n            }\n            catch (error) {\n                this.logError(`Failed to convert block ${blockId}:`, error);\n                throw error;\n            }\n        }\n        return { activities, generators, resources };\n    }\n    async convertConnections(page, analysis, source) {\n        var _a;\n        let connectorCount = 0;\n        const outgoingConnectionCounts = new Map();\n        for (const [lineId, line] of page.allLines) {\n            const endpoint1 = line.getEndpoint1();\n            if (endpoint1 === null || endpoint1 === void 0 ? void 0 : endpoint1.connection) {\n                const sourceId = endpoint1.connection.id;\n                outgoingConnectionCounts.set(sourceId, (outgoingConnectionCounts.get(sourceId) || 0) + 1);\n            }\n        }\n        const collectionId = this.collectionIds[ModelDataSource_1.MODEL_COLLECTIONS.CONNECTORS];\n        for (const [lineId, line] of page.allLines) {\n            try {\n                const endpoint1 = line.getEndpoint1();\n                const endpoint2 = line.getEndpoint2();\n                if (!(endpoint1 === null || endpoint1 === void 0 ? void 0 : endpoint1.connection) || !(endpoint2 === null || endpoint2 === void 0 ? void 0 : endpoint2.connection))\n                    continue;\n                const sourceId = endpoint1.connection.id;\n                const connector = shared_1.SimulationObjectTypeFactory.createElement(shared_1.SimulationObjectType.Connector, lineId);\n                connector.sourceId = sourceId;\n                connector.targetId = endpoint2.connection.id;\n                connector.probability = 1.0 / (outgoingConnectionCounts.get(sourceId) || 1);\n                await ((_a = source.collections.get(collectionId)) === null || _a === void 0 ? void 0 : _a.patchItems({\n                    added: [{\n                            id: connector.id,\n                            name: connector.name,\n                            sourceId: connector.sourceId,\n                            targetId: connector.targetId,\n                            probability: connector.probability,\n                            connectType: connector.connectType,\n                            type: shared_1.SimulationObjectType.Connector\n                        }]\n                }));\n                if (connector.operationSteps.length > 0) {\n                    await this.createOperationSteps(connector.id, connector.operationSteps, source);\n                }\n                line.setReferenceKey('simulation_object', {\n                    collectionId,\n                    primaryKey: connector.id,\n                    readonly: true\n                });\n                connectorCount++;\n            }\n            catch (error) {\n                this.logError(`Failed to convert connection ${lineId}:`, error);\n                throw error;\n            }\n        }\n        return connectorCount;\n    }\n    updateBlockAnalysis(analysis, blockId, connectionType) {\n        let blockInfo = analysis.get(blockId);\n        if (!blockInfo) {\n            blockInfo = {\n                incomingCount: 0,\n                outgoingCount: 0,\n                elementType: undefined\n            };\n            analysis.set(blockId, blockInfo);\n        }\n        if (connectionType === 'incoming') {\n            blockInfo.incomingCount++;\n        }\n        else {\n            blockInfo.outgoingCount++;\n        }\n    }\n    determineElementTypes(blockAnalysis, page) {\n        this.log('Starting element type determination');\n        // First pass: Block class identification\n        this.log('First pass - Block class identification');\n        for (const [blockId, block] of page.allBlocks) {\n            const analysis = blockAnalysis.get(blockId) || {\n                incomingCount: 0,\n                outgoingCount: 0,\n                elementType: undefined\n            };\n            blockAnalysis.set(blockId, analysis);\n            this.log(`Block ${blockId} initial analysis:`, {\n                incomingCount: analysis.incomingCount,\n                outgoingCount: analysis.outgoingCount,\n                elementType: analysis.elementType\n            });\n        }\n        // Second pass: Connection pattern analysis\n        this.log('Second pass - Connection pattern analysis');\n        for (const [blockId, analysis] of blockAnalysis) {\n            if (!analysis.elementType) {\n                const oldType = analysis.elementType;\n                if (analysis.incomingCount === 0 && analysis.outgoingCount > 0) {\n                    analysis.elementType = shared_1.SimulationObjectType.Generator;\n                }\n                else if (analysis.incomingCount > 0) {\n                    analysis.elementType = shared_1.SimulationObjectType.Activity;\n                }\n                this.log(`Block ${blockId} type determination:`, {\n                    from: oldType,\n                    to: analysis.elementType,\n                    incomingCount: analysis.incomingCount,\n                    outgoingCount: analysis.outgoingCount\n                });\n            }\n        }\n    }\n    getBlockName(block) {\n        if (block.textAreas && block.textAreas.size > 0) {\n            for (const text of block.textAreas.values()) {\n                if (text && text.trim()) {\n                    return text.trim();\n                }\n            }\n        }\n        const className = block.getClassName() || 'Block';\n        return `New ${className}`;\n    }\n}\nexports.PageSchemaConversionService = PageSchemaConversionService;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/services/conversion/PageSchemaConversionService.ts?");

/***/ }),

/***/ "./src/types/ActivityLucid.ts":
/*!************************************!*\
  !*** ./src/types/ActivityLucid.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ActivityLucid = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst SimObjectLucid_1 = __webpack_require__(/*! ./SimObjectLucid */ \"./src/types/SimObjectLucid.ts\");\n/**\n * Lucid-specific implementation of an Activity.\n * Maps a Lucid Block element to a simulation Activity.\n */\nclass ActivityLucid extends SimObjectLucid_1.SimObjectLucid {\n    constructor(block, storageAdapter) {\n        super(block, storageAdapter);\n    }\n    get type() {\n        return shared_1.SimulationObjectType.Activity;\n    }\n    createSimObject() {\n        var _a, _b, _c;\n        // Always create with element ID\n        const activity = new shared_1.Activity(this.platformElementId, // Always use element ID\n        '', // Name will be set below\n        1, // Default capacity\n        1, // Default inputBufferCapacity\n        1, // Default outputBufferCapacity\n        [] // Default empty operationSteps\n        );\n        // Cast the stored data to our interface\n        const storedData = this.storageAdapter.getElementData(this.element);\n        if (storedData) {\n            // Now TypeScript knows the shape of storedData\n            activity.name = storedData.name || this.getElementName('Activity');\n            activity.capacity = (_a = storedData.capacity) !== null && _a !== void 0 ? _a : 1;\n            activity.inputBufferCapacity = (_b = storedData.inputBufferCapacity) !== null && _b !== void 0 ? _b : 1;\n            activity.outputBufferCapacity = (_c = storedData.outputBufferCapacity) !== null && _c !== void 0 ? _c : 1;\n            activity.operationSteps = storedData.operationSteps || [];\n        }\n        else {\n            activity.name = this.getElementName('Activity');\n        }\n        return activity;\n    }\n    updateFromPlatform() {\n        // Update name if not already set\n        if (!this.simObject.name) {\n            this.simObject.name = this.getElementName('Activity');\n        }\n        // Store updated data - only store the properties we care about\n        const dataToStore = {\n            id: this.platformElementId, // Include the id to satisfy StorageAdapter\n            name: this.simObject.name,\n            capacity: this.simObject.capacity,\n            inputBufferCapacity: this.simObject.inputBufferCapacity,\n            outputBufferCapacity: this.simObject.outputBufferCapacity,\n            operationSteps: this.simObject.operationSteps\n        };\n        this.storageAdapter.updateElementData(this.element, dataToStore);\n    }\n    getElementName(defaultPrefix) {\n        const block = this.element;\n        if (block.textAreas && block.textAreas.size > 0) {\n            for (const text of block.textAreas.values()) {\n                if (text && text.trim()) {\n                    return text.trim();\n                }\n            }\n        }\n        const className = block.getClassName() || 'Block';\n        return `${defaultPrefix} ${className}`;\n    }\n    static createFromConversion(block, storageAdapter) {\n        // Create default activity using the static method\n        const defaultActivity = shared_1.Activity.createDefault(block.id);\n        const name = SimObjectLucid_1.SimObjectLucid.getNameFromBlock(block, 'Act');\n        // Convert to StoredActivityData format\n        const storedData = {\n            id: defaultActivity.id,\n            name: name,\n            capacity: defaultActivity.capacity,\n            inputBufferCapacity: defaultActivity.inputBufferCapacity,\n            outputBufferCapacity: defaultActivity.outputBufferCapacity,\n            operationSteps: defaultActivity.operationSteps\n        };\n        // Set up both data and metadata using setElementData\n        storageAdapter.setElementData(block, storedData, shared_1.SimulationObjectType.Activity, {\n            version: \"1.0.0\"\n        });\n        // Now create the ActivityLucid instance\n        return new ActivityLucid(block, storageAdapter);\n    }\n}\nexports.ActivityLucid = ActivityLucid;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/types/ActivityLucid.ts?");

/***/ }),

/***/ "./src/types/ConnectorLucid.ts":
/*!*************************************!*\
  !*** ./src/types/ConnectorLucid.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectorLucid = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst SimObjectLucid_1 = __webpack_require__(/*! ./SimObjectLucid */ \"./src/types/SimObjectLucid.ts\");\n/**\n * Lucid-specific implementation of a Connector.\n * Maps a Lucid Line element to a simulation Connector.\n */\nclass ConnectorLucid extends SimObjectLucid_1.SimObjectLucid {\n    // private line: LineProxy;\n    constructor(line, storageAdapter) {\n        super(line, storageAdapter);\n        // this.line = line;\n        // Reinitialize the simulation object using the correctly set `this.line`.\n        // this.simObject = this.createSimObject();\n    }\n    get type() {\n        return shared_1.SimulationObjectType.Connector;\n    }\n    createSimObject() {\n        var _a, _b, _c, _d, _e, _f;\n        const line = this.element;\n        console.log(`[ConnectorLucid] Line ${line.id} endpoints:`, {\n            endpoint1: {\n                connectionId: (_a = line.getEndpoint1().connection) === null || _a === void 0 ? void 0 : _a.id,\n                position: { x: line.getEndpoint1().x, y: line.getEndpoint1().y }\n            },\n            endpoint2: {\n                connectionId: (_b = line.getEndpoint2().connection) === null || _b === void 0 ? void 0 : _b.id,\n                position: { x: line.getEndpoint2().x, y: line.getEndpoint2().y }\n            }\n        });\n        // Create connector with element-specific properties\n        const connector = new shared_1.Connector(this.platformElementId, // id\n        this.getElementName('Connector'), // name\n        ((_c = line.getEndpoint1().connection) === null || _c === void 0 ? void 0 : _c.id) || '', // sourceId\n        ((_d = line.getEndpoint2().connection) === null || _d === void 0 ? void 0 : _d.id) || '', // targetId\n        1.0, // probability\n        shared_1.ConnectType.Probability, // connectType\n        [] // default operationSteps\n        );\n        // Get stored custom data\n        const storedData = this.storageAdapter.getElementData(this.element);\n        if (storedData) {\n            // Only copy specific properties we want from stored data\n            connector.probability = (_e = storedData.probability) !== null && _e !== void 0 ? _e : 1.0;\n            connector.connectType = (_f = storedData.connectType) !== null && _f !== void 0 ? _f : shared_1.ConnectType.Probability;\n            connector.operationSteps = storedData.operationSteps || [];\n        }\n        return connector;\n    }\n    updateFromPlatform() {\n        var _a, _b;\n        const line = this.element;\n        // Update element-specific properties\n        this.simObject.name = this.getElementName('Connector');\n        this.simObject.sourceId = ((_a = line.getEndpoint1().connection) === null || _a === void 0 ? void 0 : _a.id) || '';\n        this.simObject.targetId = ((_b = line.getEndpoint2().connection) === null || _b === void 0 ? void 0 : _b.id) || '';\n        // Store only custom data properties\n        const dataToStore = {\n            id: this.platformElementId,\n            probability: this.simObject.probability,\n            connectType: this.simObject.connectType,\n            operationSteps: this.simObject.operationSteps\n        };\n        this.storageAdapter.updateElementData(this.element, dataToStore);\n    }\n    getElementName(defaultPrefix) {\n        var _a, _b;\n        // Check for text areas on the line\n        const line = this.element;\n        for (const [, text] of line.textAreas) {\n            if (text && text.trim()) {\n                return text.trim();\n            }\n        }\n        // If no text found, generate a name based on endpoints\n        const sourceName = this.getEndpointName((_a = line.getEndpoint1().connection) === null || _a === void 0 ? void 0 : _a.id);\n        const targetName = this.getEndpointName((_b = line.getEndpoint2().connection) === null || _b === void 0 ? void 0 : _b.id);\n        if (sourceName && targetName) {\n            return `${sourceName} → ${targetName}`;\n        }\n        return `${defaultPrefix} ${line.id}`;\n    }\n    getBlockName(block) {\n        if (block.textAreas && block.textAreas.size > 0) {\n            for (const text of block.textAreas.values()) {\n                if (text && text.trim()) {\n                    return text.trim();\n                }\n            }\n        }\n        const className = block.getClassName() || 'Block';\n        return `New ${className}`;\n    }\n    getEndpointName(elementId) {\n        const line = this.element;\n        if (!elementId)\n            return undefined;\n        const block = line.getPage().allBlocks.get(elementId);\n        if (!block)\n            return undefined;\n        return this.getBlockName(block);\n    }\n    static createFromConversion(line, storageAdapter) {\n        // Create default connector using the static method\n        const defaultConnector = shared_1.Connector.createDefault(line.id);\n        // Safely get endpoints with null checks\n        const endpoint1 = line.getEndpoint1();\n        const endpoint2 = line.getEndpoint2();\n        // Set source and target IDs if connections exist\n        if (endpoint1 && endpoint1.connection) {\n            defaultConnector.sourceId = endpoint1.connection.id;\n        }\n        if (endpoint2 && endpoint2.connection) {\n            defaultConnector.targetId = endpoint2.connection.id;\n        }\n        // Custom name using endpoints if available\n        let name = `Connector ${line.id}`;\n        if (defaultConnector.sourceId && defaultConnector.targetId) {\n            // Try to get block names from page\n            const page = line.getPage();\n            const sourceBlock = page.allBlocks.get(defaultConnector.sourceId);\n            const targetBlock = page.allBlocks.get(defaultConnector.targetId);\n            const sourceName = sourceBlock ? ConnectorLucid.getNameFromBlock(sourceBlock, 'Source') : 'Source';\n            const targetName = targetBlock ? ConnectorLucid.getNameFromBlock(targetBlock, 'Target') : 'Target';\n            name = `${sourceName} → ${targetName}`;\n        }\n        defaultConnector.name = name;\n        // Convert to StoredConnectorData format\n        const storedData = {\n            id: defaultConnector.id,\n            probability: defaultConnector.probability,\n            connectType: defaultConnector.connectType,\n            operationSteps: defaultConnector.operationSteps\n        };\n        // Set up both data and metadata\n        storageAdapter.setElementData(line, storedData, shared_1.SimulationObjectType.Connector, {\n            version: \"1.0.0\"\n        });\n        // Create and return the ConnectorLucid instance\n        return new ConnectorLucid(line, storageAdapter);\n    }\n}\nexports.ConnectorLucid = ConnectorLucid;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/types/ConnectorLucid.ts?");

/***/ }),

/***/ "./src/types/EntityLucid.ts":
/*!**********************************!*\
  !*** ./src/types/EntityLucid.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityLucid = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst SimObjectLucid_1 = __webpack_require__(/*! ./SimObjectLucid */ \"./src/types/SimObjectLucid.ts\");\nclass EntityLucid extends SimObjectLucid_1.SimObjectLucid {\n    constructor(block, storageAdapter) {\n        super(block, storageAdapter);\n    }\n    get type() {\n        return shared_1.SimulationObjectType.Entity;\n    }\n    createSimObject() {\n        // Create entity with element-specific properties\n        const entity = new shared_1.Entity(this.platformElementId, '' // name will be set below\n        );\n        // Get stored custom data\n        const storedData = this.storageAdapter.getElementData(this.element);\n        if (storedData) {\n            // Only copy name from stored data\n            entity.name = storedData.name || this.getElementName('Entity');\n        }\n        else {\n            entity.name = this.getElementName('Entity');\n        }\n        return entity;\n    }\n    updateFromPlatform() {\n        // Update name only if not already set\n        if (!this.simObject.name) {\n            this.simObject.name = this.getElementName('Entity');\n        }\n        // Store custom data properties\n        const dataToStore = {\n            id: this.platformElementId,\n            name: this.simObject.name\n        };\n        this.storageAdapter.updateElementData(this.element, dataToStore);\n    }\n    getElementName(defaultPrefix) {\n        const block = this.element;\n        if (block.textAreas && block.textAreas.size > 0) {\n            for (const text of block.textAreas.values()) {\n                if (text && text.trim()) {\n                    return text.trim();\n                }\n            }\n        }\n        const className = block.getClassName() || 'Block';\n        return `${defaultPrefix} ${className}`;\n    }\n    static createFromConversion(block, storageAdapter) {\n        // Create default entity using the static method from Entity\n        const defaultEntity = shared_1.Entity.createDefault(block.id);\n        // Get name from block text if available\n        const name = SimObjectLucid_1.SimObjectLucid.getNameFromBlock(block, 'Entity');\n        // Convert to StoredEntityData format\n        const storedData = {\n            id: defaultEntity.id,\n            name: name // Use the name from block text instead of default\n        };\n        // Set up both data and metadata using setElementData\n        storageAdapter.setElementData(block, storedData, shared_1.SimulationObjectType.Entity, {\n            version: \"1.0.0\"\n        });\n        // Now create the EntityLucid instance\n        return new EntityLucid(block, storageAdapter);\n    }\n}\nexports.EntityLucid = EntityLucid;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/types/EntityLucid.ts?");

/***/ }),

/***/ "./src/types/GeneratorLucid.ts":
/*!*************************************!*\
  !*** ./src/types/GeneratorLucid.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GeneratorLucid = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst SimObjectLucid_1 = __webpack_require__(/*! ./SimObjectLucid */ \"./src/types/SimObjectLucid.ts\");\n/**\n * Lucid-specific implementation of a Generator.\n * Maps a Lucid Block element to a simulation Generator.\n */\nclass GeneratorLucid extends SimObjectLucid_1.SimObjectLucid {\n    constructor(block, storageAdapter) {\n        // Pass the block as the element to the parent constructor\n        super(block, storageAdapter);\n    }\n    get type() {\n        return shared_1.SimulationObjectType.Generator;\n    }\n    createSimObject() {\n        var _a, _b, _c, _d, _e;\n        // Create generator with element-specific properties\n        const generator = new shared_1.Generator(this.platformElementId, this.getElementName('Generator'), \"\", // default activityKeyId\n        shared_1.ModelDefaults.DEFAULT_ENTITY_ID, Infinity, // default periodicOccurrences\n        new shared_1.Duration(1, shared_1.PeriodUnit.HOURS, shared_1.DurationType.CONSTANT), // default periodIntervalDuration\n        1, // default entitiesPerCreation\n        new shared_1.Duration(0, shared_1.PeriodUnit.HOURS, shared_1.DurationType.CONSTANT), // default periodicStartDuration\n        Infinity // default maxEntities\n        );\n        // Get stored custom data\n        const storedData = this.storageAdapter.getElementData(this.element);\n        if (storedData) {\n            // Copy specific properties from stored data\n            generator.activityKeyId = (_a = storedData.activityKeyId) !== null && _a !== void 0 ? _a : \"\";\n            generator.entityId = (_b = storedData.entityId) !== null && _b !== void 0 ? _b : shared_1.ModelDefaults.DEFAULT_ENTITY_ID;\n            generator.periodicOccurrences = (_c = storedData.periodicOccurrences) !== null && _c !== void 0 ? _c : Infinity;\n            generator.entitiesPerCreation = (_d = storedData.entitiesPerCreation) !== null && _d !== void 0 ? _d : 1;\n            generator.maxEntities = (_e = storedData.maxEntities) !== null && _e !== void 0 ? _e : Infinity;\n            // Handle Duration objects\n            if (storedData.periodIntervalDuration) {\n                generator.periodIntervalDuration = new shared_1.Duration(storedData.periodIntervalDuration.durationLength, storedData.periodIntervalDuration.durationPeriodUnit, storedData.periodIntervalDuration.durationType, storedData.periodIntervalDuration.distribution);\n            }\n            if (storedData.periodicStartDuration) {\n                generator.periodicStartDuration = new shared_1.Duration(storedData.periodicStartDuration.durationLength, storedData.periodicStartDuration.durationPeriodUnit, storedData.periodicStartDuration.durationType, storedData.periodicStartDuration.distribution);\n            }\n        }\n        return generator;\n    }\n    updateFromPlatform() {\n        // Update element-specific properties\n        this.simObject.name = this.getElementName('Generator');\n        // Store only custom data properties\n        const dataToStore = {\n            id: this.platformElementId,\n            activityKeyId: this.simObject.activityKeyId,\n            entityId: this.simObject.entityId,\n            periodicOccurrences: this.simObject.periodicOccurrences,\n            periodIntervalDuration: {\n                durationLength: this.simObject.periodIntervalDuration.durationLength,\n                durationPeriodUnit: this.simObject.periodIntervalDuration.durationPeriodUnit,\n                durationType: this.simObject.periodIntervalDuration.durationType,\n                distribution: this.simObject.periodIntervalDuration.distribution\n            },\n            entitiesPerCreation: this.simObject.entitiesPerCreation,\n            periodicStartDuration: {\n                durationLength: this.simObject.periodicStartDuration.durationLength,\n                durationPeriodUnit: this.simObject.periodicStartDuration.durationPeriodUnit,\n                durationType: this.simObject.periodicStartDuration.durationType,\n                distribution: this.simObject.periodicStartDuration.distribution\n            },\n            maxEntities: this.simObject.maxEntities\n        };\n        this.storageAdapter.updateElementData(this.element, dataToStore);\n    }\n    getElementName(defaultPrefix) {\n        const block = this.element;\n        // Check for text areas on the block\n        if (block.textAreas && block.textAreas.size > 0) {\n            for (const text of block.textAreas.values()) {\n                if (text && text.trim()) {\n                    return text.trim();\n                }\n            }\n        }\n        // If no text found, use class name\n        const className = block.getClassName() || 'Block';\n        return `${defaultPrefix} ${className}`;\n    }\n    static createFromConversion(block, storageAdapter) {\n        // Create default generator using the static method\n        const defaultGenerator = shared_1.Generator.createDefault(block.id);\n        // Convert to StoredGeneratorData format\n        const storedData = {\n            id: defaultGenerator.id,\n            activityKeyId: defaultGenerator.activityKeyId,\n            entityId: defaultGenerator.entityId,\n            periodicOccurrences: defaultGenerator.periodicOccurrences,\n            periodIntervalDuration: {\n                durationLength: defaultGenerator.periodIntervalDuration.durationLength,\n                durationPeriodUnit: defaultGenerator.periodIntervalDuration.durationPeriodUnit,\n                durationType: defaultGenerator.periodIntervalDuration.durationType,\n                distribution: defaultGenerator.periodIntervalDuration.distribution\n            },\n            entitiesPerCreation: defaultGenerator.entitiesPerCreation,\n            periodicStartDuration: {\n                durationLength: defaultGenerator.periodicStartDuration.durationLength,\n                durationPeriodUnit: defaultGenerator.periodicStartDuration.durationPeriodUnit,\n                durationType: defaultGenerator.periodicStartDuration.durationType,\n                distribution: defaultGenerator.periodicStartDuration.distribution\n            },\n            maxEntities: defaultGenerator.maxEntities\n        };\n        // Set up both data and metadata\n        storageAdapter.setElementData(block, storedData, shared_1.SimulationObjectType.Generator, {\n            version: \"1.0.0\"\n        });\n        // Create and return the GeneratorLucid instance\n        return new GeneratorLucid(block, storageAdapter);\n    }\n}\nexports.GeneratorLucid = GeneratorLucid;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/types/GeneratorLucid.ts?");

/***/ }),

/***/ "./src/types/ModelLucid.ts":
/*!*********************************!*\
  !*** ./src/types/ModelLucid.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelLucid = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst SimObjectLucid_1 = __webpack_require__(/*! ./SimObjectLucid */ \"./src/types/SimObjectLucid.ts\");\nclass ModelLucid extends SimObjectLucid_1.SimObjectLucid {\n    constructor(pageProxy, storageAdapter) {\n        super(pageProxy, storageAdapter);\n    }\n    get type() {\n        return shared_1.SimulationObjectType.Model;\n    }\n    createSimObject() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        const page = this.element;\n        // Create model with element-specific properties\n        const model = new shared_1.Model(this.platformElementId, '', // name will be set below\n        shared_1.ModelDefaults.DEFAULT_REPS, shared_1.ModelDefaults.DEFAULT_FORECAST_DAYS, shared_1.ModelDefaults.DEFAULT_SEED, shared_1.ModelDefaults.DEFAULT_CLOCK_UNIT, shared_1.SimulationTimeType.Clock, 0, shared_1.PeriodUnit.HOURS, 24, shared_1.PeriodUnit.HOURS, null, null, null);\n        // Get stored custom data\n        const storedData = this.storageAdapter.getElementData(page);\n        if (storedData) {\n            // Copy properties from stored data\n            model.name = storedData.name || this.getElementName();\n            model.reps = (_a = storedData.reps) !== null && _a !== void 0 ? _a : shared_1.ModelDefaults.DEFAULT_REPS;\n            model.forecastDays = (_b = storedData.forecastDays) !== null && _b !== void 0 ? _b : shared_1.ModelDefaults.DEFAULT_FORECAST_DAYS;\n            model.seed = (_c = storedData.seed) !== null && _c !== void 0 ? _c : shared_1.ModelDefaults.DEFAULT_SEED;\n            model.oneClockUnit = (_d = storedData.oneClockUnit) !== null && _d !== void 0 ? _d : shared_1.ModelDefaults.DEFAULT_CLOCK_UNIT;\n            model.simulationTimeType = (_e = storedData.simulationTimeType) !== null && _e !== void 0 ? _e : shared_1.SimulationTimeType.Clock;\n            model.warmupClockPeriod = (_f = storedData.warmupClockPeriod) !== null && _f !== void 0 ? _f : 0;\n            model.warmupClockPeriodUnit = (_g = storedData.warmupClockPeriodUnit) !== null && _g !== void 0 ? _g : shared_1.PeriodUnit.HOURS;\n            model.runClockPeriod = (_h = storedData.runClockPeriod) !== null && _h !== void 0 ? _h : 24;\n            model.runClockPeriodUnit = (_j = storedData.runClockPeriodUnit) !== null && _j !== void 0 ? _j : shared_1.PeriodUnit.HOURS;\n            model.warmupDateTime = (_k = storedData.warmupDateTime) !== null && _k !== void 0 ? _k : null;\n            model.startDateTime = (_l = storedData.startDateTime) !== null && _l !== void 0 ? _l : null;\n            model.finishDateTime = (_m = storedData.finishDateTime) !== null && _m !== void 0 ? _m : null;\n        }\n        else {\n            model.name = this.getElementName();\n        }\n        return model;\n    }\n    updateFromPlatform() {\n        const page = this.element;\n        // Update name only if not already set\n        if (!this.simObject.name) {\n            this.simObject.name = this.getElementName();\n        }\n        // Store custom data properties\n        const dataToStore = {\n            id: this.platformElementId,\n            name: this.simObject.name,\n            reps: this.simObject.reps,\n            forecastDays: this.simObject.forecastDays,\n            seed: this.simObject.seed,\n            oneClockUnit: this.simObject.oneClockUnit,\n            simulationTimeType: this.simObject.simulationTimeType,\n            warmupClockPeriod: this.simObject.warmupClockPeriod,\n            warmupClockPeriodUnit: this.simObject.warmupClockPeriodUnit,\n            runClockPeriod: this.simObject.runClockPeriod,\n            runClockPeriodUnit: this.simObject.runClockPeriodUnit,\n            warmupDateTime: this.simObject.warmupDateTime,\n            startDateTime: this.simObject.startDateTime,\n            finishDateTime: this.simObject.finishDateTime\n        };\n        this.storageAdapter.updateElementData(page, dataToStore);\n    }\n    getElementName() {\n        const page = this.element;\n        return page.getTitle() || 'Unnamed Model';\n    }\n    validate() {\n        return !!this.simObject.name &&\n            this.simObject.reps > 0 &&\n            this.simObject.forecastDays > 0;\n    }\n}\nexports.ModelLucid = ModelLucid;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/types/ModelLucid.ts?");

/***/ }),

/***/ "./src/types/ResourceLucid.ts":
/*!************************************!*\
  !*** ./src/types/ResourceLucid.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResourceLucid = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst SimObjectLucid_1 = __webpack_require__(/*! ./SimObjectLucid */ \"./src/types/SimObjectLucid.ts\");\n/**\n * Lucid-specific implementation of a Resource.\n * Maps a Lucid Block element to a simulation Resource.\n */\nclass ResourceLucid extends SimObjectLucid_1.SimObjectLucid {\n    constructor(block, storageAdapter) {\n        // Pass the block as the element to the parent constructor\n        super(block, storageAdapter);\n    }\n    get type() {\n        return shared_1.SimulationObjectType.Resource;\n    }\n    createSimObject() {\n        var _a;\n        // Create resource with element-specific properties\n        const resource = new shared_1.Resource(this.platformElementId, '', // name will be set below\n        1 // default capacity\n        );\n        // Get stored custom data\n        const storedData = this.storageAdapter.getElementData(this.element);\n        if (storedData) {\n            // Only copy specific properties from stored data\n            resource.name = storedData.name || this.getElementName('Resource');\n            resource.capacity = (_a = storedData.capacity) !== null && _a !== void 0 ? _a : 1;\n        }\n        else {\n            resource.name = this.getElementName('Resource');\n        }\n        return resource;\n    }\n    updateFromPlatform() {\n        // Update name if not already set\n        if (!this.simObject.name) {\n            this.simObject.name = this.getElementName('Resource');\n        }\n        // Store only custom data properties\n        const dataToStore = {\n            id: this.platformElementId,\n            name: this.simObject.name,\n            capacity: this.simObject.capacity\n        };\n        this.storageAdapter.updateElementData(this.element, dataToStore);\n    }\n    getElementName(defaultPrefix) {\n        const block = this.element;\n        // Check for text areas on the block\n        if (block.textAreas && block.textAreas.size > 0) {\n            for (const text of block.textAreas.values()) {\n                if (text && text.trim()) {\n                    return text.trim();\n                }\n            }\n        }\n        // If no text found, use class name\n        const className = block.getClassName() || 'Block';\n        return `${defaultPrefix} ${className}`;\n    }\n    static createFromConversion(block, storageAdapter) {\n        // Create default resource using the static method\n        const defaultResource = shared_1.Resource.createDefault(block.id);\n        // Get name from block text if available\n        const name = SimObjectLucid_1.SimObjectLucid.getNameFromBlock(block, 'Res');\n        // Convert to StoredResourceData format\n        const storedData = {\n            id: defaultResource.id,\n            name: name,\n            capacity: defaultResource.capacity\n        };\n        // Set up both data and metadata\n        storageAdapter.setElementData(block, storedData, shared_1.SimulationObjectType.Resource, {\n            version: \"1.0.0\"\n        });\n        // Create and return the ResourceLucid instance\n        return new ResourceLucid(block, storageAdapter);\n    }\n}\nexports.ResourceLucid = ResourceLucid;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/types/ResourceLucid.ts?");

/***/ }),

/***/ "./src/types/ResourceRequirementLucid.ts":
/*!***********************************************!*\
  !*** ./src/types/ResourceRequirementLucid.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResourceRequirementLucid = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst SimObjectLucid_1 = __webpack_require__(/*! ./SimObjectLucid */ \"./src/types/SimObjectLucid.ts\");\n/**\n * Lucid-specific implementation of a ResourceRequirement.\n * Maps a Lucid Block element to a simulation ResourceRequirement.\n */\nclass ResourceRequirementLucid extends SimObjectLucid_1.SimObjectLucid {\n    constructor(block, storageAdapter) {\n        super(block, storageAdapter);\n        this.block = block;\n    }\n    get type() {\n        return shared_1.SimulationObjectType.ResourceRequirement;\n    }\n    createSimObject() {\n        // Unlike other types, ResourceRequirement doesn't have a createDefault.\n        // Instead, we create a basic requirement with an empty clause array.\n        return new shared_1.ResourceRequirement(this.block.id, this.getElementName('Resource Requirement'), [] // empty root clauses\n        );\n    }\n    /**\n     * Creates a ResourceRequirement from a specific Resource\n     */\n    static createFromResource(block, storageAdapter, resource) {\n        const instance = new ResourceRequirementLucid(block, storageAdapter);\n        instance.simObject = shared_1.ResourceRequirement.createForSingleResource(resource);\n        return instance;\n    }\n    updateFromPlatform() {\n        // Update name\n        this.simObject.name = this.getElementName('Resource Requirement');\n        // Note: Resource requirement clauses and requests are typically \n        // updated through user interactions in the panel rather than \n        // from changes to the Lucid block itself\n        // Store updated data\n        this.storageAdapter.updateElementData(this.block, this.simObject);\n    }\n    getElementName(defaultPrefix) {\n        // Check for text areas on the block\n        if (this.block.textAreas && this.block.textAreas.size > 0) {\n            for (const text of this.block.textAreas.values()) {\n                if (text && text.trim()) {\n                    return text.trim();\n                }\n            }\n        }\n        // If no text found, use class name\n        const className = this.block.getClassName() || 'Block';\n        return `${defaultPrefix} ${className}`;\n    }\n    /**\n     * Additional method to add a clause to the requirement\n     */\n    addClause(clause) {\n        this.simObject.addClause(clause);\n        this.storageAdapter.updateElementData(this.block, this.simObject);\n    }\n    /**\n     * Additional method to remove a clause from the requirement\n     */\n    removeClause(clauseId) {\n        this.simObject.removeClause(clauseId);\n        this.storageAdapter.updateElementData(this.block, this.simObject);\n    }\n    static createFromConversion(block, storageAdapter) {\n        // Create default resource requirement\n        // Note: ResourceRequirement doesn't have a createDefault method\n        const defaultRequirement = new shared_1.ResourceRequirement(block.id, `Resource Requirement ${block.getClassName() || 'Block'}`, [] // empty root clauses\n        );\n        // Convert to StoredResourceRequirementData format\n        const storedData = {\n            id: defaultRequirement.id,\n            name: defaultRequirement.name,\n            rootClauses: defaultRequirement.rootClauses\n        };\n        // Set up both data and metadata\n        storageAdapter.setElementData(block, storedData, shared_1.SimulationObjectType.ResourceRequirement, {\n            version: \"1.0.0\"\n        });\n        // Create and return the ResourceRequirementLucid instance\n        return new ResourceRequirementLucid(block, storageAdapter);\n    }\n}\nexports.ResourceRequirementLucid = ResourceRequirementLucid;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/types/ResourceRequirementLucid.ts?");

/***/ }),

/***/ "./src/types/SimObjectLucid.ts":
/*!*************************************!*\
  !*** ./src/types/SimObjectLucid.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimObjectLucid = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\n/**\n * Base abstract class for Lucid-specific simulation objects.\n * Implements common functionality and enforces the PlatformSimObject contract.\n */\nclass SimObjectLucid {\n    constructor(element, storageAdapter) {\n        this.element = element;\n        this.storageAdapter = storageAdapter;\n        this.simObject = this.createSimObject();\n    }\n    /**\n     * Gets the unique identifier of the Lucid element\n     */\n    get platformElementId() {\n        return this.element.id;\n    }\n    /**\n     * abstract static method for conversion\n     */\n    static createFromConversion(element, storageAdapter) {\n        throw new Error('createFromConversion must be implemented by subclass');\n    }\n    /**\n     * Gets the platform-agnostic simulation object\n     */\n    getSimulationObject() {\n        return this.simObject;\n    }\n    /**\n     * Validates the Lucid element storage\n     */\n    validate() {\n        return this.storageAdapter.validateStorage(this.element);\n    }\n    /**\n     * Gets Lucid-specific metadata\n     */\n    getMetadata() {\n        return {\n            platform: shared_1.PlatformType.Lucid,\n            version: '1.0.0',\n            lastModified: new Date().toISOString(),\n            elementId: this.element.id,\n            elementType: this.type\n        };\n    }\n    /**\n     * Static utility method to get name from a block's text areas\n     */\n    static getNameFromBlock(block, defaultPrefix) {\n        if (block.textAreas && block.textAreas.size > 0) {\n            for (const text of block.textAreas.values()) {\n                if (text && text.trim()) {\n                    return text.trim();\n                }\n            }\n        }\n        const className = block.getClassName() || 'Block';\n        return `${defaultPrefix} ${className}`;\n    }\n}\nexports.SimObjectLucid = SimObjectLucid;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/types/SimObjectLucid.ts?");

/***/ }),

/***/ "./src/types/index.ts":
/*!****************************!*\
  !*** ./src/types/index.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// Base Platform Object\n__exportStar(__webpack_require__(/*! ./SimObjectLucid */ \"./src/types/SimObjectLucid.ts\"), exports);\n// Specific Implementations\n__exportStar(__webpack_require__(/*! ./ModelLucid */ \"./src/types/ModelLucid.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./ActivityLucid */ \"./src/types/ActivityLucid.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./ConnectorLucid */ \"./src/types/ConnectorLucid.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityLucid */ \"./src/types/EntityLucid.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./GeneratorLucid */ \"./src/types/GeneratorLucid.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./ResourceLucid */ \"./src/types/ResourceLucid.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./ResourceRequirementLucid */ \"./src/types/ResourceRequirementLucid.ts\"), exports);\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/types/index.ts?");

/***/ }),

/***/ "./src/versioning/LucidPreflightChecker.ts":
/*!*************************************************!*\
  !*** ./src/versioning/LucidPreflightChecker.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidPreflightChecker = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\n/**\n * Performs Lucid-specific preflight checks\n */\nclass LucidPreflightChecker {\n    /**\n     * Validates that the page has necessary structure for upgrade\n     */\n    async validatePage(page) {\n        const issues = [];\n        // Check if page has model metadata\n        const metaStr = page.shapeData.get(LucidPreflightChecker.META_KEY);\n        if (!metaStr || typeof metaStr !== 'string') {\n            issues.push({\n                message: 'Page is missing q_meta data',\n                severity: shared_1.UpgradeIssueSeverity.Error\n            });\n            return issues; // Early return as other checks depend on q_meta\n        }\n        try {\n            const metadata = JSON.parse(metaStr);\n            const pageVersion = metadata.version;\n            // Validate all elements have consistent versions\n            const elementIssues = await this.validateElementVersions(page, pageVersion);\n            issues.push(...elementIssues);\n        }\n        catch (error) {\n            issues.push({\n                message: `Error parsing page metadata: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                severity: shared_1.UpgradeIssueSeverity.Error\n            });\n        }\n        return issues;\n    }\n    /**\n     * Validates that all elements have matching versions\n     */\n    async validateElementVersions(page, pageVersion) {\n        const issues = [];\n        // Check blocks\n        for (const block of page.blocks.values()) {\n            const metaStr = block.shapeData.get(LucidPreflightChecker.META_KEY);\n            if (!metaStr || typeof metaStr !== 'string')\n                continue; // Skip non-Quodsi elements\n            try {\n                const metadata = JSON.parse(metaStr);\n                if (metadata.version !== pageVersion) {\n                    issues.push({\n                        elementId: block.id,\n                        elementType: metadata.type,\n                        message: `Block version (${metadata.version}) does not match page version (${pageVersion})`,\n                        severity: shared_1.UpgradeIssueSeverity.Error\n                    });\n                }\n            }\n            catch (error) {\n                issues.push({\n                    elementId: block.id,\n                    message: `Error parsing block metadata: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                    severity: shared_1.UpgradeIssueSeverity.Error\n                });\n            }\n        }\n        // Check lines\n        for (const line of page.lines.values()) {\n            const metaStr = line.shapeData.get(LucidPreflightChecker.META_KEY);\n            if (!metaStr || typeof metaStr !== 'string')\n                continue; // Skip non-Quodsi elements\n            try {\n                const metadata = JSON.parse(metaStr);\n                if (metadata.version !== pageVersion) {\n                    issues.push({\n                        elementId: line.id,\n                        elementType: metadata.type,\n                        message: `Line version (${metadata.version}) does not match page version (${pageVersion})`,\n                        severity: shared_1.UpgradeIssueSeverity.Error\n                    });\n                }\n            }\n            catch (error) {\n                issues.push({\n                    elementId: line.id,\n                    message: `Error parsing line metadata: ${error instanceof Error ? error.message : 'Unknown error'}`,\n                    severity: shared_1.UpgradeIssueSeverity.Error\n                });\n            }\n        }\n        return issues;\n    }\n    /**\n     * Gets the version from page metadata\n     */\n    getPageVersion(page) {\n        const metaStr = page.shapeData.get(LucidPreflightChecker.META_KEY);\n        if (!metaStr || typeof metaStr !== 'string')\n            return null;\n        try {\n            const metadata = JSON.parse(metaStr);\n            return metadata.version;\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\nexports.LucidPreflightChecker = LucidPreflightChecker;\nLucidPreflightChecker.META_KEY = 'q_meta';\nLucidPreflightChecker.DATA_KEY = 'q_data';\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/versioning/LucidPreflightChecker.ts?");

/***/ }),

/***/ "./src/versioning/LucidVersionManager.ts":
/*!***********************************************!*\
  !*** ./src/versioning/LucidVersionManager.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidVersionManager = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst shared_2 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst shared_3 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst LucidVersionUpgrader_1 = __webpack_require__(/*! ./LucidVersionUpgrader */ \"./src/versioning/LucidVersionUpgrader.ts\");\nconst NotificationService_1 = __webpack_require__(/*! ../services/NotificationService */ \"./src/services/NotificationService.ts\");\n/**\n * Manages version upgrades in the LucidChart environment\n */\nclass LucidVersionManager {\n    constructor() {\n        // Get notification service instance\n        this.notificationService = NotificationService_1.NotificationService.getInstance();\n        // Register the Lucid upgrader with the factory\n        shared_3.VersionUpgraderFactory.registerUpgrader(shared_2.PlatformType.Lucid, LucidVersionUpgrader_1.LucidVersionUpgrader);\n        // Create version manager with Lucid-specific options\n        this.versionManager = new shared_1.VersionManager(shared_2.PlatformType.Lucid, {\n            notifyUser: true,\n            onNotify: (message) => this.notificationService.showMessage(message),\n            onUpgradeStart: () => this.handleUpgradeStart(),\n            onUpgradeComplete: () => this.handleUpgradeComplete(),\n            onUpgradeFailed: (error) => this.handleUpgradeFailed(error)\n        });\n    }\n    /**\n     * Checks if a page needs upgrading and performs upgrade if necessary\n     */\n    async handlePageLoad(page) {\n        try {\n            // Get current version from page\n            const preflightResult = await this.versionManager.checkUpgrade(page);\n            if (!preflightResult.canUpgrade) {\n                return;\n            }\n            // Show upgrade needed notification\n            this.notificationService.showMessage(`Model upgrade required from ${preflightResult.sourceVersion} to ${preflightResult.targetVersion}`);\n            // Check for issues\n            if (preflightResult.issues.length > 0) {\n                const issueMessages = preflightResult.issues\n                    .map(issue => `- ${issue.message}`)\n                    .join('\\n');\n                this.notificationService.showWarning(`Upgrade issues found:\\n${issueMessages}`);\n                return;\n            }\n            // Perform upgrade\n            await this.versionManager.performUpgrade(page);\n        }\n        catch (error) {\n            const message = error instanceof Error ? error.message : 'Unknown error';\n            this.notificationService.showError(`Error during version check: ${message}`);\n        }\n    }\n    handleUpgradeStart() {\n        // Could add loading indicator or lock UI\n    }\n    handleUpgradeComplete() {\n        // Could refresh UI or model tree\n    }\n    handleUpgradeFailed(error) {\n        this.notificationService.showError(`Upgrade failed and was rolled back: ${error.message}`);\n    }\n}\nexports.LucidVersionManager = LucidVersionManager;\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/versioning/LucidVersionManager.ts?");

/***/ }),

/***/ "./src/versioning/LucidVersionUpgrader.ts":
/*!************************************************!*\
  !*** ./src/versioning/LucidVersionUpgrader.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidVersionUpgrader = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst shared_2 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst LucidPreflightChecker_1 = __webpack_require__(/*! ./LucidPreflightChecker */ \"./src/versioning/LucidPreflightChecker.ts\");\n/**\n * Lucid-specific implementation of version upgrader\n */\nclass LucidVersionUpgrader extends shared_1.BaseVersionUpgrader {\n    constructor(currentVersion, options) {\n        super(currentVersion, options);\n        this.preflightChecker = new LucidPreflightChecker_1.LucidPreflightChecker();\n        this.backupData = new Map();\n    }\n    /**\n     * Gets the source version from the page metadata\n     */\n    async getSourceVersion(page) {\n        const version = this.preflightChecker.getPageVersion(page);\n        return version || '';\n    }\n    /**\n     * Performs Lucid-specific validation\n     */\n    async validatePlatformRequirements(page) {\n        return this.preflightChecker.validatePage(page);\n    }\n    /**\n     * Backs up current state before upgrade\n     */\n    async beginUpgrade(page) {\n        this.backupData.clear();\n        // Backup page data\n        this.backupElementData('page', page);\n        // Backup blocks\n        for (const block of page.blocks.values()) {\n            this.backupElementData(block.id, block);\n        }\n        // Backup lines\n        for (const line of page.lines.values()) {\n            this.backupElementData(line.id, line);\n        }\n    }\n    /**\n     * Backs up an element's shape data\n     */\n    backupElementData(id, element) {\n        const meta = element.shapeData.get(LucidVersionUpgrader.META_KEY);\n        const data = element.shapeData.get(LucidVersionUpgrader.DATA_KEY);\n        if (meta && data && typeof meta === 'string' && typeof data === 'string') {\n            this.backupData.set(id, { meta, data });\n        }\n    }\n    /**\n     * Performs the upgrade on all elements\n     */\n    async performUpgrade(page) {\n        const sourceVersion = await this.getSourceVersion(page);\n        const transformations = (0, shared_2.getTransformationsBetweenVersions)(sourceVersion, this.currentVersion);\n        // Upgrade page/model first\n        await this.upgradeElement(page, transformations, 'Model');\n        // Upgrade blocks\n        for (const block of page.blocks.values()) {\n            await this.upgradeElement(block, transformations);\n        }\n        // Upgrade lines\n        for (const line of page.lines.values()) {\n            await this.upgradeElement(line, transformations);\n        }\n    }\n    /**\n     * Upgrades a single element\n     */\n    async upgradeElement(element, transformations, forceType) {\n        const metaStr = element.shapeData.get(LucidVersionUpgrader.META_KEY);\n        const dataStr = element.shapeData.get(LucidVersionUpgrader.DATA_KEY);\n        if (!metaStr || !dataStr || typeof metaStr !== 'string' || typeof dataStr !== 'string')\n            return;\n        try {\n            const meta = JSON.parse(metaStr);\n            const data = JSON.parse(dataStr);\n            const elementType = forceType || meta.type;\n            const transform = transformations.find(t => t.objectType === elementType);\n            if (transform && transform.transformations.length > 0) {\n                // Transform the data\n                const newData = transform.transformations[0].transform(data);\n                // Update metadata\n                meta.version = this.currentVersion;\n                meta.lastModified = new Date().toISOString();\n                // Save back to element\n                element.shapeData.set(LucidVersionUpgrader.META_KEY, JSON.stringify(meta));\n                element.shapeData.set(LucidVersionUpgrader.DATA_KEY, JSON.stringify(newData));\n            }\n        }\n        catch (error) {\n            throw new Error(`Failed to upgrade element ${element.id}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n     * Verifies upgrade and cleans up backup if successful\n     */\n    async finalizeUpgrade(page) {\n        // Verify blocks\n        for (const block of page.blocks.values()) {\n            const metaStr = block.shapeData.get(LucidVersionUpgrader.META_KEY);\n            if (!metaStr || typeof metaStr !== 'string')\n                continue;\n            try {\n                const meta = JSON.parse(metaStr);\n                if (meta.version !== this.currentVersion) {\n                    throw new Error(`Block ${block.id} was not upgraded correctly`);\n                }\n            }\n            catch (error) {\n                throw new Error(`Failed to verify block ${block.id}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        }\n        // Verify lines\n        for (const line of page.lines.values()) {\n            const metaStr = line.shapeData.get(LucidVersionUpgrader.META_KEY);\n            if (!metaStr || typeof metaStr !== 'string')\n                continue;\n            try {\n                const meta = JSON.parse(metaStr);\n                if (meta.version !== this.currentVersion) {\n                    throw new Error(`Line ${line.id} was not upgraded correctly`);\n                }\n            }\n            catch (error) {\n                throw new Error(`Failed to verify line ${line.id}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        }\n        // Clear backup data after successful upgrade\n        this.backupData.clear();\n    }\n    /**\n     * Restores previous state if upgrade fails\n     */\n    async rollbackUpgrade(page) {\n        if (this.backupData.size === 0)\n            return;\n        // Restore page data\n        const pageBackup = this.backupData.get('page');\n        if (pageBackup) {\n            this.restoreElementData(page, pageBackup);\n        }\n        // Restore blocks\n        for (const block of page.blocks.values()) {\n            const blockBackup = this.backupData.get(block.id);\n            if (blockBackup) {\n                this.restoreElementData(block, blockBackup);\n            }\n        }\n        // Restore lines\n        for (const line of page.lines.values()) {\n            const lineBackup = this.backupData.get(line.id);\n            if (lineBackup) {\n                this.restoreElementData(line, lineBackup);\n            }\n        }\n        this.backupData.clear();\n    }\n    /**\n     * Restores an element's shape data from backup\n     */\n    restoreElementData(element, backup) {\n        element.shapeData.set(LucidVersionUpgrader.META_KEY, backup.meta);\n        element.shapeData.set(LucidVersionUpgrader.DATA_KEY, backup.data);\n    }\n}\nexports.LucidVersionUpgrader = LucidVersionUpgrader;\nLucidVersionUpgrader.META_KEY = 'q_meta';\nLucidVersionUpgrader.DATA_KEY = 'q_data';\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/versioning/LucidVersionUpgrader.ts?");

/***/ }),

/***/ "./src/versioning/index.ts":
/*!*********************************!*\
  !*** ./src/versioning/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = void 0;\n__exportStar(__webpack_require__(/*! ./LucidPreflightChecker */ \"./src/versioning/LucidPreflightChecker.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./LucidVersionUpgrader */ \"./src/versioning/LucidVersionUpgrader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./LucidVersionManager */ \"./src/versioning/LucidVersionManager.ts\"), exports);\n// Default export for convenient instantiation\nvar LucidVersionManager_1 = __webpack_require__(/*! ./LucidVersionManager */ \"./src/versioning/LucidVersionManager.ts\");\nObject.defineProperty(exports, \"default\", ({ enumerable: true, get: function () { return LucidVersionManager_1.LucidVersionManager; } }));\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/./src/versioning/index.ts?");

/***/ }),

/***/ "../../shared/dist/constants/version.js":
/*!**********************************************!*\
  !*** ../../shared/dist/constants/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isValidVersion = exports.compareVersions = exports.parseVersion = exports.QUODSI_VERSION = void 0;\r\n/**\r\n * Current version of Quodsi\r\n * Should be updated to match package.json version when making releases\r\n */\r\nexports.QUODSI_VERSION = \"1.1.0\";\r\n/**\r\n * Parses a version string into its components\r\n */\r\nvar parseVersion = function (version) {\r\n    var _a = version.split('.').map(Number), _b = _a[0], major = _b === void 0 ? 0 : _b, _c = _a[1], minor = _c === void 0 ? 0 : _c, _d = _a[2], patch = _d === void 0 ? 0 : _d;\r\n    return { major: major, minor: minor, patch: patch };\r\n};\r\nexports.parseVersion = parseVersion;\r\n/**\r\n * Compares two version strings\r\n * @returns negative if v1 < v2, 0 if equal, positive if v1 > v2\r\n */\r\nvar compareVersions = function (v1, v2) {\r\n    var ver1 = (0, exports.parseVersion)(v1);\r\n    var ver2 = (0, exports.parseVersion)(v2);\r\n    if (ver1.major !== ver2.major)\r\n        return ver1.major - ver2.major;\r\n    if (ver1.minor !== ver2.minor)\r\n        return ver1.minor - ver2.minor;\r\n    return ver1.patch - ver2.patch;\r\n};\r\nexports.compareVersions = compareVersions;\r\n/**\r\n * Checks if a version string is valid\r\n */\r\nvar isValidVersion = function (version) {\r\n    return /^\\d+\\.\\d+\\.\\d+$/.test(version);\r\n};\r\nexports.isValidVersion = isValidVersion;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/constants/version.js?");

/***/ }),

/***/ "../../shared/dist/core/logging/QuodsiLogger.js":
/*!******************************************************!*\
  !*** ../../shared/dist/core/logging/QuodsiLogger.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.QuodsiLogger = void 0;\r\nvar QuodsiLogger = /** @class */ (function () {\r\n    // No initialization in constructor since we can't access LOG_PREFIX\r\n    function QuodsiLogger() {\r\n        this.loggingEnabled = false;\r\n    }\r\n    QuodsiLogger.prototype.setLogging = function (enabled) {\r\n        // Initialize on first use if needed\r\n        if (!QuodsiLogger.instanceMap.has(this.LOG_PREFIX)) {\r\n            QuodsiLogger.instanceMap.set(this.LOG_PREFIX, enabled);\r\n        }\r\n        else {\r\n            QuodsiLogger.instanceMap.set(this.LOG_PREFIX, enabled);\r\n        }\r\n        this.loggingEnabled = enabled;\r\n        if (enabled) {\r\n            this.log(\"Logging enabled\");\r\n        }\r\n    };\r\n    QuodsiLogger.prototype.isLoggingEnabled = function () {\r\n        // Initialize as false if not yet set\r\n        if (!QuodsiLogger.instanceMap.has(this.LOG_PREFIX)) {\r\n            QuodsiLogger.instanceMap.set(this.LOG_PREFIX, false);\r\n            this.loggingEnabled = false;\r\n        }\r\n        return this.loggingEnabled;\r\n    };\r\n    QuodsiLogger.prototype.log = function (message) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        if (this.isLoggingEnabled()) {\r\n            console.log.apply(console, __spreadArray([\"\".concat(this.LOG_PREFIX, \" \").concat(message)], args, false));\r\n        }\r\n    };\r\n    QuodsiLogger.prototype.logError = function (message) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        if (this.isLoggingEnabled()) {\r\n            console.error.apply(console, __spreadArray([\"\".concat(this.LOG_PREFIX, \" \").concat(message)], args, false));\r\n        }\r\n    };\r\n    QuodsiLogger.prototype.logWarning = function (message) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        if (this.isLoggingEnabled()) {\r\n            console.warn.apply(console, __spreadArray([\"\".concat(this.LOG_PREFIX, \" \").concat(message)], args, false));\r\n        }\r\n    };\r\n    QuodsiLogger.prototype.logDebug = function (message) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        if (this.isLoggingEnabled()) {\r\n            console.debug.apply(console, __spreadArray([\"\".concat(this.LOG_PREFIX, \" \").concat(message)], args, false));\r\n        }\r\n    };\r\n    QuodsiLogger.instanceMap = new Map();\r\n    return QuodsiLogger;\r\n}());\r\nexports.QuodsiLogger = QuodsiLogger;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/core/logging/QuodsiLogger.js?");

/***/ }),

/***/ "../../shared/dist/factories/SimulationObjectTypeFactory.js":
/*!******************************************************************!*\
  !*** ../../shared/dist/factories/SimulationObjectTypeFactory.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimulationObjectTypeFactory = void 0;\r\nvar __1 = __webpack_require__(/*! .. */ \"../../shared/dist/index.js\");\r\nvar SimulationObjectTypeFactory;\r\n(function (SimulationObjectTypeFactory) {\r\n    function createActivity(lucidId) {\r\n        return __1.Activity.createDefault(lucidId);\r\n    }\r\n    SimulationObjectTypeFactory.createActivity = createActivity;\r\n    function createConnector(lucidId) {\r\n        return __1.Connector.createDefault(lucidId);\r\n    }\r\n    SimulationObjectTypeFactory.createConnector = createConnector;\r\n    function createGenerator(lucidId) {\r\n        return __1.Generator.createDefault(lucidId);\r\n    }\r\n    SimulationObjectTypeFactory.createGenerator = createGenerator;\r\n    function createResource(lucidId) {\r\n        return __1.Resource.createDefault(lucidId);\r\n    }\r\n    SimulationObjectTypeFactory.createResource = createResource;\r\n    function createEntity(lucidId) {\r\n        return __1.Entity.createDefault(lucidId);\r\n    }\r\n    SimulationObjectTypeFactory.createEntity = createEntity;\r\n    function createElement(type, lucidId) {\r\n        switch (type) {\r\n            case __1.SimulationObjectType.Activity:\r\n                return createActivity(lucidId);\r\n            case __1.SimulationObjectType.Connector:\r\n                return createConnector(lucidId);\r\n            case __1.SimulationObjectType.Generator:\r\n                return createGenerator(lucidId);\r\n            case __1.SimulationObjectType.Resource:\r\n                return createResource(lucidId);\r\n            case __1.SimulationObjectType.Entity:\r\n                return createEntity(lucidId);\r\n            default:\r\n                return {\r\n                    id: lucidId,\r\n                    name: \"New \".concat(type),\r\n                    type: type\r\n                };\r\n        }\r\n    }\r\n    SimulationObjectTypeFactory.createElement = createElement;\r\n})(SimulationObjectTypeFactory = exports.SimulationObjectTypeFactory || (exports.SimulationObjectTypeFactory = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/factories/SimulationObjectTypeFactory.js?");

/***/ }),

/***/ "../../shared/dist/index.js":
/*!**********************************!*\
  !*** ../../shared/dist/index.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./platform */ \"../../shared/dist/platform/index.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./core/logging/QuodsiLogger */ \"../../shared/dist/core/logging/QuodsiLogger.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/ActivityRelationships */ \"../../shared/dist/types/ActivityRelationships.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/BlockAnalysis */ \"../../shared/dist/types/BlockAnalysis.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/ConversionResult */ \"../../shared/dist/types/ConversionResult.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/EditorReferenceData */ \"../../shared/dist/types/EditorReferenceData.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/messaging */ \"../../shared/dist/types/messaging/index.js\"), exports); // This exports JsonTypes, MessageTypes, and utils\r\n__exportStar(__webpack_require__(/*! ./types/PageStatus */ \"../../shared/dist/types/PageStatus.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/ProcessAnalysisResult */ \"../../shared/dist/types/ProcessAnalysisResult.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/SelectionState */ \"../../shared/dist/types/SelectionState.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/SelectionType */ \"../../shared/dist/types/SelectionType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/simComponentType */ \"../../shared/dist/types/simComponentType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/validation */ \"../../shared/dist/types/validation/index.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/MetaData */ \"../../shared/dist/types/MetaData.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/RunState */ \"../../shared/dist/types/elements/RunState.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/DiagramElementType */ \"../../shared/dist/types/DiagramElementType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Activity */ \"../../shared/dist/types/elements/Activity.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ActivityListManager */ \"../../shared/dist/types/elements/ActivityListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Connector */ \"../../shared/dist/types/elements/Connector.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ConnectorListManager */ \"../../shared/dist/types/elements/ConnectorListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ConnectType */ \"../../shared/dist/types/elements/ConnectType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Distribution */ \"../../shared/dist/types/elements/Distribution.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/DistributionType */ \"../../shared/dist/types/elements/DistributionType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Duration */ \"../../shared/dist/types/elements/Duration.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/DurationType */ \"../../shared/dist/types/elements/DurationType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Entity */ \"../../shared/dist/types/elements/Entity.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/EntityListManager */ \"../../shared/dist/types/elements/EntityListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Experiment */ \"../../shared/dist/types/elements/Experiment.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Generator */ \"../../shared/dist/types/elements/Generator.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/GeneratorListManager */ \"../../shared/dist/types/elements/GeneratorListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Model */ \"../../shared/dist/types/elements/Model.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ModelDefaults */ \"../../shared/dist/types/elements/ModelDefaults.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ModelDefinition */ \"../../shared/dist/types/elements/ModelDefinition.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ModelUtils */ \"../../shared/dist/types/elements/ModelUtils.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/OperationStep */ \"../../shared/dist/types/elements/OperationStep.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/PeriodUnit */ \"../../shared/dist/types/elements/PeriodUnit.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/RequirementMode */ \"../../shared/dist/types/elements/RequirementMode.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Resource */ \"../../shared/dist/types/elements/Resource.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ResourceListManager */ \"../../shared/dist/types/elements/ResourceListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ResourceRequest */ \"../../shared/dist/types/elements/ResourceRequest.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/RequirementClause */ \"../../shared/dist/types/elements/RequirementClause.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ResourceRequirement */ \"../../shared/dist/types/elements/ResourceRequirement.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Scenario */ \"../../shared/dist/types/elements/Scenario.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/SimulationObject */ \"../../shared/dist/types/elements/SimulationObject.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/SimulationTimeType */ \"../../shared/dist/types/elements/SimulationTimeType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./factories/SimulationObjectTypeFactory */ \"../../shared/dist/factories/SimulationObjectTypeFactory.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/accordion/ModelElement */ \"../../shared/dist/types/accordion/ModelElement.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/accordion/ModelStructure */ \"../../shared/dist/types/accordion/ModelStructure.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/accordion/ValidationState */ \"../../shared/dist/types/accordion/ValidationState.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/accordion/AccordionState */ \"../../shared/dist/types/accordion/AccordionState.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ModelDefinitionLogger */ \"../../shared/dist/types/elements/ModelDefinitionLogger.js\"), exports);\r\n// Export API services\r\n__exportStar(__webpack_require__(/*! ./services/lucidApi */ \"../../shared/dist/services/lucidApi.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./utils/csvUtils */ \"../../shared/dist/utils/csvUtils.js\"), exports);\r\n// Export serialization\r\n__exportStar(__webpack_require__(/*! ./serialization */ \"../../shared/dist/serialization/index.js\"), exports);\r\n// Export validation\r\n__exportStar(__webpack_require__(/*! ./validation */ \"../../shared/dist/validation/index.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./versioning */ \"../../shared/dist/versioning/index.js\"), exports);\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/index.js?");

/***/ }),

/***/ "../../shared/dist/platform/PlatformSimObject.js":
/*!*******************************************************!*\
  !*** ../../shared/dist/platform/PlatformSimObject.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/platform/PlatformSimObject.js?");

/***/ }),

/***/ "../../shared/dist/platform/PlatformType.js":
/*!**************************************************!*\
  !*** ../../shared/dist/platform/PlatformType.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isPlatformType = exports.PlatformType = void 0;\r\n/**\r\n * Enumeration of supported diagram/design platforms\r\n */\r\nvar PlatformType;\r\n(function (PlatformType) {\r\n    PlatformType[\"Lucid\"] = \"Lucid\";\r\n    PlatformType[\"Miro\"] = \"Miro\";\r\n    PlatformType[\"Canva\"] = \"Canva\";\r\n})(PlatformType = exports.PlatformType || (exports.PlatformType = {}));\r\n/**\r\n * Type guard to check if a string is a valid PlatformType\r\n */\r\nfunction isPlatformType(value) {\r\n    return Object.values(PlatformType).includes(value);\r\n}\r\nexports.isPlatformType = isPlatformType;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/platform/PlatformType.js?");

/***/ }),

/***/ "../../shared/dist/platform/index.js":
/*!*******************************************!*\
  !*** ../../shared/dist/platform/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./PlatformSimObject */ \"../../shared/dist/platform/PlatformSimObject.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./PlatformType */ \"../../shared/dist/platform/PlatformType.js\"), exports);\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/platform/index.js?");

/***/ }),

/***/ "../../shared/dist/serialization/BaseModelDefinitionSerializer.js":
/*!************************************************************************!*\
  !*** ../../shared/dist/serialization/BaseModelDefinitionSerializer.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BaseModelDefinitionSerializer = void 0;\r\nvar SerializationError_1 = __webpack_require__(/*! ./errors/SerializationError */ \"../../shared/dist/serialization/errors/SerializationError.js\");\r\nvar InvalidModelError_1 = __webpack_require__(/*! ./errors/InvalidModelError */ \"../../shared/dist/serialization/errors/InvalidModelError.js\");\r\nvar BaseModelDefinitionSerializer = /** @class */ (function () {\r\n    function BaseModelDefinitionSerializer() {\r\n    }\r\n    BaseModelDefinitionSerializer.prototype.validateModel = function (modelDefinition) {\r\n        if (!modelDefinition) {\r\n            throw new InvalidModelError_1.InvalidModelError('ModelDefinition cannot be null or undefined');\r\n        }\r\n        if (!modelDefinition.model) {\r\n            throw new InvalidModelError_1.InvalidModelError('Model is required');\r\n        }\r\n        if (!modelDefinition.entities.getAll().length) {\r\n            throw new InvalidModelError_1.InvalidModelError('At least one entity is required');\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.serializeModel = function (model) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        try {\r\n            if (!model.id || !model.name) {\r\n                throw new InvalidModelError_1.InvalidModelError('Model must have id and name');\r\n            }\r\n            return {\r\n                id: model.id,\r\n                name: model.name,\r\n                reps: model.reps,\r\n                forecastDays: model.forecastDays,\r\n                seed: model.seed,\r\n                oneClockUnit: model.oneClockUnit,\r\n                simulationTimeType: model.simulationTimeType,\r\n                warmupClockPeriod: model.warmupClockPeriod,\r\n                warmupClockPeriodUnit: model.warmupClockPeriodUnit,\r\n                runClockPeriod: model.runClockPeriod,\r\n                runClockPeriodUnit: model.runClockPeriodUnit,\r\n                warmupDateTime: (_b = (_a = model.warmupDateTime) === null || _a === void 0 ? void 0 : _a.toISOString()) !== null && _b !== void 0 ? _b : null,\r\n                startDateTime: (_d = (_c = model.startDateTime) === null || _c === void 0 ? void 0 : _c.toISOString()) !== null && _d !== void 0 ? _d : null,\r\n                finishDateTime: (_f = (_e = model.finishDateTime) === null || _e === void 0 ? void 0 : _e.toISOString()) !== null && _f !== void 0 ? _f : null\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('Model', 'Failed to serialize model properties', error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.serializeEntity = function (entity) {\r\n        try {\r\n            if (!entity.id || !entity.name) {\r\n                throw new InvalidModelError_1.InvalidModelError('Entity must have id and name');\r\n            }\r\n            return {\r\n                id: entity.id,\r\n                name: entity.name,\r\n                type: entity.type\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('Entity', \"Failed to serialize entity \".concat(entity.id), error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.serializeActivity = function (activity, modelDefinition) {\r\n        var _this = this;\r\n        try {\r\n            if (!activity.id || !activity.name) {\r\n                throw new InvalidModelError_1.InvalidModelError('Activity must have id and name');\r\n            }\r\n            console.log(\"[BaseModelDefinitionSerializer]: # of Connectors\", modelDefinition.connectors.size());\r\n            // Get all connectors where the sourceId matches the activity's id\r\n            var relevantConnectors = modelDefinition.connectors.getAll()\r\n                .filter(function (connector) {\r\n                // Log values for debugging\r\n                console.log(\"[BaseModelDefinitionSerializer]: Comparing connector.sourceId: \".concat(connector.sourceId, \" with activity.id: \").concat(activity.id));\r\n                return connector.sourceId === activity.id;\r\n            })\r\n                .map(function (connector) { return _this.serializeConnector(connector); });\r\n            if (relevantConnectors.length > 0) {\r\n                console.log(\"[BaseModelDefinitionSerializer]: # of Activity Connectors\", relevantConnectors.length);\r\n            }\r\n            else {\r\n                console.log(\"[BaseModelDefinitionSerializer]: # of Activity Connectors\", 0);\r\n            }\r\n            return {\r\n                id: activity.id,\r\n                name: activity.name,\r\n                type: activity.type,\r\n                capacity: activity.capacity,\r\n                inputBufferCapacity: activity.inputBufferCapacity,\r\n                outputBufferCapacity: activity.outputBufferCapacity,\r\n                operationSteps: activity.operationSteps.map(function (step) {\r\n                    return _this.serializeOperationStep(step);\r\n                }),\r\n                connectors: relevantConnectors\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('Activity', \"Failed to serialize activity \".concat(activity.id), error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.serializeOperationStep = function (step) {\r\n        try {\r\n            if (!step || !step.duration) {\r\n                throw new InvalidModelError_1.InvalidModelError('OperationStep must have a duration');\r\n            }\r\n            return {\r\n                duration: this.serializeDuration(step.duration),\r\n                requirementId: step.requirementId,\r\n                quantity: step.quantity\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('OperationStep', 'Failed to serialize operation step', error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.serializeDuration = function (duration) {\r\n        try {\r\n            if (duration.durationLength < 0) {\r\n                throw new InvalidModelError_1.InvalidModelError('Duration length cannot be negative');\r\n            }\r\n            return {\r\n                durationLength: duration.durationLength,\r\n                durationPeriodUnit: duration.durationPeriodUnit,\r\n                durationType: duration.durationType,\r\n                distribution: duration.distribution\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('Duration', 'Failed to serialize duration', error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.serializeGenerator = function (generator, modelDefinition) {\r\n        var _this = this;\r\n        try {\r\n            if (!generator.id || !generator.name) {\r\n                throw new InvalidModelError_1.InvalidModelError('Generator must have id and name');\r\n            }\r\n            // Get all connectors where the sourceId matches the generator's id\r\n            var relevantConnectors = modelDefinition.connectors.getAll()\r\n                .filter(function (connector) { return connector.sourceId === generator.id; })\r\n                .map(function (connector) { return _this.serializeConnector(connector); });\r\n            return {\r\n                id: generator.id,\r\n                name: generator.name,\r\n                type: generator.type,\r\n                activityKeyId: generator.activityKeyId,\r\n                entityId: generator.entityId,\r\n                periodicOccurrences: generator.periodicOccurrences,\r\n                periodIntervalDuration: this.serializeDuration(generator.periodIntervalDuration),\r\n                entitiesPerCreation: generator.entitiesPerCreation,\r\n                periodicStartDuration: this.serializeDuration(generator.periodicStartDuration),\r\n                maxEntities: generator.maxEntities,\r\n                connectors: relevantConnectors\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('Generator', \"Failed to serialize generator \".concat(generator.id), error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.serializeResource = function (resource) {\r\n        try {\r\n            if (!resource.id || !resource.name) {\r\n                throw new InvalidModelError_1.InvalidModelError('Resource must have id and name');\r\n            }\r\n            return {\r\n                id: resource.id,\r\n                name: resource.name,\r\n                type: resource.type,\r\n                capacity: resource.capacity\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('Resource', \"Failed to serialize resource \".concat(resource.id), error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.serializeResourceRequirement = function (requirement) {\r\n        var _this = this;\r\n        try {\r\n            if (!requirement.id || !requirement.name) {\r\n                throw new InvalidModelError_1.InvalidModelError('ResourceRequirement must have id and name');\r\n            }\r\n            return {\r\n                id: requirement.id,\r\n                name: requirement.name,\r\n                type: requirement.type,\r\n                rootClauses: requirement.rootClauses.map(function (clause) { return _this.serializeRequirementClause(clause); })\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('ResourceRequirement', \"Failed to serialize resource requirement \".concat(requirement.id), error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.serializeRequirementClause = function (clause) {\r\n        var _this = this;\r\n        try {\r\n            if (!clause.clauseId) {\r\n                throw new InvalidModelError_1.InvalidModelError('RequirementClause must have a clauseId');\r\n            }\r\n            return {\r\n                clauseId: clause.clauseId,\r\n                mode: clause.mode,\r\n                parentClauseId: clause.parentClauseId,\r\n                requests: clause.requests.map(function (request) { return _this.serializeResourceRequest(request); }),\r\n                subClauses: clause.subClauses.map(function (subClause) { return _this.serializeRequirementClause(subClause); })\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('RequirementClause', \"Failed to serialize requirement clause \".concat(clause.clauseId), error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.serializeResourceRequest = function (request) {\r\n        try {\r\n            if (!request.resourceId) {\r\n                throw new InvalidModelError_1.InvalidModelError('ResourceRequest must have a resourceId');\r\n            }\r\n            return {\r\n                resourceId: request.resourceId,\r\n                quantity: request.quantity,\r\n                priority: request.priority,\r\n                keepResource: request.keepResource\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('ResourceRequest', \"Failed to serialize resource request for resource \".concat(request.resourceId), error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.serializeConnector = function (connector) {\r\n        var _this = this;\r\n        try {\r\n            if (!connector.id || !connector.sourceId || !connector.targetId) {\r\n                throw new InvalidModelError_1.InvalidModelError('Connector must have id, sourceId, and targetId');\r\n            }\r\n            return {\r\n                id: connector.id,\r\n                name: connector.name,\r\n                sourceId: connector.sourceId,\r\n                targetId: connector.targetId,\r\n                type: connector.type,\r\n                probability: connector.probability,\r\n                connectType: connector.connectType,\r\n                operationSteps: connector.operationSteps.map(function (step) {\r\n                    return _this.serializeOperationStep(step);\r\n                })\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('Connector', \"Failed to serialize connector \".concat(connector.id), error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    BaseModelDefinitionSerializer.prototype.getMetadata = function () {\r\n        try {\r\n            return {\r\n                version: this.getVersion().toString(),\r\n                timestamp: new Date().toISOString()\r\n            };\r\n        }\r\n        catch (error) {\r\n            throw new SerializationError_1.SerializationError('Metadata', 'Failed to generate metadata', error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    return BaseModelDefinitionSerializer;\r\n}());\r\nexports.BaseModelDefinitionSerializer = BaseModelDefinitionSerializer;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/serialization/BaseModelDefinitionSerializer.js?");

/***/ }),

/***/ "../../shared/dist/serialization/ModelSerializerFactory.js":
/*!*****************************************************************!*\
  !*** ../../shared/dist/serialization/ModelSerializerFactory.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelSerializerFactory = exports.SchemaVersion = void 0;\r\nvar ModelDefinitionSerializerV1_1 = __webpack_require__(/*! ./v1/ModelDefinitionSerializerV1 */ \"../../shared/dist/serialization/v1/ModelDefinitionSerializerV1.js\");\r\nvar UnsupportedVersionError_1 = __webpack_require__(/*! ./errors/UnsupportedVersionError */ \"../../shared/dist/serialization/errors/UnsupportedVersionError.js\");\r\nvar SchemaVersion = /** @class */ (function () {\r\n    function SchemaVersion(major, minor) {\r\n        this.major = major;\r\n        this.minor = minor;\r\n    }\r\n    SchemaVersion.prototype.toString = function () {\r\n        return \"\".concat(this.major, \".\").concat(this.minor);\r\n    };\r\n    SchemaVersion.prototype.equals = function (other) {\r\n        return this.major === other.major && this.minor === other.minor;\r\n    };\r\n    return SchemaVersion;\r\n}());\r\nexports.SchemaVersion = SchemaVersion;\r\nvar ModelSerializerFactory = /** @class */ (function () {\r\n    function ModelSerializerFactory() {\r\n    }\r\n    /**\r\n     * Creates a serializer for the specified model definition and version.\r\n     * If no version is specified, uses the latest supported version.\r\n     */\r\n    ModelSerializerFactory.create = function (modelDefinition, version) {\r\n        if (version === void 0) { version = ModelSerializerFactory.CURRENT_VERSION; }\r\n        if (!ModelSerializerFactory.isVersionSupported(version)) {\r\n            throw new UnsupportedVersionError_1.UnsupportedVersionError(version);\r\n        }\r\n        if (version.major === 1 && version.minor === 0) {\r\n            return new ModelDefinitionSerializerV1_1.ModelDefinitionSerializerV1();\r\n        }\r\n        // This should never happen due to the isVersionSupported check above\r\n        throw new UnsupportedVersionError_1.UnsupportedVersionError(version);\r\n    };\r\n    /**\r\n     * Gets the current (latest) supported version.\r\n     */\r\n    ModelSerializerFactory.getCurrentVersion = function () {\r\n        return ModelSerializerFactory.CURRENT_VERSION;\r\n    };\r\n    /**\r\n     * Checks if the specified version is supported.\r\n     */\r\n    ModelSerializerFactory.isVersionSupported = function (version) {\r\n        return ModelSerializerFactory.SUPPORTED_VERSIONS.some(function (supportedVersion) { return supportedVersion.equals(version); });\r\n    };\r\n    /**\r\n     * Gets all supported versions.\r\n     */\r\n    ModelSerializerFactory.getSupportedVersions = function () {\r\n        return __spreadArray([], ModelSerializerFactory.SUPPORTED_VERSIONS, true);\r\n    };\r\n    /**\r\n     * Gets a list of supported version strings.\r\n     */\r\n    ModelSerializerFactory.getSupportedVersionStrings = function () {\r\n        return ModelSerializerFactory.SUPPORTED_VERSIONS.map(function (v) { return v.toString(); });\r\n    };\r\n    ModelSerializerFactory.SUPPORTED_VERSIONS = [\r\n        new SchemaVersion(1, 0)\r\n    ];\r\n    ModelSerializerFactory.CURRENT_VERSION = ModelSerializerFactory.SUPPORTED_VERSIONS[ModelSerializerFactory.SUPPORTED_VERSIONS.length - 1];\r\n    return ModelSerializerFactory;\r\n}());\r\nexports.ModelSerializerFactory = ModelSerializerFactory;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/serialization/ModelSerializerFactory.js?");

/***/ }),

/***/ "../../shared/dist/serialization/errors/InvalidModelError.js":
/*!*******************************************************************!*\
  !*** ../../shared/dist/serialization/errors/InvalidModelError.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.InvalidModelError = void 0;\r\nvar SerializerError_1 = __webpack_require__(/*! ./SerializerError */ \"../../shared/dist/serialization/errors/SerializerError.js\");\r\nvar InvalidModelError = /** @class */ (function (_super) {\r\n    __extends(InvalidModelError, _super);\r\n    function InvalidModelError(details) {\r\n        var _this = _super.call(this, \"Invalid model: \".concat(details)) || this;\r\n        _this.name = 'InvalidModelError';\r\n        Object.setPrototypeOf(_this, InvalidModelError.prototype);\r\n        return _this;\r\n    }\r\n    return InvalidModelError;\r\n}(SerializerError_1.SerializerError));\r\nexports.InvalidModelError = InvalidModelError;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/serialization/errors/InvalidModelError.js?");

/***/ }),

/***/ "../../shared/dist/serialization/errors/SerializationError.js":
/*!********************************************************************!*\
  !*** ../../shared/dist/serialization/errors/SerializationError.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SerializationError = void 0;\r\nvar SerializerError_1 = __webpack_require__(/*! ./SerializerError */ \"../../shared/dist/serialization/errors/SerializerError.js\");\r\nvar SerializationError = /** @class */ (function (_super) {\r\n    __extends(SerializationError, _super);\r\n    function SerializationError(component, details, originalError) {\r\n        var _this = this;\r\n        var message = originalError\r\n            ? \"Failed to serialize \".concat(component, \": \").concat(details, \". Original error: \").concat(originalError.message)\r\n            : \"Failed to serialize \".concat(component, \": \").concat(details);\r\n        _this = _super.call(this, message) || this;\r\n        _this.name = 'SerializationError';\r\n        Object.setPrototypeOf(_this, SerializationError.prototype);\r\n        return _this;\r\n    }\r\n    return SerializationError;\r\n}(SerializerError_1.SerializerError));\r\nexports.SerializationError = SerializationError;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/serialization/errors/SerializationError.js?");

/***/ }),

/***/ "../../shared/dist/serialization/errors/SerializerError.js":
/*!*****************************************************************!*\
  !*** ../../shared/dist/serialization/errors/SerializerError.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SerializerError = void 0;\r\nvar SerializerError = /** @class */ (function (_super) {\r\n    __extends(SerializerError, _super);\r\n    function SerializerError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.name = 'SerializerError';\r\n        Object.setPrototypeOf(_this, SerializerError.prototype);\r\n        return _this;\r\n    }\r\n    return SerializerError;\r\n}(Error));\r\nexports.SerializerError = SerializerError;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/serialization/errors/SerializerError.js?");

/***/ }),

/***/ "../../shared/dist/serialization/errors/UnsupportedVersionError.js":
/*!*************************************************************************!*\
  !*** ../../shared/dist/serialization/errors/UnsupportedVersionError.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UnsupportedVersionError = void 0;\r\nvar SerializerError_1 = __webpack_require__(/*! ./SerializerError */ \"../../shared/dist/serialization/errors/SerializerError.js\");\r\nvar UnsupportedVersionError = /** @class */ (function (_super) {\r\n    __extends(UnsupportedVersionError, _super);\r\n    function UnsupportedVersionError(version) {\r\n        var _this = _super.call(this, \"Version \".concat(version.toString(), \" is not supported\")) || this;\r\n        _this.name = 'UnsupportedVersionError';\r\n        Object.setPrototypeOf(_this, UnsupportedVersionError.prototype);\r\n        return _this;\r\n    }\r\n    return UnsupportedVersionError;\r\n}(SerializerError_1.SerializerError));\r\nexports.UnsupportedVersionError = UnsupportedVersionError;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/serialization/errors/UnsupportedVersionError.js?");

/***/ }),

/***/ "../../shared/dist/serialization/index.js":
/*!************************************************!*\
  !*** ../../shared/dist/serialization/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SerializationError = exports.UnsupportedVersionError = exports.InvalidModelError = exports.SerializerError = exports.ModelDefinitionSerializerV1 = exports.BaseModelDefinitionSerializer = exports.SchemaVersion = exports.ModelSerializerFactory = void 0;\r\n// Core exports\r\nvar ModelSerializerFactory_1 = __webpack_require__(/*! ./ModelSerializerFactory */ \"../../shared/dist/serialization/ModelSerializerFactory.js\");\r\nObject.defineProperty(exports, \"ModelSerializerFactory\", ({ enumerable: true, get: function () { return ModelSerializerFactory_1.ModelSerializerFactory; } }));\r\nObject.defineProperty(exports, \"SchemaVersion\", ({ enumerable: true, get: function () { return ModelSerializerFactory_1.SchemaVersion; } }));\r\nvar BaseModelDefinitionSerializer_1 = __webpack_require__(/*! ./BaseModelDefinitionSerializer */ \"../../shared/dist/serialization/BaseModelDefinitionSerializer.js\");\r\nObject.defineProperty(exports, \"BaseModelDefinitionSerializer\", ({ enumerable: true, get: function () { return BaseModelDefinitionSerializer_1.BaseModelDefinitionSerializer; } }));\r\n// V1 Serializer\r\nvar ModelDefinitionSerializerV1_1 = __webpack_require__(/*! ./v1/ModelDefinitionSerializerV1 */ \"../../shared/dist/serialization/v1/ModelDefinitionSerializerV1.js\");\r\nObject.defineProperty(exports, \"ModelDefinitionSerializerV1\", ({ enumerable: true, get: function () { return ModelDefinitionSerializerV1_1.ModelDefinitionSerializerV1; } }));\r\n// Errors\r\nvar SerializerError_1 = __webpack_require__(/*! ./errors/SerializerError */ \"../../shared/dist/serialization/errors/SerializerError.js\");\r\nObject.defineProperty(exports, \"SerializerError\", ({ enumerable: true, get: function () { return SerializerError_1.SerializerError; } }));\r\nvar InvalidModelError_1 = __webpack_require__(/*! ./errors/InvalidModelError */ \"../../shared/dist/serialization/errors/InvalidModelError.js\");\r\nObject.defineProperty(exports, \"InvalidModelError\", ({ enumerable: true, get: function () { return InvalidModelError_1.InvalidModelError; } }));\r\nvar UnsupportedVersionError_1 = __webpack_require__(/*! ./errors/UnsupportedVersionError */ \"../../shared/dist/serialization/errors/UnsupportedVersionError.js\");\r\nObject.defineProperty(exports, \"UnsupportedVersionError\", ({ enumerable: true, get: function () { return UnsupportedVersionError_1.UnsupportedVersionError; } }));\r\nvar SerializationError_1 = __webpack_require__(/*! ./errors/SerializationError */ \"../../shared/dist/serialization/errors/SerializationError.js\");\r\nObject.defineProperty(exports, \"SerializationError\", ({ enumerable: true, get: function () { return SerializationError_1.SerializationError; } }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/serialization/index.js?");

/***/ }),

/***/ "../../shared/dist/serialization/v1/ModelDefinitionSerializerV1.js":
/*!*************************************************************************!*\
  !*** ../../shared/dist/serialization/v1/ModelDefinitionSerializerV1.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelDefinitionSerializerV1 = void 0;\r\nvar BaseModelDefinitionSerializer_1 = __webpack_require__(/*! ../BaseModelDefinitionSerializer */ \"../../shared/dist/serialization/BaseModelDefinitionSerializer.js\");\r\nvar SerializationError_1 = __webpack_require__(/*! ../errors/SerializationError */ \"../../shared/dist/serialization/errors/SerializationError.js\");\r\nvar ModelDefinitionSerializerV1 = /** @class */ (function (_super) {\r\n    __extends(ModelDefinitionSerializerV1, _super);\r\n    function ModelDefinitionSerializerV1() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ModelDefinitionSerializerV1.prototype.getVersion = function () {\r\n        return {\r\n            major: 1,\r\n            minor: 0,\r\n            toString: function () {\r\n                return \"\".concat(this.major, \".\").concat(this.minor);\r\n            }\r\n        };\r\n    };\r\n    ModelDefinitionSerializerV1.prototype.validateV1Specific = function (modelDefinition) {\r\n        // Add any V1-specific validation rules\r\n    };\r\n    ModelDefinitionSerializerV1.prototype.serialize = function (modelDefinition) {\r\n        var _this = this;\r\n        try {\r\n            // Validate the model\r\n            this.validateModel(modelDefinition);\r\n            this.validateV1Specific(modelDefinition);\r\n            var metadata = this.getMetadata();\r\n            return {\r\n                formatVersion: '1.0',\r\n                metadata: metadata,\r\n                model: this.serializeModel(modelDefinition.model),\r\n                entities: modelDefinition.entities.getAll().map(function (entity) {\r\n                    return _this.serializeEntity(entity);\r\n                }),\r\n                activities: modelDefinition.activities.getAll().map(function (activity) {\r\n                    return _this.serializeActivity(activity, modelDefinition);\r\n                }),\r\n                resources: modelDefinition.resources.getAll().map(function (resource) {\r\n                    return _this.serializeResource(resource);\r\n                }),\r\n                generators: modelDefinition.generators.getAll().map(function (generator) {\r\n                    return _this.serializeGenerator(generator, modelDefinition);\r\n                }),\r\n                resourceRequirements: modelDefinition.resourceRequirements.getAll().map(function (requirement) {\r\n                    return _this.serializeResourceRequirement(requirement);\r\n                })\r\n            };\r\n        }\r\n        catch (error) {\r\n            if (error instanceof SerializationError_1.SerializationError) {\r\n                throw error;\r\n            }\r\n            throw new SerializationError_1.SerializationError('Model', 'Failed to serialize model definition', error instanceof Error ? error : undefined);\r\n        }\r\n    };\r\n    return ModelDefinitionSerializerV1;\r\n}(BaseModelDefinitionSerializer_1.BaseModelDefinitionSerializer));\r\nexports.ModelDefinitionSerializerV1 = ModelDefinitionSerializerV1;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/serialization/v1/ModelDefinitionSerializerV1.js?");

/***/ }),

/***/ "../../shared/dist/services/lucidApi.js":
/*!**********************************************!*\
  !*** ../../shared/dist/services/lucidApi.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.createLucidApiService = exports.LucidApiService = void 0;\r\n// src/services/lucidApi.ts\r\nvar axios_1 = __importDefault(__webpack_require__(/*! axios */ \"../../node_modules/axios/dist/browser/axios.cjs\"));\r\nvar LucidApiService = /** @class */ (function () {\r\n    function LucidApiService(baseUrl) {\r\n        if (!baseUrl) {\r\n            throw new Error('baseUrl is required for LucidApiService');\r\n        }\r\n        this.baseURL = baseUrl;\r\n    }\r\n    LucidApiService.prototype.simulateDocument = function (documentId, pageId, userId, authToken) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, headers, response, error_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        url = \"\".concat(this.baseURL, \"Lucid/simulate/\").concat(documentId, \"?pageId=\").concat(pageId, \"&userId=\").concat(userId);\r\n                        headers = {\r\n                            'Accept': 'application/json',\r\n                            'Content-Type': 'application/json'\r\n                        };\r\n                        if (authToken) {\r\n                            headers['Authorization'] = \"Bearer \".concat(authToken);\r\n                        }\r\n                        return [4 /*yield*/, (0, axios_1.default)({\r\n                                method: 'POST',\r\n                                url: url,\r\n                                headers: headers\r\n                            })];\r\n                    case 1:\r\n                        response = _a.sent();\r\n                        if (response.status !== 200) {\r\n                            throw new Error(\"HTTP error! status: \".concat(response.status));\r\n                        }\r\n                        return [2 /*return*/, true];\r\n                    case 2:\r\n                        error_1 = _a.sent();\r\n                        console.error('Error in simulateDocument:', error_1);\r\n                        throw error_1;\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    LucidApiService.prototype.getActivityUtilization = function (documentId, userId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var blobName, url, response, error_2;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        blobName = \"\".concat(userId, \"/activity_utilization.csv\");\r\n                        url = \"\".concat(this.baseURL, \"Lucid/files/\").concat(documentId, \"/\").concat(blobName);\r\n                        return [4 /*yield*/, (0, axios_1.default)({\r\n                                method: 'GET',\r\n                                url: url,\r\n                                responseType: 'text'\r\n                            })];\r\n                    case 1:\r\n                        response = _a.sent();\r\n                        if (response.status !== 200) {\r\n                            throw new Error(\"HTTP error! status: \".concat(response.status));\r\n                        }\r\n                        return [2 /*return*/, response.data];\r\n                    case 2:\r\n                        error_2 = _a.sent();\r\n                        console.error('Error in getActivityUtilization:', error_2);\r\n                        throw error_2;\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    LucidApiService.prototype.getDocumentStatus = function (documentId, authToken) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, headers, response, error_3;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        url = \"\".concat(this.baseURL, \"Lucid/status/\").concat(documentId);\r\n                        headers = {\r\n                            'Accept': 'application/json',\r\n                            'Content-Type': 'application/json'\r\n                        };\r\n                        if (authToken) {\r\n                            headers['Authorization'] = \"Bearer \".concat(authToken);\r\n                        }\r\n                        return [4 /*yield*/, (0, axios_1.default)({\r\n                                method: 'GET',\r\n                                url: url,\r\n                                headers: headers\r\n                            })];\r\n                    case 1:\r\n                        response = _a.sent();\r\n                        if (response.status !== 200) {\r\n                            throw new Error(\"HTTP error! status: \".concat(response.status));\r\n                        }\r\n                        return [2 /*return*/, response.data];\r\n                    case 2:\r\n                        error_3 = _a.sent();\r\n                        console.error('Error in getDocumentStatus:', error_3);\r\n                        throw error_3;\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    LucidApiService.prototype.getSimulationStatus = function (documentId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, response, error_4;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        url = \"\".concat(this.baseURL, \"Lucid/status/\").concat(documentId);\r\n                        return [4 /*yield*/, (0, axios_1.default)({\r\n                                method: 'GET',\r\n                                url: url,\r\n                                headers: {\r\n                                    'Accept': 'application/json'\r\n                                }\r\n                            })];\r\n                    case 1:\r\n                        response = _a.sent();\r\n                        if (response.status !== 200) {\r\n                            throw new Error(\"HTTP error! status: \".concat(response.status));\r\n                        }\r\n                        return [2 /*return*/, response.data];\r\n                    case 2:\r\n                        error_4 = _a.sent();\r\n                        console.error('Error in getSimulationStatus:', error_4);\r\n                        throw error_4;\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return LucidApiService;\r\n}());\r\nexports.LucidApiService = LucidApiService;\r\nfunction createLucidApiService(baseUrl) {\r\n    return new LucidApiService(baseUrl);\r\n}\r\nexports.createLucidApiService = createLucidApiService;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/services/lucidApi.js?");

/***/ }),

/***/ "../../shared/dist/types/ActivityRelationships.js":
/*!********************************************************!*\
  !*** ../../shared/dist/types/ActivityRelationships.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/ActivityRelationships.js?");

/***/ }),

/***/ "../../shared/dist/types/BlockAnalysis.js":
/*!************************************************!*\
  !*** ../../shared/dist/types/BlockAnalysis.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/BlockAnalysis.js?");

/***/ }),

/***/ "../../shared/dist/types/ConversionResult.js":
/*!***************************************************!*\
  !*** ../../shared/dist/types/ConversionResult.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/ConversionResult.js?");

/***/ }),

/***/ "../../shared/dist/types/DiagramElementType.js":
/*!*****************************************************!*\
  !*** ../../shared/dist/types/DiagramElementType.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DiagramElementType = void 0;\r\nvar DiagramElementType;\r\n(function (DiagramElementType) {\r\n    DiagramElementType[\"BLOCK\"] = \"block\";\r\n    DiagramElementType[\"LINE\"] = \"line\";\r\n})(DiagramElementType = exports.DiagramElementType || (exports.DiagramElementType = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/DiagramElementType.js?");

/***/ }),

/***/ "../../shared/dist/types/EditorReferenceData.js":
/*!******************************************************!*\
  !*** ../../shared/dist/types/EditorReferenceData.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/EditorReferenceData.js?");

/***/ }),

/***/ "../../shared/dist/types/MetaData.js":
/*!*******************************************!*\
  !*** ../../shared/dist/types/MetaData.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/MetaData.js?");

/***/ }),

/***/ "../../shared/dist/types/PageStatus.js":
/*!*********************************************!*\
  !*** ../../shared/dist/types/PageStatus.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/PageStatus.js?");

/***/ }),

/***/ "../../shared/dist/types/ProcessAnalysisResult.js":
/*!********************************************************!*\
  !*** ../../shared/dist/types/ProcessAnalysisResult.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/ProcessAnalysisResult.js?");

/***/ }),

/***/ "../../shared/dist/types/SelectionState.js":
/*!*************************************************!*\
  !*** ../../shared/dist/types/SelectionState.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/SelectionState.js?");

/***/ }),

/***/ "../../shared/dist/types/SelectionType.js":
/*!************************************************!*\
  !*** ../../shared/dist/types/SelectionType.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SelectionType = void 0;\r\n/**\r\n * Defines all possible selection types\r\n */\r\nvar SelectionType;\r\n(function (SelectionType) {\r\n    SelectionType[\"NONE\"] = \"none\";\r\n    SelectionType[\"UNCONVERTED_ELEMENT\"] = \"unconverted_element\";\r\n    SelectionType[\"MULTIPLE\"] = \"multiple\";\r\n    SelectionType[\"UNKNOWN_BLOCK\"] = \"unknown_block\";\r\n    SelectionType[\"UNKNOWN_LINE\"] = \"unknown_line\";\r\n    SelectionType[\"ACTIVITY\"] = \"activity\";\r\n    SelectionType[\"CONNECTOR\"] = \"connector\";\r\n    SelectionType[\"ENTITY\"] = \"entity\";\r\n    SelectionType[\"GENERATOR\"] = \"generator\";\r\n    SelectionType[\"RESOURCE\"] = \"resource\";\r\n    SelectionType[\"MODEL\"] = \"model\";\r\n})(SelectionType = exports.SelectionType || (exports.SelectionType = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/SelectionType.js?");

/***/ }),

/***/ "../../shared/dist/types/accordion/AccordionState.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/accordion/AccordionState.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/accordion/AccordionState.js?");

/***/ }),

/***/ "../../shared/dist/types/accordion/ModelElement.js":
/*!*********************************************************!*\
  !*** ../../shared/dist/types/accordion/ModelElement.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/accordion/ModelElement.js?");

/***/ }),

/***/ "../../shared/dist/types/accordion/ModelStructure.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/accordion/ModelStructure.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/accordion/ModelStructure.js?");

/***/ }),

/***/ "../../shared/dist/types/accordion/ValidationState.js":
/*!************************************************************!*\
  !*** ../../shared/dist/types/accordion/ValidationState.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/accordion/ValidationState.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Activity.js":
/*!****************************************************!*\
  !*** ../../shared/dist/types/elements/Activity.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Activity = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar OperationStep_1 = __webpack_require__(/*! ./OperationStep */ \"../../shared/dist/types/elements/OperationStep.js\");\r\nvar Duration_1 = __webpack_require__(/*! ./Duration */ \"../../shared/dist/types/elements/Duration.js\");\r\nvar PeriodUnit_1 = __webpack_require__(/*! ./PeriodUnit */ \"../../shared/dist/types/elements/PeriodUnit.js\");\r\nvar DurationType_1 = __webpack_require__(/*! ./DurationType */ \"../../shared/dist/types/elements/DurationType.js\");\r\nvar Activity = /** @class */ (function () {\r\n    function Activity(id, name, capacity, inputBufferCapacity, outputBufferCapacity, operationSteps) {\r\n        if (capacity === void 0) { capacity = 1; }\r\n        if (inputBufferCapacity === void 0) { inputBufferCapacity = 1; }\r\n        if (outputBufferCapacity === void 0) { outputBufferCapacity = 1; }\r\n        if (operationSteps === void 0) { operationSteps = []; }\r\n        this.id = id;\r\n        this.name = name;\r\n        this.capacity = capacity;\r\n        this.inputBufferCapacity = inputBufferCapacity;\r\n        this.outputBufferCapacity = outputBufferCapacity;\r\n        this.operationSteps = operationSteps;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Activity;\r\n    }\r\n    Activity.createDefault = function (id) {\r\n        var defaultDuration = new Duration_1.Duration(1, PeriodUnit_1.PeriodUnit.MINUTES, DurationType_1.DurationType.CONSTANT);\r\n        var defaultOperationStep = (0, OperationStep_1.createOperationStep)(defaultDuration);\r\n        return new Activity(id, 'New Activity', 1, // capacity\r\n        1, // inputBufferCapacity\r\n        1, // outputBufferCapacity\r\n        [defaultOperationStep]);\r\n    };\r\n    return Activity;\r\n}());\r\nexports.Activity = Activity;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/Activity.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ActivityListManager.js":
/*!***************************************************************!*\
  !*** ../../shared/dist/types/elements/ActivityListManager.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ActivityListManager = void 0;\r\nvar ComponentListManager_1 = __webpack_require__(/*! ./ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\");\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar ActivityListManager = /** @class */ (function (_super) {\r\n    __extends(ActivityListManager, _super);\r\n    function ActivityListManager() {\r\n        return _super.call(this, SimulationObjectType_1.SimulationObjectType.Activity) || this;\r\n    }\r\n    return ActivityListManager;\r\n}(ComponentListManager_1.ComponentListManager));\r\nexports.ActivityListManager = ActivityListManager;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ActivityListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ComponentListManager.js":
/*!****************************************************************!*\
  !*** ../../shared/dist/types/elements/ComponentListManager.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ComponentListManager = void 0;\r\nvar ComponentListManager = /** @class */ (function () {\r\n    function ComponentListManager(type) {\r\n        this.items = new Map();\r\n        this.type = type;\r\n    }\r\n    ComponentListManager.prototype.getNextName = function () {\r\n        return \"\".concat(this.type, \" \").concat(this.items.size + 1);\r\n    };\r\n    ComponentListManager.prototype.add = function (item) {\r\n        this.items.set(item.id, item);\r\n    };\r\n    ComponentListManager.prototype.remove = function (id) {\r\n        this.items.delete(id);\r\n    };\r\n    ComponentListManager.prototype.get = function (id) {\r\n        return this.items.get(id);\r\n    };\r\n    ComponentListManager.prototype.getAll = function () {\r\n        return Array.from(this.items.values());\r\n    };\r\n    ComponentListManager.prototype.clear = function () {\r\n        this.items.clear();\r\n    };\r\n    ComponentListManager.prototype.size = function () {\r\n        return this.items.size;\r\n    };\r\n    return ComponentListManager;\r\n}());\r\nexports.ComponentListManager = ComponentListManager;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ComponentListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ConnectType.js":
/*!*******************************************************!*\
  !*** ../../shared/dist/types/elements/ConnectType.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ConnectTypeUtils = exports.ConnectType = void 0;\r\n// connectType.ts\r\nvar ConnectType;\r\n(function (ConnectType) {\r\n    ConnectType[\"Probability\"] = \"Probability\";\r\n    ConnectType[\"AttributeValue\"] = \"AttributeValue\";\r\n})(ConnectType = exports.ConnectType || (exports.ConnectType = {}));\r\nvar ConnectTypeUtils = /** @class */ (function () {\r\n    function ConnectTypeUtils() {\r\n    }\r\n    ConnectTypeUtils.stringToConnectRule = function (inputStr) {\r\n        // Normalize the input string to lower case to make the matching case-insensitive\r\n        var normalizedStr = inputStr.toLowerCase();\r\n        // Define a mapping of string representations to ConnectType values\r\n        var stringToEnumMapping = {\r\n            \"percentage\": ConnectType.Probability,\r\n            \"attributevalue\": ConnectType.AttributeValue\r\n        };\r\n        // Look up the normalized string in the mapping and return the corresponding ConnectType value\r\n        // If the input string doesn't match any key in the mapping, throw an Error\r\n        if (normalizedStr in stringToEnumMapping) {\r\n            return stringToEnumMapping[normalizedStr];\r\n        }\r\n        else {\r\n            throw new Error(\"Unknown ConnectType: '\".concat(inputStr, \"'\"));\r\n        }\r\n    };\r\n    return ConnectTypeUtils;\r\n}());\r\nexports.ConnectTypeUtils = ConnectTypeUtils;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ConnectType.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Connector.js":
/*!*****************************************************!*\
  !*** ../../shared/dist/types/elements/Connector.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Connector = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar ConnectType_1 = __webpack_require__(/*! ./ConnectType */ \"../../shared/dist/types/elements/ConnectType.js\");\r\nvar Connector = /** @class */ (function () {\r\n    function Connector(id, name, sourceId, targetId, probability, connectType, operationSteps) {\r\n        if (probability === void 0) { probability = 1.0; }\r\n        if (connectType === void 0) { connectType = ConnectType_1.ConnectType.Probability; }\r\n        if (operationSteps === void 0) { operationSteps = []; }\r\n        this.id = id;\r\n        this.name = name;\r\n        this.sourceId = sourceId;\r\n        this.targetId = targetId;\r\n        this.probability = probability;\r\n        this.connectType = connectType;\r\n        this.operationSteps = operationSteps;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Connector;\r\n    }\r\n    Connector.createDefault = function (id) {\r\n        return new Connector(id, 'New Connector', '', // sourceId\r\n        '', // targetId\r\n        1.0, // probability\r\n        ConnectType_1.ConnectType.Probability, // connectType\r\n        [] // operationSteps\r\n        );\r\n    };\r\n    return Connector;\r\n}());\r\nexports.Connector = Connector;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/Connector.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ConnectorListManager.js":
/*!****************************************************************!*\
  !*** ../../shared/dist/types/elements/ConnectorListManager.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ConnectorListManager = void 0;\r\nvar ComponentListManager_1 = __webpack_require__(/*! ./ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\");\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar ConnectorListManager = /** @class */ (function (_super) {\r\n    __extends(ConnectorListManager, _super);\r\n    function ConnectorListManager() {\r\n        return _super.call(this, SimulationObjectType_1.SimulationObjectType.Connector) || this;\r\n    }\r\n    return ConnectorListManager;\r\n}(ComponentListManager_1.ComponentListManager));\r\nexports.ConnectorListManager = ConnectorListManager;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ConnectorListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Distribution.js":
/*!********************************************************!*\
  !*** ../../shared/dist/types/elements/Distribution.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Distribution = void 0;\r\nvar Distribution = /** @class */ (function () {\r\n    function Distribution(distributionType, parameters, description) {\r\n        if (description === void 0) { description = \"\"; }\r\n        this.distributionType = distributionType;\r\n        this.parameters = parameters;\r\n        this.description = description;\r\n    }\r\n    return Distribution;\r\n}());\r\nexports.Distribution = Distribution;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/Distribution.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/DistributionType.js":
/*!************************************************************!*\
  !*** ../../shared/dist/types/elements/DistributionType.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DistributionType = void 0;\r\nvar DistributionType;\r\n(function (DistributionType) {\r\n    DistributionType[\"MULTINOMIAL\"] = \"multinomial\";\r\n    DistributionType[\"UNIFORM\"] = \"uniform\";\r\n    DistributionType[\"TRIANGULAR\"] = \"triangular\";\r\n    DistributionType[\"EXPONENTIAL\"] = \"exponential\";\r\n    DistributionType[\"NORMAL\"] = \"normal\";\r\n    DistributionType[\"LOGNORMAL\"] = \"lognormal\";\r\n    DistributionType[\"BETA\"] = \"beta\";\r\n    DistributionType[\"GAMMA\"] = \"gamma\";\r\n    DistributionType[\"WEIBULL\"] = \"weibull\";\r\n    DistributionType[\"DISCRETE\"] = \"discrete\";\r\n    DistributionType[\"POISSON\"] = \"poisson\";\r\n    DistributionType[\"BINOMIAL\"] = \"binomial\";\r\n    DistributionType[\"BERNOULLI\"] = \"bernoulli\";\r\n    DistributionType[\"GEOMETRIC\"] = \"geometric\";\r\n    DistributionType[\"NEGATIVE_BINOMIAL\"] = \"negative_binomial\";\r\n    DistributionType[\"SAMPLE_MULTINOMIAL\"] = \"sample_multinomial\";\r\n    DistributionType[\"SAMPLE_MULTINOMIAL_ONE\"] = \"sample_multinomial_one\";\r\n    DistributionType[\"PROBABILITY_VALUES\"] = \"probability_values\";\r\n    DistributionType[\"SAMPLE_NEXT_SERVICE_INDEX\"] = \"sample_next_service_index\";\r\n    DistributionType[\"CHI_SQUARE\"] = \"chisquare\";\r\n    DistributionType[\"F_DISTRIBUTION\"] = \"f_distribution\";\r\n    DistributionType[\"HYPERGEOMETRIC\"] = \"hypergeometric\";\r\n    DistributionType[\"LAPLACE\"] = \"laplace\";\r\n    DistributionType[\"LOGISTIC\"] = \"logistic\";\r\n    DistributionType[\"LOG_SERIES\"] = \"logseries\";\r\n    DistributionType[\"PARETO\"] = \"pareto\";\r\n    DistributionType[\"RAYLEIGH\"] = \"rayleigh\";\r\n    DistributionType[\"T_DISTRIBUTION\"] = \"t_distribution\";\r\n    DistributionType[\"VON_MISES\"] = \"vonmises\";\r\n    DistributionType[\"WALD\"] = \"wald\";\r\n    DistributionType[\"ZIPF\"] = \"zipf\";\r\n})(DistributionType = exports.DistributionType || (exports.DistributionType = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/DistributionType.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Duration.js":
/*!****************************************************!*\
  !*** ../../shared/dist/types/elements/Duration.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Duration = void 0;\r\nvar PeriodUnit_1 = __webpack_require__(/*! ./PeriodUnit */ \"../../shared/dist/types/elements/PeriodUnit.js\");\r\nvar DurationType_1 = __webpack_require__(/*! ./DurationType */ \"../../shared/dist/types/elements/DurationType.js\");\r\nvar Duration = /** @class */ (function () {\r\n    function Duration(durationLength, durationPeriodUnit, durationType, distribution) {\r\n        if (durationLength === void 0) { durationLength = 0.0; }\r\n        if (durationPeriodUnit === void 0) { durationPeriodUnit = PeriodUnit_1.PeriodUnit.MINUTES; }\r\n        if (durationType === void 0) { durationType = DurationType_1.DurationType.CONSTANT; }\r\n        if (distribution === void 0) { distribution = null; }\r\n        this.durationLength = durationLength;\r\n        this.durationPeriodUnit = durationPeriodUnit;\r\n        this.durationType = durationType;\r\n        this.distribution = distribution;\r\n    }\r\n    return Duration;\r\n}());\r\nexports.Duration = Duration;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/Duration.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/DurationType.js":
/*!********************************************************!*\
  !*** ../../shared/dist/types/elements/DurationType.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DurationType = void 0;\r\nvar DurationType;\r\n(function (DurationType) {\r\n    DurationType[\"CONSTANT\"] = \"CONSTANT\";\r\n    DurationType[\"DISTRIBUTION\"] = \"DISTRIBUTION\";\r\n})(DurationType = exports.DurationType || (exports.DurationType = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/DurationType.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Entity.js":
/*!**************************************************!*\
  !*** ../../shared/dist/types/elements/Entity.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Entity = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar Entity = /** @class */ (function () {\r\n    function Entity(id, name) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Entity;\r\n    }\r\n    Entity.createDefault = function (id) {\r\n        return new Entity(id, 'New Entity');\r\n    };\r\n    return Entity;\r\n}());\r\nexports.Entity = Entity;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/Entity.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/EntityListManager.js":
/*!*************************************************************!*\
  !*** ../../shared/dist/types/elements/EntityListManager.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EntityListManager = void 0;\r\nvar ComponentListManager_1 = __webpack_require__(/*! ./ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\");\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar EntityListManager = /** @class */ (function (_super) {\r\n    __extends(EntityListManager, _super);\r\n    function EntityListManager() {\r\n        return _super.call(this, SimulationObjectType_1.SimulationObjectType.Entity) || this;\r\n    }\r\n    return EntityListManager;\r\n}(ComponentListManager_1.ComponentListManager));\r\nexports.EntityListManager = EntityListManager;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/EntityListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Experiment.js":
/*!******************************************************!*\
  !*** ../../shared/dist/types/elements/Experiment.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/Experiment.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Generator.js":
/*!*****************************************************!*\
  !*** ../../shared/dist/types/elements/Generator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Generator = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar Duration_1 = __webpack_require__(/*! ./Duration */ \"../../shared/dist/types/elements/Duration.js\");\r\nvar ModelDefaults_1 = __webpack_require__(/*! ./ModelDefaults */ \"../../shared/dist/types/elements/ModelDefaults.js\");\r\nvar PeriodUnit_1 = __webpack_require__(/*! ./PeriodUnit */ \"../../shared/dist/types/elements/PeriodUnit.js\");\r\nvar DurationType_1 = __webpack_require__(/*! ./DurationType */ \"../../shared/dist/types/elements/DurationType.js\");\r\nvar Generator = /** @class */ (function () {\r\n    function Generator(id, name, activityKeyId, entityId, periodicOccurrences, periodIntervalDuration, entitiesPerCreation, periodicStartDuration, maxEntities) {\r\n        if (activityKeyId === void 0) { activityKeyId = \"\"; }\r\n        if (entityId === void 0) { entityId = ModelDefaults_1.ModelDefaults.DEFAULT_ENTITY_ID; }\r\n        if (periodicOccurrences === void 0) { periodicOccurrences = Infinity; }\r\n        if (periodIntervalDuration === void 0) { periodIntervalDuration = new Duration_1.Duration(); }\r\n        if (entitiesPerCreation === void 0) { entitiesPerCreation = 1; }\r\n        if (periodicStartDuration === void 0) { periodicStartDuration = new Duration_1.Duration(); }\r\n        if (maxEntities === void 0) { maxEntities = Infinity; }\r\n        this.id = id;\r\n        this.name = name;\r\n        this.activityKeyId = activityKeyId;\r\n        this.entityId = entityId;\r\n        this.periodicOccurrences = periodicOccurrences;\r\n        this.periodIntervalDuration = periodIntervalDuration;\r\n        this.entitiesPerCreation = entitiesPerCreation;\r\n        this.periodicStartDuration = periodicStartDuration;\r\n        this.maxEntities = maxEntities;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Generator;\r\n    }\r\n    Generator.createDefault = function (id) {\r\n        return new Generator(id, 'New Generator', '{SomeActivityName}', ModelDefaults_1.ModelDefaults.DEFAULT_ENTITY_ID, 10, // periodicOccurrences\r\n        new Duration_1.Duration(1, PeriodUnit_1.PeriodUnit.HOURS, DurationType_1.DurationType.CONSTANT), // periodIntervalDuration\r\n        1, // entitiesPerCreation\r\n        new Duration_1.Duration(0, PeriodUnit_1.PeriodUnit.HOURS, DurationType_1.DurationType.CONSTANT), // periodicStartDuration\r\n        999 // maxEntities\r\n        );\r\n    };\r\n    return Generator;\r\n}());\r\nexports.Generator = Generator;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/Generator.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/GeneratorListManager.js":
/*!****************************************************************!*\
  !*** ../../shared/dist/types/elements/GeneratorListManager.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GeneratorListManager = void 0;\r\nvar ComponentListManager_1 = __webpack_require__(/*! ./ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\");\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar GeneratorListManager = /** @class */ (function (_super) {\r\n    __extends(GeneratorListManager, _super);\r\n    function GeneratorListManager() {\r\n        return _super.call(this, SimulationObjectType_1.SimulationObjectType.Generator) || this;\r\n    }\r\n    return GeneratorListManager;\r\n}(ComponentListManager_1.ComponentListManager));\r\nexports.GeneratorListManager = GeneratorListManager;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/GeneratorListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Model.js":
/*!*************************************************!*\
  !*** ../../shared/dist/types/elements/Model.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Model = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar PeriodUnit_1 = __webpack_require__(/*! ./PeriodUnit */ \"../../shared/dist/types/elements/PeriodUnit.js\");\r\nvar SimulationTimeType_1 = __webpack_require__(/*! ./SimulationTimeType */ \"../../shared/dist/types/elements/SimulationTimeType.js\");\r\nvar ModelDefaults_1 = __webpack_require__(/*! ./ModelDefaults */ \"../../shared/dist/types/elements/ModelDefaults.js\");\r\nvar Model = /** @class */ (function () {\r\n    function Model(id, name, reps, forecastDays, seed, oneClockUnit, simulationTimeType, warmupClockPeriod, warmupClockPeriodUnit, runClockPeriod, runClockPeriodUnit, warmupDateTime, startDateTime, finishDateTime) {\r\n        if (warmupDateTime === void 0) { warmupDateTime = null; }\r\n        if (startDateTime === void 0) { startDateTime = null; }\r\n        if (finishDateTime === void 0) { finishDateTime = null; }\r\n        this.id = id;\r\n        this.name = name;\r\n        this.reps = reps;\r\n        this.forecastDays = forecastDays;\r\n        this.seed = seed;\r\n        this.oneClockUnit = oneClockUnit;\r\n        this.simulationTimeType = simulationTimeType;\r\n        this.warmupClockPeriod = warmupClockPeriod;\r\n        this.warmupClockPeriodUnit = warmupClockPeriodUnit;\r\n        this.runClockPeriod = runClockPeriod;\r\n        this.runClockPeriodUnit = runClockPeriodUnit;\r\n        this.warmupDateTime = warmupDateTime;\r\n        this.startDateTime = startDateTime;\r\n        this.finishDateTime = finishDateTime;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Model;\r\n    }\r\n    Model.createDefault = function (id) {\r\n        return new Model(id, //id\r\n        'New Model', //name\r\n        ModelDefaults_1.ModelDefaults.DEFAULT_REPS, //reps\r\n        ModelDefaults_1.ModelDefaults.DEFAULT_FORECAST_DAYS, //forecast\r\n        ModelDefaults_1.ModelDefaults.DEFAULT_SEED, //seed\r\n        ModelDefaults_1.ModelDefaults.DEFAULT_CLOCK_UNIT, //oneClockUnit\r\n        SimulationTimeType_1.SimulationTimeType.Clock, //oneClockUnit\r\n        0, //simulationTimeType\r\n        PeriodUnit_1.PeriodUnit.HOURS, //warmupClockPeriod\r\n        24, //runClockPeriod\r\n        PeriodUnit_1.PeriodUnit.HOURS, //runClockPeriodUnit\r\n        null, // warmupDateTime\r\n        null, // startDateTime\r\n        null // finishDateTime\r\n        );\r\n    };\r\n    return Model;\r\n}());\r\nexports.Model = Model;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/Model.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ModelDefaults.js":
/*!*********************************************************!*\
  !*** ../../shared/dist/types/elements/ModelDefaults.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelDefaults = void 0;\r\nvar PeriodUnit_1 = __webpack_require__(/*! ./PeriodUnit */ \"../../shared/dist/types/elements/PeriodUnit.js\");\r\nvar SimulationTimeType_1 = __webpack_require__(/*! ./SimulationTimeType */ \"../../shared/dist/types/elements/SimulationTimeType.js\");\r\nvar ModelDefaults;\r\n(function (ModelDefaults) {\r\n    ModelDefaults.DEFAULT_SEED = 12345;\r\n    ModelDefaults.DEFAULT_CLOCK_UNIT = PeriodUnit_1.PeriodUnit.MINUTES;\r\n    ModelDefaults.DEFAULT_SIMULATION_TIME_TYPE = SimulationTimeType_1.SimulationTimeType.Clock;\r\n    ModelDefaults.DEFAULT_WARMUP_PERIOD = 0.0;\r\n    ModelDefaults.DEFAULT_RUN_PERIOD = 0.0;\r\n    ModelDefaults.DEFAULT_REPS = 1;\r\n    ModelDefaults.DEFAULT_FORECAST_DAYS = 30;\r\n    ModelDefaults.DEFAULT_ENTITY_ID = \"00000000-0000-0000-0000-000000000000\";\r\n    ModelDefaults.DEFAULT_ENTITY_NAME = \"Default Entity\";\r\n})(ModelDefaults = exports.ModelDefaults || (exports.ModelDefaults = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ModelDefaults.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ModelDefinition.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/elements/ModelDefinition.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelDefinition = void 0;\r\nvar ActivityListManager_1 = __webpack_require__(/*! ./ActivityListManager */ \"../../shared/dist/types/elements/ActivityListManager.js\");\r\nvar ConnectorListManager_1 = __webpack_require__(/*! ./ConnectorListManager */ \"../../shared/dist/types/elements/ConnectorListManager.js\");\r\nvar Entity_1 = __webpack_require__(/*! ./Entity */ \"../../shared/dist/types/elements/Entity.js\");\r\nvar EntityListManager_1 = __webpack_require__(/*! ./EntityListManager */ \"../../shared/dist/types/elements/EntityListManager.js\");\r\nvar GeneratorListManager_1 = __webpack_require__(/*! ./GeneratorListManager */ \"../../shared/dist/types/elements/GeneratorListManager.js\");\r\nvar ModelDefaults_1 = __webpack_require__(/*! ./ModelDefaults */ \"../../shared/dist/types/elements/ModelDefaults.js\");\r\nvar ResourceListManager_1 = __webpack_require__(/*! ./ResourceListManager */ \"../../shared/dist/types/elements/ResourceListManager.js\");\r\nvar ResourceRequirementListManager_1 = __webpack_require__(/*! ./ResourceRequirementListManager */ \"../../shared/dist/types/elements/ResourceRequirementListManager.js\");\r\nvar ModelDefinition = /** @class */ (function () {\r\n    function ModelDefinition(model) {\r\n        this.model = model;\r\n        this.activities = new ActivityListManager_1.ActivityListManager();\r\n        this.connectors = new ConnectorListManager_1.ConnectorListManager();\r\n        this.resources = new ResourceListManager_1.ResourceListManager();\r\n        this.resourceRequirements = new ResourceRequirementListManager_1.ResourceRequirementListManager();\r\n        this.generators = new GeneratorListManager_1.GeneratorListManager();\r\n        this.entities = new EntityListManager_1.EntityListManager();\r\n        // Add default entity\r\n        var defaultEntity = new Entity_1.Entity(ModelDefaults_1.ModelDefaults.DEFAULT_ENTITY_ID, ModelDefaults_1.ModelDefaults.DEFAULT_ENTITY_NAME);\r\n        this.entities.add(defaultEntity);\r\n    }\r\n    Object.defineProperty(ModelDefinition.prototype, \"id\", {\r\n        get: function () { return this.model.id; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ModelDefinition.prototype, \"name\", {\r\n        get: function () { return this.model.name; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return ModelDefinition;\r\n}());\r\nexports.ModelDefinition = ModelDefinition;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ModelDefinition.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ModelDefinitionLogger.js":
/*!*****************************************************************!*\
  !*** ../../shared/dist/types/elements/ModelDefinitionLogger.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelDefinitionLogger = void 0;\r\nvar QuodsiLogger_1 = __webpack_require__(/*! ../../core/logging/QuodsiLogger */ \"../../shared/dist/core/logging/QuodsiLogger.js\");\r\nvar ModelDefinitionLogger = /** @class */ (function (_super) {\r\n    __extends(ModelDefinitionLogger, _super);\r\n    function ModelDefinitionLogger() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.LOG_PREFIX = '[ModelDefinitionLogger]';\r\n        return _this;\r\n    }\r\n    ModelDefinitionLogger.logModelDefinition = function (modelDefinition) {\r\n        var logger = new ModelDefinitionLogger();\r\n        logger.setLogging(false);\r\n        logger.logDefinition(modelDefinition);\r\n    };\r\n    ModelDefinitionLogger.prototype.logDefinition = function (modelDefinition) {\r\n        this.log(\"\\nLogging Model Definition:\");\r\n        try {\r\n            // Log basic model details\r\n            this.log(\"Model ID: \".concat(modelDefinition.id));\r\n            this.log(\"Model Name: \".concat(modelDefinition.name));\r\n            this.logActivities(modelDefinition);\r\n            this.logConnectors(modelDefinition);\r\n            this.logResources(modelDefinition);\r\n            this.logGenerators(modelDefinition);\r\n            this.logEntities(modelDefinition);\r\n        }\r\n        catch (error) {\r\n            this.logError(\"An error occurred while logging the model definition:\", error);\r\n        }\r\n    };\r\n    ModelDefinitionLogger.prototype.logActivities = function (modelDefinition) {\r\n        var _this = this;\r\n        this.log(\"\\nActivities:\");\r\n        var activities = modelDefinition.activities.getAll();\r\n        activities.forEach(function (activity) { return _this.safeExecute(function () { return _this.logActivity(activity); }, \"Activity ID: \".concat(activity === null || activity === void 0 ? void 0 : activity.id)); });\r\n    };\r\n    ModelDefinitionLogger.prototype.logConnectors = function (modelDefinition) {\r\n        var _this = this;\r\n        this.log(\"\\nConnectors:\");\r\n        var connectors = modelDefinition.connectors.getAll();\r\n        connectors.forEach(function (connector) { return _this.safeExecute(function () { return _this.logConnector(connector); }, \"Connector ID: \".concat(connector === null || connector === void 0 ? void 0 : connector.id)); });\r\n    };\r\n    ModelDefinitionLogger.prototype.logResources = function (modelDefinition) {\r\n        var _this = this;\r\n        this.log(\"\\nResources:\");\r\n        var resources = modelDefinition.resources.getAll();\r\n        resources.forEach(function (resource) { return _this.safeExecute(function () { return _this.logResource(resource); }, \"Resource ID: \".concat(resource === null || resource === void 0 ? void 0 : resource.id)); });\r\n    };\r\n    ModelDefinitionLogger.prototype.logResourceRequirements = function (modelDefinition) {\r\n        var _this = this;\r\n        this.log(\"\\ResourceRequirement:\");\r\n        var requirements = modelDefinition.resourceRequirements.getAll();\r\n        requirements.forEach(function (requirement) { return _this.safeExecute(function () { return _this.logResourceRequirement(requirement); }, \"Resource ID: \".concat(requirement === null || requirement === void 0 ? void 0 : requirement.id)); });\r\n    };\r\n    ModelDefinitionLogger.prototype.logGenerators = function (modelDefinition) {\r\n        var _this = this;\r\n        this.log(\"\\nGenerators:\");\r\n        var generators = modelDefinition.generators.getAll();\r\n        generators.forEach(function (generator) { return _this.safeExecute(function () { return _this.logGenerator(generator); }, \"Generator ID: \".concat(generator === null || generator === void 0 ? void 0 : generator.id)); });\r\n    };\r\n    ModelDefinitionLogger.prototype.logEntities = function (modelDefinition) {\r\n        var _this = this;\r\n        this.log(\"\\nEntities:\");\r\n        var entities = modelDefinition.entities.getAll();\r\n        entities.forEach(function (entity) { return _this.safeExecute(function () { return _this.logEntity(entity); }, \"Entity ID: \".concat(entity === null || entity === void 0 ? void 0 : entity.id)); });\r\n    };\r\n    ModelDefinitionLogger.prototype.safeExecute = function (action, context) {\r\n        try {\r\n            action();\r\n        }\r\n        catch (error) {\r\n            this.logError(\"Failed to log \".concat(context, \":\"), error);\r\n        }\r\n    };\r\n    ModelDefinitionLogger.prototype.logActivity = function (activity) {\r\n        var _this = this;\r\n        var _a, _b;\r\n        this.log(\"  Activity ID: \".concat(activity.id));\r\n        this.log(\"    Name: \".concat(activity.name));\r\n        this.log(\"    Capacity: \".concat(activity.capacity));\r\n        this.log(\"    Input Buffer Capacity: \".concat(activity.inputBufferCapacity));\r\n        this.log(\"    Output Buffer Capacity: \".concat(activity.outputBufferCapacity));\r\n        this.log(\"    Number of Operation Steps: \".concat(((_a = activity.operationSteps) === null || _a === void 0 ? void 0 : _a.length) || 0));\r\n        (_b = activity.operationSteps) === null || _b === void 0 ? void 0 : _b.forEach(function (step, index) {\r\n            var _a;\r\n            _this.log(\"      Operation Step \".concat(index + 1, \":\"));\r\n            _this.log(\"        Duration: \".concat(((_a = step.duration) === null || _a === void 0 ? void 0 : _a.durationLength) || \"Not defined\"));\r\n            if (step.requirementId) {\r\n                _this.log(\"        Resource Requirement ID: \".concat(step.requirementId));\r\n                _this.log(\"        Quantity: \".concat(step.quantity));\r\n                // If you need to log the actual resource requests, you'll need to pass\r\n                // the ResourceRequirement data to this method or have a way to look it up\r\n                /* Example if you had access to requirements:\r\n                const requirement = this.getRequirement(step.requirementId);\r\n                if (requirement) {\r\n                    this.log(`        Requirement Mode: ${requirement.mode}`);\r\n                    this.log(\"        Resource Requests:\");\r\n                    requirement.requests.forEach(request => {\r\n                        this.log(`          Resource ID: ${request.resourceId}, ` +\r\n                                `Quantity: ${request.quantity}, ` +\r\n                                `Priority: ${request.priority}, ` +\r\n                                `Keep Resource: ${request.keepResource}`);\r\n                    });\r\n                }\r\n                */\r\n            }\r\n        });\r\n    };\r\n    ModelDefinitionLogger.prototype.logConnector = function (connector) {\r\n        var _this = this;\r\n        this.log(\"  Connector ID: \".concat(connector.id));\r\n        this.log(\"    Name: \".concat(connector.name || \"Unnamed\"));\r\n        this.log(\"    Source ID: \".concat(connector.sourceId || \"Not defined\"));\r\n        this.log(\"    Target ID: \".concat(connector.targetId || \"Not defined\"));\r\n        this.log(\"    Probability: \".concat(connector.probability !== undefined ? connector.probability : \"Not defined\"));\r\n        this.log(\"    Connection Type: \".concat(connector.connectType || \"Not defined\"));\r\n        var operationSteps = connector.operationSteps;\r\n        this.log(\"    Number of Operation Steps: \".concat((operationSteps === null || operationSteps === void 0 ? void 0 : operationSteps.length) || 0));\r\n        operationSteps === null || operationSteps === void 0 ? void 0 : operationSteps.forEach(function (step, index) {\r\n            var _a;\r\n            _this.log(\"      Operation Step \".concat(index + 1, \":\"));\r\n            _this.log(\"        Duration: \".concat(((_a = step.duration) === null || _a === void 0 ? void 0 : _a.durationLength) || \"Not defined\"));\r\n            if (step.requirementId) {\r\n                _this.log(\"        Resource Requirement ID: \".concat(step.requirementId));\r\n                _this.log(\"        Quantity: \".concat(step.quantity));\r\n            }\r\n        });\r\n    };\r\n    ModelDefinitionLogger.prototype.logResource = function (resource) {\r\n        this.log(\"  Resource ID: \".concat(resource.id));\r\n        this.log(\"    Name: \".concat(resource.name));\r\n        this.log(\"    Capacity: \".concat(resource.capacity));\r\n    };\r\n    ModelDefinitionLogger.prototype.logResourceRequirement = function (resourceRequirement) {\r\n        this.log(\"  Resource ID: \".concat(resourceRequirement.id));\r\n        this.log(\"    Name: \".concat(resourceRequirement.name));\r\n        // this.log(`    Mode: ${resourceRequirement.mode}`);\r\n    };\r\n    ModelDefinitionLogger.prototype.logGenerator = function (generator) {\r\n        var _a, _b;\r\n        this.log(\"  Generator ID: \".concat(generator.id));\r\n        this.log(\"    Name: \".concat(generator.name || \"Unnamed\"));\r\n        this.log(\"    Activity Key ID: \".concat(generator.activityKeyId || \"Not defined\"));\r\n        this.log(\"    Entity ID: \".concat(generator.entityId || \"Not defined\"));\r\n        this.log(\"    Periodic Occurrences: \".concat(generator.periodicOccurrences || \"Not defined\"));\r\n        var periodIntervalDuration = (_a = generator.periodIntervalDuration) === null || _a === void 0 ? void 0 : _a.durationLength;\r\n        this.log(\"    Period Interval Duration: \".concat(periodIntervalDuration !== undefined ? periodIntervalDuration : \"Not defined\"));\r\n        this.log(\"    Entities Per Creation: \".concat(generator.entitiesPerCreation || \"Not defined\"));\r\n        var periodicStartDuration = (_b = generator.periodicStartDuration) === null || _b === void 0 ? void 0 : _b.durationLength;\r\n        this.log(\"    Periodic Start Duration: \".concat(periodicStartDuration !== undefined ? periodicStartDuration : \"Not defined\"));\r\n        this.log(\"    Max Entities: \".concat(generator.maxEntities || \"Not defined\"));\r\n    };\r\n    ModelDefinitionLogger.prototype.logEntity = function (entity) {\r\n        this.log(\"  Entity ID: \".concat(entity.id));\r\n        this.log(\"    Name: \".concat(entity.name));\r\n    };\r\n    return ModelDefinitionLogger;\r\n}(QuodsiLogger_1.QuodsiLogger));\r\nexports.ModelDefinitionLogger = ModelDefinitionLogger;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ModelDefinitionLogger.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ModelUtils.js":
/*!******************************************************!*\
  !*** ../../shared/dist/types/elements/ModelUtils.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelUtils = void 0;\r\nvar SimulationTimeType_1 = __webpack_require__(/*! ./SimulationTimeType */ \"../../shared/dist/types/elements/SimulationTimeType.js\");\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar ModelDefaults_1 = __webpack_require__(/*! ./ModelDefaults */ \"../../shared/dist/types/elements/ModelDefaults.js\");\r\nvar ModelUtils = /** @class */ (function () {\r\n    function ModelUtils() {\r\n    }\r\n    /**\r\n     * Generates a UUID for the model\r\n     */\r\n    ModelUtils.generateUUID = function () {\r\n        var _a;\r\n        try {\r\n            // Check if we're in a browser environment and have crypto support\r\n            if (typeof window !== 'undefined' && ((_a = window === null || window === void 0 ? void 0 : window.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID)) {\r\n                return window.crypto.randomUUID();\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Silently fall through to fallback\r\n        }\r\n        // Fallback implementation\r\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n            var r = Math.random() * 16 | 0;\r\n            var v = c === 'x' ? r : (r & 0x3 | 0x8);\r\n            return v.toString(16);\r\n        });\r\n    };\r\n    /**\r\n     * Creates a new default model instance with a UUID\r\n     */\r\n    ModelUtils.createNew = function (name) {\r\n        if (name === void 0) { name = 'New Model'; }\r\n        return ModelUtils.createWithDefaults({\r\n            name: name\r\n            // Remove id generation - it will be set by the caller\r\n        });\r\n    };\r\n    /**\r\n     * Creates a complete Model object with default values for all optional fields\r\n     */\r\n    ModelUtils.createWithDefaults = function (partialModel) {\r\n        var defaults = {\r\n            id: partialModel.id,\r\n            name: partialModel.name || 'New Model',\r\n            type: SimulationObjectType_1.SimulationObjectType.Model,\r\n            reps: ModelDefaults_1.ModelDefaults.DEFAULT_REPS,\r\n            forecastDays: ModelDefaults_1.ModelDefaults.DEFAULT_FORECAST_DAYS,\r\n            seed: ModelDefaults_1.ModelDefaults.DEFAULT_SEED,\r\n            oneClockUnit: ModelDefaults_1.ModelDefaults.DEFAULT_CLOCK_UNIT,\r\n            simulationTimeType: ModelDefaults_1.ModelDefaults.DEFAULT_SIMULATION_TIME_TYPE,\r\n            warmupClockPeriod: ModelDefaults_1.ModelDefaults.DEFAULT_WARMUP_PERIOD,\r\n            warmupClockPeriodUnit: ModelDefaults_1.ModelDefaults.DEFAULT_CLOCK_UNIT,\r\n            runClockPeriod: ModelDefaults_1.ModelDefaults.DEFAULT_RUN_PERIOD,\r\n            runClockPeriodUnit: ModelDefaults_1.ModelDefaults.DEFAULT_CLOCK_UNIT,\r\n            warmupDateTime: null,\r\n            startDateTime: null,\r\n            finishDateTime: null\r\n        };\r\n        return __assign(__assign({}, defaults), partialModel);\r\n    };\r\n    ModelUtils.validate = function (model) {\r\n        var validated = __assign({}, model);\r\n        // Ensure model has a valid UUID\r\n        if (!validated.id) {\r\n            validated.id = ModelUtils.generateUUID();\r\n        }\r\n        validated.reps = Math.max(1, model.reps);\r\n        validated.forecastDays = Math.max(1, model.forecastDays);\r\n        if (validated.warmupClockPeriod !== undefined) {\r\n            validated.warmupClockPeriod = Math.max(0, validated.warmupClockPeriod);\r\n        }\r\n        if (validated.runClockPeriod !== undefined) {\r\n            validated.runClockPeriod = Math.max(0, validated.runClockPeriod);\r\n        }\r\n        if (validated.simulationTimeType === SimulationTimeType_1.SimulationTimeType.Clock) {\r\n            validated.warmupDateTime = null;\r\n            validated.startDateTime = null;\r\n            validated.finishDateTime = null;\r\n        }\r\n        else if (validated.simulationTimeType === SimulationTimeType_1.SimulationTimeType.CalendarDate) {\r\n            validated.warmupClockPeriod = undefined;\r\n            validated.runClockPeriod = undefined;\r\n            validated.warmupClockPeriodUnit = undefined;\r\n            validated.runClockPeriodUnit = undefined;\r\n        }\r\n        return validated;\r\n    };\r\n    ModelUtils.isComplete = function (model) {\r\n        return (typeof model.id === 'string' &&\r\n            model.id.length > 0 &&\r\n            typeof model.name === 'string' &&\r\n            typeof model.reps === 'number' &&\r\n            typeof model.forecastDays === 'number' &&\r\n            model.type === SimulationObjectType_1.SimulationObjectType.Model);\r\n    };\r\n    return ModelUtils;\r\n}());\r\nexports.ModelUtils = ModelUtils;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ModelUtils.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/OperationStep.js":
/*!*********************************************************!*\
  !*** ../../shared/dist/types/elements/OperationStep.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.createOperationStep = void 0;\r\nfunction createOperationStep(duration, // duration required parameter\r\noptions) {\r\n    var _a, _b;\r\n    if (options === void 0) { options = {}; }\r\n    return {\r\n        requirementId: (_a = options.requirementId) !== null && _a !== void 0 ? _a : null,\r\n        quantity: (_b = options.quantity) !== null && _b !== void 0 ? _b : 1,\r\n        duration: duration\r\n    };\r\n}\r\nexports.createOperationStep = createOperationStep;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/OperationStep.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/PeriodUnit.js":
/*!******************************************************!*\
  !*** ../../shared/dist/types/elements/PeriodUnit.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.PeriodUnit = void 0;\r\nvar PeriodUnit;\r\n(function (PeriodUnit) {\r\n    PeriodUnit[\"SECONDS\"] = \"SECONDS\";\r\n    PeriodUnit[\"MINUTES\"] = \"MINUTES\";\r\n    PeriodUnit[\"HOURS\"] = \"HOURS\";\r\n    PeriodUnit[\"DAYS\"] = \"DAYS\";\r\n})(PeriodUnit = exports.PeriodUnit || (exports.PeriodUnit = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/PeriodUnit.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/RequirementClause.js":
/*!*************************************************************!*\
  !*** ../../shared/dist/types/elements/RequirementClause.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.RequirementClause = void 0;\r\nvar RequirementMode_1 = __webpack_require__(/*! ./RequirementMode */ \"../../shared/dist/types/elements/RequirementMode.js\");\r\nvar ResourceRequest_1 = __webpack_require__(/*! ./ResourceRequest */ \"../../shared/dist/types/elements/ResourceRequest.js\");\r\nvar RequirementClause = /** @class */ (function () {\r\n    function RequirementClause(clauseId, mode, parentClauseId, requests, subClauses) {\r\n        if (requests === void 0) { requests = []; }\r\n        if (subClauses === void 0) { subClauses = []; }\r\n        this.clauseId = clauseId;\r\n        this.mode = mode;\r\n        this.parentClauseId = parentClauseId;\r\n        this.requests = requests;\r\n        this.subClauses = subClauses;\r\n    }\r\n    /**\r\n     * Adds a sub-clause to this clause.\r\n     * @param clause - The sub-clause to add.\r\n     */\r\n    RequirementClause.prototype.addSubClause = function (clause) {\r\n        this.subClauses.push(clause);\r\n    };\r\n    /**\r\n     * Adds a ResourceRequest to this clause.\r\n     * @param request - The ResourceRequest to add.\r\n     */\r\n    RequirementClause.prototype.addRequest = function (request) {\r\n        this.requests.push(request);\r\n    };\r\n    /**\r\n     * Validates the clause to ensure it has at least one request or sub-clause.\r\n     * @throws Error if the clause is invalid.\r\n     */\r\n    RequirementClause.prototype.validate = function () {\r\n        if (!this.requests.length && !this.subClauses.length) {\r\n            throw new Error(\"RequirementClause \".concat(this.clauseId, \" must have at least one request or sub-clause.\"));\r\n        }\r\n    };\r\n    /**\r\n     * Factory method to create a clause with a single ResourceRequest.\r\n     */\r\n    RequirementClause.createSingleRequestClause = function (clauseId, resourceId, quantity, mode, parentClauseId, priority, keepResource) {\r\n        if (quantity === void 0) { quantity = 1; }\r\n        if (mode === void 0) { mode = RequirementMode_1.RequirementMode.REQUIRE_ALL; }\r\n        // Use the ResourceRequest class's factory method\r\n        var resourceRequest = ResourceRequest_1.ResourceRequest.create(resourceId, {\r\n            quantity: quantity,\r\n            priority: priority,\r\n            keepResource: keepResource,\r\n        });\r\n        // Return a new RequirementClause instance\r\n        return new RequirementClause(clauseId, mode, parentClauseId, [resourceRequest] // Single request\r\n        );\r\n    };\r\n    /**\r\n     * Factory method to create a clause with multiple ResourceRequests.\r\n     */\r\n    RequirementClause.createMultiRequestClause = function (clauseId, requests, mode, parentClauseId) {\r\n        if (mode === void 0) { mode = RequirementMode_1.RequirementMode.REQUIRE_ALL; }\r\n        // Map input data to ResourceRequest instances\r\n        var resourceRequests = requests.map(function (r) {\r\n            return ResourceRequest_1.ResourceRequest.create(r.resourceId, {\r\n                quantity: r.quantity,\r\n                priority: r.priority,\r\n                keepResource: r.keepResource,\r\n            });\r\n        });\r\n        // Return a new RequirementClause instance\r\n        return new RequirementClause(clauseId, mode, parentClauseId, resourceRequests // Multiple requests\r\n        );\r\n    };\r\n    return RequirementClause;\r\n}());\r\nexports.RequirementClause = RequirementClause;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/RequirementClause.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/RequirementMode.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/elements/RequirementMode.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.RequirementMode = void 0;\r\n/**\r\n * Enumerates the modes in which resource requests can be required:\r\n * - REQUIRE_ALL: All child items must be satisfied.\r\n * - REQUIRE_ANY: At least one of the child items must be satisfied.\r\n */\r\nvar RequirementMode;\r\n(function (RequirementMode) {\r\n    RequirementMode[\"REQUIRE_ALL\"] = \"REQUIRE_ALL\";\r\n    RequirementMode[\"REQUIRE_ANY\"] = \"REQUIRE_ANY\";\r\n})(RequirementMode = exports.RequirementMode || (exports.RequirementMode = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/RequirementMode.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Resource.js":
/*!****************************************************!*\
  !*** ../../shared/dist/types/elements/Resource.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Resource = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar Resource = /** @class */ (function () {\r\n    function Resource(id, name, capacity) {\r\n        if (capacity === void 0) { capacity = 1; }\r\n        this.id = id;\r\n        this.name = name;\r\n        this.capacity = capacity;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Resource;\r\n    }\r\n    Resource.createDefault = function (id) {\r\n        return new Resource(id, 'New Resource', 1 // capacity\r\n        );\r\n    };\r\n    return Resource;\r\n}());\r\nexports.Resource = Resource;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/Resource.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ResourceListManager.js":
/*!***************************************************************!*\
  !*** ../../shared/dist/types/elements/ResourceListManager.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResourceListManager = void 0;\r\nvar ComponentListManager_1 = __webpack_require__(/*! ./ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\");\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar ResourceListManager = /** @class */ (function (_super) {\r\n    __extends(ResourceListManager, _super);\r\n    function ResourceListManager() {\r\n        return _super.call(this, SimulationObjectType_1.SimulationObjectType.Resource) || this;\r\n    }\r\n    return ResourceListManager;\r\n}(ComponentListManager_1.ComponentListManager));\r\nexports.ResourceListManager = ResourceListManager;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ResourceListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ResourceRequest.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/elements/ResourceRequest.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResourceRequest = void 0;\r\n/**\r\n * Represents a request for a certain quantity of a particular resource.\r\n *\r\n * @property resourceId   - The ID of the resource being requested.\r\n * @property quantity     - How many units of the resource are needed.\r\n * @property priority     - Used for ordering or weighting resource allocation.\r\n * @property keepResource - If true, resource cannot be swapped out once assigned.\r\n */\r\nvar ResourceRequest = /** @class */ (function () {\r\n    /**\r\n     * Constructs a new ResourceRequest.\r\n     *\r\n     * @param resourceId   - The ID of the resource being requested.\r\n     * @param quantity     - How many units of the resource are needed.\r\n     * @param priority     - Priority for the request.\r\n     * @param keepResource - Whether the resource should be locked after assignment.\r\n     */\r\n    function ResourceRequest(resourceId, quantity, priority, keepResource) {\r\n        if (quantity === void 0) { quantity = 1; }\r\n        if (priority === void 0) { priority = 1; }\r\n        if (keepResource === void 0) { keepResource = false; }\r\n        this.resourceId = resourceId;\r\n        this.quantity = quantity;\r\n        this.priority = priority;\r\n        this.keepResource = keepResource;\r\n    }\r\n    /**\r\n     * Factory method to create a ResourceRequest with default values.\r\n     *\r\n     * @param resourceId - Required string ID of the resource.\r\n     * @param options    - Partial override for the ResourceRequest fields\r\n     *                     (other than resourceId).\r\n     * @returns A new ResourceRequest instance.\r\n     */\r\n    ResourceRequest.create = function (resourceId, options) {\r\n        var _a, _b, _c;\r\n        if (options === void 0) { options = {}; }\r\n        return new ResourceRequest(resourceId, (_a = options.quantity) !== null && _a !== void 0 ? _a : 1, (_b = options.priority) !== null && _b !== void 0 ? _b : 1, (_c = options.keepResource) !== null && _c !== void 0 ? _c : false);\r\n    };\r\n    /**\r\n     * Validates the ResourceRequest, ensuring it meets expected criteria.\r\n     * Throws an error if invalid.\r\n     */\r\n    ResourceRequest.prototype.validate = function () {\r\n        if (this.quantity <= 0) {\r\n            throw new Error(\"Quantity must be greater than 0.\");\r\n        }\r\n        if (this.priority < 1) {\r\n            throw new Error(\"Priority must be at least 1.\");\r\n        }\r\n    };\r\n    /**\r\n     * Converts the ResourceRequest to a plain JSON object.\r\n     */\r\n    ResourceRequest.prototype.toJSON = function () {\r\n        return {\r\n            resourceId: this.resourceId,\r\n            quantity: this.quantity,\r\n            priority: this.priority,\r\n            keepResource: this.keepResource,\r\n        };\r\n    };\r\n    return ResourceRequest;\r\n}());\r\nexports.ResourceRequest = ResourceRequest;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ResourceRequest.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ResourceRequirement.js":
/*!***************************************************************!*\
  !*** ../../shared/dist/types/elements/ResourceRequirement.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResourceRequirement = void 0;\r\nvar RequirementClause_1 = __webpack_require__(/*! ./RequirementClause */ \"../../shared/dist/types/elements/RequirementClause.js\");\r\nvar RequirementMode_1 = __webpack_require__(/*! ./RequirementMode */ \"../../shared/dist/types/elements/RequirementMode.js\");\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar ResourceRequest_1 = __webpack_require__(/*! ./ResourceRequest */ \"../../shared/dist/types/elements/ResourceRequest.js\");\r\nvar ResourceRequirement = /** @class */ (function () {\r\n    function ResourceRequirement(id, name, rootClauses) {\r\n        if (rootClauses === void 0) { rootClauses = []; }\r\n        this.type = SimulationObjectType_1.SimulationObjectType.ResourceRequirement;\r\n        this.id = id;\r\n        this.name = name;\r\n        this.rootClauses = rootClauses;\r\n    }\r\n    /**\r\n     * Validates the ResourceRequirement, ensuring it meets basic criteria.\r\n     */\r\n    ResourceRequirement.prototype.validate = function () {\r\n        if (!this.rootClauses.length) {\r\n            throw new Error(\"ResourceRequirement must have at least one root clause.\");\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Adds a new clause to the rootClauses array.\r\n     *\r\n     * @param clause - The clause to add.\r\n     */\r\n    ResourceRequirement.prototype.addClause = function (clause) {\r\n        this.rootClauses.push(clause);\r\n    };\r\n    /**\r\n     * Removes a clause by its ID.\r\n     *\r\n     * @param clauseId - The ID of the clause to remove.\r\n     */\r\n    ResourceRequirement.prototype.removeClause = function (clauseId) {\r\n        this.rootClauses = this.rootClauses.filter(function (clause) { return clause.clauseId !== clauseId; });\r\n    };\r\n    /**\r\n     * Converts the ResourceRequirement to a plain JSON object.\r\n     */\r\n    ResourceRequirement.prototype.toJSON = function () {\r\n        return {\r\n            id: this.id,\r\n            name: this.name,\r\n            type: this.type,\r\n            rootClauses: this.rootClauses,\r\n        };\r\n    };\r\n    ResourceRequirement.createForSingleResource = function (resource, requestOpts, clauseId, mode) {\r\n        if (requestOpts === void 0) { requestOpts = {}; }\r\n        if (clauseId === void 0) { clauseId = \"clause-1\"; }\r\n        if (mode === void 0) { mode = RequirementMode_1.RequirementMode.REQUIRE_ALL; }\r\n        // Generate an ID and name for the ResourceRequirement\r\n        var id = \"\".concat(resource.id);\r\n        var name = \"\".concat(resource.name);\r\n        // Create a ResourceRequest instance\r\n        var request = ResourceRequest_1.ResourceRequest.create(resource.id, requestOpts);\r\n        // Create a RequirementClause instance\r\n        var clause = new RequirementClause_1.RequirementClause(clauseId, mode, undefined, // parentClauseId (optional)\r\n        [request], // requests\r\n        [] // subClauses\r\n        );\r\n        // Return a new ResourceRequirement instance\r\n        return new ResourceRequirement(id, name, [clause]);\r\n    };\r\n    return ResourceRequirement;\r\n}());\r\nexports.ResourceRequirement = ResourceRequirement;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ResourceRequirement.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ResourceRequirementListManager.js":
/*!**************************************************************************!*\
  !*** ../../shared/dist/types/elements/ResourceRequirementListManager.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResourceRequirementListManager = void 0;\r\nvar ComponentListManager_1 = __webpack_require__(/*! ./ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\");\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar ResourceRequirementListManager = /** @class */ (function (_super) {\r\n    __extends(ResourceRequirementListManager, _super);\r\n    function ResourceRequirementListManager() {\r\n        return _super.call(this, SimulationObjectType_1.SimulationObjectType.ResourceRequirement) || this;\r\n    }\r\n    return ResourceRequirementListManager;\r\n}(ComponentListManager_1.ComponentListManager));\r\nexports.ResourceRequirementListManager = ResourceRequirementListManager;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/ResourceRequirementListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/RunState.js":
/*!****************************************************!*\
  !*** ../../shared/dist/types/elements/RunState.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.RunState = void 0;\r\nvar RunState;\r\n(function (RunState) {\r\n    RunState[\"NotRun\"] = \"NOT_RUN\";\r\n    RunState[\"Running\"] = \"RUNNING\";\r\n    RunState[\"RanWithErrors\"] = \"RAN_WITH_ERRORS\";\r\n    RunState[\"RanSuccessfully\"] = \"RAN_SUCCESSFULLY\";\r\n})(RunState = exports.RunState || (exports.RunState = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/RunState.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Scenario.js":
/*!****************************************************!*\
  !*** ../../shared/dist/types/elements/Scenario.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/Scenario.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/SimulationObject.js":
/*!************************************************************!*\
  !*** ../../shared/dist/types/elements/SimulationObject.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/SimulationObject.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/SimulationObjectType.js":
/*!****************************************************************!*\
  !*** ../../shared/dist/types/elements/SimulationObjectType.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimulationObjectType = void 0;\r\nvar SimulationObjectType;\r\n(function (SimulationObjectType) {\r\n    SimulationObjectType[\"Entity\"] = \"Entity\";\r\n    SimulationObjectType[\"Activity\"] = \"Activity\";\r\n    SimulationObjectType[\"Connector\"] = \"Connector\";\r\n    SimulationObjectType[\"Generator\"] = \"Generator\";\r\n    SimulationObjectType[\"Resource\"] = \"Resource\";\r\n    SimulationObjectType[\"ResourceRequirement\"] = \"ResourceRequirement\";\r\n    SimulationObjectType[\"Scenario\"] = \"Scenario\";\r\n    SimulationObjectType[\"Experiment\"] = \"Experiment\";\r\n    SimulationObjectType[\"Model\"] = \"Model\";\r\n    SimulationObjectType[\"None\"] = \"None\";\r\n})(SimulationObjectType = exports.SimulationObjectType || (exports.SimulationObjectType = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/SimulationObjectType.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/SimulationTimeType.js":
/*!**************************************************************!*\
  !*** ../../shared/dist/types/elements/SimulationTimeType.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimulationTimeType = void 0;\r\nvar SimulationTimeType;\r\n(function (SimulationTimeType) {\r\n    SimulationTimeType[\"Clock\"] = \"Clock\";\r\n    SimulationTimeType[\"CalendarDate\"] = \"CalendarDate\";\r\n})(SimulationTimeType = exports.SimulationTimeType || (exports.SimulationTimeType = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/elements/SimulationTimeType.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/JsonTypes.js":
/*!******************************************************!*\
  !*** ../../shared/dist/types/messaging/JsonTypes.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/JsonTypes.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/MessageTypes.js":
/*!*********************************************************!*\
  !*** ../../shared/dist/types/messaging/MessageTypes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.MessageTypes = void 0;\r\nvar MessageTypes;\r\n(function (MessageTypes) {\r\n    // React App Lifecycle\r\n    MessageTypes[\"REACT_APP_READY\"] = \"reactAppReady\";\r\n    // Selection Management\r\n    MessageTypes[\"SELECTION_CHANGED_PAGE_NO_MODEL\"] = \"selectionPageNoModel\";\r\n    MessageTypes[\"SELECTION_CHANGED_PAGE_WITH_MODEL\"] = \"selectionPageWithModel\";\r\n    MessageTypes[\"SELECTION_CHANGED_SIMULATION_OBJECT\"] = \"selectionSimObject\";\r\n    MessageTypes[\"SELECTION_CHANGED_MULTIPLE\"] = \"selectionMultiple\";\r\n    MessageTypes[\"SELECTION_CHANGED_UNCONVERTED\"] = \"selectionUnconverted\";\r\n    // Model Conversion\r\n    MessageTypes[\"CONVERT_PAGE\"] = \"convertPage\";\r\n    MessageTypes[\"CONVERSION_ERROR\"] = \"conversionError\";\r\n    // Element Data Operations\r\n    MessageTypes[\"GET_ELEMENT_DATA\"] = \"getElementData\";\r\n    MessageTypes[\"UPDATE_ELEMENT_DATA\"] = \"updateElementData\";\r\n    MessageTypes[\"UPDATE_SUCCESS\"] = \"updateSuccess\";\r\n    MessageTypes[\"CONVERT_ELEMENT\"] = \"convertElement\";\r\n    // Model Validation\r\n    MessageTypes[\"VALIDATE_MODEL\"] = \"validateModel\";\r\n    MessageTypes[\"VALIDATION_RESULT\"] = \"validationResult\";\r\n    // Error Handling\r\n    MessageTypes[\"ERROR\"] = \"error\";\r\n    // Model Operations\r\n    MessageTypes[\"REMOVE_MODEL\"] = \"removeModel\";\r\n    MessageTypes[\"MODEL_REMOVED\"] = \"modelRemoved\";\r\n    MessageTypes[\"SIMULATE_MODEL\"] = \"simulateModel\";\r\n    MessageTypes[\"SIMULATION_STARTED\"] = \"SIMULATION_STARTED\";\r\n    MessageTypes[\"SIMULATION_STATUS_UPDATE\"] = \"SIMULATION_STATUS_UPDATE\";\r\n    MessageTypes[\"SIMULATION_STATUS_CHECK\"] = \"SIMULATION_STATUS_CHECK\";\r\n    MessageTypes[\"SIMULATION_STATUS_ERROR\"] = \"SIMULATION_STATUS_ERROR\";\r\n    MessageTypes[\"OUTPUT_CREATE_PAGE\"] = \"outputCreatePage\";\r\n    // Tree View State Management\r\n    MessageTypes[\"TREE_STATE_UPDATE\"] = \"treeStateUpdate\";\r\n    MessageTypes[\"TREE_NODE_TOGGLE\"] = \"treeNodeToggle\";\r\n    MessageTypes[\"TREE_NODE_EXPAND_PATH\"] = \"treeNodeExpandPath\";\r\n    MessageTypes[\"TREE_STATE_SYNC\"] = \"treeStateSync\";\r\n})(MessageTypes = exports.MessageTypes || (exports.MessageTypes = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/MessageTypes.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/index.js":
/*!**************************************************!*\
  !*** ../../shared/dist/types/messaging/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./JsonTypes */ \"../../shared/dist/types/messaging/JsonTypes.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./payloads */ \"../../shared/dist/types/messaging/payloads/index.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./utils/MessageValidation */ \"../../shared/dist/types/messaging/utils/MessageValidation.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./utils/ExtensionMessaging */ \"../../shared/dist/types/messaging/utils/ExtensionMessaging.js\"), exports);\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/index.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/AppLifecyclePayloads.js":
/*!**************************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/AppLifecyclePayloads.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/payloads/AppLifecyclePayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ModelData.js":
/*!***************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ModelData.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/payloads/ModelData.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ModelItemData.js":
/*!*******************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ModelItemData.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/payloads/ModelItemData.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ModelItemPayloads.js":
/*!***********************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ModelItemPayloads.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/payloads/ModelItemPayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ModelPayloads.js":
/*!*******************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ModelPayloads.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/payloads/ModelPayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ModelTreePayloads.js":
/*!***********************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ModelTreePayloads.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/payloads/ModelTreePayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/SelectionPayloads.js":
/*!***********************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/SelectionPayloads.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/payloads/SelectionPayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ValidationPayloads.js":
/*!************************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ValidationPayloads.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/payloads/ValidationPayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/index.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./ModelItemData */ \"../../shared/dist/types/messaging/payloads/ModelItemData.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ModelData */ \"../../shared/dist/types/messaging/payloads/ModelData.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./AppLifecyclePayloads */ \"../../shared/dist/types/messaging/payloads/AppLifecyclePayloads.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ModelPayloads */ \"../../shared/dist/types/messaging/payloads/ModelPayloads.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ModelItemPayloads */ \"../../shared/dist/types/messaging/payloads/ModelItemPayloads.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ValidationPayloads */ \"../../shared/dist/types/messaging/payloads/ValidationPayloads.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ModelTreePayloads */ \"../../shared/dist/types/messaging/payloads/ModelTreePayloads.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./SelectionPayloads */ \"../../shared/dist/types/messaging/payloads/SelectionPayloads.js\"), exports);\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/payloads/index.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/utils/ExtensionMessaging.js":
/*!*********************************************************************!*\
  !*** ../../shared/dist/types/messaging/utils/ExtensionMessaging.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ExtensionMessaging = void 0;\r\nvar ExtensionMessaging = /** @class */ (function () {\r\n    function ExtensionMessaging() {\r\n        this.handlers = new Map();\r\n    }\r\n    ExtensionMessaging.getInstance = function () {\r\n        if (!ExtensionMessaging.instance) {\r\n            ExtensionMessaging.instance = new ExtensionMessaging();\r\n        }\r\n        return ExtensionMessaging.instance;\r\n    };\r\n    /**\r\n     * Creates a serializable message. At runtime, enums will serialize to their string values.\r\n     */\r\n    ExtensionMessaging.prototype.createSerializableMessage = function (type, payload) {\r\n        return {\r\n            messagetype: type,\r\n            data: payload !== null && payload !== void 0 ? payload : null\r\n        };\r\n    };\r\n    ExtensionMessaging.prototype.handleIncomingMessage = function (message) {\r\n        console.log('[ExtensionMessaging] Received incoming message:', message);\r\n        if (!(message === null || message === void 0 ? void 0 : message.messagetype)) {\r\n            console.warn('[ExtensionMessaging] Message missing messagetype:', message);\r\n            return;\r\n        }\r\n        var handlers = this.handlers.get(message.messagetype);\r\n        if (handlers) {\r\n            console.log(\"[ExtensionMessaging] Found \".concat(handlers.size, \" handlers for incoming message type: \").concat(message.messagetype));\r\n            handlers.forEach(function (handler) { return handler(message.data); });\r\n        }\r\n        else {\r\n            console.warn(\"[ExtensionMessaging] No handlers found for incoming message type: \".concat(message.messagetype));\r\n        }\r\n    };\r\n    ExtensionMessaging.prototype.onMessage = function (type, handler) {\r\n        var _this = this;\r\n        if (!this.handlers.has(type)) {\r\n            this.handlers.set(type, new Set());\r\n        }\r\n        this.handlers.get(type).add(handler);\r\n        // Return unsubscribe function\r\n        return function () {\r\n            var _a;\r\n            (_a = _this.handlers.get(type)) === null || _a === void 0 ? void 0 : _a.delete(handler);\r\n        };\r\n    };\r\n    ExtensionMessaging.prototype.sendMessage = function (type, payload) {\r\n        console.log('[ExtensionMessaging] Sending message:', { type: type, payload: payload });\r\n        try {\r\n            // First, notify any local handlers\r\n            var handlers = this.handlers.get(type);\r\n            if (handlers) {\r\n                handlers.forEach(function (handler) { return handler(payload); });\r\n            }\r\n            // Then, send to parent window\r\n            var message = this.createSerializableMessage(type, payload);\r\n            window.parent.postMessage(message, \"*\");\r\n            console.log('[ExtensionMessaging] Message posted to parent window');\r\n        }\r\n        catch (error) {\r\n            console.error('[ExtensionMessaging] Failed to send message:', error);\r\n            throw error;\r\n        }\r\n    };\r\n    return ExtensionMessaging;\r\n}());\r\nexports.ExtensionMessaging = ExtensionMessaging;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/utils/ExtensionMessaging.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/utils/MessageValidation.js":
/*!********************************************************************!*\
  !*** ../../shared/dist/types/messaging/utils/MessageValidation.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isValidMessage = void 0;\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n/**\r\n * Type guard to check if a message is valid\r\n */\r\nfunction isValidMessage(message) {\r\n    return message\r\n        && typeof message === 'object'\r\n        && 'messagetype' in message\r\n        && Object.values(MessageTypes_1.MessageTypes).includes(message.messagetype);\r\n}\r\nexports.isValidMessage = isValidMessage;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/messaging/utils/MessageValidation.js?");

/***/ }),

/***/ "../../shared/dist/types/simComponentType.js":
/*!***************************************************!*\
  !*** ../../shared/dist/types/simComponentType.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimComponentType = void 0;\r\nvar SimComponentType;\r\n(function (SimComponentType) {\r\n    SimComponentType[\"ACTIVITY\"] = \"activity\";\r\n    SimComponentType[\"GENERATOR\"] = \"generator\";\r\n    SimComponentType[\"CONNECTOR\"] = \"connector\";\r\n    SimComponentType[\"MODEL\"] = \"model\";\r\n    SimComponentType[\"ENTITY\"] = \"entity\";\r\n    SimComponentType[\"RESOURCE\"] = \"resource\";\r\n    SimComponentType[\"NONE\"] = \"none\";\r\n})(SimComponentType = exports.SimComponentType || (exports.SimComponentType = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/simComponentType.js?");

/***/ }),

/***/ "../../shared/dist/types/validation/ValidationTypes.js":
/*!*************************************************************!*\
  !*** ../../shared/dist/types/validation/ValidationTypes.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n// types/ValidationTypes.ts\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/validation/ValidationTypes.js?");

/***/ }),

/***/ "../../shared/dist/types/validation/index.js":
/*!***************************************************!*\
  !*** ../../shared/dist/types/validation/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./ValidationTypes */ \"../../shared/dist/types/validation/ValidationTypes.js\"), exports);\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/types/validation/index.js?");

/***/ }),

/***/ "../../shared/dist/utils/csvUtils.js":
/*!*******************************************!*\
  !*** ../../shared/dist/utils/csvUtils.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.calculateTableDimensions = exports.parseCsvBlob = void 0;\r\n// src/utils/csvUtils.ts\r\nfunction parseCsvBlob(blob) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var text, rows;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, blob.text()];\r\n                case 1:\r\n                    text = _a.sent();\r\n                    rows = text.split('\\n').map(function (row) { return row.split(','); });\r\n                    return [2 /*return*/, rows];\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.parseCsvBlob = parseCsvBlob;\r\nfunction calculateTableDimensions(data) {\r\n    var _a;\r\n    var padding = 20;\r\n    var cellWidth = 120;\r\n    var cellHeight = 30;\r\n    var cols = ((_a = data[0]) === null || _a === void 0 ? void 0 : _a.length) || 0;\r\n    var rows = data.length;\r\n    return {\r\n        width: (cols * cellWidth) + (padding * 2),\r\n        height: (rows * cellHeight) + (padding * 2)\r\n    };\r\n}\r\nexports.calculateTableDimensions = calculateTableDimensions;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/utils/csvUtils.js?");

/***/ }),

/***/ "../../shared/dist/validation/common/ValidationMessages.js":
/*!*****************************************************************!*\
  !*** ../../shared/dist/validation/common/ValidationMessages.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ValidationMessages = void 0;\r\nvar ValidationMessages = /** @class */ (function () {\r\n    function ValidationMessages() {\r\n    }\r\n    // Existing messages...\r\n    ValidationMessages.missingName = function (elementType, elementId) {\r\n        return {\r\n            type: 'warning',\r\n            message: \"\".concat(elementType, \" \").concat(elementId, \" has no name\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.isolatedElement = function (elementType, elementId) {\r\n        return {\r\n            type: 'error',\r\n            message: \"\".concat(elementType, \" \").concat(elementId, \" is isolated (no connections)\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.invalidConnection = function (connectorId, type, elementId) {\r\n        return {\r\n            type: 'error',\r\n            message: \"Connector \".concat(connectorId, \" has invalid \").concat(type, \" (\").concat(elementId, \")\"),\r\n            elementId: connectorId\r\n        };\r\n    };\r\n    ValidationMessages.invalidCapacity = function (elementType, elementId, minimum) {\r\n        if (minimum === void 0) { minimum = 1; }\r\n        return {\r\n            type: 'error',\r\n            message: \"\".concat(elementType, \" \").concat(elementId, \" has invalid capacity (must be >= \").concat(minimum, \")\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    // New messages for Activity validation\r\n    ValidationMessages.noConnections = function (elementType, elementId, direction) {\r\n        return {\r\n            type: 'warning',\r\n            message: \"\".concat(elementType, \" \").concat(elementId, \" has no \").concat(direction, \" connections (potential \").concat(direction === 'incoming' ? 'start' : 'end', \" activity)\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.largeBufferCapacity = function (elementType, elementId, type) {\r\n        return {\r\n            type: 'warning',\r\n            message: \"\".concat(elementType, \" \").concat(elementId, \" has unusually large \").concat(type, \" buffer capacity\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.invalidBufferCapacity = function (elementType, elementId, type) {\r\n        return {\r\n            type: 'error',\r\n            message: \"\".concat(elementType, \" \").concat(elementId, \" has invalid \").concat(type, \" buffer capacity\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.missingOperationSteps = function (elementId) {\r\n        return {\r\n            type: 'error',\r\n            message: \"Activity \".concat(elementId, \" is missing operation steps property\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.noOperationSteps = function (elementId) {\r\n        return {\r\n            type: 'warning',\r\n            message: \"Activity \".concat(elementId, \" has no operation steps defined\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.invalidStepDuration = function (elementId, stepNumber) {\r\n        return {\r\n            type: 'error',\r\n            message: \"Activity \".concat(elementId, \" operation step \").concat(stepNumber, \" has invalid duration\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.unusualStepDuration = function (elementId, stepNumber, duration) {\r\n        return {\r\n            type: 'warning',\r\n            message: \"Activity \".concat(elementId, \" operation step \").concat(stepNumber, \" has unusual duration (\").concat(duration, \" seconds)\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.duplicateResourceRequest = function (elementId, stepNumber) {\r\n        return {\r\n            type: 'warning',\r\n            message: \"Activity \".concat(elementId, \" operation step \").concat(stepNumber, \" requests the same resource multiple times\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.invalidResourceQuantity = function (elementId, stepNumber) {\r\n        return {\r\n            type: 'error',\r\n            message: \"Activity \".concat(elementId, \" operation step \").concat(stepNumber, \" has invalid resource quantity\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.unusualCycleTime = function (elementId, type, time) {\r\n        return {\r\n            type: 'warning',\r\n            message: \"Activity \".concat(elementId, \" has unusually \").concat(type, \" \").concat(type === 'short' ? 'minimum' : 'maximum', \" cycle time (\").concat(time, \" seconds)\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.bufferOverflowRisk = function (elementId) {\r\n        return {\r\n            type: 'warning',\r\n            message: \"Activity \".concat(elementId, \" may experience input buffer overflow at maximum throughput\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.smallInputBuffer = function (elementId) {\r\n        return {\r\n            type: 'warning',\r\n            message: \"Activity \".concat(elementId, \" input buffer may be too small for incoming flow capacity\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.circularDependency = function (elementId) {\r\n        return {\r\n            type: 'warning',\r\n            message: \"Potential circular dependency detected involving activity \".concat(elementId),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    ValidationMessages.resourceLeak = function (elementId) {\r\n        return {\r\n            type: 'warning',\r\n            message: \"Activity \".concat(elementId, \" requests resources but never releases them\"),\r\n            elementId: elementId\r\n        };\r\n    };\r\n    // Existing utility messages...\r\n    ValidationMessages.validationSuccess = function () {\r\n        return {\r\n            type: 'info',\r\n            message: 'Model validation passed successfully'\r\n        };\r\n    };\r\n    ValidationMessages.validationError = function (error) {\r\n        return {\r\n            type: 'error',\r\n            message: \"Validation failed: \".concat(error instanceof Error ? error.message : 'Unknown error')\r\n        };\r\n    };\r\n    // Generator Validation\r\n    ValidationMessages.generatorValidation = function (category, generatorId, detail) {\r\n        return {\r\n            type: 'error',\r\n            message: \"Generator \".concat(generatorId, \" has invalid \").concat(category, \": \").concat(detail),\r\n            elementId: generatorId\r\n        };\r\n    };\r\n    // Element Counts\r\n    ValidationMessages.missingRequiredElement = function (elementType) {\r\n        return {\r\n            type: 'error',\r\n            message: \"Model must have at least one \".concat(elementType),\r\n        };\r\n    };\r\n    return ValidationMessages;\r\n}());\r\nexports.ValidationMessages = ValidationMessages;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/validation/common/ValidationMessages.js?");

/***/ }),

/***/ "../../shared/dist/validation/common/ValidationRule.js":
/*!*************************************************************!*\
  !*** ../../shared/dist/validation/common/ValidationRule.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ValidationRule = void 0;\r\n/**\r\n * Base class for validation rules\r\n */\r\nvar ValidationRule = /** @class */ (function () {\r\n    function ValidationRule() {\r\n        /**\r\n         * Flag to enable or disable logging across all validation rules.\r\n         */\r\n        this.loggingEnabled = false;\r\n    }\r\n    /**\r\n     * Method to toggle logging.\r\n     * @param enabled - True to enable logging, false to disable.\r\n     */\r\n    ValidationRule.prototype.setLogging = function (enabled) {\r\n        this.loggingEnabled = enabled;\r\n    };\r\n    /**\r\n     * Checks if logging is enabled.\r\n     * @returns True if logging is enabled, false otherwise.\r\n     */\r\n    ValidationRule.prototype.isLoggingEnabled = function () {\r\n        return this.loggingEnabled;\r\n    };\r\n    /**\r\n     * Logs a message if logging is enabled.\r\n     * @param message - The message to log.\r\n     */\r\n    ValidationRule.prototype.log = function (message) {\r\n        if (this.isLoggingEnabled()) {\r\n            console.log(\"[\".concat(this.constructor.name, \"] \").concat(message));\r\n        }\r\n    };\r\n    return ValidationRule;\r\n}());\r\nexports.ValidationRule = ValidationRule;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/validation/common/ValidationRule.js?");

/***/ }),

/***/ "../../shared/dist/validation/index.js":
/*!*********************************************!*\
  !*** ../../shared/dist/validation/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelValidationService = exports.ResourceValidation = exports.GeneratorValidation = exports.EntityValidation = exports.ElementCountsValidation = exports.ConnectorValidation = exports.ActivityValidation = exports.ValidationRule = exports.ValidationMessages = void 0;\r\n// Common exports\r\nvar ValidationMessages_1 = __webpack_require__(/*! ./common/ValidationMessages */ \"../../shared/dist/validation/common/ValidationMessages.js\");\r\nObject.defineProperty(exports, \"ValidationMessages\", ({ enumerable: true, get: function () { return ValidationMessages_1.ValidationMessages; } }));\r\nvar ValidationRule_1 = __webpack_require__(/*! ./common/ValidationRule */ \"../../shared/dist/validation/common/ValidationRule.js\");\r\nObject.defineProperty(exports, \"ValidationRule\", ({ enumerable: true, get: function () { return ValidationRule_1.ValidationRule; } }));\r\n// Rule exports\r\nvar ActivityValidation_1 = __webpack_require__(/*! ./rules/ActivityValidation */ \"../../shared/dist/validation/rules/ActivityValidation.js\");\r\nObject.defineProperty(exports, \"ActivityValidation\", ({ enumerable: true, get: function () { return ActivityValidation_1.ActivityValidation; } }));\r\nvar ConnectorValidation_1 = __webpack_require__(/*! ./rules/ConnectorValidation */ \"../../shared/dist/validation/rules/ConnectorValidation.js\");\r\nObject.defineProperty(exports, \"ConnectorValidation\", ({ enumerable: true, get: function () { return ConnectorValidation_1.ConnectorValidation; } }));\r\nvar ElementCountsValidation_1 = __webpack_require__(/*! ./rules/ElementCountsValidation */ \"../../shared/dist/validation/rules/ElementCountsValidation.js\");\r\nObject.defineProperty(exports, \"ElementCountsValidation\", ({ enumerable: true, get: function () { return ElementCountsValidation_1.ElementCountsValidation; } }));\r\nvar EntityValidation_1 = __webpack_require__(/*! ./rules/EntityValidation */ \"../../shared/dist/validation/rules/EntityValidation.js\");\r\nObject.defineProperty(exports, \"EntityValidation\", ({ enumerable: true, get: function () { return EntityValidation_1.EntityValidation; } }));\r\nvar GeneratorValidation_1 = __webpack_require__(/*! ./rules/GeneratorValidation */ \"../../shared/dist/validation/rules/GeneratorValidation.js\");\r\nObject.defineProperty(exports, \"GeneratorValidation\", ({ enumerable: true, get: function () { return GeneratorValidation_1.GeneratorValidation; } }));\r\nvar ResourceValidation_1 = __webpack_require__(/*! ./rules/ResourceValidation */ \"../../shared/dist/validation/rules/ResourceValidation.js\");\r\nObject.defineProperty(exports, \"ResourceValidation\", ({ enumerable: true, get: function () { return ResourceValidation_1.ResourceValidation; } }));\r\n// Service exports\r\nvar ModelValidationService_1 = __webpack_require__(/*! ./services/ModelValidationService */ \"../../shared/dist/validation/services/ModelValidationService.js\");\r\nObject.defineProperty(exports, \"ModelValidationService\", ({ enumerable: true, get: function () { return ModelValidationService_1.ModelValidationService; } }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/validation/index.js?");

/***/ }),

/***/ "../../shared/dist/validation/rules/ActivityValidation.js":
/*!****************************************************************!*\
  !*** ../../shared/dist/validation/rules/ActivityValidation.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ActivityValidation = void 0;\r\nvar ValidationRule_1 = __webpack_require__(/*! ../common/ValidationRule */ \"../../shared/dist/validation/common/ValidationRule.js\");\r\nvar ValidationMessages_1 = __webpack_require__(/*! ../common/ValidationMessages */ \"../../shared/dist/validation/common/ValidationMessages.js\");\r\nvar ActivityValidation = /** @class */ (function (_super) {\r\n    __extends(ActivityValidation, _super);\r\n    function ActivityValidation() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ActivityValidation.prototype.validate = function (state, messages) {\r\n        var _this = this;\r\n        var activities = state.modelDefinition.activities.getAll();\r\n        activities.forEach(function (activity) {\r\n            _this.validateActivityConnectivity(activity.id, state, messages);\r\n            _this.validateActivityData(activity, messages);\r\n            _this.validateOperationSequence(activity, state, messages);\r\n            _this.validateBufferConstraints(activity, state, messages);\r\n        });\r\n        this.validateActivityInteractions(state, messages);\r\n    };\r\n    ActivityValidation.prototype.validateActivityConnectivity = function (activityId, state, messages) {\r\n        /**\r\n         * Validates that an activity is properly connected.\r\n         * Ensures it has at least one incoming or outgoing connection.\r\n         */\r\n        this.log(\"Validating connectivity for Activity ID: \".concat(activityId));\r\n        var relationships = state.activityRelationships.get(activityId);\r\n        if (!relationships) {\r\n            this.log(\"Activity ID \".concat(activityId, \" is isolated.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.isolatedElement(\"Activity\", activityId));\r\n            return;\r\n        }\r\n        if (relationships.incomingConnectors.size === 0 && relationships.outgoingConnectors.size === 0) {\r\n            this.log(\"Activity ID \".concat(activityId, \" has no incoming or outgoing connections.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.isolatedElement(\"Activity\", activityId));\r\n        }\r\n        if (relationships.incomingConnectors.size === 0) {\r\n            this.log(\"Activity ID \".concat(activityId, \" has no incoming connections.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.noConnections(\"Activity\", activityId, \"incoming\"));\r\n        }\r\n        if (relationships.outgoingConnectors.size === 0) {\r\n            this.log(\"Activity ID \".concat(activityId, \" has no outgoing connections.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.noConnections(\"Activity\", activityId, \"outgoing\"));\r\n        }\r\n    };\r\n    ActivityValidation.prototype.validateActivityData = function (activity, messages) {\r\n        /**\r\n         * Validates the core data of an activity, including its name, capacity, and buffer sizes.\r\n         */\r\n        var _a;\r\n        this.log(\"Validating data for Activity ID: \".concat(activity.id));\r\n        if (!((_a = activity.name) === null || _a === void 0 ? void 0 : _a.trim())) {\r\n            this.log(\"Activity ID \".concat(activity.id, \" has a missing name.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.missingName(\"Activity\", activity.id));\r\n        }\r\n        if (typeof activity.capacity !== \"number\" || activity.capacity < 1) {\r\n            this.log(\"Activity ID \".concat(activity.id, \" has an invalid capacity: \").concat(activity.capacity));\r\n            messages.push(ValidationMessages_1.ValidationMessages.invalidCapacity(\"Activity\", activity.id));\r\n        }\r\n        this.validateBufferCapacities(activity, messages);\r\n        this.validateOperationSteps(activity, messages);\r\n    };\r\n    ActivityValidation.prototype.validateBufferCapacities = function (activity, messages) {\r\n        /**\r\n         * Validates the input and output buffer capacities of an activity.\r\n         */\r\n        this.log(\"Validating buffer capacities for Activity ID: \".concat(activity.id));\r\n        if (typeof activity.inputBufferCapacity !== \"number\" || activity.inputBufferCapacity < 0) {\r\n            this.log(\"Activity ID \".concat(activity.id, \" has an invalid input buffer capacity: \").concat(activity.inputBufferCapacity));\r\n            messages.push(ValidationMessages_1.ValidationMessages.invalidBufferCapacity(\"Activity\", activity.id, \"input\"));\r\n        }\r\n        else if (activity.inputBufferCapacity > ActivityValidation.MAX_BUFFER_SIZE) {\r\n            this.log(\"Activity ID \".concat(activity.id, \" has a large input buffer capacity: \").concat(activity.inputBufferCapacity));\r\n            messages.push(ValidationMessages_1.ValidationMessages.largeBufferCapacity(\"Activity\", activity.id, \"input\"));\r\n        }\r\n        if (typeof activity.outputBufferCapacity !== \"number\" || activity.outputBufferCapacity < 0) {\r\n            this.log(\"Activity ID \".concat(activity.id, \" has an invalid output buffer capacity: \").concat(activity.outputBufferCapacity));\r\n            messages.push(ValidationMessages_1.ValidationMessages.invalidBufferCapacity(\"Activity\", activity.id, \"output\"));\r\n        }\r\n        else if (activity.outputBufferCapacity > ActivityValidation.MAX_BUFFER_SIZE) {\r\n            this.log(\"Activity ID \".concat(activity.id, \" has a large output buffer capacity: \").concat(activity.outputBufferCapacity));\r\n            messages.push(ValidationMessages_1.ValidationMessages.largeBufferCapacity(\"Activity\", activity.id, \"output\"));\r\n        }\r\n    };\r\n    ActivityValidation.prototype.validateOperationSteps = function (activity, messages) {\r\n        /**\r\n         * Validates the operation steps defined for an activity.\r\n         */\r\n        var _this = this;\r\n        this.log(\"Validating operation steps for Activity ID: \".concat(activity.id));\r\n        if (!Array.isArray(activity.operationSteps)) {\r\n            this.log(\"Activity ID \".concat(activity.id, \" has no operation steps defined.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.missingOperationSteps(activity.id));\r\n            return;\r\n        }\r\n        if (activity.operationSteps.length === 0) {\r\n            this.log(\"Activity ID \".concat(activity.id, \" has an empty operation step list.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.noOperationSteps(activity.id));\r\n            return;\r\n        }\r\n        activity.operationSteps.forEach(function (step, index) {\r\n            _this.validateOperationStep(activity.id, step, index, messages);\r\n        });\r\n    };\r\n    ActivityValidation.prototype.validateOperationStep = function (activityId, step, index, messages) {\r\n        var _a;\r\n        this.log(\"Validating operation step \".concat(index + 1, \" for Activity ID: \").concat(activityId));\r\n        // Validate duration\r\n        if (!((_a = step.duration) === null || _a === void 0 ? void 0 : _a.durationLength)) {\r\n            this.log(\"Operation step \".concat(index + 1, \" for Activity ID \").concat(activityId, \" has an invalid duration.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.invalidStepDuration(activityId, index + 1));\r\n        }\r\n        else {\r\n            var duration = step.duration.durationLength;\r\n            if (duration < ActivityValidation.MIN_CYCLE_TIME || duration > ActivityValidation.MAX_CYCLE_TIME) {\r\n                this.log(\"Operation step \".concat(index + 1, \" for Activity ID \").concat(activityId, \" has an unusual duration: \").concat(duration));\r\n                messages.push(ValidationMessages_1.ValidationMessages.unusualStepDuration(activityId, index + 1, duration));\r\n            }\r\n        }\r\n        // Validate resource requirement\r\n        if (step.requirementId) {\r\n            this.validateResourceRequirement(activityId, step.requirementId, step.quantity, index, messages);\r\n        }\r\n    };\r\n    ActivityValidation.prototype.validateResourceRequirement = function (activityId, requirementId, quantity, stepIndex, messages) {\r\n        // You might want to pass ModelDefinitionState to this method to look up requirements\r\n        if (quantity < 1) {\r\n            messages.push({\r\n                type: 'error',\r\n                message: \"Operation step \".concat(stepIndex + 1, \" has invalid quantity: \").concat(quantity),\r\n                elementId: activityId\r\n            });\r\n        }\r\n    };\r\n    ActivityValidation.prototype.validateOperationSequence = function (activity, state, messages) {\r\n        var _a, _b;\r\n        this.log(\"Validating operation sequence for Activity ID: \".concat(activity.id));\r\n        if (!((_a = activity.operationSteps) === null || _a === void 0 ? void 0 : _a.length))\r\n            return;\r\n        var resourceRequirements = ((_b = state.modelDefinition.resourceRequirements) === null || _b === void 0 ? void 0 : _b.getAll()) || [];\r\n        var requirementMap = new Map(resourceRequirements.map(function (req) { return [req.id, req]; }));\r\n        var hasResourceRequest = false;\r\n        activity.operationSteps.forEach(function (step) {\r\n            if (step.requirementId) {\r\n                var requirement = requirementMap.get(step.requirementId);\r\n                if (requirement && requirement.rootClauses) {\r\n                    requirement.rootClauses.forEach(function (clause) {\r\n                        if (clause && clause.requests.length > 0) {\r\n                            hasResourceRequest = true;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        });\r\n        if (hasResourceRequest) {\r\n            this.log(\"Resource requests detected but no release logic for Activity ID: \".concat(activity.id));\r\n            messages.push(ValidationMessages_1.ValidationMessages.resourceLeak(activity.id));\r\n        }\r\n    };\r\n    ActivityValidation.prototype.validateBufferConstraints = function (activity, state, messages) {\r\n        this.log(\"Validating buffer constraints for Activity ID: \".concat(activity.id));\r\n        var relationships = state.activityRelationships.get(activity.id);\r\n        if (!relationships)\r\n            return;\r\n        var incomingCapacity = Array.from(relationships.incomingConnectors).reduce(function (total, connectorId) {\r\n            var connector = state.connections.get(connectorId);\r\n            if (connector) {\r\n                var sourceActivity = state.modelDefinition.activities.get(connector.sourceId);\r\n                if (sourceActivity) {\r\n                    total += sourceActivity.capacity;\r\n                }\r\n            }\r\n            return total;\r\n        }, 0);\r\n        if (incomingCapacity > activity.inputBufferCapacity * 2) {\r\n            this.log(\"Activity ID \".concat(activity.id, \" has insufficient input buffer capacity.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.smallInputBuffer(activity.id));\r\n        }\r\n    };\r\n    ActivityValidation.prototype.validateActivityInteractions = function (state, messages) {\r\n        /**\r\n         * Validates interactions among activities to detect deadlocks or circular dependencies.\r\n         */\r\n        var _this = this;\r\n        this.log(\"Validating activity interactions for potential deadlocks.\");\r\n        var activities = state.modelDefinition.activities.getAll();\r\n        var visited = new Set();\r\n        var stack = new Set();\r\n        activities.forEach(function (activity) {\r\n            if (!visited.has(activity.id)) {\r\n                _this.detectCycles(activity.id, state, visited, stack, messages);\r\n            }\r\n        });\r\n    };\r\n    ActivityValidation.prototype.detectCycles = function (activityId, state, visited, stack, messages) {\r\n        /**\r\n         * Detects cycles within the activity graph.\r\n         */\r\n        var _this = this;\r\n        visited.add(activityId);\r\n        stack.add(activityId);\r\n        var relationships = state.activityRelationships.get(activityId);\r\n        if (relationships) {\r\n            relationships.outgoingConnectors.forEach(function (connectorId) {\r\n                var connector = state.connections.get(connectorId);\r\n                if (connector) {\r\n                    var targetId = connector.targetId;\r\n                    if (!visited.has(targetId)) {\r\n                        _this.detectCycles(targetId, state, visited, stack, messages);\r\n                    }\r\n                    else if (stack.has(targetId)) {\r\n                        _this.log(\"Circular dependency detected involving Activity ID \".concat(activityId));\r\n                        messages.push(ValidationMessages_1.ValidationMessages.circularDependency(activityId));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        stack.delete(activityId);\r\n    };\r\n    ActivityValidation.MAX_BUFFER_SIZE = 10000;\r\n    ActivityValidation.MIN_CYCLE_TIME = 0.001;\r\n    ActivityValidation.MAX_CYCLE_TIME = 86400; // 24 hours in seconds\r\n    return ActivityValidation;\r\n}(ValidationRule_1.ValidationRule));\r\nexports.ActivityValidation = ActivityValidation;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/validation/rules/ActivityValidation.js?");

/***/ }),

/***/ "../../shared/dist/validation/rules/ConnectorValidation.js":
/*!*****************************************************************!*\
  !*** ../../shared/dist/validation/rules/ConnectorValidation.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ConnectorValidation = void 0;\r\nvar ValidationRule_1 = __webpack_require__(/*! ../common/ValidationRule */ \"../../shared/dist/validation/common/ValidationRule.js\");\r\nvar ValidationMessages_1 = __webpack_require__(/*! ../common/ValidationMessages */ \"../../shared/dist/validation/common/ValidationMessages.js\");\r\nvar ConnectType_1 = __webpack_require__(/*! ../../types/elements/ConnectType */ \"../../shared/dist/types/elements/ConnectType.js\");\r\nvar ConnectorValidation = /** @class */ (function (_super) {\r\n    __extends(ConnectorValidation, _super);\r\n    function ConnectorValidation() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ConnectorValidation.prototype.validate = function (state, messages) {\r\n        var _this = this;\r\n        var connectors = state.modelDefinition.connectors.getAll();\r\n        var connectorsBySource = this.groupConnectorsBySource(connectors);\r\n        this.log(\"Starting validation of individual connectors.\");\r\n        connectors.forEach(function (connector) {\r\n            _this.validateConnectorEndpoints(connector, state, messages);\r\n            _this.validateConnectorData(connector, messages);\r\n            _this.validateConnectorType(connector, messages);\r\n        });\r\n        this.log(\"Validating probability distributions for connector groups.\");\r\n        connectorsBySource.forEach(function (sourceConnectors, sourceId) {\r\n            _this.validateProbabilityGroup(sourceId, sourceConnectors, messages);\r\n        });\r\n        this.log(\"Detecting circular references in connectors.\");\r\n        this.detectCircularReferences(state, messages);\r\n        this.log(\"Completed validation of connectors.\");\r\n    };\r\n    ConnectorValidation.prototype.groupConnectorsBySource = function (connectors) {\r\n        var groups = new Map();\r\n        connectors.forEach(function (connector) {\r\n            var sourceConnectors = groups.get(connector.sourceId) || [];\r\n            sourceConnectors.push(connector);\r\n            groups.set(connector.sourceId, sourceConnectors);\r\n        });\r\n        return groups;\r\n    };\r\n    ConnectorValidation.prototype.validateConnectorEndpoints = function (connector, state, messages) {\r\n        /**\r\n         * Validates that the endpoints of a connector (source and target) are valid.\r\n         */\r\n        this.log(\"Validating endpoints for Connector ID: \".concat(connector.id));\r\n        var sourceActivity = state.modelDefinition.activities.get(connector.sourceId);\r\n        var sourceGenerator = state.modelDefinition.generators.get(connector.sourceId);\r\n        if (!sourceActivity && !sourceGenerator) {\r\n            this.log(\"Connector ID \".concat(connector.id, \" has an invalid source ID: \").concat(connector.sourceId));\r\n            messages.push(ValidationMessages_1.ValidationMessages.invalidConnection(connector.id, 'source', connector.sourceId));\r\n        }\r\n        var targetActivity = state.modelDefinition.activities.get(connector.targetId);\r\n        if (!targetActivity) {\r\n            this.log(\"Connector ID \".concat(connector.id, \" has an invalid target ID: \").concat(connector.targetId));\r\n            messages.push(ValidationMessages_1.ValidationMessages.invalidConnection(connector.id, 'target', connector.targetId));\r\n        }\r\n        if (connector.sourceId === connector.targetId) {\r\n            this.log(\"Connector ID \".concat(connector.id, \" is self-referencing.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.isolatedElement('Connector', connector.id));\r\n        }\r\n    };\r\n    ConnectorValidation.prototype.validateConnectorData = function (connector, messages) {\r\n        /**\r\n         * Validates the data properties of a connector, including name, probability, and operation steps.\r\n         */\r\n        var _this = this;\r\n        this.log(\"Validating data for Connector ID: \".concat(connector.id));\r\n        if (!connector.name || connector.name.trim().length === 0) {\r\n            this.log(\"Connector ID \".concat(connector.id, \" has a missing name.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.missingName('Connector', connector.id));\r\n        }\r\n        if (typeof connector.probability !== 'number' ||\r\n            connector.probability < 0 ||\r\n            connector.probability > 1) {\r\n            this.log(\"Connector ID \".concat(connector.id, \" has an invalid probability: \").concat(connector.probability));\r\n            messages.push({\r\n                type: 'error',\r\n                message: \"Connector \".concat(connector.id, \" has invalid probability (must be between 0 and 1)\"),\r\n                elementId: connector.id\r\n            });\r\n        }\r\n        if (connector.operationSteps && connector.operationSteps.length > 0) {\r\n            connector.operationSteps.forEach(function (step, index) {\r\n                if (!step.duration) {\r\n                    _this.log(\"Connector ID \".concat(connector.id, \" operation step \").concat(index + 1, \" has no duration.\"));\r\n                    messages.push({\r\n                        type: 'error',\r\n                        message: \"Connector \".concat(connector.id, \" operation step \").concat(index + 1, \" has no duration specified\"),\r\n                        elementId: connector.id\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    };\r\n    ConnectorValidation.prototype.validateConnectorType = function (connector, messages) {\r\n        /**\r\n         * Validates the type of the connector to ensure it is a valid `ConnectType`.\r\n         */\r\n        this.log(\"Validating type for Connector ID: \".concat(connector.id));\r\n        if (!Object.values(ConnectType_1.ConnectType).includes(connector.connectType)) {\r\n            this.log(\"Connector ID \".concat(connector.id, \" has an invalid connect type: \").concat(connector.connectType));\r\n            messages.push({\r\n                type: 'error',\r\n                message: \"Connector \".concat(connector.id, \" has invalid connect type: \").concat(connector.connectType),\r\n                elementId: connector.id\r\n            });\r\n        }\r\n    };\r\n    ConnectorValidation.prototype.validateProbabilityGroup = function (sourceId, connectors, messages) {\r\n        /**\r\n         * Validates the probability distribution of connectors originating from the same source.\r\n         */\r\n        this.log(\"Validating probability group for Source ID: \".concat(sourceId));\r\n        var probabilityConnectors = connectors.filter(function (c) { return c.connectType === ConnectType_1.ConnectType.Probability; });\r\n        if (probabilityConnectors.length > 0) {\r\n            var totalProbability = probabilityConnectors.reduce(function (sum, connector) { return sum + connector.probability; }, 0);\r\n            if (Math.abs(totalProbability - 1.0) > ConnectorValidation.PROBABILITY_TOLERANCE) {\r\n                this.log(\"Probability sum for Source ID \".concat(sourceId, \" is invalid: \").concat(totalProbability.toFixed(4)));\r\n                messages.push({\r\n                    type: 'error',\r\n                    message: \"Outgoing connection probabilities from activity \".concat(sourceId, \" sum to \").concat(totalProbability.toFixed(4), \" (should be 1.0)\"),\r\n                    elementId: sourceId\r\n                });\r\n            }\r\n        }\r\n        if (connectors.length > ConnectorValidation.MAX_OUTGOING_CONNECTIONS) {\r\n            this.log(\"Source ID \".concat(sourceId, \" has too many outgoing connections: \").concat(connectors.length));\r\n            messages.push({\r\n                type: 'warning',\r\n                message: \"Activity \".concat(sourceId, \" has unusually high number of outgoing connections (\").concat(connectors.length, \")\"),\r\n                elementId: sourceId\r\n            });\r\n        }\r\n    };\r\n    ConnectorValidation.prototype.detectCircularReferences = function (state, messages) {\r\n        /**\r\n         * Detects circular references in the graph of connectors.\r\n         */\r\n        var _this = this;\r\n        this.log(\"Detecting circular references in connectors.\");\r\n        var visited = new Set();\r\n        var stack = new Set();\r\n        var detectCycle = function (nodeId, path) {\r\n            if (path === void 0) { path = []; }\r\n            if (stack.has(nodeId)) {\r\n                _this.log(\"Circular reference detected: \".concat(__spreadArray(__spreadArray([], path, true), [nodeId], false).join(' -> ')));\r\n                messages.push({\r\n                    type: 'warning',\r\n                    message: \"Circular reference detected: \".concat(__spreadArray(__spreadArray([], path, true), [nodeId], false).join(' -> ')),\r\n                    elementId: nodeId\r\n                });\r\n                return true;\r\n            }\r\n            if (visited.has(nodeId))\r\n                return false;\r\n            visited.add(nodeId);\r\n            stack.add(nodeId);\r\n            var outgoingConnectors = state.modelDefinition.connectors.getAll()\r\n                .filter(function (c) { return c.sourceId === nodeId; });\r\n            for (var _i = 0, outgoingConnectors_1 = outgoingConnectors; _i < outgoingConnectors_1.length; _i++) {\r\n                var connector = outgoingConnectors_1[_i];\r\n                if (detectCycle(connector.targetId, __spreadArray(__spreadArray([], path, true), [nodeId], false))) {\r\n                    return true;\r\n                }\r\n            }\r\n            stack.delete(nodeId);\r\n            return false;\r\n        };\r\n        state.modelDefinition.activities.getAll().forEach(function (activity) {\r\n            if (!visited.has(activity.id)) {\r\n                detectCycle(activity.id);\r\n            }\r\n        });\r\n    };\r\n    ConnectorValidation.PROBABILITY_TOLERANCE = 0.0001;\r\n    ConnectorValidation.MAX_OUTGOING_CONNECTIONS = 20;\r\n    return ConnectorValidation;\r\n}(ValidationRule_1.ValidationRule));\r\nexports.ConnectorValidation = ConnectorValidation;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/validation/rules/ConnectorValidation.js?");

/***/ }),

/***/ "../../shared/dist/validation/rules/ElementCountsValidation.js":
/*!*********************************************************************!*\
  !*** ../../shared/dist/validation/rules/ElementCountsValidation.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ElementCountsValidation = void 0;\r\nvar ValidationRule_1 = __webpack_require__(/*! ../common/ValidationRule */ \"../../shared/dist/validation/common/ValidationRule.js\");\r\n/**\r\n * Validates basic element counts and requirements.\r\n */\r\nvar ElementCountsValidation = /** @class */ (function (_super) {\r\n    __extends(ElementCountsValidation, _super);\r\n    function ElementCountsValidation() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ElementCountsValidation.prototype.validate = function (state, messages) {\r\n        var modelDefinition = state.modelDefinition;\r\n        this.log(\"Starting validation of element counts.\");\r\n        if (modelDefinition.generators.size() === 0) {\r\n            this.log(\"Validation failed: Model has no generators.\");\r\n            messages.push({\r\n                type: 'error',\r\n                message: 'Model must have at least one generator'\r\n            });\r\n        }\r\n        if (modelDefinition.activities.size() === 0) {\r\n            this.log(\"Validation failed: Model has no activities.\");\r\n            messages.push({\r\n                type: 'error',\r\n                message: 'Model must have at least one activity'\r\n            });\r\n        }\r\n        // if (modelDefinition.resources.size() === 0) {\r\n        //     this.log(\"Validation warning: Model has no resources defined.\");\r\n        //     messages.push({\r\n        //         type: 'warning',\r\n        //         message: 'Model has no resources defined'\r\n        //     });\r\n        // }\r\n        if (modelDefinition.entities.size() === 0) {\r\n            this.log(\"Validation failed: Model has no entities.\");\r\n            messages.push({\r\n                type: 'error',\r\n                message: 'Model must have at least one entity'\r\n            });\r\n        }\r\n        this.log(\"Completed validation of element counts.\");\r\n    };\r\n    return ElementCountsValidation;\r\n}(ValidationRule_1.ValidationRule));\r\nexports.ElementCountsValidation = ElementCountsValidation;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/validation/rules/ElementCountsValidation.js?");

/***/ }),

/***/ "../../shared/dist/validation/rules/EntityValidation.js":
/*!**************************************************************!*\
  !*** ../../shared/dist/validation/rules/EntityValidation.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EntityValidation = void 0;\r\nvar ValidationRule_1 = __webpack_require__(/*! ../common/ValidationRule */ \"../../shared/dist/validation/common/ValidationRule.js\");\r\nvar ValidationMessages_1 = __webpack_require__(/*! ../common/ValidationMessages */ \"../../shared/dist/validation/common/ValidationMessages.js\");\r\nvar EntityValidation = /** @class */ (function (_super) {\r\n    __extends(EntityValidation, _super);\r\n    function EntityValidation() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    EntityValidation.prototype.validate = function (state, messages) {\r\n        var _this = this;\r\n        var entities = state.modelDefinition.entities.getAll();\r\n        this.log(\"Starting validation of entities.\");\r\n        // Check if there's at least one entity defined\r\n        if (entities.length === 0) {\r\n            this.log(\"Validation failed: No entities defined.\");\r\n            messages.push(ValidationMessages_1.ValidationMessages.missingRequiredElement('entity'));\r\n            return;\r\n        }\r\n        // Validate each entity\r\n        entities.forEach(function (entity) {\r\n            _this.validateEntityData(entity, messages);\r\n            _this.validateEntityUsage(entity, state, messages);\r\n        });\r\n        this.log(\"Completed validation of entities.\");\r\n    };\r\n    EntityValidation.prototype.validateEntityData = function (entity, messages) {\r\n        /**\r\n         * Validates the basic data properties of an entity.\r\n         */\r\n        this.log(\"Validating data for Entity ID: \".concat(entity.id));\r\n        if (!entity.name || entity.name.trim().length === 0) {\r\n            this.log(\"Entity ID \".concat(entity.id, \" has a missing name.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.missingName('Entity', entity.id));\r\n        }\r\n        if (!entity.id || entity.id.trim().length === 0) {\r\n            this.log(\"Entity ID \".concat(entity.id, \" has missing or invalid ID.\"));\r\n            messages.push({\r\n                type: 'error',\r\n                message: \"Entity has missing or invalid ID\",\r\n                elementId: entity.id\r\n            });\r\n        }\r\n        if (entity.name === 'New Entity') {\r\n            this.log(\"Entity ID \".concat(entity.id, \" is using the default name.\"));\r\n            messages.push({\r\n                type: 'warning',\r\n                message: \"Entity \".concat(entity.id, \" is using default name\"),\r\n                elementId: entity.id\r\n            });\r\n        }\r\n    };\r\n    EntityValidation.prototype.validateEntityUsage = function (entity, state, messages) {\r\n        /**\r\n         * Validates the usage of an entity within the model.\r\n         */\r\n        this.log(\"Validating usage for Entity ID: \".concat(entity.id));\r\n        var isUsedByGenerator = state.modelDefinition.generators.getAll()\r\n            .some(function (generator) { return generator.entityId === entity.id; });\r\n        if (!isUsedByGenerator) {\r\n            this.log(\"Entity ID \".concat(entity.id, \" is not used by any generator.\"));\r\n            messages.push({\r\n                type: 'warning',\r\n                message: \"Entity \".concat(entity.id, \" is not used by any generator\"),\r\n                elementId: entity.id\r\n            });\r\n        }\r\n        var entities = state.modelDefinition.entities.getAll();\r\n        var duplicateNames = entities.filter(function (e) {\r\n            return e.id !== entity.id && e.name.trim().toLowerCase() === entity.name.trim().toLowerCase();\r\n        });\r\n        if (duplicateNames.length > 0) {\r\n            this.log(\"Entity ID \".concat(entity.id, \" has a name conflict with other entities.\"));\r\n            messages.push({\r\n                type: 'warning',\r\n                message: \"Entity \".concat(entity.id, \" has a name that conflicts with other entities\"),\r\n                elementId: entity.id\r\n            });\r\n        }\r\n    };\r\n    return EntityValidation;\r\n}(ValidationRule_1.ValidationRule));\r\nexports.EntityValidation = EntityValidation;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/validation/rules/EntityValidation.js?");

/***/ }),

/***/ "../../shared/dist/validation/rules/GeneratorValidation.js":
/*!*****************************************************************!*\
  !*** ../../shared/dist/validation/rules/GeneratorValidation.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GeneratorValidation = void 0;\r\nvar ValidationRule_1 = __webpack_require__(/*! ../common/ValidationRule */ \"../../shared/dist/validation/common/ValidationRule.js\");\r\nvar ValidationMessages_1 = __webpack_require__(/*! ../common/ValidationMessages */ \"../../shared/dist/validation/common/ValidationMessages.js\");\r\nvar GeneratorValidation = /** @class */ (function (_super) {\r\n    __extends(GeneratorValidation, _super);\r\n    function GeneratorValidation() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    GeneratorValidation.prototype.validate = function (state, messages) {\r\n        var _this = this;\r\n        var generators = state.modelDefinition.generators.getAll();\r\n        generators.forEach(function (generator) {\r\n            _this.validateGeneratorConnectivity(generator, state, messages);\r\n            _this.validateGeneratorData(generator, state, messages);\r\n            _this.validateDurationSettings(generator, messages);\r\n            _this.validateEntitySettings(generator, state, messages);\r\n        });\r\n        this.validateGeneratorInteractions(generators, messages);\r\n    };\r\n    GeneratorValidation.prototype.validateGeneratorConnectivity = function (generator, state, messages) {\r\n        /**\r\n         * Validates the connectivity of a Generator to ensure it has at least one outgoing connection.\r\n         * Logs the validation process and any connectivity issues if logging is enabled.\r\n         */\r\n        this.log(\"Starting connectivity validation for Generator ID: \".concat(generator.id, \", Name: \").concat(generator.name));\r\n        // Check for outgoing connections using the connections map\r\n        var hasOutgoingConnections = Array.from(state.connections.values())\r\n            .some(function (connection) { return connection.sourceId === generator.id; });\r\n        if (!hasOutgoingConnections) {\r\n            this.log(\"Validation failed: Generator ID \".concat(generator.id, \" has no outgoing connections.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.isolatedElement('Generator', generator.id));\r\n        }\r\n        else {\r\n            this.log(\"Validation passed: Generator ID \".concat(generator.id, \" has outgoing connections.\"));\r\n        }\r\n        this.log(\"Completed connectivity validation for Generator ID: \".concat(generator.id));\r\n    };\r\n    GeneratorValidation.prototype.validateGeneratorData = function (generator, state, messages) {\r\n        /**\r\n         * Validates the data properties of a given Generator.\r\n         * Ensures the Generator has a valid name, valid entities per creation,\r\n         * periodic occurrences, max entities constraints, and referenced activity key IDs exist.\r\n         */\r\n        this.log(\"Starting validation for Generator ID: \".concat(generator.id, \", Name: \").concat(generator.name));\r\n        // Validate the Generator's name\r\n        if (!generator.name || generator.name.trim().length === 0) {\r\n            this.log(\"Validation failed: Generator ID \".concat(generator.id, \" has an empty or missing name.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.missingName('Generator', generator.id));\r\n        }\r\n        // Validate entities per creation\r\n        if (typeof generator.entitiesPerCreation !== 'number' ||\r\n            generator.entitiesPerCreation < GeneratorValidation.MIN_ENTITIES_PER_CREATION ||\r\n            generator.entitiesPerCreation > GeneratorValidation.MAX_ENTITIES_PER_CREATION) {\r\n            this.log(\"Validation failed: Generator ID \".concat(generator.id, \" has invalid entitiesPerCreation (\").concat(generator.entitiesPerCreation, \").\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('entities per creation', generator.id, \"Must be between \".concat(GeneratorValidation.MIN_ENTITIES_PER_CREATION, \" and \").concat(GeneratorValidation.MAX_ENTITIES_PER_CREATION)));\r\n        }\r\n        // Validate periodic occurrences\r\n        if (generator.periodicOccurrences !== Infinity &&\r\n            (typeof generator.periodicOccurrences !== 'number' ||\r\n                generator.periodicOccurrences < GeneratorValidation.MIN_PERIODIC_OCCURRENCES)) {\r\n            this.log(\"Validation failed: Generator ID \".concat(generator.id, \" has invalid periodicOccurrences (\").concat(generator.periodicOccurrences, \").\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('periodic occurrences', generator.id, 'Must be Infinity or a number greater than 0'));\r\n        }\r\n        // Validate maxEntities\r\n        if (generator.maxEntities !== Infinity &&\r\n            (typeof generator.maxEntities !== 'number' ||\r\n                generator.maxEntities < GeneratorValidation.MIN_MAX_ENTITIES ||\r\n                generator.maxEntities > GeneratorValidation.MAX_MAX_ENTITIES)) {\r\n            this.log(\"Validation failed: Generator ID \".concat(generator.id, \" has invalid maxEntities (\").concat(generator.maxEntities, \").\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('maximum entities limit', generator.id, \"Must be Infinity or between \".concat(GeneratorValidation.MIN_MAX_ENTITIES, \" and \").concat(GeneratorValidation.MAX_MAX_ENTITIES)));\r\n        }\r\n        this.log(\"Completed validation for Generator ID: \".concat(generator.id));\r\n    };\r\n    GeneratorValidation.prototype.validateDurationSettings = function (generator, messages) {\r\n        /**\r\n         * Validates the duration settings of a Generator.\r\n         * Ensures that the period interval duration and start duration are valid and logically consistent.\r\n         */\r\n        this.log(\"Starting duration settings validation for Generator ID: \".concat(generator.id));\r\n        if (!generator.periodIntervalDuration || generator.periodIntervalDuration.durationLength < 0) {\r\n            this.log(\"Validation failed: Generator ID \".concat(generator.id, \" has invalid period interval duration.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('period interval duration', generator.id, 'Must have a valid duration length'));\r\n        }\r\n        if (!generator.periodicStartDuration || generator.periodicStartDuration.durationLength < 0) {\r\n            this.log(\"Validation failed: Generator ID \".concat(generator.id, \" has invalid periodic start duration.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('periodic start duration', generator.id, 'Must have a valid duration length'));\r\n        }\r\n        // if (generator.periodIntervalDuration?.durationLength && generator.periodicStartDuration?.durationLength) {\r\n        //     if (generator.periodicStartDuration.durationLength > generator.periodIntervalDuration.durationLength) {\r\n        //         this.log(`Warning: Generator ID ${generator.id} has start duration longer than interval duration.`);\r\n        //         messages.push({\r\n        //             type: 'warning',\r\n        //             message: `Generator ${generator.id} has start duration longer than interval duration`,\r\n        //             elementId: generator.id\r\n        //         });\r\n        //     }\r\n        // }\r\n        this.log(\"Completed duration settings validation for Generator ID: \".concat(generator.id));\r\n    };\r\n    GeneratorValidation.prototype.validateEntitySettings = function (generator, state, messages) {\r\n        /**\r\n         * Validates the entity-related settings of a Generator.\r\n         * Ensures entity references exist and constraints on entity creation are valid.\r\n         */\r\n        this.log(\"Starting entity settings validation for Generator ID: \".concat(generator.id));\r\n        if (!generator.entityId) {\r\n            this.log(\"Validation failed: Generator ID \".concat(generator.id, \" does not specify an entity ID.\"));\r\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('entity reference', generator.id, 'Must specify an entity ID'));\r\n        }\r\n        else {\r\n            var entityExists = state.modelDefinition.entities.get(generator.entityId);\r\n            if (!entityExists) {\r\n                this.log(\"Validation failed: Generator ID \".concat(generator.id, \" references a non-existent entity (\").concat(generator.entityId, \").\"));\r\n                messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('entity reference', generator.id, \"References non-existent entity \".concat(generator.entityId)));\r\n            }\r\n        }\r\n        if (generator.periodicOccurrences !== Infinity && generator.maxEntities !== Infinity) {\r\n            var totalEntities = generator.periodicOccurrences * generator.entitiesPerCreation;\r\n            if (totalEntities > generator.maxEntities) {\r\n                this.log(\"Warning: Generator ID \".concat(generator.id, \" may exceed maximum entities limit.\"));\r\n                messages.push({\r\n                    type: 'warning',\r\n                    message: \"Generator \".concat(generator.id, \" may reach maximum entities limit before completing all periodic occurrences\"),\r\n                    elementId: generator.id\r\n                });\r\n            }\r\n        }\r\n        this.log(\"Completed entity settings validation for Generator ID: \".concat(generator.id));\r\n    };\r\n    GeneratorValidation.prototype.validateGeneratorInteractions = function (generators, messages) {\r\n        /**\r\n         * Validates interactions among multiple Generators.\r\n         * Checks for overlapping start times and potential system overload due to high entity generation rates.\r\n         */\r\n        var _this = this;\r\n        var _a;\r\n        this.log(\"Starting generator interactions validation.\");\r\n        var startTimes = new Map();\r\n        generators.forEach(function (generator) {\r\n            var _a;\r\n            var startTime = ((_a = generator.periodicStartDuration) === null || _a === void 0 ? void 0 : _a.durationLength) || 0;\r\n            var existingGenerators = startTimes.get(startTime) || [];\r\n            existingGenerators.push(generator);\r\n            startTimes.set(startTime, existingGenerators);\r\n        });\r\n        startTimes.forEach(function (overlappingGenerators, startTime) {\r\n            if (overlappingGenerators.length > 1) {\r\n                _this.log(\"Warning: Overlapping start times detected for Generators: \".concat(overlappingGenerators.map(function (g) { return g.id; }).join(', '), \" at time \").concat(startTime, \".\"));\r\n                messages.push({\r\n                    type: 'warning',\r\n                    message: \"Multiple generators (\".concat(overlappingGenerators.map(function (g) { return g.id; }).join(', '), \") start at the same time (\").concat(startTime, \")\"),\r\n                    elementId: overlappingGenerators[0].id\r\n                });\r\n            }\r\n        });\r\n        var totalEntitiesPerSecond = 0;\r\n        generators.forEach(function (generator) {\r\n            var _a;\r\n            if ((_a = generator.periodIntervalDuration) === null || _a === void 0 ? void 0 : _a.durationLength) {\r\n                var generatorRate = generator.entitiesPerCreation / generator.periodIntervalDuration.durationLength;\r\n                totalEntitiesPerSecond += generatorRate;\r\n            }\r\n        });\r\n        if (totalEntitiesPerSecond > 1000) {\r\n            this.log(\"Warning: High entity generation rate detected (\".concat(totalEntitiesPerSecond.toFixed(2), \" entities/second).\"));\r\n            messages.push({\r\n                type: 'warning',\r\n                message: \"High entity generation rate detected (\".concat(totalEntitiesPerSecond.toFixed(2), \" entities/second)\"),\r\n                elementId: (_a = generators[0]) === null || _a === void 0 ? void 0 : _a.id\r\n            });\r\n        }\r\n        this.log(\"Completed generator interactions validation.\");\r\n    };\r\n    // Constants for validation limits\r\n    GeneratorValidation.MIN_ENTITIES_PER_CREATION = 1;\r\n    GeneratorValidation.MAX_ENTITIES_PER_CREATION = 1000;\r\n    GeneratorValidation.MIN_PERIODIC_OCCURRENCES = 1;\r\n    GeneratorValidation.MIN_MAX_ENTITIES = 1;\r\n    GeneratorValidation.MAX_MAX_ENTITIES = 1000000;\r\n    return GeneratorValidation;\r\n}(ValidationRule_1.ValidationRule));\r\nexports.GeneratorValidation = GeneratorValidation;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/validation/rules/GeneratorValidation.js?");

/***/ }),

/***/ "../../shared/dist/validation/rules/ResourceValidation.js":
/*!****************************************************************!*\
  !*** ../../shared/dist/validation/rules/ResourceValidation.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResourceValidation = void 0;\r\nvar ValidationRule_1 = __webpack_require__(/*! ../common/ValidationRule */ \"../../shared/dist/validation/common/ValidationRule.js\");\r\nvar RequirementMode_1 = __webpack_require__(/*! ../../types/elements/RequirementMode */ \"../../shared/dist/types/elements/RequirementMode.js\");\r\nvar ResourceValidation = /** @class */ (function (_super) {\r\n    __extends(ResourceValidation, _super);\r\n    function ResourceValidation() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ResourceValidation.prototype.validate = function (state, messages) {\r\n        var _this = this;\r\n        var resources = state.modelDefinition.resources.getAll();\r\n        this.log(\"Starting validation of resources.\");\r\n        // First validate each resource's data\r\n        resources.forEach(function (resource) {\r\n            _this.validateResourceData(resource, messages);\r\n        });\r\n        // Then check resource usage across activities\r\n        this.validateResourceUsage(state, messages);\r\n        this.log(\"Completed validation of resources.\");\r\n    };\r\n    ResourceValidation.prototype.validateResourceData = function (resource, messages) {\r\n        /**\r\n         * Validates the basic properties of a resource, such as name and capacity.\r\n         */\r\n        this.log(\"Validating data for Resource ID: \".concat(resource.id));\r\n        if (!resource.name || resource.name.trim().length === 0) {\r\n            this.log(\"Resource ID \".concat(resource.id, \" has no name.\"));\r\n            messages.push({\r\n                type: 'warning',\r\n                message: \"Resource \".concat(resource.id, \" has no name\"),\r\n                elementId: resource.id\r\n            });\r\n        }\r\n        if (typeof resource.capacity !== 'number' || resource.capacity < 1) {\r\n            this.log(\"Resource ID \".concat(resource.id, \" has invalid capacity: \").concat(resource.capacity));\r\n            messages.push({\r\n                type: 'error',\r\n                message: \"Resource \".concat(resource.id, \" has invalid capacity (must be >= 1)\"),\r\n                elementId: resource.id\r\n            });\r\n        }\r\n        if (Math.floor(resource.capacity) !== resource.capacity) {\r\n            this.log(\"Resource ID \".concat(resource.id, \" has non-integer capacity: \").concat(resource.capacity));\r\n            messages.push({\r\n                type: 'error',\r\n                message: \"Resource \".concat(resource.id, \" capacity must be a whole number\"),\r\n                elementId: resource.id\r\n            });\r\n        }\r\n        if (resource.capacity > 1000000) {\r\n            this.log(\"Resource ID \".concat(resource.id, \" has unusually high capacity: \").concat(resource.capacity));\r\n            messages.push({\r\n                type: 'warning',\r\n                message: \"Resource \".concat(resource.id, \" has unusually high capacity (\").concat(resource.capacity, \")\"),\r\n                elementId: resource.id\r\n            });\r\n        }\r\n    };\r\n    ResourceValidation.prototype.validateResourceUsage = function (state, messages) {\r\n        var _this = this;\r\n        var _a;\r\n        this.log(\"Validating resource usage across activities.\");\r\n        var resources = state.modelDefinition.resources.getAll();\r\n        var activities = state.modelDefinition.activities.getAll();\r\n        var resourceRequirements = ((_a = state.modelDefinition.resourceRequirements) === null || _a === void 0 ? void 0 : _a.getAll()) || [];\r\n        var requirementMap = new Map(resourceRequirements.map(function (req) { return [req.id, req]; }));\r\n        // Resource ID -> Set of Activity IDs\r\n        var resourceUsage = new Map();\r\n        // Initialize resource usage map\r\n        resources.forEach(function (resource) {\r\n            resourceUsage.set(resource.id, new Set());\r\n        });\r\n        // Process activities and their resource requirements\r\n        activities.forEach(function (activity) {\r\n            if (activity.operationSteps) {\r\n                activity.operationSteps.forEach(function (step) {\r\n                    if (step.requirementId) {\r\n                        var requirement = requirementMap.get(step.requirementId);\r\n                        if (requirement) {\r\n                            _this.processResourceRequirement(requirement, activity, resourceUsage, messages);\r\n                        }\r\n                        else {\r\n                            messages.push({\r\n                                type: 'error',\r\n                                message: \"Invalid resource requirement reference: \".concat(step.requirementId),\r\n                                elementId: activity.id\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        // Check for unused resources\r\n        resourceUsage.forEach(function (usedByActivities, resourceId) {\r\n            if (usedByActivities.size === 0) {\r\n                _this.log(\"Resource ID \".concat(resourceId, \" is not used by any activity.\"));\r\n                messages.push({\r\n                    type: 'warning',\r\n                    message: \"Resource \".concat(resourceId, \" is not used by any activity\"),\r\n                    elementId: resourceId\r\n                });\r\n            }\r\n        });\r\n        this.checkResourceConflicts(state, resourceUsage, messages);\r\n    };\r\n    ResourceValidation.prototype.processResourceRequirement = function (requirement, activity, resourceUsage, messages) {\r\n        var _this = this;\r\n        requirement.rootClauses.forEach(function (clause) {\r\n            // Process based on requirement mode\r\n            if (clause.mode === RequirementMode_1.RequirementMode.REQUIRE_ALL) {\r\n                // All resources must be available\r\n                clause.requests.forEach(function (request) {\r\n                    _this.addResourceUsage(request.resourceId, activity, resourceUsage);\r\n                });\r\n            }\r\n            else if (clause.mode === RequirementMode_1.RequirementMode.REQUIRE_ANY) {\r\n                // At least one resource must be available\r\n                // Just mark all as potentially used, detailed conflict resolution \r\n                // will be handled in checkResourceConflicts\r\n                clause.requests.forEach(function (request) {\r\n                    _this.addResourceUsage(request.resourceId, activity, resourceUsage);\r\n                });\r\n            }\r\n        });\r\n    };\r\n    ResourceValidation.prototype.addResourceUsage = function (resourceId, activity, resourceUsage) {\r\n        var usageSet = resourceUsage.get(resourceId);\r\n        if (usageSet) {\r\n            usageSet.add(activity.id);\r\n        }\r\n        else {\r\n            this.log(\"Warning: Reference to non-existent resource ID: \".concat(resourceId));\r\n        }\r\n    };\r\n    ResourceValidation.prototype.processResourceRequests = function (requests, activity, resourceUsage, messages) {\r\n        /**\r\n         * Processes resource requests within an activity's operation steps.\r\n         */\r\n        var _this = this;\r\n        requests.forEach(function (request) {\r\n            if (request.requests) {\r\n                _this.processResourceRequests(request.requests, activity, resourceUsage, messages);\r\n                return;\r\n            }\r\n            if (request.resource) {\r\n                var resourceId = request.resource.id;\r\n                var usageSet = resourceUsage.get(resourceId);\r\n                if (usageSet) {\r\n                    usageSet.add(activity.id);\r\n                    if (typeof request.quantity !== 'number' || request.quantity < 1) {\r\n                        _this.log(\"Activity ID \".concat(activity.id, \" has invalid resource quantity for Resource ID \").concat(resourceId));\r\n                        messages.push({\r\n                            type: 'error',\r\n                            message: \"Invalid resource quantity in activity \".concat(activity.id, \" for resource \").concat(resourceId),\r\n                            elementId: activity.id\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    _this.log(\"Activity ID \".concat(activity.id, \" references non-existent Resource ID \").concat(resourceId));\r\n                    messages.push({\r\n                        type: 'error',\r\n                        message: \"Activity \".concat(activity.id, \" references non-existent resource \").concat(resourceId),\r\n                        elementId: activity.id\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    };\r\n    ResourceValidation.prototype.checkResourceConflicts = function (state, resourceUsage, messages) {\r\n        /**\r\n         * Checks for conflicts in resource usage, such as overutilization.\r\n         */\r\n        var _this = this;\r\n        this.log(\"Checking for resource usage conflicts.\");\r\n        var resources = state.modelDefinition.resources.getAll();\r\n        resources.forEach(function (resource) {\r\n            var usedByActivities = resourceUsage.get(resource.id);\r\n            if (usedByActivities && usedByActivities.size > 1) {\r\n                _this.validateConcurrentResourceUsage(state, resource, Array.from(usedByActivities), messages);\r\n            }\r\n        });\r\n    };\r\n    ResourceValidation.prototype.validateConcurrentResourceUsage = function (state, resource, activityIds, messages) {\r\n        /**\r\n         * Validates concurrent usage of a resource across multiple activities.\r\n         */\r\n        var _this = this;\r\n        this.log(\"Validating concurrent usage for Resource ID: \".concat(resource.id));\r\n        var activities = activityIds\r\n            .map(function (id) { return state.modelDefinition.activities.get(id); })\r\n            .filter(function (activity) { return activity !== undefined; });\r\n        var totalMaxPossibleDemand = 0;\r\n        activities.forEach(function (activity) {\r\n            var maxDemand = _this.calculateMaxResourceDemand(activity, resource.id);\r\n            totalMaxPossibleDemand += maxDemand;\r\n        });\r\n        if (totalMaxPossibleDemand > resource.capacity) {\r\n            this.log(\"Resource ID \".concat(resource.id, \" might be overutilized. Capacity: \").concat(resource.capacity, \", Demand: \").concat(totalMaxPossibleDemand));\r\n            messages.push({\r\n                type: 'warning',\r\n                message: \"Potential resource conflict: Resource \".concat(resource.id, \" (capacity: \").concat(resource.capacity, \") might be overutilized. Maximum possible demand: \").concat(totalMaxPossibleDemand),\r\n                elementId: resource.id\r\n            });\r\n        }\r\n    };\r\n    ResourceValidation.prototype.calculateMaxResourceDemand = function (activity, resourceId) {\r\n        /**\r\n         * Calculates the maximum possible demand for a resource by a single activity.\r\n         */\r\n        var _a;\r\n        var maxDemand = 0;\r\n        (_a = activity.operationSteps) === null || _a === void 0 ? void 0 : _a.forEach(function (step) {\r\n            var _a;\r\n            if ((_a = step.resourceSetRequest) === null || _a === void 0 ? void 0 : _a.requests) {\r\n                step.resourceSetRequest.requests.forEach(function (request) {\r\n                    var _a;\r\n                    if (((_a = request.resource) === null || _a === void 0 ? void 0 : _a.id) === resourceId) {\r\n                        maxDemand = Math.max(maxDemand, request.quantity || 0);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        return maxDemand;\r\n    };\r\n    return ResourceValidation;\r\n}(ValidationRule_1.ValidationRule));\r\nexports.ResourceValidation = ResourceValidation;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/validation/rules/ResourceValidation.js?");

/***/ }),

/***/ "../../shared/dist/validation/services/ModelValidationService.js":
/*!***********************************************************************!*\
  !*** ../../shared/dist/validation/services/ModelValidationService.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelValidationService = void 0;\r\nvar QuodsiLogger_1 = __webpack_require__(/*! ../../core/logging/QuodsiLogger */ \"../../shared/dist/core/logging/QuodsiLogger.js\");\r\nvar ValidationMessages_1 = __webpack_require__(/*! ../common/ValidationMessages */ \"../../shared/dist/validation/common/ValidationMessages.js\");\r\nvar ActivityValidation_1 = __webpack_require__(/*! ../rules/ActivityValidation */ \"../../shared/dist/validation/rules/ActivityValidation.js\");\r\nvar ConnectorValidation_1 = __webpack_require__(/*! ../rules/ConnectorValidation */ \"../../shared/dist/validation/rules/ConnectorValidation.js\");\r\nvar ElementCountsValidation_1 = __webpack_require__(/*! ../rules/ElementCountsValidation */ \"../../shared/dist/validation/rules/ElementCountsValidation.js\");\r\nvar GeneratorValidation_1 = __webpack_require__(/*! ../rules/GeneratorValidation */ \"../../shared/dist/validation/rules/GeneratorValidation.js\");\r\nvar ResourceValidation_1 = __webpack_require__(/*! ../rules/ResourceValidation */ \"../../shared/dist/validation/rules/ResourceValidation.js\");\r\nvar EntityValidation_1 = __webpack_require__(/*! ../rules/EntityValidation */ \"../../shared/dist/validation/rules/EntityValidation.js\");\r\nvar ModelValidationService = /** @class */ (function (_super) {\r\n    __extends(ModelValidationService, _super);\r\n    function ModelValidationService() {\r\n        var _this = _super.call(this) || this;\r\n        _this.LOG_PREFIX = \"[ModelValidation]\";\r\n        _this.cachedState = null;\r\n        _this.lastModelDefinitionHash = null;\r\n        _this.rules = [\r\n            new ElementCountsValidation_1.ElementCountsValidation(),\r\n            new ActivityValidation_1.ActivityValidation(),\r\n            new ConnectorValidation_1.ConnectorValidation(),\r\n            new GeneratorValidation_1.GeneratorValidation(),\r\n            new ResourceValidation_1.ResourceValidation(),\r\n            new EntityValidation_1.EntityValidation()\r\n        ];\r\n        _this.setLogging(false);\r\n        return _this;\r\n    }\r\n    ModelValidationService.prototype.validate = function (modelDefinition) {\r\n        var messages = [];\r\n        // ModelDefinitionLogger.log(modelDefinition)\r\n        try {\r\n            // Generate a hash of the model definition for cache comparison\r\n            var currentHash = this.generateModelHash(modelDefinition);\r\n            // Create or retrieve cached ModelState\r\n            var state = this.getModelState(modelDefinition, currentHash);\r\n            // Batch validate all rules\r\n            this.batchValidate(state, messages);\r\n            // Add success message if no issues found\r\n            if (messages.length === 0) {\r\n                messages.push(ValidationMessages_1.ValidationMessages.validationSuccess());\r\n            }\r\n            // Calculate validation metrics\r\n            var result = this.calculateValidationMetrics(messages);\r\n            // Log validation results\r\n            this.logValidationResults(result);\r\n            return result;\r\n        }\r\n        catch (error) {\r\n            this.logError('[ModelValidation] Validation error:', error);\r\n            return {\r\n                isValid: false,\r\n                errorCount: 1,\r\n                warningCount: 0,\r\n                messages: [ValidationMessages_1.ValidationMessages.validationError(error)]\r\n            };\r\n        }\r\n    };\r\n    /**\r\n     * Enable or disable logging for a specific validation rule by its class name.\r\n     * @param ruleName - The class name of the validation rule.\r\n     * @param enabled - True to enable logging, false to disable.\r\n     */\r\n    ModelValidationService.prototype.setRuleLogging = function (ruleName, enabled) {\r\n        var rule = this.rules.find(function (r) { return r.constructor.name === ruleName; });\r\n        if (rule) {\r\n            rule.setLogging(enabled);\r\n            this.log(\"Logging for \".concat(ruleName, \" set to \").concat(enabled));\r\n        }\r\n        else {\r\n            console.warn(\"[ModelValidationService] Validation rule \".concat(ruleName, \" not found.\"));\r\n        }\r\n    };\r\n    ModelValidationService.prototype.generateModelHash = function (modelDefinition) {\r\n        // Create a simple hash based on model contents\r\n        var activities = modelDefinition.activities.size();\r\n        var connectors = modelDefinition.connectors.size();\r\n        var resources = modelDefinition.resources.size();\r\n        var generators = modelDefinition.generators.size();\r\n        return \"\".concat(activities, \"-\").concat(connectors, \"-\").concat(resources, \"-\").concat(generators);\r\n    };\r\n    ModelValidationService.prototype.getModelState = function (modelDefinition, currentHash) {\r\n        // Reuse cached state if model hasn't changed\r\n        if (this.cachedState && this.lastModelDefinitionHash === currentHash) {\r\n            this.log(\"Model Definition hasn't changed, reusing cached validation}\");\r\n            return this.cachedState;\r\n        }\r\n        this.log(\"Model Definition has change\");\r\n        // Create new state\r\n        var state = {\r\n            modelDefinition: modelDefinition,\r\n            connections: new Map(modelDefinition.connectors.getAll().map(function (c) { return [c.id, c]; })),\r\n            activityRelationships: this.buildActivityRelationships(modelDefinition)\r\n        };\r\n        // Cache the new state\r\n        this.cachedState = state;\r\n        this.lastModelDefinitionHash = currentHash;\r\n        return state;\r\n    };\r\n    ModelValidationService.prototype.batchValidate = function (state, messages) {\r\n        var _this = this;\r\n        this.log(\"[ModelValidation] Starting batch validation.\");\r\n        // ModelDefinitionLogger.logModelDefinition(state.modelDefinition)\r\n        // Validate all rules\r\n        var validationPromises = this.rules.map(function (rule) {\r\n            return new Promise(function (resolve) {\r\n                rule.validate(state, messages);\r\n                resolve();\r\n            });\r\n        });\r\n        // Wait for all validations to complete\r\n        Promise.all(validationPromises).then(function () {\r\n            _this.log(\"[ModelValidation] Batch validation completed.\");\r\n        });\r\n    };\r\n    ModelValidationService.prototype.calculateValidationMetrics = function (messages) {\r\n        var errorCount = messages.filter(function (m) { return m.type === 'error'; }).length;\r\n        var warningCount = messages.filter(function (m) { return m.type === 'warning'; }).length;\r\n        return {\r\n            isValid: errorCount === 0,\r\n            errorCount: errorCount,\r\n            warningCount: warningCount,\r\n            messages: messages\r\n        };\r\n    };\r\n    ModelValidationService.prototype.logValidationResults = function (result) {\r\n        this.log('[ModelValidation] Validation results:', {\r\n            isValid: result.isValid,\r\n            errorCount: result.errorCount,\r\n            warningCount: result.warningCount,\r\n            messageCount: result.messages.length,\r\n            messages: result.messages\r\n        });\r\n    };\r\n    ModelValidationService.prototype.buildActivityRelationships = function (modelDefinition) {\r\n        var _a;\r\n        var relationships = new Map();\r\n        // Get resources and their requirements for lookup\r\n        var resourceRequirements = ((_a = modelDefinition.resourceRequirements) === null || _a === void 0 ? void 0 : _a.getAll()) || [];\r\n        var requirementMap = new Map(resourceRequirements.map(function (req) { return [req.id, req]; }));\r\n        // Initialize relationships map for better performance\r\n        var activities = modelDefinition.activities.getAll();\r\n        var connectors = modelDefinition.connectors.getAll();\r\n        // Pre-allocate relationships for all activities\r\n        activities.forEach(function (activity) {\r\n            relationships.set(activity.id, {\r\n                incomingConnectors: new Set(),\r\n                outgoingConnectors: new Set(),\r\n                assignedResources: new Set()\r\n            });\r\n        });\r\n        // Process connectors in batch\r\n        connectors.forEach(function (connector) {\r\n            var sourceRel = relationships.get(connector.sourceId);\r\n            var targetRel = relationships.get(connector.targetId);\r\n            if (sourceRel)\r\n                sourceRel.outgoingConnectors.add(connector.id);\r\n            if (targetRel)\r\n                targetRel.incomingConnectors.add(connector.id);\r\n        });\r\n        // Process resource assignments efficiently\r\n        activities.forEach(function (activity) {\r\n            var activityRel = relationships.get(activity.id);\r\n            if (!activityRel || !activity.operationSteps)\r\n                return;\r\n            // Process resource requirements for each operation step\r\n            activity.operationSteps.forEach(function (step) {\r\n                if (step.requirementId) {\r\n                    var requirement = requirementMap.get(step.requirementId);\r\n                    if (requirement) {\r\n                        requirement.rootClauses.forEach(function (clause) {\r\n                            clause.requests.forEach(function (request) {\r\n                                activityRel.assignedResources.add(request.resourceId);\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        return relationships;\r\n    };\r\n    return ModelValidationService;\r\n}(QuodsiLogger_1.QuodsiLogger));\r\nexports.ModelValidationService = ModelValidationService;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/validation/services/ModelValidationService.js?");

/***/ }),

/***/ "../../shared/dist/versioning/BaseVersionUpgrader.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/versioning/BaseVersionUpgrader.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BaseVersionUpgrader = void 0;\r\nvar PreflightResult_1 = __webpack_require__(/*! ./PreflightResult */ \"../../shared/dist/versioning/PreflightResult.js\");\r\n/**\r\n * Base implementation of version upgrader\r\n * Provides common functionality for platform-specific upgraders\r\n */\r\nvar BaseVersionUpgrader = /** @class */ (function () {\r\n    function BaseVersionUpgrader(currentVersion, options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.currentVersion = currentVersion;\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * Checks if source version can be upgraded to current version\r\n     */\r\n    BaseVersionUpgrader.prototype.canUpgrade = function (sourceVersion) {\r\n        // Simple version comparison for now\r\n        return sourceVersion !== this.currentVersion;\r\n    };\r\n    /**\r\n     * Performs validation check before attempting upgrade\r\n     */\r\n    BaseVersionUpgrader.prototype.preflight = function (page) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var sourceVersion, issues, baseIssues, platformIssues, hasErrors;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.getSourceVersion(page)];\r\n                    case 1:\r\n                        sourceVersion = _a.sent();\r\n                        issues = [];\r\n                        return [4 /*yield*/, this.validateBaseRequirements(page)];\r\n                    case 2:\r\n                        baseIssues = _a.sent();\r\n                        issues.push.apply(issues, baseIssues);\r\n                        return [4 /*yield*/, this.validatePlatformRequirements(page)];\r\n                    case 3:\r\n                        platformIssues = _a.sent();\r\n                        issues.push.apply(issues, platformIssues);\r\n                        hasErrors = issues.some(function (issue) { return issue.severity === PreflightResult_1.UpgradeIssueSeverity.Error; });\r\n                        return [2 /*return*/, {\r\n                                canUpgrade: !hasErrors,\r\n                                sourceVersion: sourceVersion,\r\n                                targetVersion: this.currentVersion,\r\n                                issues: issues\r\n                            }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Performs the upgrade on all elements\r\n     */\r\n    BaseVersionUpgrader.prototype.upgrade = function (page) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var preflightResult, error_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!!this.options.skipPreflight) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.preflight(page)];\r\n                    case 1:\r\n                        preflightResult = _a.sent();\r\n                        if (!preflightResult.canUpgrade) {\r\n                            throw new Error('Preflight check failed. Cannot proceed with upgrade.');\r\n                        }\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 6, , 8]);\r\n                        return [4 /*yield*/, this.beginUpgrade(page)];\r\n                    case 3:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this.performUpgrade(page)];\r\n                    case 4:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this.finalizeUpgrade(page)];\r\n                    case 5:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 8];\r\n                    case 6:\r\n                        error_1 = _a.sent();\r\n                        return [4 /*yield*/, this.rollbackUpgrade(page)];\r\n                    case 7:\r\n                        _a.sent();\r\n                        throw error_1;\r\n                    case 8: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Validates basic requirements common to all platforms\r\n     */\r\n    BaseVersionUpgrader.prototype.validateBaseRequirements = function (page) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var issues;\r\n            return __generator(this, function (_a) {\r\n                issues = [];\r\n                // Example base validation\r\n                if (!page) {\r\n                    issues.push({\r\n                        message: 'No page/document provided',\r\n                        severity: PreflightResult_1.UpgradeIssueSeverity.Error\r\n                    });\r\n                }\r\n                return [2 /*return*/, issues];\r\n            });\r\n        });\r\n    };\r\n    return BaseVersionUpgrader;\r\n}());\r\nexports.BaseVersionUpgrader = BaseVersionUpgrader;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/BaseVersionUpgrader.js?");

/***/ }),

/***/ "../../shared/dist/versioning/IVersionUpgrader.js":
/*!********************************************************!*\
  !*** ../../shared/dist/versioning/IVersionUpgrader.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/IVersionUpgrader.js?");

/***/ }),

/***/ "../../shared/dist/versioning/PreflightResult.js":
/*!*******************************************************!*\
  !*** ../../shared/dist/versioning/PreflightResult.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UpgradeIssueSeverity = void 0;\r\n/**\r\n * Represents the severity of an upgrade issue\r\n */\r\nvar UpgradeIssueSeverity;\r\n(function (UpgradeIssueSeverity) {\r\n    /** Issue prevents upgrade from proceeding */\r\n    UpgradeIssueSeverity[\"Error\"] = \"Error\";\r\n    /** Issue should be noted but doesn't prevent upgrade */\r\n    UpgradeIssueSeverity[\"Warning\"] = \"Warning\";\r\n})(UpgradeIssueSeverity = exports.UpgradeIssueSeverity || (exports.UpgradeIssueSeverity = {}));\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/PreflightResult.js?");

/***/ }),

/***/ "../../shared/dist/versioning/VersionManager.js":
/*!******************************************************!*\
  !*** ../../shared/dist/versioning/VersionManager.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.VersionManager = void 0;\r\nvar VersionUpgraderFactory_1 = __webpack_require__(/*! ./VersionUpgraderFactory */ \"../../shared/dist/versioning/VersionUpgraderFactory.js\");\r\n/**\r\n * Manages version checking and upgrading across platforms\r\n */\r\nvar VersionManager = /** @class */ (function () {\r\n    function VersionManager(platform, options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.options = options;\r\n        this.upgrader = VersionUpgraderFactory_1.VersionUpgraderFactory.createUpgrader(platform, options);\r\n    }\r\n    /**\r\n     * Checks if the provided version needs an upgrade\r\n     */\r\n    VersionManager.prototype.needsUpgrade = function (version) {\r\n        return this.upgrader.canUpgrade(version);\r\n    };\r\n    /**\r\n     * Performs preflight check for upgrade\r\n     */\r\n    VersionManager.prototype.checkUpgrade = function (page) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, this.upgrader.preflight(page)];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Performs the upgrade process\r\n     */\r\n    VersionManager.prototype.performUpgrade = function (page) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var error_1, errorMessage;\r\n            return __generator(this, function (_o) {\r\n                switch (_o.label) {\r\n                    case 0:\r\n                        _o.trys.push([0, 2, , 3]);\r\n                        (_b = (_a = this.options).onUpgradeStart) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n                        (_d = (_c = this.options).onNotify) === null || _d === void 0 ? void 0 : _d.call(_c, 'Starting upgrade process...');\r\n                        return [4 /*yield*/, this.upgrader.upgrade(page)];\r\n                    case 1:\r\n                        _o.sent();\r\n                        (_f = (_e = this.options).onUpgradeComplete) === null || _f === void 0 ? void 0 : _f.call(_e);\r\n                        (_h = (_g = this.options).onNotify) === null || _h === void 0 ? void 0 : _h.call(_g, 'Upgrade completed successfully');\r\n                        return [3 /*break*/, 3];\r\n                    case 2:\r\n                        error_1 = _o.sent();\r\n                        errorMessage = error_1 instanceof Error ? error_1.message : 'Unknown error';\r\n                        (_k = (_j = this.options).onUpgradeFailed) === null || _k === void 0 ? void 0 : _k.call(_j, error_1);\r\n                        (_m = (_l = this.options).onNotify) === null || _m === void 0 ? void 0 : _m.call(_l, \"Upgrade failed: \".concat(errorMessage));\r\n                        throw error_1;\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Gets the current version number\r\n     */\r\n    VersionManager.prototype.getCurrentVersion = function () {\r\n        return this.upgrader.currentVersion;\r\n    };\r\n    return VersionManager;\r\n}());\r\nexports.VersionManager = VersionManager;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/VersionManager.js?");

/***/ }),

/***/ "../../shared/dist/versioning/VersionUpgraderFactory.js":
/*!**************************************************************!*\
  !*** ../../shared/dist/versioning/VersionUpgraderFactory.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.VersionUpgraderFactory = void 0;\r\nvar version_1 = __webpack_require__(/*! ../constants/version */ \"../../shared/dist/constants/version.js\");\r\n/**\r\n * Factory for creating platform-specific version upgraders\r\n */\r\nvar VersionUpgraderFactory = /** @class */ (function () {\r\n    function VersionUpgraderFactory() {\r\n    }\r\n    /**\r\n     * Registers an upgrader implementation for a specific platform\r\n     */\r\n    VersionUpgraderFactory.registerUpgrader = function (platform, upgraderClass) {\r\n        this.upgraders.set(platform, upgraderClass);\r\n    };\r\n    /**\r\n     * Creates an upgrader instance for the specified platform\r\n     * @throws Error if no upgrader is registered for the platform\r\n     * @throws Error if current version is invalid\r\n     */\r\n    VersionUpgraderFactory.createUpgrader = function (platform, options) {\r\n        // Validate current version\r\n        if (!(0, version_1.isValidVersion)(version_1.QUODSI_VERSION)) {\r\n            throw new Error(\"Invalid Quodsi version: \".concat(version_1.QUODSI_VERSION));\r\n        }\r\n        var upgraderClass = this.upgraders.get(platform);\r\n        if (!upgraderClass) {\r\n            throw new Error(\"No upgrader registered for platform: \".concat(platform));\r\n        }\r\n        return new upgraderClass(version_1.QUODSI_VERSION, options);\r\n    };\r\n    /**\r\n     * Gets the current version number\r\n     */\r\n    VersionUpgraderFactory.getCurrentVersion = function () {\r\n        return version_1.QUODSI_VERSION;\r\n    };\r\n    /**\r\n     * Gets the current version info broken down into components\r\n     */\r\n    VersionUpgraderFactory.getCurrentVersionInfo = function () {\r\n        return (0, version_1.parseVersion)(version_1.QUODSI_VERSION);\r\n    };\r\n    /**\r\n     * Checks if an upgrade is needed from the source version\r\n     * @param sourceVersion The version to check\r\n     * @returns true if sourceVersion is older than current version\r\n     * @throws Error if either version is invalid\r\n     */\r\n    VersionUpgraderFactory.needsUpgrade = function (sourceVersion) {\r\n        if (!(0, version_1.isValidVersion)(sourceVersion)) {\r\n            throw new Error(\"Invalid source version: \".concat(sourceVersion));\r\n        }\r\n        if (!(0, version_1.isValidVersion)(version_1.QUODSI_VERSION)) {\r\n            throw new Error(\"Invalid Quodsi version: \".concat(version_1.QUODSI_VERSION));\r\n        }\r\n        return (0, version_1.compareVersions)(version_1.QUODSI_VERSION, sourceVersion) > 0;\r\n    };\r\n    /**\r\n     * Gets supported platforms\r\n     */\r\n    VersionUpgraderFactory.getSupportedPlatforms = function () {\r\n        return Array.from(this.upgraders.keys());\r\n    };\r\n    /**\r\n     * Checks if a platform is supported\r\n     */\r\n    VersionUpgraderFactory.isPlatformSupported = function (platform) {\r\n        return this.upgraders.has(platform);\r\n    };\r\n    VersionUpgraderFactory.upgraders = new Map();\r\n    return VersionUpgraderFactory;\r\n}());\r\nexports.VersionUpgraderFactory = VersionUpgraderFactory;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/VersionUpgraderFactory.js?");

/***/ }),

/***/ "../../shared/dist/versioning/index.js":
/*!*********************************************!*\
  !*** ../../shared/dist/versioning/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./PreflightResult */ \"../../shared/dist/versioning/PreflightResult.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./IVersionUpgrader */ \"../../shared/dist/versioning/IVersionUpgrader.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./BaseVersionUpgrader */ \"../../shared/dist/versioning/BaseVersionUpgrader.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./VersionManager */ \"../../shared/dist/versioning/VersionManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./VersionUpgraderFactory */ \"../../shared/dist/versioning/VersionUpgraderFactory.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./transformations */ \"../../shared/dist/versioning/transformations/index.js\"), exports);\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/index.js?");

/***/ }),

/***/ "../../shared/dist/versioning/transformations/ActivityTransforms.js":
/*!**************************************************************************!*\
  !*** ../../shared/dist/versioning/transformations/ActivityTransforms.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ActivityTransforms = exports.ActivityRouteType = void 0;\r\n/**\r\n * Supported routing types for activities\r\n */\r\nvar ActivityRouteType;\r\n(function (ActivityRouteType) {\r\n    ActivityRouteType[\"FIFO\"] = \"FIFO\";\r\n    ActivityRouteType[\"LIFO\"] = \"LIFO\";\r\n})(ActivityRouteType = exports.ActivityRouteType || (exports.ActivityRouteType = {}));\r\n/**\r\n * Transformations for Activity objects\r\n */\r\nexports.ActivityTransforms = {\r\n    objectType: 'Activity',\r\n    transformations: [\r\n        {\r\n            sourceVersion: '1.0.0',\r\n            targetVersion: '1.1.0',\r\n            transform: function (data) { return (__assign(__assign({}, data), { routeType: ActivityRouteType.FIFO // Add new property with default FIFO\r\n             })); }\r\n        }\r\n        // Additional transformations can be added here as versions evolve\r\n    ]\r\n};\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/transformations/ActivityTransforms.js?");

/***/ }),

/***/ "../../shared/dist/versioning/transformations/ConnectorTransforms.js":
/*!***************************************************************************!*\
  !*** ../../shared/dist/versioning/transformations/ConnectorTransforms.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ConnectorTransforms = void 0;\r\n/**\r\n * Transformations for Connector objects\r\n */\r\nexports.ConnectorTransforms = {\r\n    objectType: 'Connector',\r\n    transformations: [\r\n        {\r\n            sourceVersion: '1.0.0',\r\n            targetVersion: '1.1.0',\r\n            transform: function (data) { return (__assign(__assign({}, data), { logic: null // Add new property for Python script, initially null\r\n             })); }\r\n        }\r\n        // Additional transformations can be added here as versions evolve\r\n    ]\r\n};\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/transformations/ConnectorTransforms.js?");

/***/ }),

/***/ "../../shared/dist/versioning/transformations/EntityTransforms.js":
/*!************************************************************************!*\
  !*** ../../shared/dist/versioning/transformations/EntityTransforms.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EntityTransforms = void 0;\r\n/**\r\n * Transformations for Entity objects\r\n */\r\nexports.EntityTransforms = {\r\n    objectType: 'Entity',\r\n    transformations: [\r\n        {\r\n            sourceVersion: '1.0.0',\r\n            targetVersion: '1.1.0',\r\n            transform: function (data) { return (__assign({}, data\r\n            // No changes in this version, but structure is ready for future updates\r\n            )); }\r\n        }\r\n    ]\r\n};\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/transformations/EntityTransforms.js?");

/***/ }),

/***/ "../../shared/dist/versioning/transformations/GeneratorTransforms.js":
/*!***************************************************************************!*\
  !*** ../../shared/dist/versioning/transformations/GeneratorTransforms.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GeneratorTransforms = void 0;\r\n/**\r\n * Transformations for Generator objects\r\n */\r\nexports.GeneratorTransforms = {\r\n    objectType: 'Generator',\r\n    transformations: [\r\n        {\r\n            sourceVersion: '1.0.0',\r\n            targetVersion: '1.1.0',\r\n            transform: function (data) { return (__assign({}, data\r\n            // No changes in this version, but structure is ready for future updates\r\n            )); }\r\n        }\r\n    ]\r\n};\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/transformations/GeneratorTransforms.js?");

/***/ }),

/***/ "../../shared/dist/versioning/transformations/ModelTransforms.js":
/*!***********************************************************************!*\
  !*** ../../shared/dist/versioning/transformations/ModelTransforms.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelTransforms = void 0;\r\n/**\r\n * Transformations for Model (ModelDefinition) objects\r\n */\r\nexports.ModelTransforms = {\r\n    objectType: 'Model',\r\n    transformations: [\r\n        {\r\n            sourceVersion: '1.0.0',\r\n            targetVersion: '1.1.0',\r\n            transform: function (data) { return (__assign({}, data\r\n            // No changes in this version, but structure is ready for future updates\r\n            )); }\r\n        }\r\n    ]\r\n};\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/transformations/ModelTransforms.js?");

/***/ }),

/***/ "../../shared/dist/versioning/transformations/ResourceTransforms.js":
/*!**************************************************************************!*\
  !*** ../../shared/dist/versioning/transformations/ResourceTransforms.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResourceTransforms = void 0;\r\n/**\r\n * Transformations for Resource objects\r\n */\r\nexports.ResourceTransforms = {\r\n    objectType: 'Resource',\r\n    transformations: [\r\n        {\r\n            sourceVersion: '1.0.0',\r\n            targetVersion: '1.1.0',\r\n            transform: function (data) { return (__assign({}, data\r\n            // No changes in this version, but structure is ready for future updates\r\n            )); }\r\n        }\r\n    ]\r\n};\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/transformations/ResourceTransforms.js?");

/***/ }),

/***/ "../../shared/dist/versioning/transformations/TransformationTypes.js":
/*!***************************************************************************!*\
  !*** ../../shared/dist/versioning/transformations/TransformationTypes.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.TransformationError = void 0;\r\n/**\r\n * Error thrown when transformation fails\r\n */\r\nvar TransformationError = /** @class */ (function (_super) {\r\n    __extends(TransformationError, _super);\r\n    function TransformationError(message, objectType, sourceVersion, targetVersion, originalError) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.objectType = objectType;\r\n        _this.sourceVersion = sourceVersion;\r\n        _this.targetVersion = targetVersion;\r\n        _this.originalError = originalError;\r\n        _this.name = 'TransformationError';\r\n        return _this;\r\n    }\r\n    return TransformationError;\r\n}(Error));\r\nexports.TransformationError = TransformationError;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/transformations/TransformationTypes.js?");

/***/ }),

/***/ "../../shared/dist/versioning/transformations/index.js":
/*!*************************************************************!*\
  !*** ../../shared/dist/versioning/transformations/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getTransformationsBetweenVersions = exports.getTransformations = exports.AllTransformations = void 0;\r\n__exportStar(__webpack_require__(/*! ./TransformationTypes */ \"../../shared/dist/versioning/transformations/TransformationTypes.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ActivityTransforms */ \"../../shared/dist/versioning/transformations/ActivityTransforms.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ConnectorTransforms */ \"../../shared/dist/versioning/transformations/ConnectorTransforms.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./EntityTransforms */ \"../../shared/dist/versioning/transformations/EntityTransforms.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./GeneratorTransforms */ \"../../shared/dist/versioning/transformations/GeneratorTransforms.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ResourceTransforms */ \"../../shared/dist/versioning/transformations/ResourceTransforms.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ModelTransforms */ \"../../shared/dist/versioning/transformations/ModelTransforms.js\"), exports);\r\nvar ActivityTransforms_1 = __webpack_require__(/*! ./ActivityTransforms */ \"../../shared/dist/versioning/transformations/ActivityTransforms.js\");\r\nvar ConnectorTransforms_1 = __webpack_require__(/*! ./ConnectorTransforms */ \"../../shared/dist/versioning/transformations/ConnectorTransforms.js\");\r\nvar EntityTransforms_1 = __webpack_require__(/*! ./EntityTransforms */ \"../../shared/dist/versioning/transformations/EntityTransforms.js\");\r\nvar GeneratorTransforms_1 = __webpack_require__(/*! ./GeneratorTransforms */ \"../../shared/dist/versioning/transformations/GeneratorTransforms.js\");\r\nvar ResourceTransforms_1 = __webpack_require__(/*! ./ResourceTransforms */ \"../../shared/dist/versioning/transformations/ResourceTransforms.js\");\r\nvar ModelTransforms_1 = __webpack_require__(/*! ./ModelTransforms */ \"../../shared/dist/versioning/transformations/ModelTransforms.js\");\r\n/**\r\n * Collection of all available transformations\r\n */\r\nexports.AllTransformations = [\r\n    ModelTransforms_1.ModelTransforms,\r\n    ActivityTransforms_1.ActivityTransforms,\r\n    ConnectorTransforms_1.ConnectorTransforms,\r\n    EntityTransforms_1.EntityTransforms,\r\n    GeneratorTransforms_1.GeneratorTransforms,\r\n    ResourceTransforms_1.ResourceTransforms\r\n];\r\n/**\r\n * Helper to get transformations for a specific object type\r\n */\r\nfunction getTransformations(objectType) {\r\n    return exports.AllTransformations.find(function (t) { return t.objectType === objectType; });\r\n}\r\nexports.getTransformations = getTransformations;\r\n/**\r\n * Helper to get all transformations between two versions\r\n */\r\nfunction getTransformationsBetweenVersions(sourceVersion, targetVersion) {\r\n    return exports.AllTransformations.map(function (transformSet) { return (__assign(__assign({}, transformSet), { transformations: transformSet.transformations.filter(function (t) {\r\n            return t.sourceVersion === sourceVersion && t.targetVersion === targetVersion;\r\n        }) })); }).filter(function (transformSet) { return transformSet.transformations.length > 0; });\r\n}\r\nexports.getTransformationsBetweenVersions = getTransformationsBetweenVersions;\r\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../shared/dist/versioning/transformations/index.js?");

/***/ }),

/***/ "../../node_modules/axios/dist/browser/axios.cjs":
/*!*******************************************************!*\
  !*** ../../node_modules/axios/dist/browser/axios.cjs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Axios v1.7.9 Copyright (c) 2024 Matt Zabriskie and contributors\n\n\nfunction bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\n\nconst kindOf = (cache => thing => {\n    const str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n};\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n};\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n};\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\nconst [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : __webpack_require__.g)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  };\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n};\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n};\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n};\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n};\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n};\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n};\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[Symbol.iterator];\n\n  const iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n};\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n};\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n};\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n};\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  };\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n};\n\nconst noop = () => {};\n\nconst toFiniteNumber = (value, defaultValue) => {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n};\n\nconst ALPHA = 'abcdefghijklmnopqrstuvwxyz';\n\nconst DIGIT = '0123456789';\n\nconst ALPHABET = {\n  DIGIT,\n  ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n};\n\nconst generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {\n  let str = '';\n  const {length} = alphabet;\n  while (size--) {\n    str += alphabet[Math.random() * length|0];\n  }\n\n  return str;\n};\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  };\n\n  return visit(obj, 0);\n};\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\n// original code\n// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34\n\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\n  if (setImmediateSupported) {\n    return setImmediate;\n  }\n\n  return postMessageSupported ? ((token, callbacks) => {\n    _global.addEventListener(\"message\", ({source, data}) => {\n      if (source === _global && data === token) {\n        callbacks.length && callbacks.shift()();\n      }\n    }, false);\n\n    return (cb) => {\n      callbacks.push(cb);\n      _global.postMessage(token, \"*\");\n    }\n  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);\n})(\n  typeof setImmediate === 'function',\n  isFunction(_global.postMessage)\n);\n\nconst asap = typeof queueMicrotask !== 'undefined' ?\n  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);\n\n// *********************\n\nvar utils$1 = {\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isReadableStream,\n  isRequest,\n  isResponse,\n  isHeaders,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  ALPHABET,\n  generateString,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable,\n  setImmediate: _setImmediate,\n  asap\n};\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  if (response) {\n    this.response = response;\n    this.status = response.status ? response.status : null;\n  }\n}\n\nutils$1.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils$1.toJSONObject(this.config),\n      code: this.code,\n      status: this.status\n    };\n  }\n});\n\nconst prototype$1 = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype$1, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(prototype$1);\n\n  utils$1.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\n// eslint-disable-next-line strict\nvar httpAdapter = null;\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils$1.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils$1.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils$1.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils$1.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);\n\n  if (!utils$1.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils$1.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (!useBlob && utils$1.isBlob(value)) {\n      throw new AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils$1.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils$1.isArray(value) && isFlatArray(value)) ||\n        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils$1.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils$1.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils$1.forEach(value, function each(el, key) {\n      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils$1.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode$1(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && toFormData(params, this, options);\n}\n\nconst prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode$1);\n  } : encode$1;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?(object|Function)} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || encode;\n\n  if (utils$1.isFunction(options)) {\n    options = {\n      serialize: options\n    };\n  } \n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils$1.isURLSearchParams(params) ?\n      params.toString() :\n      new AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils$1.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\nvar InterceptorManager$1 = InterceptorManager;\n\nvar transitionalDefaults = {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n\nvar URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;\n\nvar FormData$1 = typeof FormData !== 'undefined' ? FormData : null;\n\nvar Blob$1 = typeof Blob !== 'undefined' ? Blob : null;\n\nvar platform$1 = {\n  isBrowser: true,\n  classes: {\n    URLSearchParams: URLSearchParams$1,\n    FormData: FormData$1,\n    Blob: Blob$1\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n};\n\nconst hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nconst _navigator = typeof navigator === 'object' && navigator || undefined;\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = hasBrowserEnv &&\n  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\nconst origin = hasBrowserEnv && window.location.href || 'http://localhost';\n\nvar utils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  hasBrowserEnv: hasBrowserEnv,\n  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,\n  hasStandardBrowserEnv: hasStandardBrowserEnv,\n  navigator: _navigator,\n  origin: origin\n});\n\nvar platform = {\n  ...utils,\n  ...platform$1\n};\n\nfunction toURLEncodedForm(data, options) {\n  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils$1.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils$1.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === '__proto__') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils$1.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils$1.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils$1.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils$1.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils$1.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils$1.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils$1.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: ['xhr', 'http', 'fetch'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = utils$1.isObject(data);\n\n    if (isObjectPayload && utils$1.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils$1.isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    }\n\n    if (utils$1.isArrayBuffer(data) ||\n      utils$1.isBuffer(data) ||\n      utils$1.isStream(data) ||\n      utils$1.isFile(data) ||\n      utils$1.isBlob(data) ||\n      utils$1.isReadableStream(data)\n    ) {\n      return data;\n    }\n    if (utils$1.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils$1.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {\n      return data;\n    }\n\n    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\n\nutils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\n  defaults.headers[method] = {};\n});\n\nvar defaults$1 = defaults;\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils$1.toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\nvar parseHeaders = rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils$1.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils$1.isString(value)) return;\n\n  if (utils$1.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils$1.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils$1.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils$1.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite);\n    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else if (utils$1.isHeaders(header)) {\n      for (const [key, value] of header.entries()) {\n        setHeader(value, key, rewrite);\n      }\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils$1.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils$1.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils$1.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils$1.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils$1.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils$1.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils$1.forEach(this, (value, header) => {\n      const key = utils$1.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils$1.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils$1.freezeMethods(AxiosHeaders);\n\nvar AxiosHeaders$1 = AxiosHeaders;\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n  const config = this || defaults$1;\n  const context = response || config;\n  const headers = AxiosHeaders$1.from(context.headers);\n  let data = context.data;\n\n  utils$1.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils$1.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n\nfunction parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\n/**\n * Throttle decorator\n * @param {Function} fn\n * @param {Number} freq\n * @return {Function}\n */\nfunction throttle(fn, freq) {\n  let timestamp = 0;\n  let threshold = 1000 / freq;\n  let lastArgs;\n  let timer;\n\n  const invoke = (args, now = Date.now()) => {\n    timestamp = now;\n    lastArgs = null;\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    fn.apply(null, args);\n  };\n\n  const throttled = (...args) => {\n    const now = Date.now();\n    const passed = now - timestamp;\n    if ( passed >= threshold) {\n      invoke(args, now);\n    } else {\n      lastArgs = args;\n      if (!timer) {\n        timer = setTimeout(() => {\n          timer = null;\n          invoke(lastArgs);\n        }, threshold - passed);\n      }\n    }\n  };\n\n  const flush = () => lastArgs && invoke(lastArgs);\n\n  return [throttled, flush];\n}\n\nconst progressEventReducer = (listener, isDownloadStream, freq = 3) => {\n  let bytesNotified = 0;\n  const _speedometer = speedometer(50, 250);\n\n  return throttle(e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e,\n      lengthComputable: total != null,\n      [isDownloadStream ? 'download' : 'upload']: true\n    };\n\n    listener(data);\n  }, freq);\n};\n\nconst progressEventDecorator = (total, throttled) => {\n  const lengthComputable = total != null;\n\n  return [(loaded) => throttled[0]({\n    lengthComputable,\n    total,\n    loaded\n  }), throttled[1]];\n};\n\nconst asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));\n\nvar isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {\n  url = new URL(url, platform.origin);\n\n  return (\n    origin.protocol === url.protocol &&\n    origin.host === url.host &&\n    (isMSIE || origin.port === url.port)\n  );\n})(\n  new URL(platform.origin),\n  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)\n) : () => true;\n\nvar cookies = platform.hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure) {\n      const cookie = [name + '=' + encodeURIComponent(value)];\n\n      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n\n      utils$1.isString(path) && cookie.push('path=' + path);\n\n      utils$1.isString(domain) && cookie.push('domain=' + domain);\n\n      secure === true && cookie.push('secure');\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read(name) {\n      const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return (match ? decodeURIComponent(match[3]) : null);\n    },\n\n    remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  };\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n\nconst headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, prop, caseless) {\n    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {\n      return utils$1.merge.call({caseless}, target, source);\n    } else if (utils$1.isPlainObject(source)) {\n      return utils$1.merge({}, source);\n    } else if (utils$1.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, prop , caseless) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(a, b, prop , caseless);\n    } else if (!utils$1.isUndefined(a)) {\n      return getMergedValue(undefined, a, prop , caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils$1.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)\n  };\n\n  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n\nvar resolveConfig = (config) => {\n  const newConfig = mergeConfig({}, config);\n\n  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;\n\n  newConfig.headers = headers = AxiosHeaders$1.from(headers);\n\n  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);\n\n  // HTTP basic authentication\n  if (auth) {\n    headers.set('Authorization', 'Basic ' +\n      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))\n    );\n  }\n\n  let contentType;\n\n  if (utils$1.isFormData(data)) {\n    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n      headers.setContentType(undefined); // Let the browser set it\n    } else if ((contentType = headers.getContentType()) !== false) {\n      // fix semicolon duplication issue for ReactNative FormData implementation\n      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];\n      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));\n    }\n  }\n\n  // Add xsrf header\n  // This is only done if running in a standard browser environment.\n  // Specifically not if we're in a web worker, or react-native.\n\n  if (platform.hasStandardBrowserEnv) {\n    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));\n\n    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {\n      // Add xsrf header\n      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);\n\n      if (xsrfValue) {\n        headers.set(xsrfHeaderName, xsrfValue);\n      }\n    }\n  }\n\n  return newConfig;\n};\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nvar xhrAdapter = isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = resolveConfig(config);\n    let requestData = _config.data;\n    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();\n    let {responseType, onUploadProgress, onDownloadProgress} = _config;\n    let onCanceled;\n    let uploadThrottled, downloadThrottled;\n    let flushUpload, flushDownload;\n\n    function done() {\n      flushUpload && flushUpload(); // flush events\n      flushDownload && flushDownload(); // flush events\n\n      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);\n\n      _config.signal && _config.signal.removeEventListener('abort', onCanceled);\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders$1.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = _config.transitional || transitionalDefaults;\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils$1.isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (onDownloadProgress) {\n      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));\n      request.addEventListener('progress', downloadThrottled);\n    }\n\n    // Not all browsers support upload events\n    if (onUploadProgress && request.upload) {\n      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));\n\n      request.upload.addEventListener('progress', uploadThrottled);\n\n      request.upload.addEventListener('loadend', flushUpload);\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(_config.url);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n};\n\nconst composeSignals = (signals, timeout) => {\n  const {length} = (signals = signals ? signals.filter(Boolean) : []);\n\n  if (timeout || length) {\n    let controller = new AbortController();\n\n    let aborted;\n\n    const onabort = function (reason) {\n      if (!aborted) {\n        aborted = true;\n        unsubscribe();\n        const err = reason instanceof Error ? reason : this.reason;\n        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));\n      }\n    };\n\n    let timer = timeout && setTimeout(() => {\n      timer = null;\n      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));\n    }, timeout);\n\n    const unsubscribe = () => {\n      if (signals) {\n        timer && clearTimeout(timer);\n        timer = null;\n        signals.forEach(signal => {\n          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);\n        });\n        signals = null;\n      }\n    };\n\n    signals.forEach((signal) => signal.addEventListener('abort', onabort));\n\n    const {signal} = controller;\n\n    signal.unsubscribe = () => utils$1.asap(unsubscribe);\n\n    return signal;\n  }\n};\n\nvar composeSignals$1 = composeSignals;\n\nconst streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n};\n\nconst readBytes = async function* (iterable, chunkSize) {\n  for await (const chunk of readStream(iterable)) {\n    yield* streamChunk(chunk, chunkSize);\n  }\n};\n\nconst readStream = async function* (stream) {\n  if (stream[Symbol.asyncIterator]) {\n    yield* stream;\n    return;\n  }\n\n  const reader = stream.getReader();\n  try {\n    for (;;) {\n      const {done, value} = await reader.read();\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  } finally {\n    await reader.cancel();\n  }\n};\n\nconst trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  };\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n};\n\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\n\n// used only inside the fetch adapter\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n    async (str) => new Uint8Array(await new Response(str).arrayBuffer())\n);\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n};\n\nconst supportsRequestStream = isReadableStreamSupported && test(() => {\n  let duplexAccessed = false;\n\n  const hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    },\n  }).headers.has('Content-Type');\n\n  return duplexAccessed && !hasContentType;\n});\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst supportsResponseStream = isReadableStreamSupported &&\n  test(() => utils$1.isReadableStream(new Response('').body));\n\n\nconst resolvers = {\n  stream: supportsResponseStream && ((res) => res.body)\n};\n\nisFetchSupported && (((res) => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :\n      (_, config) => {\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      });\n  });\n})(new Response));\n\nconst getBodyLength = async (body) => {\n  if (body == null) {\n    return 0;\n  }\n\n  if(utils$1.isBlob(body)) {\n    return body.size;\n  }\n\n  if(utils$1.isSpecCompliantForm(body)) {\n    const _request = new Request(platform.origin, {\n      method: 'POST',\n      body,\n    });\n    return (await _request.arrayBuffer()).byteLength;\n  }\n\n  if(utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {\n    return body.byteLength;\n  }\n\n  if(utils$1.isURLSearchParams(body)) {\n    body = body + '';\n  }\n\n  if(utils$1.isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n};\n\nconst resolveBodyLength = async (headers, body) => {\n  const length = utils$1.toFiniteNumber(headers.getContentLength());\n\n  return length == null ? getBodyLength(body) : length;\n};\n\nvar fetchAdapter = isFetchSupported && (async (config) => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = 'same-origin',\n    fetchOptions\n  } = resolveConfig(config);\n\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n  let request;\n\n  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n  });\n\n  let requestContentLength;\n\n  try {\n    if (\n      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n      (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n    ) {\n      let _request = new Request(url, {\n        method: 'POST',\n        body: data,\n        duplex: \"half\"\n      });\n\n      let contentTypeHeader;\n\n      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n        headers.setContentType(contentTypeHeader);\n      }\n\n      if (_request.body) {\n        const [onProgress, flush] = progressEventDecorator(\n          requestContentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress))\n        );\n\n        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n      }\n    }\n\n    if (!utils$1.isString(withCredentials)) {\n      withCredentials = withCredentials ? 'include' : 'omit';\n    }\n\n    // Cloudflare Workers throws when credentials are defined\n    // see https://github.com/cloudflare/workerd/issues/902\n    const isCredentialsSupported = \"credentials\" in Request.prototype;\n    request = new Request(url, {\n      ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: \"half\",\n      credentials: isCredentialsSupported ? withCredentials : undefined\n    });\n\n    let response = await fetch(request);\n\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n      const options = {};\n\n      ['status', 'statusText', 'headers'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n\n      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));\n\n      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n        responseContentLength,\n        progressEventReducer(asyncDecorator(onDownloadProgress), true)\n      ) || [];\n\n      response = new Response(\n        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n          flush && flush();\n          unsubscribe && unsubscribe();\n        }),\n        options\n      );\n    }\n\n    responseType = responseType || 'text';\n\n    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);\n\n    !isStreamResponse && unsubscribe && unsubscribe();\n\n    return await new Promise((resolve, reject) => {\n      settle(resolve, reject, {\n        data: responseData,\n        headers: AxiosHeaders$1.from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      });\n    })\n  } catch (err) {\n    unsubscribe && unsubscribe();\n\n    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {\n      throw Object.assign(\n        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n        {\n          cause: err.cause || err\n        }\n      )\n    }\n\n    throw AxiosError.from(err, err && err.code, config, request);\n  }\n});\n\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter,\n  fetch: fetchAdapter\n};\n\nutils$1.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {value});\n  }\n});\n\nconst renderReason = (reason) => `- ${reason}`;\n\nconst isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;\n\nvar adapters = {\n  getAdapter: (adapters) => {\n    adapters = utils$1.isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new AxiosError(`Unknown adapter '${id}'`);\n        }\n      }\n\n      if (adapter) {\n        break;\n      }\n\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n\n    if (!adapter) {\n\n      const reasons = Object.entries(rejectedReasons)\n        .map(([id, state]) => `adapter ${id} ` +\n          (state === false ? 'is not supported by the environment' : 'is not available in the build')\n        );\n\n      let s = length ?\n        (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n        'as no adapter specified';\n\n      throw new AxiosError(\n        `There is no suitable adapter to dispatch the request ` + s,\n        'ERR_NOT_SUPPORT'\n      );\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n};\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = AxiosHeaders$1.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = AxiosHeaders$1.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n\nconst VERSION = \"1.7.9\";\n\nconst validators$1 = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators$1[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators$1.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\nvalidators$1.spelling = function spelling(correctSpelling) {\n  return (value, opt) => {\n    // eslint-disable-next-line no-console\n    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);\n    return true;\n  }\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nvar validator = {\n  assertOptions,\n  validators: validators$1\n};\n\nconst validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new InterceptorManager$1(),\n      response: new InterceptorManager$1()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      if (err instanceof Error) {\n        let dummy = {};\n\n        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());\n\n        // slice off the Error: ... line\n        const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, '') : '';\n        try {\n          if (!err.stack) {\n            err.stack = stack;\n            // match without the 2 top stack lines\n          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, ''))) {\n            err.stack += '\\n' + stack;\n          }\n        } catch (e) {\n          // ignore the case where \"stack\" is an un-writable property\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: validators.transitional(validators.boolean),\n        forcedJSONParsing: validators.transitional(validators.boolean),\n        clarifyTimeoutError: validators.transitional(validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (utils$1.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        };\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: validators.function,\n          serialize: validators.function\n        }, true);\n      }\n    }\n\n    validator.assertOptions(config, {\n      baseUrl: validators.spelling('baseURL'),\n      withXsrfToken: validators.spelling('withXSRFToken')\n    }, true);\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && utils$1.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && utils$1.forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nvar Axios$1 = Axios;\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  toAbortSignal() {\n    const controller = new AbortController();\n\n    const abort = (err) => {\n      controller.abort(err);\n    };\n\n    this.subscribe(abort);\n\n    controller.signal.unsubscribe = () => this.unsubscribe(abort);\n\n    return controller.signal;\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\nvar CancelToken$1 = CancelToken;\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n  return utils$1.isObject(payload) && (payload.isAxiosError === true);\n}\n\nconst HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\nvar HttpStatusCode$1 = HttpStatusCode;\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new Axios$1(defaultConfig);\n  const instance = bind(Axios$1.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils$1.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(defaults$1);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios$1;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = CanceledError;\naxios.CancelToken = CancelToken$1;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\n\naxios.AxiosHeaders = AxiosHeaders$1;\n\naxios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.getAdapter = adapters.getAdapter;\n\naxios.HttpStatusCode = HttpStatusCode$1;\n\naxios.default = axios;\n\nmodule.exports = axios;\n//# sourceMappingURL=axios.cjs.map\n\n\n//# sourceURL=webpack://@quodsi/editor-extension/../../node_modules/axios/dist/browser/axios.cjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/extension.ts");
/******/ 	
/******/ })()
;