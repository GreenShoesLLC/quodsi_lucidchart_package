/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/lucid-extension-sdk/commandtypes.js":
/*!**************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/commandtypes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZOrderOperation = exports.isRawSendXHRResponse = exports.MermaidDiagramType = exports.GetLLMContextType = exports.GetItemsAtSearchType = exports.GetDocumentChunksType = exports.HashAlgorithmEnum = exports.commandTitles = void 0;\nconst checks_1 = __webpack_require__(/*! ./core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\n/** @ignore */\nexports.commandTitles = new Map([\n    [\"aci\" /* CommandName.AddCardIntegration */, 'AddCardIntegration'],\n    [\"adfm\" /* CommandName.AddDiagramFromMermaid */, 'AddDiagramFromMermaid'],\n    [\"adft\" /* CommandName.AddDiagramFromText */, 'AddDiagramFromText'],\n    [\"alta\" /* CommandName.AddLineTextArea */, 'AddLineTextArea'],\n    [\"ami\" /* CommandName.AddMenuItem */, 'AddMenuItem'],\n    [\"asd\" /* CommandName.AddShapeData */, 'AddShapeData'],\n    [\"asi\" /* CommandName.AddSpreadsheetIntegration */, 'AddSpreadsheetIntegration'],\n    [\"atc\" /* CommandName.AddTableColumn */, 'AddTableColumn'],\n    [\"atr\" /* CommandName.AddTableRow */, 'AddTableRow'],\n    [\"a\" /* CommandName.Alert */, 'Alert'],\n    [\"av\" /* CommandName.AnimateViewport */, 'AnimateViewport'],\n    [\"adi\" /* CommandName.AwaitDataSourceImport */, 'AwaitDataSourceImport'],\n    [\"ai\" /* CommandName.AwaitImport */, 'AwaitImport'],\n    [\"b\" /* CommandName.Bootstrap */, 'Bootstrap'],\n    [\"ceps\" /* CommandName.CanEditPackageSettings */, 'CanEditPackageSettings'],\n    [\"cdc\" /* CommandName.CancelDragBlockToCanvas */, 'CancelDragBlockToCanvas'],\n    [\"c\" /* CommandName.Confirm */, 'Confirm'],\n    [\"cb\" /* CommandName.CreateBlock */, 'CreateBlock'],\n    [\"cc\" /* CommandName.CreateCollection */, 'CreateCollection'],\n    [\"cds\" /* CommandName.CreateDataSource */, 'CreateDataSource'],\n    [\"cde\" /* CommandName.CreateDocumentElement */, 'CreateDocumentElement'],\n    [\"cg\" /* CommandName.CreateGroup */, 'CreateGroup'],\n    [\"cl\" /* CommandName.CreateLine */, 'CreateLine'],\n    [\"cp\" /* CommandName.CreatePage */, 'CreatePage'],\n    [\"die\" /* CommandName.DataItemExists */, 'DataItemExists'],\n    [\"dde\" /* CommandName.DeleteDocumentElement */, 'DeleteDocumentElement'],\n    [\"di\" /* CommandName.DeleteItem */, 'DeleteItem'],\n    [\"dp\" /* CommandName.DeletePage */, 'DeletePage'],\n    [\"dsd\" /* CommandName.DeleteShapeData */, 'DeleteShapeData'],\n    [\"dtc\" /* CommandName.DeleteTableColumn */, 'DeleteTableColumn'],\n    [\"dtr\" /* CommandName.DeleteTableRow */, 'DeleteTableRow'],\n    [\"d\" /* CommandName.Download */, 'Download'],\n    [\"dpm\" /* CommandName.DragPointerMove */, 'DragPointerMove'],\n    [\"dpu\" /* CommandName.DragPointerUp */, 'DragPointerUp'],\n    [\"dis\" /* CommandName.DuplicateItems */, 'DuplicateItems'],\n    [\"ee\" /* CommandName.ElementExists */, 'ElementExists'],\n    [\"ef\" /* CommandName.ExecuteFormula */, 'ExecuteFormula'],\n    [\"fas\" /* CommandName.FindAvailableSpace */, 'FindAvailableSpace'],\n    [\"fbe\" /* CommandName.FireBeaconEvent */, 'FireBeaconEvent'],\n    [\"gcl\" /* CommandName.GetConnectedLines */, 'GetConnectedLines'],\n    [\"gcp\" /* CommandName.GetCurrentPage */, 'GetCurrentPage'],\n    [\"gcs\" /* CommandName.GetCustomShape */, 'GetCustomShape'],\n    [\"gdif\" /* CommandName.GetDataItemField */, 'GetDataItemField'],\n    [\"gdap\" /* CommandName.GetDocumentAccessPermission */, 'GetDocumentAccessPermission'],\n    [\"gdc\" /* CommandName.GetDocumentChunks */, 'GetDocumentChunks'],\n    [\"gdid\" /* CommandName.GetDocumentId */, 'GetDocumentId'],\n    [\"get\" /* CommandName.GetElementType */, 'GetElementType'],\n    [\"gec\" /* CommandName.GetEnvironmentConfig */, 'GetEnvironmentConfig'],\n    [\"gip\" /* CommandName.GetItemPageId */, 'GetItemPageId'],\n    [\"gia\" /* CommandName.GetItemsAt */, 'GetItemsAt'],\n    [\"llm\" /* CommandName.GetLLMContextFromItems */, 'GetLLMContextFromItems'],\n    [\"goci\" /* CommandName.GetOAuthClientId */, 'GetOAuthClientId'],\n    [\"got\" /* CommandName.GetOAuthToken */, 'GetOAuthToken'],\n    [\"gps\" /* CommandName.GetPackageSettings */, 'GetPackageSettings'],\n    [\"gpr\" /* CommandName.GetProduct */, 'GetProduct'],\n    [\"gp\" /* CommandName.GetProperty */, 'GetProperty'],\n    [\"grk\" /* CommandName.GetReferenceKey */, 'GetReferenceKey'],\n    [\"grlp\" /* CommandName.GetRelativeLinePosition */, 'GetRelativeLinePosition'],\n    [\"gs\" /* CommandName.GetSelection */, 'GetSelection'],\n    [\"gsd\" /* CommandName.GetShapeData */, 'GetShapeData'],\n    [\"gsvg\" /* CommandName.GetSvg */, 'GetSvg'],\n    [\"gts\" /* CommandName.GetTextStyle */, 'GetTextStyle'],\n    [\"guid\" /* CommandName.GetUserId */, 'GetUserId'],\n    [\"gvr\" /* CommandName.GetVisibleRect */, 'GetVisibleRect'],\n    [\"hm\" /* CommandName.HideModal */, 'HideModal'],\n    [\"hp\" /* CommandName.HidePanel */, 'HidePanel'],\n    [\"hac\" /* CommandName.HookAllChanges */, 'HookAllChanges'],\n    [\"hci\" /* CommandName.HookCreateItems */, 'HookCreateItems'],\n    [\"hdi\" /* CommandName.HookDeleteItems */, 'HookDeleteItems'],\n    [\"hs\" /* CommandName.HookSelection */, 'HookSelection'],\n    [\"hte\" /* CommandName.HookTextEdit */, 'HookTextEdit'],\n    [\"ic\" /* CommandName.ImportCards */, 'ImportCards'],\n    [\"il\" /* CommandName.ImportLinks */, 'ImportLinks'],\n    [\"imp\" /* CommandName.ImportPage */, 'ImportPage'],\n    [\"k\" /* CommandName.KillExtension */, 'KillExtension'],\n    [\"lb\" /* CommandName.ListBlocks */, 'ListBlocks'],\n    [\"lcf\" /* CommandName.ListCollectionFields */, 'ListCollectionFields'],\n    [\"lc\" /* CommandName.ListCollections */, 'ListCollections'],\n    [\"ldi\" /* CommandName.ListDataItems */, 'ListDataItems'],\n    [\"lds\" /* CommandName.ListDataSources */, 'ListDataSources'],\n    [\"lde\" /* CommandName.ListDocumentElements */, 'ListDocumentElements'],\n    [\"lg\" /* CommandName.ListGroups */, 'ListGroups'],\n    [\"ll\" /* CommandName.ListLines */, 'ListLines'],\n    [\"lp\" /* CommandName.ListPages */, 'ListPages'],\n    [\"lpr\" /* CommandName.ListProperties */, 'ListProperties'],\n    [\"lrk\" /* CommandName.ListReferenceKeys */, 'ListReferenceKeys'],\n    [\"lsd\" /* CommandName.ListShapeData */, 'ListShapeData'],\n    [\"lta\" /* CommandName.ListTextAreas */, 'ListTextAreas'],\n    [\"lbc\" /* CommandName.LoadBlockClasses */, 'LoadBlockClasses'],\n    [\"log\" /* CommandName.LogForTestCase */, 'LogForTestCase'],\n    [\"mt\" /* CommandName.MeasureText */, 'MeasureText'],\n    [\"oi\" /* CommandName.OffsetItems */, 'OffsetItems'],\n    [\"pdi\" /* CommandName.PatchDataItems */, 'PatchDataItems'],\n    [\"p\" /* CommandName.Prompt */, 'Prompt'],\n    [\"rp\" /* CommandName.RegisterPanel */, 'RegisterPanel'],\n    [\"ru\" /* CommandName.RegisterUnfurl */, 'RegisterUnfurl'],\n    [\"r\" /* CommandName.ReloadExtension */, 'ReloadExtension'],\n    [\"aoauth\" /* CommandName.SendAsyncOAuthRequest */, 'SendAsyncOAuthRequest'],\n    [\"oauth\" /* CommandName.SendOAuthRequest */, 'SendOAuthRequest'],\n    [\"suim\" /* CommandName.SendUIMessage */, 'SendUIMessage'],\n    [\"xhr\" /* CommandName.SendXHR */, 'SendXHR'],\n    [\"scp\" /* CommandName.SetCurrentPage */, 'SetCurrentPage'],\n    [\"sps\" /* CommandName.SetPackageSettings */, 'SetPackageSettings'],\n    [\"sp\" /* CommandName.SetProperty */, 'SetProperty'],\n    [\"srk\" /* CommandName.SetReferenceKey */, 'SetReferenceKey'],\n    [\"ss\" /* CommandName.SetSelection */, 'SetSelection'],\n    [\"ssd\" /* CommandName.SetShapeData */, 'SetShapeData'],\n    [\"sts\" /* CommandName.SetTextStyle */, 'SetTextStyle'],\n    [\"sm\" /* CommandName.ShowModal */, 'ShowModal'],\n    [\"spsm\" /* CommandName.ShowPackageSettingsModal */, 'ShowPackageSettingsModal'],\n    [\"spn\" /* CommandName.ShowPanel */, 'ShowPanel'],\n    [\"sleep\" /* CommandName.SleepForTestCase */, 'SleepForTestCase'],\n    [\"sdc\" /* CommandName.StartDragBlockToCanvas */, 'StartDragBlockToCanvas'],\n    [\"pdf\" /* CommandName.StartPDFUploadRequest */, 'StartPDFUploadRequest'],\n    [\"throw\" /* CommandName.ThrowForTestCase */, 'ThrowForTestCase'],\n    [\"tauth\" /* CommandName.TriggerAuthFlow */, 'TriggerAuthFlow'],\n    [\"uac\" /* CommandName.UnhookAllChanges */, 'UnhookAllChanges'],\n    [\"uci\" /* CommandName.UnhookCreateItems */, 'UnhookCreateItems'],\n    [\"udi\" /* CommandName.UnhookDeleteItems */, 'UnhookDeleteItems'],\n    [\"us\" /* CommandName.UnhookSelection */, 'UnhookSelection'],\n    [\"ute\" /* CommandName.UnhookTextEdit */, 'UnhookTextEdit'],\n    [\"wm\" /* CommandName.WithMutex */, 'WithMutex'],\n    [\"wsa\" /* CommandName.WithSilentActions */, 'WithSilentActions'],\n    [\"z\" /* CommandName.ZOrder */, 'ZOrder'],\n]);\nvar HashAlgorithmEnum;\n(function (HashAlgorithmEnum) {\n    /** Use the SHA 256 hashing algorithm */\n    HashAlgorithmEnum[\"sha256\"] = \"SHA256\";\n})(HashAlgorithmEnum || (exports.HashAlgorithmEnum = HashAlgorithmEnum = {}));\nvar GetDocumentChunksType;\n(function (GetDocumentChunksType) {\n    /**\n     * Breaks up a document into chunks geographically\n     */\n    GetDocumentChunksType[GetDocumentChunksType[\"Geographic\"] = 0] = \"Geographic\";\n    /**\n     * Breaks up a document into chunks by finding containing blocks\n     */\n    GetDocumentChunksType[GetDocumentChunksType[\"Container\"] = 1] = \"Container\";\n})(GetDocumentChunksType || (exports.GetDocumentChunksType = GetDocumentChunksType = {}));\nvar GetItemsAtSearchType;\n(function (GetItemsAtSearchType) {\n    GetItemsAtSearchType[GetItemsAtSearchType[\"PossiblyOverlapping\"] = 0] = \"PossiblyOverlapping\";\n    GetItemsAtSearchType[GetItemsAtSearchType[\"Overlapping\"] = 1] = \"Overlapping\";\n    GetItemsAtSearchType[GetItemsAtSearchType[\"Contained\"] = 2] = \"Contained\";\n})(GetItemsAtSearchType || (exports.GetItemsAtSearchType = GetItemsAtSearchType = {}));\nvar GetLLMContextType;\n(function (GetLLMContextType) {\n    /** Get context in a format for LLMs where relationships among connected and\n     * contained items are preserved. Expand the scope of the selection to\n     * include blocks contained by the selection as well as lines connecting\n     * items in the selection. */\n    GetLLMContextType[GetLLMContextType[\"Relational\"] = 1] = \"Relational\";\n    /** Get context containing only plain text displayed on the given items, more suitable for embeddings */\n    GetLLMContextType[GetLLMContextType[\"PlainText\"] = 2] = \"PlainText\";\n    /** Get context in a format for LLMs where relationships among connected and\n     * contained items are preserved. Do not expand the scope of the selection,\n     * other than to ensure relationships are represented. Text on selected\n     * items will be included, but text on automatically added items will not.\n     * */\n    GetLLMContextType[GetLLMContextType[\"RelationalWithoutExpansion\"] = 3] = \"RelationalWithoutExpansion\";\n})(GetLLMContextType || (exports.GetLLMContextType = GetLLMContextType = {}));\nvar MermaidDiagramType;\n(function (MermaidDiagramType) {\n    MermaidDiagramType[\"FLOWCHART\"] = \"flowchart\";\n    MermaidDiagramType[\"CLASS_DIAGRAM\"] = \"class_diagram\";\n    MermaidDiagramType[\"ERD\"] = \"erd\";\n    // The following types are not yet supported.\n    // SEQUENCE_DIAGRAM = 'sequence_diagram',\n    // STATE_DIAGRAM = 'state_diagram',\n    // USER_JOURNEY = 'user_journey',\n    // GANTT = 'gantt',\n    // PIECHART = 'piechart',\n    // MINDMAP = 'mindmap',\n    // REQUIREMENT_DIAGRAM = 'requirement_diagram',\n    // GITGRAPH = 'gitgraph',\n    // TIMELINE = 'timeline',\n})(MermaidDiagramType || (exports.MermaidDiagramType = MermaidDiagramType = {}));\nfunction isRawSendXHRResponse(val) {\n    return (0, checks_1.isString)(val['url']) && (0, checks_1.isString)(val['t']) && (0, checks_1.isNumber)(val['s']) && (0, checks_1.isObject)(val['h']);\n}\nexports.isRawSendXHRResponse = isRawSendXHRResponse;\nvar ZOrderOperation;\n(function (ZOrderOperation) {\n    ZOrderOperation[ZOrderOperation[\"UP\"] = 1] = \"UP\";\n    ZOrderOperation[ZOrderOperation[\"TOP\"] = 2] = \"TOP\";\n    ZOrderOperation[ZOrderOperation[\"DOWN\"] = 3] = \"DOWN\";\n    ZOrderOperation[ZOrderOperation[\"BOTTOM\"] = 4] = \"BOTTOM\";\n})(ZOrderOperation || (exports.ZOrderOperation = ZOrderOperation = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/commandtypes.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/base64.js":
/*!*************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/base64.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeBase64 = exports.decodeBase64 = void 0;\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n//This gives a ~8x speedup vs. using alphabet.indexOf() in the main decode loop.\nconst charCodeToEncodedInt = [];\nfor (let i = 0; i < alphabet.length; i++) {\n    charCodeToEncodedInt[alphabet.charCodeAt(i)] = i;\n}\nfunction decodeBase64(base64String) {\n    //Filter out whitespace, etc\n    base64String = base64String.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n    if (base64String.length % 4 !== 0) {\n        throw new Error('Invalid base64 input; length must be a multiple of 4');\n    }\n    //4 characters of input turns into 3 bytes of output\n    let bytes = (base64String.length / 4) * 3;\n    //But each trailing = (up to 2) is one fewer byte of output\n    if (base64String.endsWith('==')) {\n        bytes -= 2;\n    }\n    else if (base64String.endsWith('=')) {\n        bytes -= 1;\n    }\n    const output = new Uint8Array(bytes);\n    let inputIndex = 0;\n    for (let outputIndex = 0; outputIndex < bytes; outputIndex += 3) {\n        //Get the 4 numbers 0-63 encoded in the next 4 characters\n        const enc1 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        const enc2 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        const enc3 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        const enc4 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        if (enc1 === undefined || enc2 === undefined || enc3 === undefined || enc4 === undefined) {\n            throw new Error('char code to encoded int contains an undefined index');\n        }\n        //Read 8 total bits into each of the output values. Skip one byte\n        //for each padding = at the end of the string\n        output[outputIndex] = (enc1 << 2) | (enc2 >> 4);\n        if (enc3 != 64) {\n            output[outputIndex + 1] = ((enc2 & 15) << 4) | (enc3 >> 2);\n        }\n        if (enc4 != 64) {\n            output[outputIndex + 2] = ((enc3 & 3) << 6) | enc4;\n        }\n    }\n    return output;\n}\nexports.decodeBase64 = decodeBase64;\nfunction encodeBase64(byteArray) {\n    // 3 bytes of input become 4 chars of output\n    // i.e. every 6 bits of input becomes 1 char of output\n    const fullByteChunkCount = Math.floor(byteArray.length / 3);\n    const outputLength = Math.ceil(byteArray.length / 3) * 4;\n    const output = new Array(outputLength);\n    let inputIndex = 0;\n    let outputIndex = 0;\n    for (let byteChunkIndex = 0; byteChunkIndex < fullByteChunkCount; byteChunkIndex++) {\n        const byte1 = byteArray[inputIndex++];\n        const byte2 = byteArray[inputIndex++];\n        const byte3 = byteArray[inputIndex++];\n        if (byte1 === undefined || byte2 === undefined || byte3 === undefined) {\n            throw new Error('byteArray contains undefined indexes');\n        }\n        const enc1 = byte1 >> 2; // first 6 bits of byte1\n        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4); // last 2 bits of byte1 and first 4 bits of byte2\n        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6); // last 4 bits of byte2 and first 2 bits of byte3\n        const enc4 = byte3 & 63; // last 6 bits of byte3\n        output[outputIndex++] = alphabet[enc1];\n        output[outputIndex++] = alphabet[enc2];\n        output[outputIndex++] = alphabet[enc3];\n        output[outputIndex++] = alphabet[enc4];\n    }\n    // handle remainder, i.e. trailing one or two bytes\n    if (inputIndex < byteArray.length) {\n        const byte1 = byteArray[inputIndex++];\n        const hasSecondByte = inputIndex < byteArray.length;\n        const byte2 = hasSecondByte ? byteArray[inputIndex++] : 0;\n        const enc1 = byte1 >> 2; // first 6 bits of byte1\n        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4); // last 2 bits of byte1 and first 4 bits of byte2\n        const enc3 = hasSecondByte ? (byte2 & 15) << 2 : 64; // last 4 bits of byte2\n        output[outputIndex++] = alphabet[enc1];\n        output[outputIndex++] = alphabet[enc2];\n        output[outputIndex++] = alphabet[enc3];\n        output[outputIndex++] = '=';\n    }\n    return output.join('');\n}\nexports.encodeBase64 = encodeBase64;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/base64.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidCardFields = exports.StatusValues = exports.deserializeLucidCardFieldDisplaySettings = exports.serializeLucidCardFieldDisplaySettings = exports.isOnClickHandlerKey = exports.OnClickHandlerKeys = exports.isFieldDisplayType = exports.FieldDisplayType = void 0;\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * When configuring a field on a LucidCardBlock to be displayed as a data graphic, one of these values specifies\n * the function to convert the field value to the data graphic settings. The definition of these functions is in\n * LucidCardsLibrary.registerStencilDisplayTypes.\n */\nvar FieldDisplayType;\n(function (FieldDisplayType) {\n    /**\n     * Text badge with the full text of the field.\n     * Black text on a light gray background in the upper-right of the card.\n     */\n    FieldDisplayType[\"BasicTextBadge\"] = \"BasicTextBadge\";\n    /**\n     * Given a name (usually of a user), puts a text badge with their initials (first letter of each name)\n     * at the bottom-left of the card, black text on a light gray background.\n     */\n    FieldDisplayType[\"InitializedString\"] = \"InitializedString\";\n    /**\n     * Given a number, display the number in the bottom-left of the card. If the number is higher than 999,\n     * display 999.\n     */\n    FieldDisplayType[\"StandardEstimation\"] = \"StandardEstimation\";\n    /**\n     * Given a URL, display a small image cropped into a circle in the lower-left of the card.\n     */\n    FieldDisplayType[\"ImageBadge\"] = \"ImageBadge\";\n    /**\n     * Given a URL, display a small image cropped into a square in the lower-left of the card.\n     */\n    FieldDisplayType[\"SquareImageBadge\"] = \"SquareImageBadge\";\n    /**\n     * Given a date, display a small calendar icon alongside a very short version of the date\n     * as a string, e.g. \"Sep 9\"\n     */\n    FieldDisplayType[\"DateBadge\"] = \"DateBadge\";\n    /** Given an object containing iconUrl (optional) and name (optional), determine whether\n     * to display as an ImageBadge or InitializedString (or nothing, if neither is present).\n     */\n    FieldDisplayType[\"UserProfile\"] = \"UserProfile\";\n})(FieldDisplayType || (exports.FieldDisplayType = FieldDisplayType = {}));\nexports.isFieldDisplayType = (0, validators_1.enumValidator)(FieldDisplayType);\n/**\n * When configuring a field on a LucidCardBlock to be displayed as a data graphic, this click handler value\n * specifies what to do when the user clicks on the data graphic produced.\n */\nvar OnClickHandlerKeys;\n(function (OnClickHandlerKeys) {\n    /**\n     * Display the UI panel to edit fields on the data associated with the card\n     */\n    OnClickHandlerKeys[\"BasicEditPanel\"] = \"BasicEditPanel\";\n    /**\n     * Open a new browser window to a URL specified by linkFormula\n     */\n    OnClickHandlerKeys[\"OpenBrowserWindow\"] = \"OpenBrowserWindow\";\n    /**\n     * Display a custom UI panel to edit non-standard fields on the data associated with the card\n     */\n    OnClickHandlerKeys[\"CustomEditAction\"] = \"CustomEditAction\";\n})(OnClickHandlerKeys || (exports.OnClickHandlerKeys = OnClickHandlerKeys = {}));\nexports.isOnClickHandlerKey = (0, validators_1.enumValidator)(OnClickHandlerKeys);\n/** @ignore */\nfunction serializeLucidCardFieldDisplaySettings(settings) {\n    return {\n        'StencilConfig': settings.stencilConfig && {\n            'getterKey': settings.stencilConfig.displayType,\n            'f': settings.stencilConfig.valueFormula,\n            't': settings.stencilConfig.tooltipFormula,\n            'l': settings.stencilConfig.linkFormula,\n            'fg': settings.stencilConfig.foregroundColor,\n            'bg': settings.stencilConfig.backgroundColor,\n            'h': settings.stencilConfig.horizontalPosition,\n            'v': settings.stencilConfig.verticalPosition,\n            'onClickHandlerKey': settings.stencilConfig.onClickHandlerKey,\n            'imageBadgeSettings': settings.stencilConfig.imageBadgeSettings,\n            'textBadgeSettings': settings.stencilConfig.textBadgeSettings,\n        },\n    };\n}\nexports.serializeLucidCardFieldDisplaySettings = serializeLucidCardFieldDisplaySettings;\n/** @ignore */\nfunction deserializeLucidCardFieldDisplaySettings(settings) {\n    return {\n        stencilConfig: settings['StencilConfig'] && {\n            displayType: settings['StencilConfig']['getterKey'],\n            valueFormula: settings['StencilConfig']['f'],\n            tooltipFormula: settings['StencilConfig']['t'],\n            linkFormula: settings['StencilConfig']['l'],\n            foregroundColor: settings['StencilConfig']['fg'],\n            backgroundColor: settings['StencilConfig']['bg'],\n            horizontalPosition: settings['StencilConfig']['h'],\n            verticalPosition: settings['StencilConfig']['v'],\n            onClickHandlerKey: settings['StencilConfig']['onClickHandlerKey'],\n            imageBadgeSettings: settings['StencilConfig']['imageBadgeSettings'],\n            textBadgeSettings: settings['StencilConfig']['textBadgeSettings'],\n        },\n    };\n}\nexports.deserializeLucidCardFieldDisplaySettings = deserializeLucidCardFieldDisplaySettings;\n/**\n * These are the six possible values for the status of a basic card block.\n * Must be kept in sync with cake/app/webroot/ts/libraries/lucidcards/lucidcarddefaultstatus.ts\n */\nvar StatusValues;\n(function (StatusValues) {\n    StatusValues[\"New\"] = \"New\";\n    StatusValues[\"Todo\"] = \"To Do\";\n    StatusValues[\"InProgress\"] = \"In Progress\";\n    StatusValues[\"Done\"] = \"Done\";\n    StatusValues[\"NotDoing\"] = \"Not Doing\";\n    StatusValues[\"Blocked\"] = \"Blocked\";\n})(StatusValues || (exports.StatusValues = StatusValues = {}));\nvar LucidCardFields;\n(function (LucidCardFields) {\n    LucidCardFields[\"Title\"] = \"Title\";\n    LucidCardFields[\"Description\"] = \"Description\";\n    LucidCardFields[\"Assignee\"] = \"Assignee\";\n    LucidCardFields[\"Estimate\"] = \"Estimate\";\n    LucidCardFields[\"Status\"] = \"Status\";\n    LucidCardFields[\"StartTime\"] = \"StartTime\";\n    LucidCardFields[\"EndTime\"] = \"EndTime\";\n})(LucidCardFields || (exports.LucidCardFields = LucidCardFields = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeCardIntegrationConfig = exports.serializeCardIntegrationConfig = void 0;\nconst cardfielddisplaysettings_1 = __webpack_require__(/*! ./cardfielddisplaysettings */ \"../../node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js\");\n/** @ignore */\nfunction serializeCardIntegrationConfig(config) {\n    return {\n        'cc': {\n            'f': config.cardConfig.fieldNames,\n            'fd': config.cardConfig.fieldDisplaySettings\n                ? [...config.cardConfig.fieldDisplaySettings].map(([key, settings]) => [\n                    key,\n                    (0, cardfielddisplaysettings_1.serializeLucidCardFieldDisplaySettings)(settings),\n                ])\n                : undefined,\n            'fs': config.cardConfig.fieldStyles ? [...config.cardConfig.fieldStyles] : undefined,\n        },\n        'cdpc': {\n            'f': config.cardDetailsPanelConfig.fields.map((field) => {\n                return {\n                    'n': field.name,\n                    'l': field.locked,\n                };\n            }),\n        },\n    };\n}\nexports.serializeCardIntegrationConfig = serializeCardIntegrationConfig;\n/** @ignore */\nfunction deserializeCardIntegrationConfig(raw) {\n    return {\n        cardConfig: {\n            fieldNames: raw['cc']['f'],\n            fieldStyles: raw['cc']['fs'] ? new Map(raw['cc']['fs']) : undefined,\n            fieldDisplaySettings: raw['cc']['fd']\n                ? new Map(raw['cc']['fd'].map(([key, settings]) => [\n                    key,\n                    (0, cardfielddisplaysettings_1.deserializeLucidCardFieldDisplaySettings)(settings),\n                ]))\n                : undefined,\n        },\n        cardDetailsPanelConfig: {\n            fields: raw['cdpc']['f'].map((field) => {\n                return {\n                    name: field['n'],\n                    locked: field['l'],\n                };\n            }),\n        },\n    };\n}\nexports.deserializeCardIntegrationConfig = deserializeCardIntegrationConfig;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationdefinitions.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationdefinitions.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeCardFieldArrayDefinition = exports.deserializeCardFieldDefinition = exports.isSerializedExtensionCardFieldDefinition = exports.isSerializedFieldOptions = exports.isSerializedFieldOption = exports.deserializeFieldOption = exports.serializeCardFieldArrayDefinition = exports.serializeCardFieldDefinition = exports.serializeCardFieldOption = void 0;\nconst schemadefinition_1 = __webpack_require__(/*! ../../data/schemadefinition */ \"../../node_modules/lucid-extension-sdk/data/schemadefinition.js\");\nconst checks_1 = __webpack_require__(/*! ../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../data/fieldtypedefinition/fieldtypedefinition */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst serializedfielddefinition_1 = __webpack_require__(/*! ../data/serializedfield/serializedfielddefinition */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\");\nconst serializedfields_1 = __webpack_require__(/*! ../data/serializedfield/serializedfields */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/** @ignore */\nfunction serializeCardFieldOption(option) {\n    return {\n        'l': option.label,\n        'v': option.value,\n        'i': option.iconUrl,\n    };\n}\nexports.serializeCardFieldOption = serializeCardFieldOption;\n/** @ignore */\nfunction serializeCardFieldDefinition(field) {\n    var _a;\n    return Object.assign(Object.assign({}, (0, schemadefinition_1.serializeFieldDefinition)(field)), { 'l': field.label, 'def': field.default, 'd': field.description, 'op': (0, checks_1.isString)(field.options) ? field.options : (_a = field.options) === null || _a === void 0 ? void 0 : _a.map(serializeCardFieldOption), 's': field.search });\n}\nexports.serializeCardFieldDefinition = serializeCardFieldDefinition;\n/** @ignore */\nfunction serializeCardFieldArrayDefinition(fields) {\n    return fields.map(serializeCardFieldDefinition);\n}\nexports.serializeCardFieldArrayDefinition = serializeCardFieldArrayDefinition;\n/** @ignore */\nfunction deserializeFieldOption(option) {\n    return {\n        label: option['l'],\n        value: option['v'],\n        iconUrl: option['i'],\n    };\n}\nexports.deserializeFieldOption = deserializeFieldOption;\nexports.isSerializedFieldOption = (0, validators_1.objectValidator)({\n    'l': checks_1.isString,\n    'v': serializedfields_1.isSerializedFieldType,\n    'i': (0, validators_1.option)(checks_1.isString),\n});\nexports.isSerializedFieldOptions = (0, validators_1.arrayValidator)(exports.isSerializedFieldOption);\n/** @ignore */\nexports.isSerializedExtensionCardFieldDefinition = (0, validators_1.objectValidator)({\n    'Name': checks_1.isString,\n    'Type': fieldtypedefinition_1.isSerializedFieldTypeDefinition,\n    'Constraints': (0, validators_1.option)((0, validators_1.arrayValidator)(serializedfielddefinition_1.isSerializedFieldConstraint)),\n    'l': checks_1.isString,\n    'd': (0, validators_1.option)(checks_1.isString),\n    'def': (0, validators_1.option)(serializedfields_1.isSerializedFieldType),\n    'op': (0, validators_1.option)((0, validators_1.either)(checks_1.isString, (0, validators_1.arrayValidator)(exports.isSerializedFieldOption))),\n    's': (0, validators_1.option)(checks_1.isString),\n});\n/** @ignore */\nfunction deserializeCardFieldDefinition(field) {\n    var _a;\n    return Object.assign(Object.assign({}, (0, schemadefinition_1.parseFieldDefinition)(field)), { label: field['l'], description: field['d'], default: field['def'], options: (0, checks_1.isString)(field['op']) ? field['op'] : (_a = field['op']) === null || _a === void 0 ? void 0 : _a.map(deserializeFieldOption), search: field['s'] });\n}\nexports.deserializeCardFieldDefinition = deserializeCardFieldDefinition;\n/** @ignore */\nfunction deserializeCardFieldArrayDefinition(fields) {\n    return fields.map(deserializeCardFieldDefinition);\n}\nexports.deserializeCardFieldArrayDefinition = deserializeCardFieldArrayDefinition;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationdefinitions.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidCardIntegration = void 0;\nclass LucidCardIntegration {\n    constructor(client) {\n        this.client = client;\n    }\n    showCardImport(name) {\n        return this.client.sendCommand(\"ic\" /* CommandName.ImportCards */, name);\n    }\n}\nexports.LucidCardIntegration = LucidCardIntegration;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationcustomimportmodal.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationcustomimportmodal.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidCardIntegrationCustomImportModal = void 0;\nconst modal_1 = __webpack_require__(/*! ../../ui/modal */ \"../../node_modules/lucid-extension-sdk/ui/modal.js\");\n/**\n * Extending this class lets you create a custom import modal for a Lucid card integration.\n */\nclass LucidCardIntegrationCustomImportModal extends modal_1.Modal {\n    constructor(client, config, cardIntegrationLabel) {\n        super(client, config);\n        this.cardIntegrationLabel = cardIntegrationLabel;\n    }\n    /**\n     * Once the data has been imported, call this function to create Lucid cards on the canvas.\n     */\n    createCards(collectionId, primaryKeys) {\n        return this.client.sendCommand(\"ca\" /* CommandName.CreateCards */, {\n            'cid': this.cardIntegrationLabel,\n            'coid': collectionId,\n            'pks': primaryKeys,\n        });\n    }\n}\nexports.LucidCardIntegrationCustomImportModal = LucidCardIntegrationCustomImportModal;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationcustomimportmodal.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidCardIntegrationRegistry = void 0;\nconst collectiondefinition_1 = __webpack_require__(/*! ../../data/collectiondefinition */ \"../../node_modules/lucid-extension-sdk/data/collectiondefinition.js\");\nconst datasourceproxy_1 = __webpack_require__(/*! ../../data/datasourceproxy */ \"../../node_modules/lucid-extension-sdk/data/datasourceproxy.js\");\nconst cardintegrationconfig_1 = __webpack_require__(/*! ./cardintegrationconfig */ \"../../node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js\");\nconst cardintegrationdefinitions_1 = __webpack_require__(/*! ./cardintegrationdefinitions */ \"../../node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationdefinitions.js\");\nconst lucidcardintegrationcustomimportmodal_1 = __webpack_require__(/*! ./lucidcardintegrationcustomimportmodal */ \"../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationcustomimportmodal.js\");\nclass LucidCardIntegrationRegistry {\n    static nextHookName() {\n        return '__lucidcard__hook' + LucidCardIntegrationRegistry.nextHookId++;\n    }\n    static registerFieldOptionsCallback(client, callback) {\n        const name = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(name, async ({ 'i': inputSoFar }) => {\n            const result = await callback(new Map(inputSoFar));\n            return result.map((option) => (0, cardintegrationdefinitions_1.serializeCardFieldOption)(option));\n        });\n        return name;\n    }\n    static registerFieldSearchCallback(client, callback) {\n        const name = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(name, async ({ 'i': inputSoFar, 's': searchText }) => {\n            const result = await callback(searchText, new Map(inputSoFar));\n            return result.map((option) => (0, cardintegrationdefinitions_1.serializeCardFieldOption)(option));\n        });\n        return name;\n    }\n    /**\n     * Register a card integration.\n     */\n    static addCardIntegration(client, cardIntegration) {\n        const getFieldsActionName = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(getFieldsActionName, async (param) => {\n            const dataSource = new datasourceproxy_1.DataSourceProxy(param['d'], client);\n            const fields = await cardIntegration.fieldConfiguration.getAllFields(dataSource);\n            return fields;\n        });\n        let onSelectedFieldsChangeActionName = undefined;\n        const onSelectedFieldsChange = cardIntegration.fieldConfiguration.onSelectedFieldsChange;\n        if (onSelectedFieldsChange) {\n            onSelectedFieldsChangeActionName = LucidCardIntegrationRegistry.nextHookName();\n            client.registerAction(onSelectedFieldsChangeActionName, async (param) => {\n                const dataSource = new datasourceproxy_1.DataSourceProxy(param['ds'], client);\n                await onSelectedFieldsChange(dataSource, param['sf']);\n            });\n        }\n        const getDefaultConfigActionName = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(getDefaultConfigActionName, async (param) => {\n            const dataSource = new datasourceproxy_1.DataSourceProxy(param['d'], client);\n            return (0, cardintegrationconfig_1.serializeCardIntegrationConfig)(await cardIntegration.getDefaultConfig(dataSource));\n        });\n        let showIntroActionName = undefined;\n        if (cardIntegration.showIntro) {\n            showIntroActionName = LucidCardIntegrationRegistry.nextHookName();\n            client.registerAction(showIntroActionName, cardIntegration.showIntro);\n        }\n        const serialized = {\n            'n': cardIntegration.label,\n            'dcn': cardIntegration.dataConnectorName,\n            'il': cardIntegration.itemLabel,\n            'isl': cardIntegration.itemsLabel,\n            'u': cardIntegration.iconUrl,\n            'ts': cardIntegration.textStyle,\n            'fc': {\n                'gf': getFieldsActionName,\n                'osfc': onSelectedFieldsChangeActionName,\n                'fvsc': cardIntegration.fieldConfiguration.fieldValueSearchCallbacks\n                    ? [...cardIntegration.fieldConfiguration.fieldValueSearchCallbacks.entries()]\n                    : undefined,\n            },\n            'gdc': getDefaultConfigActionName,\n            'i': showIntroActionName,\n        };\n        if (cardIntegration.importModal) {\n            const importModal = cardIntegration.importModal;\n            if (importModal instanceof lucidcardintegrationcustomimportmodal_1.LucidCardIntegrationCustomImportModal) {\n                serialized['cim'] = {\n                    'sh': LucidCardIntegrationRegistry.nextHookName(),\n                };\n                client.registerAction(serialized['cim']['sh'], () => importModal.show());\n            }\n            else {\n                serialized['im'] = {\n                    'gsf': LucidCardIntegrationRegistry.nextHookName(),\n                    's': LucidCardIntegrationRegistry.nextHookName(),\n                    'i': LucidCardIntegrationRegistry.nextHookName(),\n                    'os': importModal.onSetup ? LucidCardIntegrationRegistry.nextHookName() : undefined,\n                };\n                client.registerAction(serialized['im']['gsf'], async ({ 's': searchSoFar }) => {\n                    const result = await importModal.getSearchFields(new Map(searchSoFar));\n                    return (0, cardintegrationdefinitions_1.serializeCardFieldArrayDefinition)(result);\n                });\n                client.registerAction(serialized['im']['s'], async ({ 's': param }) => {\n                    const result = await importModal.search(new Map(param));\n                    return {\n                        'd': (0, collectiondefinition_1.serializeCollectionDefinition)(result.data),\n                        'f': (0, cardintegrationdefinitions_1.serializeCardFieldArrayDefinition)(result.fields),\n                        'm': result.partialImportMetadata && {\n                            'cid': result.partialImportMetadata.collectionId,\n                            'sid': result.partialImportMetadata.syncDataSourceId,\n                        },\n                    };\n                });\n                client.registerAction(serialized['im']['i'], async ({ 'pks': primaryKeys, 's': searchFields }) => {\n                    const result = await importModal.import(primaryKeys, new Map(searchFields));\n                    return {\n                        'c': result.collection.id,\n                        'pks': result.primaryKeys,\n                    };\n                });\n                if (serialized['im']['os']) {\n                    client.registerAction(serialized['im']['os'], async () => {\n                        var _a;\n                        await ((_a = importModal.onSetup) === null || _a === void 0 ? void 0 : _a.call(importModal));\n                    });\n                }\n            }\n        }\n        if (cardIntegration.addCard) {\n            const addCard = cardIntegration.addCard;\n            serialized['ac'] = {\n                'gif': LucidCardIntegrationRegistry.nextHookName(),\n                'cc': LucidCardIntegrationRegistry.nextHookName(),\n            };\n            client.registerAction(serialized['ac']['gif'], async ({ 'i': inputSoFar }) => {\n                const result = await addCard.getInputFields(new Map(inputSoFar));\n                return (0, cardintegrationdefinitions_1.serializeCardFieldArrayDefinition)(result);\n            });\n            client.registerAction(serialized['ac']['cc'], async ({ 'i': input }) => {\n                const result = await addCard.createCardData(new Map(input));\n                return {\n                    'c': result.collection.id,\n                    'pk': result.primaryKey,\n                };\n            });\n        }\n        client.sendCommand(\"aci\" /* CommandName.AddCardIntegration */, serialized);\n    }\n}\nexports.LucidCardIntegrationRegistry = LucidCardIntegrationRegistry;\nLucidCardIntegrationRegistry.nextHookId = 0;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/checks.js":
/*!*************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/checks.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInstanceOf = exports.isLiteral = exports.isPromise = exports.isUnknown = exports.isAny = exports.isEmptyOrNullishObject = exports.isPair = exports.isAtLeastLength = exports.isExactLength = exports.isTypedArray = exports.isArray = exports.isRecord = exports.isObjectUnsafer = exports.isObjectUnsafe = exports.isObject = exports.isFunction = exports.isInfinite = exports.isInt = exports.isNumber = exports.isBoolean = exports.isString = exports.isNullish = exports.isDefAndNotNull = exports.isVoid = exports.isUndefined = exports.isNull = exports.isDef = void 0;\n/**\n * Returns true if the specified value is not undefined.\n *\n * @param val Variable to test.\n * @return Whether variable is defined.\n */\nfunction isDef(val) {\n    return val !== undefined;\n}\nexports.isDef = isDef;\n/**\n * Returns true if the specified value is null.\n * @param val Variable to test.\n * @return Whether variable is null.\n */\nfunction isNull(val) {\n    return val === null;\n}\nexports.isNull = isNull;\n/**\n * Returns true if the specified value is undefined.\n * @param val Variable to test.\n * @return Whether variable is undefined.\n */\nfunction isUndefined(val) {\n    return val === undefined;\n}\nexports.isUndefined = isUndefined;\n/**\n * Returns true if the specified value is undefined.\n * @param val Variable to test.\n * @return Whether variable is undefined.\n */\nfunction isVoid(x) {\n    return x === undefined;\n}\nexports.isVoid = isVoid;\n/**\n * Returns true if the specified value is defined and not null.\n * @param val Variable to test.\n * @return Whether variable is defined and not null.\n */\nfunction isDefAndNotNull(val) {\n    return val != null;\n}\nexports.isDefAndNotNull = isDefAndNotNull;\n/**\n * Returns true if the specified value is null or undefined.\n * @param val Variable to test\n * @return Whether the variable is null or undefined.\n */\nfunction isNullish(val) {\n    return val == null;\n}\nexports.isNullish = isNullish;\n/**\n * Returns true if the specified value is a string.\n * @param val Variable to test.\n * @return Whether variable is a string.\n */\nfunction isString(val) {\n    return typeof val == 'string';\n}\nexports.isString = isString;\n/**\n * Returns true if the specified value is a boolean.\n * @param val Variable to test.\n * @return Whether variable is boolean.\n */\nfunction isBoolean(val) {\n    return typeof val == 'boolean';\n}\nexports.isBoolean = isBoolean;\n/**\n * Returns true if the specified value is a number.\n * @param val Variable to test.\n * @return Whether variable is a number.\n */\nfunction isNumber(val) {\n    return typeof val == 'number';\n}\nexports.isNumber = isNumber;\n/**\n * Returns true if the specified value is an integer.\n * @param val Variable to test.\n * @return Whether variable is an integer.\n */\nfunction isInt(val) {\n    return isNumber(val) && isFinite(val) && val % 1 == 0;\n}\nexports.isInt = isInt;\n/**\n * Returns true if the specified value is either positive or negative infinity.\n * @param val Variable to test.\n * @returns Whether variable is positive or negative infinity.\n */\nfunction isInfinite(val) {\n    return isNumber(val) && !isNaN(val) && !isFinite(val);\n}\nexports.isInfinite = isInfinite;\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\nexports.isFunction = isFunction;\n/**\n * Returns true if the specified value is an object (including arrays and functions) (i.e. it's safe to do property accesses on it).\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isObject(val) {\n    const type = typeof val;\n    return (type == 'object' && val != null) || type == 'function';\n}\nexports.isObject = isObject;\n/**\n * Returns true for objects, includings arrays and functions.\n * Matches the behavior of goog.isObject, with a more permissive type.\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isObjectUnsafe(val) {\n    const type = typeof val;\n    return (type == 'object' && val != null) || type == 'function';\n}\nexports.isObjectUnsafe = isObjectUnsafe;\n/**\n * Returns true for objects, includings arrays and functions.\n * Matches the behavior of goog.isObject, with an extremely permissive type.\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isObjectUnsafer(val) {\n    const type = typeof val;\n    return (type == 'object' && val != null) || type == 'function';\n}\nexports.isObjectUnsafer = isObjectUnsafer;\n/**\n * Returns true if the specified value is an object (i.e. it's safe to do property accesses on it),\n * and every value matches the record type.\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isRecord(typeGuard) {\n    return function (val) {\n        return isObject(val) && Object.values(val).every(typeGuard);\n    };\n}\nexports.isRecord = isRecord;\n/**\n * Returns true if the specified value is an array.\n *\n * This is safer than using Array.isArray directly because it doesn't introduce an `any` type.\n * @param val Variable to test.\n * @return Whether variable is an array.\n */\nfunction isArray(val) {\n    return Array.isArray(val);\n}\nexports.isArray = isArray;\n/**\n * Returns true if the specified value is an array and every element passes the type guard function.\n *\n * @param val Variable to test.\n * @param typeGuard the type guard function to test every element in the array.\n * @return Whether variable is an array of the given type.\n */\nfunction isTypedArray(typeGuard) {\n    return function (val) {\n        return isArray(val) && val.every(typeGuard);\n    };\n}\nexports.isTypedArray = isTypedArray;\nfunction isExactLength(arr, exactLength) {\n    return arr.length === exactLength;\n}\nexports.isExactLength = isExactLength;\nfunction isAtLeastLength(arr, minimumLength) {\n    return arr.length >= minimumLength;\n}\nexports.isAtLeastLength = isAtLeastLength;\n/**\n * Returns true if the specified value is a tuple where the first element, T, passes the tGuard function\n * and the second element, U, passes the uGuard function\n * @param tGuard the type guard function to test the first element in the tuple, T\n * @param uGuard the type guard function to test the second element in the tuple, U\n * @returns whether the value is a tuple of the form [T, U]\n */\nfunction isPair(tGuard, uGuard) {\n    return (x) => {\n        return isArray(x) && isExactLength(x, 2) && tGuard(x[0]) && uGuard(x[1]);\n    };\n}\nexports.isPair = isPair;\n/**\n * Returns true if the specified object is either empty or all existing keys map to a nullish value\n *\n * @param val Variable to test\n * @return Whether variable is empty or maps exclusively to nullish values\n */\nfunction isEmptyOrNullishObject(val) {\n    return !(val &&\n        typeof val === 'object' &&\n        Object.keys(val).find((key) => isDefAndNotNull(val[key])));\n}\nexports.isEmptyOrNullishObject = isEmptyOrNullishObject;\n/**\n * @deprecated Prefer isUnknown\n */\nfunction isAny(val) {\n    return true;\n}\nexports.isAny = isAny;\nfunction isUnknown(val) {\n    return true;\n}\nexports.isUnknown = isUnknown;\nfunction isPromise(val) {\n    return isObjectUnsafe(val) && isFunction(val['then']) && isFunction(val['catch']);\n}\nexports.isPromise = isPromise;\nfunction isLiteral(t) {\n    return (x) => x === t;\n}\nexports.isLiteral = isLiteral;\n/**\n * Since `instanceof` should generally be avoided, this function should generally be avoided as well.\n *\n * A valid use case is for native types, like Uint8Array.\n */\nfunction isInstanceOf(klass) {\n    return (x) => x instanceof klass;\n}\nexports.isInstanceOf = isInstanceOf;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/checks.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.alphabet = void 0;\nexports.alphabet = [\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n];\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataSourceType = void 0;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar DataSourceType;\n(function (DataSourceType) {\n    DataSourceType[DataSourceType[\"DeprecatedGoogleSheets\"] = 0] = \"DeprecatedGoogleSheets\";\n    DataSourceType[DataSourceType[\"DeprecatedCSV\"] = 1] = \"DeprecatedCSV\";\n    DataSourceType[DataSourceType[\"DeprecatedExcel\"] = 2] = \"DeprecatedExcel\";\n    DataSourceType[DataSourceType[\"Salesforce\"] = 3] = \"Salesforce\";\n    DataSourceType[DataSourceType[\"Generator\"] = 4] = \"Generator\";\n    DataSourceType[DataSourceType[\"DataService\"] = 5] = \"DataService\";\n    DataSourceType[DataSourceType[\"ForeignKeyOverride\"] = 7] = \"ForeignKeyOverride\";\n    DataSourceType[DataSourceType[\"Extension\"] = 8] = \"Extension\";\n    DataSourceType[DataSourceType[\"Unknown\"] = 9] = \"Unknown\";\n})(DataSourceType || (exports.DataSourceType = DataSourceType = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeSerializedPreviewData = exports.makeSerializedImportedDataSource = exports.makeSerializedImportedCollection = exports.MetadataPK = exports.makeNameReadablyUnique = exports.normalizeName = exports.alphabetize = void 0;\nconst dataupdatefiltertype_1 = __webpack_require__(/*! ../../../data/dataupdatefiltertype */ \"../../node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js\");\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ../fieldtypedefinition/scalarfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nconst alphabet_1 = __webpack_require__(/*! ./alphabet */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js\");\nconst datasourcetype_1 = __webpack_require__(/*! ./datasourcetype */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\");\nconst spreadsheetpossibledatatypes_1 = __webpack_require__(/*! ./spreadsheetpossibledatatypes */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js\");\nconst upstreamupdatetype_1 = __webpack_require__(/*! ./upstreamupdatetype */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\");\n/** @ignore */\nfunction _alphabetize(n) {\n    if (n == undefined || n < 0) {\n        return '';\n    }\n    else if (n < alphabet_1.alphabet.length) {\n        return alphabet_1.alphabet[n];\n    }\n    else {\n        return alphabetize(Math.floor(n / alphabet_1.alphabet.length) - 1) + alphabetize(n % alphabet_1.alphabet.length);\n    }\n}\n/** @ignore */\nconst memoize = new Map();\n/** @ignore */\nfunction alphabetize(n) {\n    const stored = memoize.get(n);\n    if (stored != null) {\n        return stored;\n    }\n    const value = _alphabetize(n);\n    memoize.set(n, value);\n    return value;\n}\nexports.alphabetize = alphabetize;\n/** @ignore */\nfunction normalizeName(name) {\n    return name.trim().toLowerCase();\n}\nexports.normalizeName = normalizeName;\nconst appendedNumberRegex = /(.*) \\(([0-9]+)\\)$/;\n/** @ignore */\nfunction makeNameReadablyUnique(originalName, usedNamesNormalized, transform = normalizeName) {\n    if (!usedNamesNormalized.has(transform(originalName))) {\n        return originalName;\n    }\n    const match = appendedNumberRegex.exec(originalName);\n    let count = 1;\n    if (match && (0, checks_1.isString)(match[1]) && (0, checks_1.isString)(match[2])) {\n        originalName = match[1];\n        count = Number(match[2]) + 1;\n    }\n    let newName = originalName;\n    do {\n        newName = originalName + ` (${count})`;\n        count++;\n    } while (usedNamesNormalized.has(transform(newName)));\n    return newName;\n}\nexports.makeNameReadablyUnique = makeNameReadablyUnique;\n/** @ignore */\nexports.MetadataPK = '__PK__';\n/** @ignore */\nfunction makePrimaryCollectionSchema(rawSchemaFields, data, schemaFromData) {\n    var _a, _b;\n    const headerRow = (_a = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.headerRow) !== null && _a !== void 0 ? _a : -1;\n    const headerRowData = headerRow >= 0 ? data[headerRow] : undefined;\n    const headerRowAsStringArray = headerRowData &&\n        rawSchemaFields.map((rawSchemaField, index) => {\n            var _a;\n            const headerRowDataAsString = `${(_a = headerRowData[rawSchemaField]) !== null && _a !== void 0 ? _a : ''}`;\n            return headerRowDataAsString.trim() === '' ? alphabetize(index) : headerRowDataAsString;\n        });\n    const schemaFields = headerRowAsStringArray !== null && headerRowAsStringArray !== void 0 ? headerRowAsStringArray : rawSchemaFields;\n    const fields = [];\n    const oldToNewFields = new Map();\n    const usedFieldsNormalized = new Set([normalizeName(exports.MetadataPK)]);\n    schemaFields.forEach((field, index) => {\n        const finalFieldName = makeNameReadablyUnique(field, usedFieldsNormalized);\n        usedFieldsNormalized.add(normalizeName(finalFieldName));\n        fields.push({ 'Name': finalFieldName, 'Type': spreadsheetpossibledatatypes_1.SpreadSheetPossibleDataTypes });\n        oldToNewFields.set(rawSchemaFields[index], finalFieldName);\n    });\n    const oldPrimaryKeys = (_b = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.primaryKey) !== null && _b !== void 0 ? _b : [];\n    const translatedPrimaryKeys = oldPrimaryKeys\n        .map((oldPrimaryKey) => oldToNewFields.get(oldPrimaryKey))\n        .filter(checks_1.isDefAndNotNull); // There should be no untranslatable primary keys, but we need to satisfy the type system\n    return {\n        sheetSchema: {\n            'Fields': fields,\n            'PrimaryKey': translatedPrimaryKeys,\n        },\n        oldToNewFields,\n    };\n}\nfunction getPrimaryKeysForData(oldToNewFields, data, schemaFromData) {\n    if (!schemaFromData || schemaFromData.primaryKey.length === 0) {\n        return data.map((row, index) => `${index + 1}`);\n    }\n    const primaryKey = schemaFromData.primaryKey;\n    const primaryKeyInNewFields = primaryKey.map((oldField) => { var _a; return (_a = oldToNewFields.get(oldField)) !== null && _a !== void 0 ? _a : oldField; });\n    // For reasons I have forgotten, the actual primary key order is determined by the alphabetized name order.\n    const sortedPrimaryKeyInNewFields = primaryKeyInNewFields.slice().sort();\n    const sortedPrimaryKey = sortedPrimaryKeyInNewFields.map((newField) => primaryKey[primaryKeyInNewFields.indexOf(newField)]);\n    const usedNames = new Set();\n    return data.map((serializedField) => {\n        const primaryKeyValues = sortedPrimaryKey.map((key) => serializedField[key]);\n        const compositeValue = JSON.stringify(primaryKeyValues);\n        const nameWithoutContext = compositeValue.slice(1, compositeValue.length - 1);\n        let name = nameWithoutContext;\n        let dupCount = -1;\n        while (usedNames.has(name)) {\n            name = `${nameWithoutContext},${++dupCount}`;\n        }\n        usedNames.add(name);\n        return name;\n    });\n}\n/** @ignore */\nfunction makeMetadataCollection(metadataType, sheetName, dataItems, sheetSchema) {\n    return {\n        'Name': sheetName + '|' + metadataType,\n        'Schema': sheetSchema,\n        'Items': dataItems,\n    };\n}\n/** @ignore */\nfunction makeItemOrderCollection(primaryKeys, sheetName, headerRow) {\n    const itemOrderItems = {};\n    let rowIndex = 0;\n    for (let i = 0; i < primaryKeys.length; i++) {\n        const primaryKey = primaryKeys[i];\n        if (i !== headerRow) {\n            rowIndex++;\n            itemOrderItems[`${rowIndex}`] = { 'Key': `${primaryKey}`, 'Order': rowIndex };\n        }\n    }\n    const itemOrderSchema = {\n        'Fields': [\n            { 'Name': 'Key', 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.STRING },\n            { 'Name': 'Order', 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER },\n        ],\n        'PrimaryKey': ['Order'],\n    };\n    return makeMetadataCollection('ItemOrder', sheetName, itemOrderItems, itemOrderSchema);\n}\n/** @ignore */\nfunction makeHeaderrowMetadataCollection(headerRowPrimaryKey, headerRowData, oldToNewFields, sheetName, schema) {\n    const dataItem = {};\n    for (const [key, field] of Object.entries(headerRowData)) {\n        const newKey = oldToNewFields.get(key);\n        if (newKey) {\n            dataItem[newKey] = field;\n        }\n    }\n    const itemOrderItems = {\n        [headerRowPrimaryKey]: dataItem,\n    };\n    return makeMetadataCollection('HeaderRowMetadata', sheetName, itemOrderItems, schema);\n}\n/** @ignore */\nfunction makeSerializedItems(primaryKeys, rawItems, oldToNewFields, headerRow, isMetadata = false) {\n    const serializedItems = {};\n    rawItems.forEach((rawItem, rowIndex) => {\n        if (isMetadata || rowIndex !== headerRow) {\n            const dataItem = {};\n            for (const [key, field] of Object.entries(rawItem)) {\n                const newKey = oldToNewFields.get(key);\n                if (newKey) {\n                    dataItem[newKey] = field;\n                }\n            }\n            const primaryKey = primaryKeys[rowIndex];\n            if (isMetadata && Object.keys(dataItem).length > 0) {\n                const metadataPrimaryKey = `${primaryKey}`;\n                dataItem[exports.MetadataPK] = metadataPrimaryKey;\n                serializedItems[`${JSON.stringify(metadataPrimaryKey)}`] = dataItem;\n            }\n            else if (!isMetadata) {\n                serializedItems[primaryKey] = dataItem;\n            }\n        }\n    });\n    return serializedItems;\n}\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nfunction makeSerializedImportedCollection(name, rawFieldNames, data, upstreamConfig, dataIsPartial, metadata, schemaFromData) {\n    var _a;\n    const { sheetSchema, oldToNewFields } = makePrimaryCollectionSchema(rawFieldNames, data, schemaFromData);\n    const primaryKeys = getPrimaryKeysForData(oldToNewFields, data, schemaFromData);\n    const headerRow = (_a = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.headerRow) !== null && _a !== void 0 ? _a : -1;\n    const metadataCollections = {};\n    metadataCollections['ItemOrder'] = makeItemOrderCollection(primaryKeys, name, headerRow);\n    if (headerRow > -1 && headerRow < data.length) {\n        const headerRowData = data[headerRow];\n        const headerRowPrimaryKey = primaryKeys[headerRow];\n        metadataCollections['HeaderRowMetadata'] = makeHeaderrowMetadataCollection(headerRowPrimaryKey, headerRowData, oldToNewFields, name, sheetSchema);\n    }\n    if (metadata) {\n        const metadataFields = [{ 'Name': exports.MetadataPK, 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.STRING }];\n        sheetSchema['Fields'].forEach((field) => metadataFields.push({\n            'Name': field['Name'],\n            'Type': [scalarfieldtype_1.ScalarFieldTypeEnum.STRING, scalarfieldtype_1.ScalarFieldTypeEnum.NULL],\n        }));\n        const metadataSchema = { 'Fields': metadataFields, 'PrimaryKey': [exports.MetadataPK] };\n        for (const [type, data] of Object.entries(metadata)) {\n            metadataCollections[type] = makeMetadataCollection(type, name, makeSerializedItems(primaryKeys, data, oldToNewFields, headerRow, true), metadataSchema);\n        }\n    }\n    return {\n        'Name': name,\n        'Schema': sheetSchema,\n        'Items': makeSerializedItems(primaryKeys, data, oldToNewFields, headerRow),\n        'UpstreamConfig': upstreamConfig,\n        'Metadata': metadataCollections,\n        'DataIsPartial': dataIsPartial,\n    };\n}\nexports.makeSerializedImportedCollection = makeSerializedImportedCollection;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nfunction makeSerializedImportedDataSource(id, name, collections) {\n    return {\n        'Properties': {\n            'Name': name,\n            'UpstreamConfig': {\n                'SourceType': datasourcetype_1.DataSourceType.DataService,\n                'UpdateType': upstreamupdatetype_1.UpstreamUpdateType.EVENTPULL,\n                'SourceConfig': {\n                    'spreadsheetId': id,\n                    'UpdateFilterType': dataupdatefiltertype_1.DataUpdateFilterType.CurrentCollectionUpdates,\n                },\n            },\n        },\n        'Collections': collections,\n    };\n}\nexports.makeSerializedImportedDataSource = makeSerializedImportedDataSource;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nfunction makeSerializedPreviewData(id, name, collections) {\n    return {\n        'Properties': {\n            'Name': name,\n            'UpstreamConfig': {\n                'SourceType': datasourcetype_1.DataSourceType.DataService,\n                'UpdateType': upstreamupdatetype_1.UpstreamUpdateType.EVENTPULL,\n                'SourceConfig': {\n                    'spreadsheetId': id,\n                    'UpdateFilterType': dataupdatefiltertype_1.DataUpdateFilterType.CurrentCollectionUpdates,\n                },\n            },\n        },\n        'Collections': collections,\n    };\n}\nexports.makeSerializedPreviewData = makeSerializedPreviewData;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MetadataTypes = void 0;\n// Google Sheets has both notes and comments, we store notes in the comment metadata collection. Comments are not\n// meant to be permanent in Google Sheets whereas they are in Excel, resulting in some confusion with our naming.\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar MetadataTypes;\n(function (MetadataTypes) {\n    MetadataTypes[\"Format\"] = \"Format\";\n    MetadataTypes[\"FillColor\"] = \"FillColor\";\n    MetadataTypes[\"TextColor\"] = \"TextColor\";\n    MetadataTypes[\"Comment\"] = \"Comment\";\n    MetadataTypes[\"Formula\"] = \"Formula\";\n    MetadataTypes[\"HeaderRowMetadata\"] = \"HeaderRowMetadata\";\n    MetadataTypes[\"ExternalLink\"] = \"ExternalLink\";\n})(MetadataTypes || (exports.MetadataTypes = MetadataTypes = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedDataSourceProperties = exports.isSerializedSourceForeignKey = exports.Direction = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializedupstreamconfig_1 = __webpack_require__(/*! ./serializedupstreamconfig */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js\");\nvar Direction;\n(function (Direction) {\n    Direction[\"Inward\"] = \"inward\";\n    Direction[\"Outward\"] = \"outward\";\n})(Direction || (exports.Direction = Direction = {}));\nexports.isSerializedSourceForeignKey = (0, validators_1.objectValidator)({\n    'Id': checks_1.isString,\n    'SourceFields': (0, validators_1.arrayValidator)(checks_1.isString),\n    'RelationshipType': checks_1.isString,\n});\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedDataSourceProperties = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'UpstreamConfig': (0, validators_1.nullableOption)(serializedupstreamconfig_1.isSerializedUpstreamConfig),\n    'SourceForeignKeys': (0, validators_1.nullableOption)((0, validators_1.arrayValidator)(exports.isSerializedSourceForeignKey)),\n});\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedPreviewData = exports.isSerializedImportedDataSource = exports.isSerializedImportedCollection = exports.isSerializedImportedMetadataCollection = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializeddataitems_1 = __webpack_require__(/*! ../serializedfield/serializeddataitems */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js\");\nconst serializedschema_1 = __webpack_require__(/*! ../serializedfield/serializedschema */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js\");\nconst serializeddatasourceproperties_1 = __webpack_require__(/*! ./serializeddatasourceproperties */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedImportedMetadataCollection = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'Schema': serializedschema_1.isSerializedSchema,\n    'Items': serializeddataitems_1.isSerializedDataItems,\n});\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedImportedCollection = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'Schema': serializedschema_1.isSerializedSchema,\n    'Items': serializeddataitems_1.isSerializedDataItems,\n    'UpstreamConfig': checks_1.isObject,\n    'Metadata': (0, checks_1.isRecord)(exports.isSerializedImportedMetadataCollection),\n    'DataIsPartial': (0, validators_1.option)(validators_1.isTrue),\n});\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedImportedDataSource = (0, validators_1.strictObjectValidator)({\n    'Properties': serializeddatasourceproperties_1.isSerializedDataSourceProperties,\n    'Collections': (0, checks_1.isTypedArray)(exports.isSerializedImportedCollection),\n});\nexports.isSerializedPreviewData = (0, validators_1.strictObjectValidator)({\n    'Properties': serializeddatasourceproperties_1.isSerializedDataSourceProperties,\n    'Collections': (0, checks_1.isTypedArray)((0, validators_1.strictObjectValidator)({\n        'Data': exports.isSerializedImportedCollection,\n        'HeaderRow': (0, validators_1.option)(checks_1.isNumber),\n        'PrimaryKey': (0, validators_1.option)((0, checks_1.isTypedArray)(checks_1.isNumber)),\n    })),\n});\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedUpstreamConfig = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst datasourcetype_1 = __webpack_require__(/*! ./datasourcetype */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\");\nconst upstreampatchtype_1 = __webpack_require__(/*! ./upstreampatchtype */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js\");\nconst upstreamupdatetype_1 = __webpack_require__(/*! ./upstreamupdatetype */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedUpstreamConfig = (0, validators_1.strictObjectValidator)({\n    'SourceType': (0, validators_1.enumValidator)(datasourcetype_1.DataSourceType),\n    'UpdateType': (0, validators_1.enumValidator)(upstreamupdatetype_1.UpstreamUpdateType),\n    'PatchType': (0, validators_1.nullableOption)((0, validators_1.enumValidator)(upstreampatchtype_1.UpstreamPatchType)),\n    'SourceConfig': checks_1.isObject,\n});\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SpreadSheetPossibleDataTypes = void 0;\nconst scalarfieldtype_1 = __webpack_require__(/*! ../fieldtypedefinition/scalarfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nexports.SpreadSheetPossibleDataTypes = [\n    scalarfieldtype_1.ScalarFieldTypeEnum.BOOLEAN,\n    scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER,\n    scalarfieldtype_1.ScalarFieldTypeEnum.STRING,\n    scalarfieldtype_1.ScalarFieldTypeEnum.NULL,\n    scalarfieldtype_1.ScalarFieldTypeEnum.CURRENCY,\n    scalarfieldtype_1.ScalarFieldTypeEnum.DATE,\n    scalarfieldtype_1.ScalarFieldTypeEnum.DATEONLY,\n    scalarfieldtype_1.ScalarFieldTypeEnum.TIMEONLY,\n    scalarfieldtype_1.ScalarFieldTypeEnum.COLOR,\n];\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedSourceConfig = exports.deserializeUpstreamConfig = exports.serializeUpstreamConfig = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nfunction serializeUpstreamConfig(config) {\n    return {\n        'SourceType': config.dataSourceType,\n        'UpdateType': config.updateType,\n        'PatchType': config.patchType,\n        'SourceConfig': config.sourceConfig,\n    };\n}\nexports.serializeUpstreamConfig = serializeUpstreamConfig;\nfunction deserializeUpstreamConfig(config) {\n    return {\n        dataSourceType: config['SourceType'],\n        updateType: config['UpdateType'],\n        patchType: config['PatchType'] === null ? undefined : config['PatchType'],\n        sourceConfig: config['SourceConfig'],\n    };\n}\nexports.deserializeUpstreamConfig = deserializeUpstreamConfig;\nfunction isSerializedSourceConfig(x) {\n    return (0, checks_1.isObject)(x);\n}\nexports.isSerializedSourceConfig = isSerializedSourceConfig;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UpstreamPatchType = void 0;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar UpstreamPatchType;\n(function (UpstreamPatchType) {\n    UpstreamPatchType[UpstreamPatchType[\"NONE\"] = 0] = \"NONE\";\n    UpstreamPatchType[UpstreamPatchType[\"MANUAL\"] = 2] = \"MANUAL\";\n    UpstreamPatchType[UpstreamPatchType[\"AUTO\"] = 3] = \"AUTO\";\n})(UpstreamPatchType || (exports.UpstreamPatchType = UpstreamPatchType = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UpstreamUpdateType = void 0;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar UpstreamUpdateType;\n(function (UpstreamUpdateType) {\n    UpstreamUpdateType[UpstreamUpdateType[\"NONE\"] = 0] = \"NONE\";\n    UpstreamUpdateType[UpstreamUpdateType[\"PULL\"] = 1] = \"PULL\";\n    UpstreamUpdateType[UpstreamUpdateType[\"USER\"] = 2] = \"USER\";\n    UpstreamUpdateType[UpstreamUpdateType[\"EVENTPULL\"] = 3] = \"EVENTPULL\";\n})(UpstreamUpdateType || (exports.UpstreamUpdateType = UpstreamUpdateType = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/fieldspecification.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/fieldspecification.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FormattedPrimaryKey = exports.declareSchema = void 0;\nfunction isArrayAndAssertReadonly(val) {\n    return Array.isArray(val);\n}\n/**\n * Specifies all the fields that this itegration will be sending to the data-sync service.\n * Give you well typed methods to convert from `YourType[]` to `{[PrimaryKey:string]: YourType}`\n * which is what most of the data sync service calls expect.\n *\n * There is fromItems which does the above will full type information, and fromItems sparse\n * which allows all the fields not part of the primaryKey to be undefined. The former should\n * be used with initial imports, and the latter can be used for updates.\n */\nfunction declareSchema({ primaryKey, fields }) {\n    const primaryKeyObj = new FormattedPrimaryKey(...primaryKey);\n    return {\n        example: fields,\n        array: Object.entries(fields).map(([name, { type, constraints, mapping }]) => {\n            return {\n                'name': name,\n                'type': isArrayAndAssertReadonly(type) ? type.slice() : type,\n                'constraints': constraints,\n                'mapping': mapping,\n            };\n        }),\n        primaryKey: primaryKeyObj,\n        fromItemsSparse: (items) => {\n            return new Map(items.map((item) => [primaryKeyObj.forItem(item), item]));\n        },\n        fromItems: (items) => {\n            return new Map(items.map((item) => [primaryKeyObj.forItem(item), item]));\n        },\n    };\n}\nexports.declareSchema = declareSchema;\n/**\n * Generates a mapper that, given a primary key definition is able to produce the primary key for that item.\n **/\nclass FormattedPrimaryKey {\n    constructor(...elements) {\n        this.elements = [...elements].sort();\n    }\n    /**\n     * Generate the serialized form of the item's primary key.\n     *\n     * For single value primary keys, the encoded values are just the json representation of the primary\n     * key. For example, if the primary key is ['id'] the following table shows encodings:\n     *\n     * | type    | value     | encoded                            |\n     * |---------|-----------|------------------------------------|\n     * | number  | `15`      | `new Map([[\"15\", ...], ...])`      |\n     * | boolean | `false`   | `new Map([[\"false\", ...], ...])`   |\n     * | string  | `\"hello\"` | `new Map([['\"hello\"', ...], ...])` |\n     *\n     * Take note of the extra quotes in the string case.\n     *\n     * For primary keys with multiple values, first sort the array of primary keys then join the json encoded values\n     * from of the keys with commas. For example:\n     *\n     * ```\n     * primary key = [\"lastName\", \"firstName\"]\n     * sorted key = [\"firstName\", \"lastName\"]\n     * row = {\"lastName\": \"Smith\", \"firstName\": \"John\", \"age\": 42}\n     * row key = '\"John\",\"Smith\"'\n     * items = new Map([['\"John\",\"Smith\"', {\"lastName\": \"Smith\", \"firstName\": \"John\", \"age\": 42}]])\n     * ```\n     */\n    forItem(item) {\n        return FormattedPrimaryKey.serializeList(this.elements.map((field) => item[field]));\n    }\n    static serializeList(items) {\n        let pk = JSON.stringify(items);\n        pk = pk.substring(1, pk.length - 1);\n        return pk;\n    }\n}\nexports.FormattedPrimaryKey = FormattedPrimaryKey;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/fieldspecification.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedBaseFieldTypeDefinition = exports.deserializeBaseFieldTypeDefinition = exports.serializeBaseFieldTypeDefinition = exports.isBaseFieldTypeDefinition = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst collectionenumfieldtype_1 = __webpack_require__(/*! ./collectionenumfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\");\nconst fieldtypearray_1 = __webpack_require__(/*! ./fieldtypearray */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst ndimensionalfieldtypearray_1 = __webpack_require__(/*! ./ndimensionalfieldtypearray */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nfunction isBaseFieldTypeDefinition(fieldType) {\n    return ((0, scalarfieldtype_1.isScalarFieldTypeEnum)(fieldType) ||\n        (0, literalfieldtype_1.isLiteralFieldType)(fieldType) ||\n        fieldType instanceof fieldtypearray_1.FieldTypeArray ||\n        fieldType instanceof ndimensionalfieldtypearray_1.NDimensionalFieldTypeArray ||\n        (0, collectionenumfieldtype_1.isCollectionEnumFieldType)(fieldType));\n}\nexports.isBaseFieldTypeDefinition = isBaseFieldTypeDefinition;\nfunction serializeBaseFieldTypeDefinition(baseFieldType) {\n    // Unfortunately there's no easy way to do goog.DEBUG checks inside lucid-extension-sdk right now.\n    // if (goog.DEBUG && !isBaseFieldTypeDefinition(baseFieldType)) {\n    //     throw new Error(`Passed non-BaseFieldTypeDefinition into serializeBaseFieldTypeDefinition()!`);\n    // }\n    if (baseFieldType instanceof literalfieldtype_1.LiteralFieldType ||\n        baseFieldType instanceof fieldtypearray_1.FieldTypeArray ||\n        baseFieldType instanceof ndimensionalfieldtypearray_1.NDimensionalFieldTypeArray ||\n        baseFieldType instanceof collectionenumfieldtype_1.CollectionEnumFieldType) {\n        return baseFieldType.toJSON();\n    }\n    return baseFieldType;\n}\nexports.serializeBaseFieldTypeDefinition = serializeBaseFieldTypeDefinition;\nfunction deserializeBaseFieldTypeDefinition(baseFieldType) {\n    if ((0, literalfieldtype_1.isSerializedLiteralFieldType)(baseFieldType)) {\n        return (0, literalfieldtype_1.deserializeLiteralFieldType)(baseFieldType);\n    }\n    if ((0, collectionenumfieldtype_1.isSerializedCollectionEnumFieldType)(baseFieldType)) {\n        return (0, collectionenumfieldtype_1.deserializeCollectionEnumFieldType)(baseFieldType);\n    }\n    if ((0, fieldtypearray_1.isSerializedFieldTypeArray)(baseFieldType, isSerializedBaseFieldTypeDefinition)) {\n        return (0, fieldtypearray_1.deserializeFieldTypeArray)(baseFieldType);\n    }\n    if ((0, ndimensionalfieldtypearray_1.isSerializedNDimensionalFieldTypeArray)(baseFieldType)) {\n        return (0, ndimensionalfieldtypearray_1.deserializeNDimensionalFieldTypeArray)(baseFieldType);\n    }\n    return baseFieldType;\n}\nexports.deserializeBaseFieldTypeDefinition = deserializeBaseFieldTypeDefinition;\nfunction isSerializedBaseFieldTypeDefinition(definition) {\n    return ((0, checks_1.isDefAndNotNull)(scalarfieldtype_1.ScalarFieldTypeEnum[definition]) ||\n        (0, literalfieldtype_1.isSerializedLiteralFieldType)(definition) ||\n        (0, collectionenumfieldtype_1.isSerializedCollectionEnumFieldType)(definition) ||\n        (0, fieldtypearray_1.isSerializedFieldTypeArray)(definition, isSerializedBaseFieldTypeDefinition) ||\n        (0, ndimensionalfieldtypearray_1.isSerializedNDimensionalFieldTypeArray)(definition));\n}\nexports.isSerializedBaseFieldTypeDefinition = isSerializedBaseFieldTypeDefinition;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedCollectionEnumFieldType = exports.deserializeCollectionEnumFieldType = exports.isCollectionEnumFieldType = exports.CollectionEnumFieldType = exports.isCollectionEnumFieldNames = exports.CollectionEnumFieldNames = exports.CollectionEnumFieldTypeKey = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nexports.CollectionEnumFieldTypeKey = 'COLLECTION_ENUM';\n/**\n * Contains the field names of all valid fields for a groovy metadata collection.\n *\n * This should be kept in sync with GroovyFieldNames in FieldType.scala\n */\nvar CollectionEnumFieldNames;\n(function (CollectionEnumFieldNames) {\n    CollectionEnumFieldNames[\"Name\"] = \"name\";\n    CollectionEnumFieldNames[\"Id\"] = \"id\";\n    CollectionEnumFieldNames[\"Description\"] = \"description\";\n    CollectionEnumFieldNames[\"Color\"] = \"color\";\n    CollectionEnumFieldNames[\"IconUrl\"] = \"iconUrl\";\n})(CollectionEnumFieldNames || (exports.CollectionEnumFieldNames = CollectionEnumFieldNames = {}));\nexports.isCollectionEnumFieldNames = (0, validators_1.enumValidator)(CollectionEnumFieldNames);\nclass CollectionEnumFieldType {\n    constructor(collectionId) {\n        this.collectionId = collectionId;\n    }\n    toJSON() {\n        return { [exports.CollectionEnumFieldTypeKey]: this.collectionId };\n    }\n}\nexports.CollectionEnumFieldType = CollectionEnumFieldType;\n/**\n * Specifies which groovy field name is used as the primary key.\n *\n * This should be kept in sync with GroovyFieldNames in FieldType.scala\n */\nCollectionEnumFieldType.PRIMARY_KEY = CollectionEnumFieldNames.Id;\nconst isCollectionEnumFieldType = (fieldType) => {\n    return fieldType instanceof CollectionEnumFieldType;\n};\nexports.isCollectionEnumFieldType = isCollectionEnumFieldType;\nfunction deserializeCollectionEnumFieldType(serializedCollectionEnumFieldType) {\n    return new CollectionEnumFieldType(serializedCollectionEnumFieldType[exports.CollectionEnumFieldTypeKey]);\n}\nexports.deserializeCollectionEnumFieldType = deserializeCollectionEnumFieldType;\nfunction isSerializedCollectionEnumFieldType(fieldType) {\n    return (0, checks_1.isObjectUnsafe)(fieldType) && (0, checks_1.isString)(fieldType[exports.CollectionEnumFieldTypeKey]);\n}\nexports.isSerializedCollectionEnumFieldType = isSerializedCollectionEnumFieldType;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeFieldTypeArray = exports.isSerializedFieldTypeArray = exports.FieldTypeArray = exports.BaseFieldTypeArray = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst collectionenumfieldtype_1 = __webpack_require__(/*! ./collectionenumfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nclass BaseFieldTypeArray {\n    constructor(validTypesArray) {\n        this.validTypesArray = validTypesArray;\n    }\n    getInnerTypes() {\n        return this.validTypesArray;\n    }\n    getInnerNonArrayTypes() {\n        return this.validTypesArray.filter((innerType) => !(innerType instanceof BaseFieldTypeArray));\n    }\n    toJSON() {\n        return {\n            'ND': false,\n            'validTypes': this.validTypesArray.map((t) => this.serializeType(t)),\n        };\n    }\n}\nexports.BaseFieldTypeArray = BaseFieldTypeArray;\nclass FieldTypeArray extends BaseFieldTypeArray {\n    serializeType(t) {\n        return (0, scalarfieldtype_1.isScalarFieldTypeEnum)(t) ? t : t.toJSON();\n    }\n}\nexports.FieldTypeArray = FieldTypeArray;\nfunction isSerializedFieldTypeArray(fieldType, validateTypeCheck) {\n    return ((0, checks_1.isObjectUnsafe)(fieldType) &&\n        (0, checks_1.isBoolean)(fieldType['ND']) &&\n        fieldType['ND'] === false &&\n        (0, checks_1.isArray)(fieldType['validTypes']) &&\n        fieldType['validTypes'].every((validType) => {\n            return validateTypeCheck(validType);\n        }));\n}\nexports.isSerializedFieldTypeArray = isSerializedFieldTypeArray;\nfunction deserializeFieldTypeArray(serializedFieldTypeArray) {\n    return new FieldTypeArray(serializedFieldTypeArray['validTypes'].map((t) => {\n        if ((0, literalfieldtype_1.isSerializedLiteralFieldType)(t)) {\n            return (0, literalfieldtype_1.deserializeLiteralFieldType)(t);\n        }\n        else if ((0, collectionenumfieldtype_1.isSerializedCollectionEnumFieldType)(t)) {\n            return (0, collectionenumfieldtype_1.deserializeCollectionEnumFieldType)(t);\n        }\n        else if ((0, checks_1.isObject)(t)) {\n            return deserializeFieldTypeArray(t);\n        }\n        return t;\n    }));\n}\nexports.deserializeFieldTypeArray = deserializeFieldTypeArray;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFieldTypeDefinition = exports.deserializeFieldTypeDefinition = exports.serializeFieldTypeDefinition = exports.fieldTypesEqual = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst basefieldtypedefinition_1 = __webpack_require__(/*! ./basefieldtypedefinition */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js\");\nconst collectionenumfieldtype_1 = __webpack_require__(/*! ./collectionenumfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\");\nconst fieldtypearray_1 = __webpack_require__(/*! ./fieldtypearray */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst ndimensionalfieldtypearray_1 = __webpack_require__(/*! ./ndimensionalfieldtypearray */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js\");\nfunction fieldTypesEqual(a, b, checkEnumCollectionId = true) {\n    if (a === b) {\n        return true;\n    }\n    if ((0, literalfieldtype_1.isLiteralFieldType)(a) && (0, literalfieldtype_1.isLiteralFieldType)(b)) {\n        return a.getLiteral() === b.getLiteral();\n    }\n    if ((0, collectionenumfieldtype_1.isCollectionEnumFieldType)(a) && (0, collectionenumfieldtype_1.isCollectionEnumFieldType)(b)) {\n        return checkEnumCollectionId ? a.collectionId === b.collectionId : true;\n    }\n    a = (0, checks_1.isArray)(a) ? a : [a];\n    b = (0, checks_1.isArray)(b) ? b : [b];\n    const setA = new Set(a);\n    const setB = new Set(b);\n    if (setA.size !== setB.size) {\n        return false;\n    }\n    for (const bItem of setB) {\n        if (setA.has(bItem)) {\n            continue;\n        }\n        if ((0, literalfieldtype_1.isLiteralFieldType)(bItem)) {\n            const found = a.some((aItem) => (0, literalfieldtype_1.isLiteralFieldType)(aItem) && fieldTypesEqual(aItem, bItem));\n            if (!found) {\n                return false;\n            }\n        }\n        else if (bItem instanceof fieldtypearray_1.FieldTypeArray) {\n            const found = a.some((aItem) => aItem instanceof fieldtypearray_1.FieldTypeArray && fieldTypesEqual(aItem.validTypesArray, bItem.validTypesArray));\n            if (!found) {\n                return false;\n            }\n        }\n        else if ((0, ndimensionalfieldtypearray_1.isNDimensionalFieldTypeArray)(bItem)) {\n            const aItem = a.find(ndimensionalfieldtypearray_1.isNDimensionalFieldTypeArray);\n            if (!aItem || !fieldTypesEqual(aItem.validTypesArray, bItem.validTypesArray)) {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\nexports.fieldTypesEqual = fieldTypesEqual;\nfunction serializeFieldTypeDefinition(fieldType) {\n    if ((0, checks_1.isArray)(fieldType)) {\n        return fieldType.map(basefieldtypedefinition_1.serializeBaseFieldTypeDefinition);\n    }\n    else {\n        return (0, basefieldtypedefinition_1.serializeBaseFieldTypeDefinition)(fieldType);\n    }\n}\nexports.serializeFieldTypeDefinition = serializeFieldTypeDefinition;\nfunction deserializeFieldTypeDefinition(serializedFieldType) {\n    if ((0, checks_1.isArray)(serializedFieldType)) {\n        return serializedFieldType.map(basefieldtypedefinition_1.deserializeBaseFieldTypeDefinition);\n    }\n    return (0, basefieldtypedefinition_1.deserializeBaseFieldTypeDefinition)(serializedFieldType);\n}\nexports.deserializeFieldTypeDefinition = deserializeFieldTypeDefinition;\nfunction isSerializedFieldTypeDefinition(definition) {\n    if ((0, checks_1.isArray)(definition)) {\n        return definition.every(basefieldtypedefinition_1.isSerializedBaseFieldTypeDefinition);\n    }\n    return (0, basefieldtypedefinition_1.isSerializedBaseFieldTypeDefinition)(definition);\n}\nexports.isSerializedFieldTypeDefinition = isSerializedFieldTypeDefinition;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeLiteralFieldType = exports.isSerializedLiteralFieldType = exports.isLiteralFieldType = exports.LiteralFieldType = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nclass LiteralFieldType {\n    constructor(literal) {\n        this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.ANY;\n        if ((0, checks_1.isString)(literal)) {\n            this.literal = literal.substring(LiteralFieldType.literalStringPrefix.length);\n            this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.STRING;\n        }\n        else if ((0, checks_1.isBoolean)(literal)) {\n            this.literal = literal;\n            this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.BOOLEAN;\n        }\n        else {\n            this.literal = literal;\n            this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER;\n        }\n    }\n    getLiteral() {\n        return this.literal;\n    }\n    getScalarFieldType() {\n        return this.scalarFieldType;\n    }\n    toJSON() {\n        if (this.scalarFieldType === scalarfieldtype_1.ScalarFieldTypeEnum.STRING) {\n            return LiteralFieldType.literalStringPrefix + this.literal;\n        }\n        return this.literal.toString();\n    }\n}\nexports.LiteralFieldType = LiteralFieldType;\nLiteralFieldType.literalStringPrefix = '%';\nfunction isLiteralFieldType(fieldType) {\n    return fieldType instanceof LiteralFieldType;\n}\nexports.isLiteralFieldType = isLiteralFieldType;\nfunction isSerializedLiteralFieldType(definition) {\n    return (0, checks_1.isString)(definition);\n}\nexports.isSerializedLiteralFieldType = isSerializedLiteralFieldType;\n/**\n * String literals without the literalStringPrefix will return the boolean literal false\n */\nfunction deserializeLiteralFieldType(serializedLiteralFieldType) {\n    if (serializedLiteralFieldType.startsWith(LiteralFieldType.literalStringPrefix)) {\n        return new LiteralFieldType(serializedLiteralFieldType);\n    }\n    const numberLiteral = Number(serializedLiteralFieldType);\n    if (isNaN(numberLiteral) ||\n        numberLiteral === Number.POSITIVE_INFINITY ||\n        numberLiteral === Number.NEGATIVE_INFINITY) {\n        return new LiteralFieldType(serializedLiteralFieldType === 'true');\n    }\n    return new LiteralFieldType(numberLiteral);\n}\nexports.deserializeLiteralFieldType = deserializeLiteralFieldType;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeNDimensionalFieldTypeArray = exports.isSerializedNDimensionalFieldTypeArray = exports.isNDimensionalFieldTypeArray = exports.isValidTypeForNDimensionalFieldTypeArray = exports.NDimensionalFieldTypeArray = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nclass NDimensionalFieldTypeArray {\n    constructor(validTypesArray) {\n        this.validTypesArray = validTypesArray;\n    }\n    getInnerTypes() {\n        return [...this.validTypesArray, this];\n    }\n    getInnerNonArrayTypes() {\n        return this.validTypesArray.filter((innerType) => (0, scalarfieldtype_1.isScalarFieldTypeEnum)(innerType) || (0, literalfieldtype_1.isLiteralFieldType)(innerType));\n    }\n    toJSON() {\n        return {\n            'ND': true,\n            'validTypes': this.validTypesArray.map((t) => ((0, scalarfieldtype_1.isScalarFieldTypeEnum)(t) ? t : t.toJSON())),\n        };\n    }\n}\nexports.NDimensionalFieldTypeArray = NDimensionalFieldTypeArray;\nfunction isValidTypeForNDimensionalFieldTypeArray(fieldType) {\n    return (0, scalarfieldtype_1.isScalarFieldTypeEnum)(fieldType) || (0, literalfieldtype_1.isLiteralFieldType)(fieldType);\n}\nexports.isValidTypeForNDimensionalFieldTypeArray = isValidTypeForNDimensionalFieldTypeArray;\nfunction isNDimensionalFieldTypeArray(fieldType) {\n    return fieldType instanceof NDimensionalFieldTypeArray;\n}\nexports.isNDimensionalFieldTypeArray = isNDimensionalFieldTypeArray;\nfunction isSerializedNDimensionalFieldTypeArray(fieldType) {\n    return ((0, checks_1.isObjectUnsafe)(fieldType) &&\n        (0, checks_1.isBoolean)(fieldType['ND']) &&\n        fieldType['ND'] === true &&\n        (0, checks_1.isTypedArray)(checks_1.isAny)(fieldType['validTypes']) &&\n        fieldType['validTypes'].every((validType) => {\n            return (0, checks_1.isDefAndNotNull)(scalarfieldtype_1.ScalarFieldTypeEnum[validType]) || (0, literalfieldtype_1.isSerializedLiteralFieldType)(validType);\n        }));\n}\nexports.isSerializedNDimensionalFieldTypeArray = isSerializedNDimensionalFieldTypeArray;\nfunction deserializeNDimensionalFieldTypeArray(serializedNDimensionalFieldTypeArray) {\n    return new NDimensionalFieldTypeArray(serializedNDimensionalFieldTypeArray['validTypes'].map((t) => {\n        if ((0, literalfieldtype_1.isSerializedLiteralFieldType)(t)) {\n            return (0, literalfieldtype_1.deserializeLiteralFieldType)(t);\n        }\n        return t;\n    }));\n}\nexports.deserializeNDimensionalFieldTypeArray = deserializeNDimensionalFieldTypeArray;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isScalarFieldTypeEnum = exports.AnyScalarFieldType = exports.ScalarFieldTypeEnum = void 0;\nvar ScalarFieldTypeEnum;\n(function (ScalarFieldTypeEnum) {\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"ANY\"] = 0] = \"ANY\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"NUMBER\"] = 1] = \"NUMBER\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"BOOLEAN\"] = 2] = \"BOOLEAN\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"STRING\"] = 3] = \"STRING\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"COLOR\"] = 4] = \"COLOR\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"DATE\"] = 5] = \"DATE\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"NULL\"] = 6] = \"NULL\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"DICTIONARY\"] = 7] = \"DICTIONARY\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"CURRENCY\"] = 8] = \"CURRENCY\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"DATEONLY\"] = 9] = \"DATEONLY\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"TIMEONLY\"] = 10] = \"TIMEONLY\";\n})(ScalarFieldTypeEnum || (exports.ScalarFieldTypeEnum = ScalarFieldTypeEnum = {}));\nexports.AnyScalarFieldType = [\n    ScalarFieldTypeEnum.ANY,\n    ScalarFieldTypeEnum.NUMBER,\n    ScalarFieldTypeEnum.STRING,\n    ScalarFieldTypeEnum.BOOLEAN,\n    ScalarFieldTypeEnum.COLOR,\n    ScalarFieldTypeEnum.DATE,\n    ScalarFieldTypeEnum.DATEONLY,\n    ScalarFieldTypeEnum.NULL,\n    ScalarFieldTypeEnum.DICTIONARY,\n    ScalarFieldTypeEnum.CURRENCY,\n    ScalarFieldTypeEnum.TIMEONLY,\n];\nconst AnyScalarFieldTypeSet = new Set(exports.AnyScalarFieldType);\nconst isScalarFieldTypeEnum = (fieldType) => {\n    return AnyScalarFieldTypeSet.has(fieldType);\n};\nexports.isScalarFieldTypeEnum = isScalarFieldTypeEnum;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSemanticFields = exports.SemanticFields = void 0;\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * Semantic Fields serve as standardized categories that transcend individual data source labels, facilitating\n * a uniform way to access and manipulate data. For instance, regardless of the source, data that pertains to \"titles\"\n * or \"user information\" often carries the same kind of information, though it may be labeled differently across systems.\n * Lucid’s Semantic Fields ensure that such data is recognized and treated consistently within the platform,\n * regardless of external labeling conventions.\n *\n * Semantic Mapping is the process through which Lucid aligns these disparate field names to a set of standardized\n * Semantic Fields. By using Semantic Fields like Title, Description, User, and Project, Lucid simplifies the way\n * users access and interact with data brought in from external sources.\n *\n * Benefits of Semantic Fields:\n * Uniformity: Ensures that data from diverse sources is referenced consistently within Lucid.\n * Integration Simplicity: Simplifies the process of integrating new data sources into Lucid by mapping to an established set of Semantic Fields.\n * Feature Compatibility: Allows for seamless use of Lucid’s intelligent features across all data, regardless of its origin.\n * Data Organization: Provides a structured approach to organizing and grouping data within the Lucid ecosystem.\n */\nvar SemanticFields;\n(function (SemanticFields) {\n    /**\n     * Represents the title or main descriptor of an item.\n     */\n    SemanticFields[\"Title\"] = \"title\";\n    /**\n     * Captures detailed information or a summary about an item.\n     */\n    SemanticFields[\"Description\"] = \"description\";\n    /**\n     * Refers to the user associated with or assigned to an item.\n     */\n    SemanticFields[\"User\"] = \"user\";\n    /**\n     * Specific to the reporting user, typically in the context of a ticketing system.\n     */\n    SemanticFields[\"Reporter\"] = \"user.reporter\";\n    /**\n     * Refers to the time associated with an item.\n     */\n    SemanticFields[\"Time\"] = \"time\";\n    /**\n     * Pertains to the ending or completion time of an item.\n     */\n    SemanticFields[\"EndTime\"] = \"time.endtime\";\n    /**\n     * Contains estimations related to items, like time or resource estimates.\n     */\n    SemanticFields[\"Estimate\"] = \"estimate\";\n    /**\n     * Reflects status of an item, typically in the context of a ticketing system.\n     */\n    SemanticFields[\"Status\"] = \"status\";\n    /**\n     * Classifies the type of issue or item, typically in the context of a ticketing system.\n     */\n    SemanticFields[\"IssueType\"] = \"issuetype\";\n    /**\n     * Indicates the importance or urgency level of an item.\n     */\n    SemanticFields[\"Priority\"] = \"priority\";\n    /**\n     * Relates to the project with which an item is associated.\n     */\n    SemanticFields[\"Project\"] = \"project\";\n    /**\n     * The unique URL or identifier linking back to the item’s source.\n     */\n    SemanticFields[\"SourceItemUrl\"] = \"url\";\n    /**\n     * Refers to the URL of the image associated with this item\n     */\n    SemanticFields[\"ImageUrl\"] = \"url.image\";\n})(SemanticFields || (exports.SemanticFields = SemanticFields = {}));\nexports.isSemanticFields = (0, validators_1.stringEnumValidator)(SemanticFields);\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.semanticKindToSemanticFields = exports.isSemanticKind = exports.SemanticKind = void 0;\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst semanticfields_1 = __webpack_require__(/*! ./semanticfields */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js\");\n/**\n * @deprecated use SemanticFields instead. SemanticKind has not been removed to ensure backwards compatability.\n */\nvar SemanticKind;\n(function (SemanticKind) {\n    SemanticKind[\"Id\"] = \"id\";\n    SemanticKind[\"Title\"] = \"title\";\n    SemanticKind[\"Name\"] = \"name\";\n    SemanticKind[\"Image\"] = \"image\";\n    SemanticKind[\"Description\"] = \"description\";\n    SemanticKind[\"Assignee\"] = \"assignee\";\n    SemanticKind[\"Estimate\"] = \"estimate\";\n    SemanticKind[\"Status\"] = \"status\";\n    SemanticKind[\"IssueType\"] = \"issuetype\";\n    SemanticKind[\"Priority\"] = \"priority\";\n    SemanticKind[\"Project\"] = \"project\";\n    SemanticKind[\"Reporter\"] = \"reporter\";\n    SemanticKind[\"StartTime\"] = \"starttime\";\n    SemanticKind[\"EndTime\"] = \"endtime\";\n    SemanticKind[\"GroupByHint\"] = \"groupbyhint\";\n    SemanticKind[\"PrimaryKeyReference\"] = \"primarykeyreference\";\n    SemanticKind[\"URL\"] = \"url\";\n})(SemanticKind || (exports.SemanticKind = SemanticKind = {}));\nexports.isSemanticKind = (0, validators_1.enumValidator)(SemanticKind);\nfunction semanticKindToSemanticFields(semanticField) {\n    if ((0, semanticfields_1.isSemanticFields)(semanticField)) {\n        return semanticField;\n    }\n    else {\n        switch (semanticField) {\n            case SemanticKind.Id:\n                return undefined;\n            case SemanticKind.Title:\n                return semanticfields_1.SemanticFields.Title;\n            // Name could have been mapped to User or Title but all uses cases outside of the unified viz API use it as Title\n            case SemanticKind.Name:\n                return semanticfields_1.SemanticFields.Title;\n            case SemanticKind.Image:\n                return semanticfields_1.SemanticFields.ImageUrl;\n            case SemanticKind.Description:\n                return semanticfields_1.SemanticFields.Description;\n            case SemanticKind.Assignee:\n                return semanticfields_1.SemanticFields.User;\n            case SemanticKind.Estimate:\n                return semanticfields_1.SemanticFields.Estimate;\n            case SemanticKind.Status:\n                return semanticfields_1.SemanticFields.Status;\n            case SemanticKind.IssueType:\n                return semanticfields_1.SemanticFields.IssueType;\n            case SemanticKind.Priority:\n                return semanticfields_1.SemanticFields.Priority;\n            case SemanticKind.Project:\n                return semanticfields_1.SemanticFields.Project;\n            case SemanticKind.Reporter:\n                return semanticfields_1.SemanticFields.Reporter;\n            case SemanticKind.StartTime:\n                return semanticfields_1.SemanticFields.Time;\n            case SemanticKind.EndTime:\n                return semanticfields_1.SemanticFields.EndTime;\n            case SemanticKind.GroupByHint:\n                return undefined;\n            case SemanticKind.PrimaryKeyReference:\n                return undefined;\n            case SemanticKind.URL:\n                return semanticfields_1.SemanticFields.SourceItemUrl;\n            default:\n                return undefined;\n        }\n    }\n}\nexports.semanticKindToSemanticFields = semanticKindToSemanticFields;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFlattenedReference = exports.isUnTypedSerializedFlattenedReference = exports.isTypedSerializedFlattenedReference = exports.FlattenedReferenceKeyName = exports.FlattenedReferenceKeyId = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nexports.FlattenedReferenceKeyId = '192d0e9f-2f5a-4032-9f03-59bbf1ea5891';\nexports.FlattenedReferenceKeyName = '192d0e9f-2f5a-4032-9f03-59bbf1ea5891_n';\n/** @ignore */\nfunction isTypedSerializedFlattenedReference(data) {\n    return (0, checks_1.isObjectUnsafe)(data) && (0, checks_1.isObject)(data['sc']) && (0, checks_1.isObject)(data['d']);\n}\nexports.isTypedSerializedFlattenedReference = isTypedSerializedFlattenedReference;\n/** @ignore */\nfunction isUnTypedSerializedFlattenedReference(data) {\n    return (0, checks_1.isObjectUnsafe)(data) && data[exports.FlattenedReferenceKeyId] === true;\n}\nexports.isUnTypedSerializedFlattenedReference = isUnTypedSerializedFlattenedReference;\n/** @ignore */\nfunction isSerializedFlattenedReference(data) {\n    return isUnTypedSerializedFlattenedReference(data) || isTypedSerializedFlattenedReference(data);\n}\nexports.isSerializedFlattenedReference = isSerializedFlattenedReference;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedDataItems = void 0;\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializedfields_1 = __webpack_require__(/*! ./serializedfields */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js\");\nexports.isSerializedDataItems = (0, validators_1.objectOfValidator)(serializedfields_1.isSerializedFields);\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFieldDefinition = exports.isSerializedFieldConstraint = exports.isFieldConstraintType = exports.FieldConstraintType = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../fieldtypedefinition/fieldtypedefinition */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst semanticfields_1 = __webpack_require__(/*! ../fieldtypedefinition/semanticfields */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js\");\nconst semantickind_1 = __webpack_require__(/*! ../fieldtypedefinition/semantickind */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js\");\n// The options here must match com.lucidchart.data.model.fielddefinition.FieldConstraintType on the backend\nvar FieldConstraintType;\n(function (FieldConstraintType) {\n    FieldConstraintType[\"REQUIRED\"] = \"required\";\n    FieldConstraintType[\"LOCKED\"] = \"locked\";\n    FieldConstraintType[\"MIN_VALUE\"] = \"minValue\";\n    FieldConstraintType[\"MAX_VALUE\"] = \"maxValue\";\n    FieldConstraintType[\"SINGLE_LINE_ONLY\"] = \"singleLineOnly\";\n    FieldConstraintType[\"NO_WHITESPACE\"] = \"noWhitespace\";\n    FieldConstraintType[\"UNIQUE_EDIT\"] = \"uniqueEditType\";\n    FieldConstraintType[\"MAX_LENGTH\"] = \"maxLength\";\n})(FieldConstraintType || (exports.FieldConstraintType = FieldConstraintType = {}));\nexports.isFieldConstraintType = (0, validators_1.enumValidator)(FieldConstraintType);\nexports.isSerializedFieldConstraint = (0, validators_1.objectValidator)({\n    'Type': (0, validators_1.enumValidator)(FieldConstraintType),\n    'Details': (0, validators_1.option)(checks_1.isAny),\n});\nexports.isSerializedFieldDefinition = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'Type': fieldtypedefinition_1.isSerializedFieldTypeDefinition,\n    'Constraints': (0, validators_1.option)((0, validators_1.arrayValidator)(exports.isSerializedFieldConstraint)),\n    'SyncSchema': (0, validators_1.option)(checks_1.isString),\n    'Mapping': (0, validators_1.option)((0, validators_1.either)((0, validators_1.arrayValidator)(semanticfields_1.isSemanticFields), (0, validators_1.arrayValidator)(semantickind_1.isSemanticKind))),\n});\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFields = exports.isSerializedJsonFieldType = exports.isSerializedFieldType = exports.isSerializedTimeObject = exports.isSerializedLucidDateObject = exports.isSerializedIsoDateObject = exports.isSerializedMillisecondsDateObject = exports.isSerializedLucidCurrency = exports.isSerializedLucidDictionary = exports.isJsonSerializedLucidDictionary = exports.isNestedSerializedLucidDictionary = exports.isSerializedColorObjectFieldType = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nfunction isSerializedColorObjectFieldType(value) {\n    return (0, checks_1.isObjectUnsafe)(value) && (0, checks_1.isObject)(value['color']);\n}\nexports.isSerializedColorObjectFieldType = isSerializedColorObjectFieldType;\n/** a dictionary type that has full type support */\nexports.isNestedSerializedLucidDictionary = (0, validators_1.strictObjectValidator)({\n    'dict': (0, validators_1.mapValidator)(isSerializedFieldType),\n});\n/** a dictionary type that only supports raw js, primarily used when external data could be arbritrary js */\nexports.isJsonSerializedLucidDictionary = (0, validators_1.strictObjectValidator)({\n    'js': (0, validators_1.mapValidator)(isSerializedJsonFieldType),\n});\nexports.isSerializedLucidDictionary = (0, validators_1.either)(exports.isNestedSerializedLucidDictionary, exports.isJsonSerializedLucidDictionary);\nexports.isSerializedLucidCurrency = (0, validators_1.objectValidator)({\n    'a': checks_1.isNumber,\n    't': checks_1.isString,\n});\nexports.isSerializedMillisecondsDateObject = (0, validators_1.objectValidator)({\n    'ms': checks_1.isNumber,\n    'isDateOnly': (0, validators_1.option)(checks_1.isBoolean),\n});\nexports.isSerializedIsoDateObject = (0, validators_1.objectValidator)({\n    'isoDate': checks_1.isString,\n    'displayTimezone': (0, validators_1.nullableOption)(checks_1.isString),\n});\nexports.isSerializedLucidDateObject = (0, validators_1.either)(exports.isSerializedMillisecondsDateObject, exports.isSerializedIsoDateObject);\nexports.isSerializedTimeObject = (0, validators_1.objectValidator)({\n    'hours': checks_1.isNumber,\n    'minutes': (0, validators_1.option)(checks_1.isNumber),\n    'seconds': (0, validators_1.option)(checks_1.isNumber),\n});\nfunction isSerializedFieldType(value) {\n    return (value == null ||\n        (0, checks_1.isNumber)(value) ||\n        (0, checks_1.isString)(value) ||\n        (0, checks_1.isBoolean)(value) ||\n        (0, exports.isSerializedLucidDictionary)(value) ||\n        (0, exports.isSerializedLucidCurrency)(value) ||\n        ((0, checks_1.isArray)(value) && value.every(isSerializedFieldType)) ||\n        (0, exports.isSerializedLucidDateObject)(value) ||\n        (0, exports.isSerializedTimeObject)(value) ||\n        isSerializedColorObjectFieldType(value));\n}\nexports.isSerializedFieldType = isSerializedFieldType;\nfunction isSerializedJsonFieldType(value) {\n    return (value == null ||\n        (0, checks_1.isNumber)(value) ||\n        (0, checks_1.isString)(value) ||\n        (0, checks_1.isBoolean)(value) ||\n        ((0, checks_1.isArray)(value) && value.every(isSerializedJsonFieldType)) ||\n        ((0, checks_1.isObject)(value) && Object.values(value).every(isSerializedJsonFieldType)));\n}\nexports.isSerializedJsonFieldType = isSerializedJsonFieldType;\nexports.isSerializedFields = (0, validators_1.objectOfValidator)(isSerializedFieldType);\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedSchema = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializedfielddefinition_1 = __webpack_require__(/*! ./serializedfielddefinition */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\");\nfunction isSerializedSchema(schema) {\n    if (schema == null) {\n        return false;\n    }\n    const fields = schema['Fields'];\n    const primaryKey = schema['PrimaryKey'];\n    const fieldLabelOverrides = schema['FieldLabelOverrides'];\n    const validOverrides = (0, checks_1.isDefAndNotNull)(fieldLabelOverrides)\n        ? (0, checks_1.isRecord)(checks_1.isString)(fieldLabelOverrides) && !(0, checks_1.isArray)(fieldLabelOverrides)\n        : true; // Optional field\n    return ((0, checks_1.isTypedArray)(serializedfielddefinition_1.isSerializedFieldDefinition)(fields) &&\n        (0, validators_1.arrayValidator)(serializedfielddefinition_1.isSerializedFieldDefinition)(fields) &&\n        (0, checks_1.isArray)(primaryKey) &&\n        primaryKey.every(checks_1.isString) &&\n        validOverrides);\n}\nexports.isSerializedSchema = isSerializedSchema;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/dataerrortype.js":
/*!********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/dataerrortype.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/dataerrortype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/defer.js":
/*!************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/defer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defer = void 0;\nfunction checkPromiseExists() {\n    if (typeof Promise !== 'function') {\n        throw new Error('No promise library available');\n    }\n}\nfunction defer() {\n    checkPromiseExists();\n    let resolve = undefined;\n    let reject = undefined;\n    const promise = new Promise((resolveLocal, rejectLocal) => {\n        resolve = resolveLocal;\n        reject = rejectLocal;\n    });\n    if (!resolve || !reject) {\n        throw new Error('Promise constructor does not provide proper arguments to callback');\n    }\n    return {\n        resolve: resolve,\n        reject: reject,\n        promise: promise,\n        then: promise.then.bind(promise),\n        catch: promise.catch.bind(promise),\n        finally: promise.finally.bind(promise),\n        [Symbol.toStringTag]: promise[Symbol.toStringTag],\n    };\n}\nexports.defer = defer;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/defer.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/guards.js":
/*!*************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/guards.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/guards.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/humanreadableerror.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/humanreadableerror.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HumanReadableError = void 0;\n/**\n * An error carrying a message that is good to be shown directly in the UI.\n * These can be thrown from extensions and caught in core code.\n */\nclass HumanReadableError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'HumanReadableError';\n    }\n}\nexports.HumanReadableError = HumanReadableError;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/humanreadableerror.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/iframe/iframeutils.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/iframe/iframeutils.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseIFrameAttributesFromHTML = exports.generateIFrameHTML = exports.DEFAULT_IFRAME_HEIGHT = exports.DEFAULT_IFRAME_WIDTH = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\n/**\n * Aspect ratio 16:9, wider rectangle\n * This will be the default setting if not provided\n *\n * The values are small since we only use width and height value to calculate aspect ratio\n * So in this case, it will be width/height, which will be 16:9\n * It's the same result as 1600 and 900 as default width and height\n */\nexports.DEFAULT_IFRAME_WIDTH = 16;\nexports.DEFAULT_IFRAME_HEIGHT = 9;\n/**\n * Iframes from external sources are not trustworthy to be embedded directly. They could cause security vulnerability,\n * including XSS attacks. Even if the iframes come from sources with good reputation, it is still a good practice to\n * sanitize their source HTML and restrict their functionality in the sandbox before embedding them to our apps.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe for a list of iframe attributes.\n */\nconst iframeRegExps = {\n    src: /src=\"((https:\\/\\/|\\/\\/).*?)\"/i,\n    height: /height=\"(\\d*?)\"/i,\n    width: /width=\"(\\d*?)\"/i,\n    title: /title=\"(.*?)\"/i,\n};\n/**\n * Generate iframe HTML from the IFrameAttributes object\n * @returns the generated iframe HTML\n * @ignore\n * */\nfunction generateIFrameHTML(iframeAttributes) {\n    let iframeHTML = `<iframe src=\"${iframeAttributes.src}\"`;\n    if (iframeAttributes.width) {\n        iframeHTML += ` width=\"${iframeAttributes.width.toString()}\"`;\n    }\n    if (iframeAttributes.height) {\n        iframeHTML += ` height=\"${iframeAttributes.height.toString()}\"`;\n    }\n    if (iframeAttributes.title) {\n        // Escape all the double quotation marks\n        const title = iframeAttributes.title.replace(/\"/g, '&quot;');\n        iframeHTML += ` title=\"${title}\"`;\n    }\n    iframeHTML += '></iframe>';\n    return iframeHTML;\n}\nexports.generateIFrameHTML = generateIFrameHTML;\n/**\n * Parse the iframe HTML, i.e. <iframe>...</iframe> into the IFrameAttributes object\n * @returns the required attributes to render the target iframe\n * @ignore\n */\nfunction parseIFrameAttributesFromHTML(iframeHTML) {\n    var _a, _b, _c, _d, _e, _f;\n    if (!iframeHTML.startsWith('<iframe')) {\n        return {\n            srcdoc: iframeHTML,\n            height: exports.DEFAULT_IFRAME_HEIGHT,\n            width: exports.DEFAULT_IFRAME_WIDTH,\n        };\n    }\n    const src = (_b = (_a = iframeHTML.match(iframeRegExps.src)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : '';\n    const height = (_c = iframeHTML.match(iframeRegExps.height)) === null || _c === void 0 ? void 0 : _c[1];\n    const width = (_d = iframeHTML.match(iframeRegExps.width)) === null || _d === void 0 ? void 0 : _d[1];\n    const title = (_f = (_e = iframeHTML.match(iframeRegExps.title)) === null || _e === void 0 ? void 0 : _e[1]) !== null && _f !== void 0 ? _f : '';\n    return {\n        src: src,\n        height: !(0, checks_1.isUndefined)(height) ? Number.parseInt(height) : exports.DEFAULT_IFRAME_HEIGHT,\n        width: !(0, checks_1.isUndefined)(width) ? Number.parseInt(width) : exports.DEFAULT_IFRAME_WIDTH,\n        title: title,\n    };\n}\nexports.parseIFrameAttributesFromHTML = parseIFrameAttributesFromHTML;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/iframe/iframeutils.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/jsonserializable.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/jsonserializable.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isJsonObject = exports.isJsonSerializable = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nfunction isJsonSerializable(x) {\n    return (x == null ||\n        (0, checks_1.isString)(x) ||\n        (0, checks_1.isNumber)(x) ||\n        (0, checks_1.isBoolean)(x) ||\n        ((0, checks_1.isArray)(x) && x.every(isJsonSerializable)) ||\n        isJsonObject(x));\n}\nexports.isJsonSerializable = isJsonSerializable;\nfunction isJsonObject(x) {\n    if (!(0, checks_1.isObjectUnsafe)(x)) {\n        return false;\n    }\n    for (const k in x) {\n        if (!isJsonSerializable(x[k])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isJsonObject = isJsonObject;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/jsonserializable.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/lucidproduct.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/lucidproduct.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidProduct = void 0;\n/**\n * Lucid products supporting the extension API\n */\nvar LucidProduct;\n(function (LucidProduct) {\n    LucidProduct[\"Chart\"] = \"chart\";\n    LucidProduct[\"Spark\"] = \"spark\";\n    LucidProduct[\"TeamSpaces\"] = \"teamspaces\";\n})(LucidProduct || (exports.LucidProduct = LucidProduct = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/lucidproduct.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/object.js":
/*!*************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/object.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromEntries = exports.flatten = exports.objectEvery = void 0;\nfunction objectEvery(obj, f, opt_this) {\n    for (const key in obj) {\n        if (!f.call(opt_this, obj[key], key, obj)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.objectEvery = objectEvery;\nfunction flatten(a) {\n    const result = [];\n    for (const item of a) {\n        result.push(...item);\n    }\n    return result;\n}\nexports.flatten = flatten;\n// TODO: Placeholder until we adopt ES8 and can use Object.fromEntries(obj)\nfunction fromEntries(entries) {\n    const result = {};\n    for (const [key, value] of entries) {\n        result[key] = value;\n    }\n    return result;\n}\nexports.fromEntries = fromEntries;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/object.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/offsettype.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/offsettype.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLinearOffsetType = exports.OffsetType = void 0;\n/**\n * When adjusting the size or location of items on a page, these are the specific operations that are available.\n */\nvar OffsetType;\n(function (OffsetType) {\n    /**\n     * Resize from the northwest (upper-left) corner of the selection, anchoring the lower-right corner in place.\n     */\n    OffsetType[OffsetType[\"NW\"] = 0] = \"NW\";\n    /**\n     * Resize from the northeast (upper-right) corner of the selection, anchoring the lower-left corner in place.\n     */\n    OffsetType[OffsetType[\"NE\"] = 1] = \"NE\";\n    /**\n     * Resize from the southeast (lower-right) corner of the selection, anchoring the upper-left corner in place.\n     */\n    OffsetType[OffsetType[\"SE\"] = 2] = \"SE\";\n    /**\n     * Resize from the southwest (lower-left) corner of the selection, anchoring the upper-right corner in place.\n     */\n    OffsetType[OffsetType[\"SW\"] = 3] = \"SW\";\n    /**\n     * Move the selection without resizing.\n     */\n    OffsetType[OffsetType[\"MOVE\"] = 4] = \"MOVE\";\n    OffsetType[OffsetType[\"ROTATE\"] = 5] = \"ROTATE\";\n    OffsetType[OffsetType[\"SCALE\"] = 6] = \"SCALE\";\n    OffsetType[OffsetType[\"CUSTOM\"] = 7] = \"CUSTOM\";\n    /**\n     * Resize from the north (upper) side of the selection, stretching vertically.\n     */\n    OffsetType[OffsetType[\"N\"] = 8] = \"N\";\n    /**\n     * Resize from the east (right) side of the selection, stretching horizontally.\n     */\n    OffsetType[OffsetType[\"E\"] = 9] = \"E\";\n    /**\n     * Resize from the south (lower) side of the selection, stretching vertically.\n     */\n    OffsetType[OffsetType[\"S\"] = 10] = \"S\";\n    /**\n     * Resize from the west (left) side of the selection, stretching horizontally.\n     */\n    OffsetType[OffsetType[\"W\"] = 11] = \"W\";\n})(OffsetType || (exports.OffsetType = OffsetType = {}));\nfunction isLinearOffsetType(offsetType) {\n    return (offsetType === OffsetType.NW ||\n        offsetType === OffsetType.NE ||\n        offsetType === OffsetType.SE ||\n        offsetType === OffsetType.SW ||\n        offsetType === OffsetType.MOVE ||\n        offsetType === OffsetType.N ||\n        offsetType === OffsetType.E ||\n        offsetType === OffsetType.S ||\n        offsetType === OffsetType.W);\n}\nexports.isLinearOffsetType = isLinearOffsetType;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/offsettype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/optionalkey.js":
/*!******************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/optionalkey.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/optionalkey.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLayerPos = exports.isVerticalPos = exports.isHorizontalPos = exports.isValidSerializedBadgeEnumPosition = exports.serializeBadgeEnumPositionAsKey = exports.serializeBadgeEnumPosition = exports.deserializeBadgeEnumPosition = exports.badgePositionsEqual = exports.defaultBadgePositionSerialized = exports.defaultBadgePosition = exports.BadgePositionsClockwise = exports.BadgeResponsiveness = exports.BadgeLayerPos = exports.VerticalBadgePos = exports.HorizontalBadgePos = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nvar HorizontalBadgePos;\n(function (HorizontalBadgePos) {\n    HorizontalBadgePos[HorizontalBadgePos[\"LEFT\"] = 0] = \"LEFT\";\n    HorizontalBadgePos[HorizontalBadgePos[\"CENTER\"] = 1] = \"CENTER\";\n    HorizontalBadgePos[HorizontalBadgePos[\"RIGHT\"] = 2] = \"RIGHT\";\n})(HorizontalBadgePos || (exports.HorizontalBadgePos = HorizontalBadgePos = {}));\nvar VerticalBadgePos;\n(function (VerticalBadgePos) {\n    VerticalBadgePos[VerticalBadgePos[\"TOP\"] = 0] = \"TOP\";\n    VerticalBadgePos[VerticalBadgePos[\"CENTER\"] = 1] = \"CENTER\";\n    VerticalBadgePos[VerticalBadgePos[\"BOTTOM\"] = 2] = \"BOTTOM\";\n})(VerticalBadgePos || (exports.VerticalBadgePos = VerticalBadgePos = {}));\nvar BadgeLayerPos;\n(function (BadgeLayerPos) {\n    BadgeLayerPos[BadgeLayerPos[\"INSIDE\"] = 0] = \"INSIDE\";\n    BadgeLayerPos[BadgeLayerPos[\"EDGE\"] = 1] = \"EDGE\";\n    BadgeLayerPos[BadgeLayerPos[\"OUTSIDE\"] = 2] = \"OUTSIDE\";\n})(BadgeLayerPos || (exports.BadgeLayerPos = BadgeLayerPos = {}));\nvar BadgeResponsiveness;\n(function (BadgeResponsiveness) {\n    BadgeResponsiveness[BadgeResponsiveness[\"STATIC\"] = 0] = \"STATIC\";\n    BadgeResponsiveness[BadgeResponsiveness[\"STACK\"] = 1] = \"STACK\";\n})(BadgeResponsiveness || (exports.BadgeResponsiveness = BadgeResponsiveness = {}));\n/*\n * The order of the badge position starting from the top-left corner and going clockwise\n */\nexports.BadgePositionsClockwise = [\n    { horizontalPos: 0, verticalPos: 0 },\n    { horizontalPos: 1, verticalPos: 0 },\n    { horizontalPos: 2, verticalPos: 0 },\n    { horizontalPos: 2, verticalPos: 1 },\n    { horizontalPos: 2, verticalPos: 2 },\n    { horizontalPos: 1, verticalPos: 2 },\n    { horizontalPos: 0, verticalPos: 2 },\n    { horizontalPos: 0, verticalPos: 1 }, // left-center\n];\nexports.defaultBadgePosition = {\n    horizontalPos: HorizontalBadgePos.RIGHT,\n    verticalPos: VerticalBadgePos.TOP,\n    layer: BadgeLayerPos.EDGE,\n    responsive: BadgeResponsiveness.STACK,\n};\nexports.defaultBadgePositionSerialized = {\n    'horiz': HorizontalBadgePos.RIGHT,\n    'vert': VerticalBadgePos.TOP,\n    'layer': BadgeLayerPos.EDGE,\n    'responsive': BadgeResponsiveness.STACK,\n};\nfunction badgePositionsEqual(a, b) {\n    return (a.horizontalPos === b.horizontalPos &&\n        a.verticalPos === b.verticalPos &&\n        a.layer === b.layer &&\n        a.responsive === b.responsive);\n}\nexports.badgePositionsEqual = badgePositionsEqual;\nfunction deserializeBadgeEnumPosition(serialized) {\n    if (serialized == null) {\n        return undefined;\n    }\n    return {\n        horizontalPos: serialized['horiz'] != null ? serialized['horiz'] : exports.defaultBadgePosition.horizontalPos,\n        verticalPos: serialized['vert'] != null ? serialized['vert'] : exports.defaultBadgePosition.verticalPos,\n        layer: serialized['layer'] != null ? serialized['layer'] : exports.defaultBadgePosition.layer,\n        responsive: serialized['responsive'] != null ? serialized['responsive'] : exports.defaultBadgePosition.responsive,\n    };\n}\nexports.deserializeBadgeEnumPosition = deserializeBadgeEnumPosition;\nfunction serializeBadgeEnumPosition(position) {\n    if (position == null) {\n        return {\n            'horiz': exports.defaultBadgePosition.horizontalPos,\n            'vert': exports.defaultBadgePosition.verticalPos,\n            'layer': exports.defaultBadgePosition.layer,\n            'responsive': exports.defaultBadgePosition.responsive,\n        };\n    }\n    return {\n        'horiz': position.horizontalPos,\n        'vert': position.verticalPos,\n        'layer': position.layer,\n        'responsive': position.responsive,\n    };\n}\nexports.serializeBadgeEnumPosition = serializeBadgeEnumPosition;\nfunction serializeBadgeEnumPositionAsKey(position) {\n    return JSON.stringify(position);\n}\nexports.serializeBadgeEnumPositionAsKey = serializeBadgeEnumPositionAsKey;\nfunction isValidSerializedBadgeEnumPosition(val) {\n    // All fields are optional, so it's fine if they're not present\n    const horizValid = val['horiz'] == undefined || Object.values(HorizontalBadgePos).includes(val['horiz']);\n    const vertValid = val['vert'] == undefined || Object.values(VerticalBadgePos).includes(val['vert']);\n    const layerValid = val['layer'] == undefined || Object.values(BadgeLayerPos).includes(val['layer']);\n    const responsiveValid = val['responsive'] == undefined || Object.values(BadgeResponsiveness).includes(val['responsive']);\n    return horizValid && vertValid && layerValid && responsiveValid;\n}\nexports.isValidSerializedBadgeEnumPosition = isValidSerializedBadgeEnumPosition;\nfunction isHorizontalPos(maybePos) {\n    if ((0, checks_1.isNumber)(maybePos)) {\n        return !!HorizontalBadgePos[maybePos];\n    }\n    return false;\n}\nexports.isHorizontalPos = isHorizontalPos;\nfunction isVerticalPos(maybePos) {\n    if ((0, checks_1.isNumber)(maybePos)) {\n        return !!VerticalBadgePos[maybePos];\n    }\n    return false;\n}\nexports.isVerticalPos = isVerticalPos;\nfunction isLayerPos(maybePos) {\n    if ((0, checks_1.isNumber)(maybePos)) {\n        return !!BadgeLayerPos[maybePos];\n    }\n    return false;\n}\nexports.isLayerPos = isLayerPos;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.areDataGraphicImagesEqual = exports.areDataGraphicIconIndexesEqual = exports.DataGraphicIconSets = void 0;\nvar DataGraphicIconSets;\n(function (DataGraphicIconSets) {\n    // Custom icons are a user-defined set of uploaded icons, not a predefined set of icons\n    DataGraphicIconSets[DataGraphicIconSets[\"CUSTOM_ICONS\"] = -1] = \"CUSTOM_ICONS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STATUS_ICONS\"] = 0] = \"STATUS_ICONS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STATUS_CIRCLES\"] = 1] = \"STATUS_CIRCLES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STOPLIGHTS\"] = 2] = \"STOPLIGHTS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"TOGGLES\"] = 3] = \"TOGGLES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"COMPLETION_PIES\"] = 4] = \"COMPLETION_PIES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"TRENDING_ARROWS\"] = 5] = \"TRENDING_ARROWS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STATUS_CHECK_BOXES\"] = 6] = \"STATUS_CHECK_BOXES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"TRENDING_ARROWS_FLIPPED\"] = 7] = \"TRENDING_ARROWS_FLIPPED\";\n})(DataGraphicIconSets || (exports.DataGraphicIconSets = DataGraphicIconSets = {}));\nfunction areDataGraphicIconIndexesEqual(a, b) {\n    return a.set == b.set && a.index == b.index && areDataGraphicImagesEqual(a.iconImage, b.iconImage);\n}\nexports.areDataGraphicIconIndexesEqual = areDataGraphicIconIndexesEqual;\nfunction areDataGraphicImagesEqual(a, b) {\n    if (a == undefined || b == undefined) {\n        return a == b;\n    }\n    return a.w == b.w && a.h == b.h && a.url == b.url;\n}\nexports.areDataGraphicImagesEqual = areDataGraphicImagesEqual;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedSimpleStaticDataGraphicSettings = exports.deserializeSimpleStaticDataGraphicSettings = exports.serializeSimpleStaticDataGraphicSettings = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst badgeposition_1 = __webpack_require__(/*! ./badgeposition */ \"../../node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nfunction serializeSimpleStaticDataGraphicSettings(settings) {\n    return {\n        'icon': settings.icon,\n        'pos': (0, badgeposition_1.serializeBadgeEnumPosition)(settings.position),\n        'color': settings.color,\n    };\n}\nexports.serializeSimpleStaticDataGraphicSettings = serializeSimpleStaticDataGraphicSettings;\nfunction deserializeSimpleStaticDataGraphicSettings(settings) {\n    return {\n        icon: settings['icon'],\n        position: (0, badgeposition_1.deserializeBadgeEnumPosition)(settings['pos']),\n        color: settings['color'],\n    };\n}\nexports.deserializeSimpleStaticDataGraphicSettings = deserializeSimpleStaticDataGraphicSettings;\nfunction isSerializedSimpleStaticDataGraphicSettings(settings) {\n    return ((0, checks_1.isObjectUnsafe)(settings) &&\n        (0, checks_1.isString)(settings['color']) &&\n        (0, checks_1.isObject)(settings['icon']) &&\n        (0, badgeposition_1.isValidSerializedBadgeEnumPosition)(settings['pos']));\n}\nexports.isSerializedSimpleStaticDataGraphicSettings = isSerializedSimpleStaticDataGraphicSettings;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/properties/fillcolor.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/properties/fillcolor.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeSimpleFill = exports.SimpleImageFillPosition = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\n/**\n * Different ways of laying out the image in the background of the block.\n */\nvar SimpleImageFillPosition;\n(function (SimpleImageFillPosition) {\n    /** The image retains its original aspect ratio, and is as large as possible while still fitting in the block */\n    SimpleImageFillPosition[\"Fit\"] = \"fit\";\n    /** The image retains its original aspect ratio, and is as small as possible while still completely covering the block */\n    SimpleImageFillPosition[\"Fill\"] = \"fill\";\n    /** The image is stretched to the bounding box of the block */\n    SimpleImageFillPosition[\"Stretch\"] = \"stretch\";\n    /** The image is shown in its original size if possible */\n    SimpleImageFillPosition[\"Original\"] = \"original\";\n    /** The image is tiled in its original size vertically and horizontally to fully cover the block */\n    SimpleImageFillPosition[\"Tile\"] = \"tile\";\n    //TODO: 'mask' but mask requires additional settings\n})(SimpleImageFillPosition || (exports.SimpleImageFillPosition = SimpleImageFillPosition = {}));\n/** @ignore */\nfunction serializeSimpleFill(fill) {\n    if ((0, checks_1.isString)(fill)) {\n        return fill;\n    }\n    else {\n        return {\n            'pos': fill.position,\n            'url': fill.url,\n            'polys': null,\n        };\n    }\n}\nexports.serializeSimpleFill = serializeSimpleFill;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/properties/fillcolor.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/properties/shadow.js":
/*!************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/properties/shadow.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeShadow = exports.serializeShadow = void 0;\nfunction serializeShadow(shadow) {\n    return {\n        'x': shadow.distance * Math.cos(shadow.angle),\n        'y': shadow.distance * Math.sin(shadow.angle),\n        'b': shadow.blur,\n        'c': shadow.color,\n        'ang': shadow.angle,\n    };\n}\nexports.serializeShadow = serializeShadow;\nfunction deserializeShadow(shadow) {\n    var _a;\n    return {\n        distance: Math.sqrt(shadow['x'] * shadow['x'] + shadow['y'] * shadow['y']),\n        angle: (_a = shadow['ang']) !== null && _a !== void 0 ? _a : Math.atan2(shadow['y'], shadow['x']),\n        blur: shadow['b'],\n        color: shadow['c'],\n    };\n}\nexports.deserializeShadow = deserializeShadow;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/properties/shadow.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/properties/strokestyle.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/properties/strokestyle.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertStrokeStyleToBorder = exports.isStrokeStyle = exports.StrokeStyle = void 0;\nvar StrokeStyle;\n(function (StrokeStyle) {\n    StrokeStyle[\"Solid\"] = \"solid\";\n    StrokeStyle[\"Dashed\"] = \"dashed\";\n    StrokeStyle[\"LongDash\"] = \"longdash\";\n    StrokeStyle[\"DashDot\"] = \"dashdot\";\n    StrokeStyle[\"DashDotDot\"] = \"dashdotdot\";\n    StrokeStyle[\"DashLongDash\"] = \"dashlongdash\";\n    StrokeStyle[\"Dashed32\"] = \"dashed32\";\n    StrokeStyle[\"Dashed44\"] = \"dashed44\";\n    StrokeStyle[\"Dashed24\"] = \"dashed24\";\n    StrokeStyle[\"Dotted\"] = \"dotted\";\n    StrokeStyle[\"DotDotDot\"] = \"dotdotdot\";\n    StrokeStyle[\"StripeThinThin\"] = \"stripethinthin\";\n    StrokeStyle[\"StripeThickThick\"] = \"stripethickthick\";\n    StrokeStyle[\"StripeThickThin\"] = \"stripethickthin\";\n    StrokeStyle[\"StripeThinThick\"] = \"stripethinthick\";\n    StrokeStyle[\"StripeThickThinThick\"] = \"stripethickthinthick\";\n    StrokeStyle[\"StripeThinThickThin\"] = \"stripethinthickthin\";\n    StrokeStyle[\"StripeTriple\"] = \"stripetriple\";\n})(StrokeStyle || (exports.StrokeStyle = StrokeStyle = {}));\nconst strokeStyleSet = new Set(Object.values(StrokeStyle));\nfunction isStrokeStyle(value) {\n    return strokeStyleSet.has(value);\n}\nexports.isStrokeStyle = isStrokeStyle;\nfunction convertStrokeStyleToBorder(strokeStyle) {\n    if (strokeStyle.startsWith('dash') || strokeStyle == StrokeStyle.LongDash) {\n        return 'dashed';\n    }\n    else if (strokeStyle.startsWith('dot')) {\n        return 'dotted';\n    }\n    else {\n        return 'solid';\n    }\n}\nexports.convertStrokeStyleToBorder = convertStrokeStyleToBorder;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/properties/strokestyle.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/result.js":
/*!*************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/result.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isEqual = exports.groupByResultType = exports.isFailure = exports.isSuccess = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nfunction isSuccess(res) {\n    return (0, checks_1.isDef)(res.value);\n}\nexports.isSuccess = isSuccess;\nfunction isFailure(res) {\n    return (0, checks_1.isDef)(res.error);\n}\nexports.isFailure = isFailure;\nfunction groupByResultType(results) {\n    const successes = [];\n    const failures = [];\n    results.forEach((result) => {\n        if (isSuccess(result)) {\n            successes.push(result);\n        }\n        else {\n            failures.push(result);\n        }\n    });\n    return [successes, failures];\n}\nexports.groupByResultType = groupByResultType;\nfunction isEqual(a, b, valueCompS, valueCompF) {\n    return ((!!a &&\n        !!b &&\n        ((isSuccess(a) && isSuccess(b) && valueCompS(a.value, b.value)) ||\n            (isFailure(a) && isFailure(b) && valueCompF(a.error, b.error)))) ||\n        a == b);\n}\nexports.isEqual = isEqual;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/result.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/rules/conditions.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/rules/conditions.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContainmentConditions = exports.ConnectedShapesCondition = exports.ShapeTypeConditions = exports.ShapeDataConditions = exports.TextConditions = exports.ConditionCombination = void 0;\nvar ConditionCombination;\n(function (ConditionCombination) {\n    ConditionCombination[\"AND\"] = \"AND\";\n    ConditionCombination[\"OR\"] = \"OR\";\n})(ConditionCombination || (exports.ConditionCombination = ConditionCombination = {}));\nvar TextConditions;\n(function (TextConditions) {\n    TextConditions[TextConditions[\"TextEmpty\"] = 0] = \"TextEmpty\";\n    TextConditions[TextConditions[\"TextNotEmpty\"] = 1] = \"TextNotEmpty\";\n    TextConditions[TextConditions[\"TextContains\"] = 2] = \"TextContains\";\n    TextConditions[TextConditions[\"TextDoesNotContain\"] = 3] = \"TextDoesNotContain\";\n    TextConditions[TextConditions[\"GreaterThan\"] = 8] = \"GreaterThan\";\n    TextConditions[TextConditions[\"GreaterThanOrEqual\"] = 9] = \"GreaterThanOrEqual\";\n    TextConditions[TextConditions[\"LessThan\"] = 10] = \"LessThan\";\n    TextConditions[TextConditions[\"LessThanOrEqual\"] = 11] = \"LessThanOrEqual\";\n    TextConditions[TextConditions[\"Equal\"] = 12] = \"Equal\";\n    TextConditions[TextConditions[\"NotEqual\"] = 13] = \"NotEqual\";\n    TextConditions[TextConditions[\"Between\"] = 14] = \"Between\";\n    TextConditions[TextConditions[\"NotBetween\"] = 15] = \"NotBetween\";\n})(TextConditions || (exports.TextConditions = TextConditions = {}));\nvar ShapeDataConditions;\n(function (ShapeDataConditions) {\n    ShapeDataConditions[ShapeDataConditions[\"TextEmpty\"] = 0] = \"TextEmpty\";\n    ShapeDataConditions[ShapeDataConditions[\"TextNotEmpty\"] = 1] = \"TextNotEmpty\";\n    ShapeDataConditions[ShapeDataConditions[\"TextContains\"] = 2] = \"TextContains\";\n    ShapeDataConditions[ShapeDataConditions[\"TextDoesNotContain\"] = 3] = \"TextDoesNotContain\";\n    /** @deprecated */ ShapeDataConditions[ShapeDataConditions[\"TextEquals\"] = 4] = \"TextEquals\";\n    /** @deprecated */ ShapeDataConditions[ShapeDataConditions[\"TextNotEqual\"] = 5] = \"TextNotEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"TextStartsWith\"] = 6] = \"TextStartsWith\";\n    ShapeDataConditions[ShapeDataConditions[\"TextEndsWith\"] = 7] = \"TextEndsWith\";\n    ShapeDataConditions[ShapeDataConditions[\"GreaterThan\"] = 8] = \"GreaterThan\";\n    ShapeDataConditions[ShapeDataConditions[\"GreaterThanOrEqual\"] = 9] = \"GreaterThanOrEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"LessThan\"] = 10] = \"LessThan\";\n    ShapeDataConditions[ShapeDataConditions[\"LessThanOrEqual\"] = 11] = \"LessThanOrEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"Equal\"] = 12] = \"Equal\";\n    ShapeDataConditions[ShapeDataConditions[\"NotEqual\"] = 13] = \"NotEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"Between\"] = 14] = \"Between\";\n    ShapeDataConditions[ShapeDataConditions[\"NotBetween\"] = 15] = \"NotBetween\";\n})(ShapeDataConditions || (exports.ShapeDataConditions = ShapeDataConditions = {}));\nvar ShapeTypeConditions;\n(function (ShapeTypeConditions) {\n    ShapeTypeConditions[ShapeTypeConditions[\"TextContains\"] = 2] = \"TextContains\";\n    ShapeTypeConditions[ShapeTypeConditions[\"TextDoesNotContain\"] = 3] = \"TextDoesNotContain\";\n})(ShapeTypeConditions || (exports.ShapeTypeConditions = ShapeTypeConditions = {}));\nvar ConnectedShapesCondition;\n(function (ConnectedShapesCondition) {\n    ConnectedShapesCondition[ConnectedShapesCondition[\"GreaterThan\"] = 8] = \"GreaterThan\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"GreaterThanOrEqual\"] = 9] = \"GreaterThanOrEqual\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"LessThan\"] = 10] = \"LessThan\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"LessThanOrEqual\"] = 11] = \"LessThanOrEqual\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"Equal\"] = 12] = \"Equal\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"NotEqual\"] = 13] = \"NotEqual\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"Between\"] = 14] = \"Between\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"NotBetween\"] = 15] = \"NotBetween\";\n})(ConnectedShapesCondition || (exports.ConnectedShapesCondition = ConnectedShapesCondition = {}));\nvar ContainmentConditions;\n(function (ContainmentConditions) {\n    ContainmentConditions[ContainmentConditions[\"TextContains\"] = 2] = \"TextContains\";\n    ContainmentConditions[ContainmentConditions[\"TextDoesNotContain\"] = 3] = \"TextDoesNotContain\";\n})(ContainmentConditions || (exports.ContainmentConditions = ContainmentConditions = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/rules/conditions.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/rules/conditiontype.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/rules/conditiontype.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConditionType = void 0;\nvar ConditionType;\n(function (ConditionType) {\n    ConditionType[ConditionType[\"Text\"] = 0] = \"Text\";\n    ConditionType[ConditionType[\"ShapeData\"] = 1] = \"ShapeData\";\n    ConditionType[ConditionType[\"Formula\"] = 2] = \"Formula\";\n    ConditionType[ConditionType[\"ShapeType\"] = 3] = \"ShapeType\";\n    ConditionType[ConditionType[\"ConnectedShapes\"] = 4] = \"ConnectedShapes\";\n    ConditionType[ConditionType[\"Containment\"] = 5] = \"Containment\";\n})(ConditionType || (exports.ConditionType = ConditionType = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/rules/conditiontype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/rules/serializedeffect.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/rules/serializedeffect.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RuleFormattingType = void 0;\nvar RuleFormattingType;\n(function (RuleFormattingType) {\n    RuleFormattingType[RuleFormattingType[\"FORMATTING\"] = 0] = \"FORMATTING\";\n    RuleFormattingType[RuleFormattingType[\"DATA_GRAPHICS\"] = 1] = \"DATA_GRAPHICS\";\n    RuleFormattingType[RuleFormattingType[\"STENCIL\"] = 2] = \"STENCIL\";\n})(RuleFormattingType || (exports.RuleFormattingType = RuleFormattingType = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/rules/serializedeffect.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/serializeddataerror.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/serializeddataerror.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedDataError = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nfunction isSerializedDataError(raw) {\n    return (0, checks_1.isObjectUnsafe)(raw) && (0, checks_1.isString)(raw['error']) && (0, checks_1.isNumber)(raw['type']);\n}\nexports.isSerializedDataError = isSerializedDataError;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/serializeddataerror.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/shapedatainheritance.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/shapedatainheritance.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShapeDataInheritance = void 0;\nvar ShapeDataInheritance;\n(function (ShapeDataInheritance) {\n    ShapeDataInheritance[ShapeDataInheritance[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * Really just a UI level of inheritance, where the shape data panel should show the ability for\n     * you to enter a value under this name, and the name isn't editable. Because the default value\n     * for missing data is already empty, there's no need to actually do much down here in the model\n     * layer.\n     */\n    ShapeDataInheritance[ShapeDataInheritance[\"NAME\"] = 1] = \"NAME\";\n    /**\n     * This is true inheritance, where the formula/value of the shape data is available on all\n     * descendant elements. i.e. if a page has a VALUE-inheritable shape data entry, that appears on\n     * every single Element on the page, including all groups and items inside those groups.\n     */\n    ShapeDataInheritance[ShapeDataInheritance[\"VALUE\"] = 2] = \"VALUE\";\n})(ShapeDataInheritance || (exports.ShapeDataInheritance = ShapeDataInheritance = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/shapedatainheritance.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidSpreadsheetIntegration = exports.CustomDetailsChooser = exports.ListChooser = exports.isImportedResults = exports.lucidSpreadsheetIntegrationFailureTypeValidator = exports.LucidSpreadsheetIntegrationFailureType = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializedupstreamconfig_1 = __webpack_require__(/*! ../data/datasource/serializedupstreamconfig */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js\");\nconst serializedschema_1 = __webpack_require__(/*! ../data/serializedfield/serializedschema */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js\");\nconst jsonserializable_1 = __webpack_require__(/*! ../jsonserializable */ \"../../node_modules/lucid-extension-sdk/core/jsonserializable.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar LucidSpreadsheetIntegrationFailureType;\n(function (LucidSpreadsheetIntegrationFailureType) {\n    LucidSpreadsheetIntegrationFailureType[\"AuthorizationFailure\"] = \"AuthorizationFailure\";\n    LucidSpreadsheetIntegrationFailureType[\"GenericFailure\"] = \"GenericFailure\";\n    LucidSpreadsheetIntegrationFailureType[\"UserCancelled\"] = \"UserCanceled\";\n})(LucidSpreadsheetIntegrationFailureType || (exports.LucidSpreadsheetIntegrationFailureType = LucidSpreadsheetIntegrationFailureType = {}));\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.lucidSpreadsheetIntegrationFailureTypeValidator = (0, validators_1.stringEnumValidator)(LucidSpreadsheetIntegrationFailureType);\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isImportedResults = (0, validators_1.strictObjectValidator)({\n    'upstreamConfig': serializedupstreamconfig_1.isSerializedUpstreamConfig,\n    'collections': (0, validators_1.arrayValidator)((0, validators_1.strictObjectValidator)({\n        'collectionId': checks_1.isString,\n        'headerRow': checks_1.isNumber,\n        'schema': serializedschema_1.isSerializedSchema,\n        'upstreamConfig': jsonserializable_1.isJsonSerializable,\n    })),\n});\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nclass ListChooser {\n    constructor(getList) {\n        this.getList = getList;\n    }\n}\nexports.ListChooser = ListChooser;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nclass CustomDetailsChooser {\n    constructor(getConfig) {\n        this.getConfig = getConfig;\n    }\n}\nexports.CustomDetailsChooser = CustomDetailsChooser;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nclass LucidSpreadsheetIntegration {\n    constructor() {\n        this.addCardsIntegration = true;\n    }\n}\nexports.LucidSpreadsheetIntegration = LucidSpreadsheetIntegration;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js":
/*!*****************************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidSpreadsheetIntegrationRegistry = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst lucidspreadsheetintegration_1 = __webpack_require__(/*! ./lucidspreadsheetintegration */ \"../../node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nclass LucidSpreadsheetIntegrationRegistry {\n    static nextHookName() {\n        return '__lucidspreadsheet__hook' + this.nextHookId++;\n    }\n    /**\n     * Register a spreadsheet integration.\n     */\n    static addSpreadsheetIntegration(client, spreadsheetIntegration) {\n        let configChooserActions;\n        const configChooser = spreadsheetIntegration.configChooser;\n        if (configChooser instanceof lucidspreadsheetintegration_1.CustomDetailsChooser) {\n            const actionName = LucidSpreadsheetIntegrationRegistry.nextHookName();\n            configChooserActions = actionName;\n            client.registerAction(actionName, async () => {\n                try {\n                    return await configChooser.getConfig();\n                }\n                catch (error) { }\n                return lucidspreadsheetintegration_1.LucidSpreadsheetIntegrationFailureType.GenericFailure;\n            });\n        }\n        else {\n            const actionName = LucidSpreadsheetIntegrationRegistry.nextHookName();\n            configChooserActions = { 'l': actionName };\n            client.registerAction(actionName, async () => {\n                try {\n                    const result = await configChooser.getList();\n                    if ((0, checks_1.isString)(result)) {\n                        return result;\n                    }\n                    return {\n                        'h': result.header,\n                        'r': result.rows.map(({ icon, id, values }) => ({ 'i': icon, 'd': id, 'l': values })),\n                    };\n                }\n                catch (error) { }\n                return lucidspreadsheetintegration_1.LucidSpreadsheetIntegrationFailureType.GenericFailure;\n            });\n        }\n        const getMultipleSheetsForSpreadsheetDetailsActionName = LucidSpreadsheetIntegrationRegistry.nextHookName();\n        client.registerAction(getMultipleSheetsForSpreadsheetDetailsActionName, async (message) => {\n            try {\n                const result = await spreadsheetIntegration.getMultipleSheetsForSpreadsheetDetails(message['spreadsheetDetails']);\n                if ((0, lucidspreadsheetintegration_1.lucidSpreadsheetIntegrationFailureTypeValidator)(result)) {\n                    return result;\n                }\n                else {\n                    // Serialize the Map\n                    return Array.from(result);\n                }\n            }\n            catch (error) { }\n            return lucidspreadsheetintegration_1.LucidSpreadsheetIntegrationFailureType.GenericFailure;\n        });\n        const serialized = {\n            'ld': spreadsheetIntegration.labelDescription,\n            'li': spreadsheetIntegration.labelIconUrl,\n            'dc': spreadsheetIntegration.dataConnectorName,\n            'c': spreadsheetIntegration.addCardsIntegration,\n            'gs': configChooserActions,\n            'gm': getMultipleSheetsForSpreadsheetDetailsActionName,\n        };\n        client.sendCommand(\"asi\" /* CommandName.AddSpreadsheetIntegration */, serialized);\n    }\n}\nexports.LucidSpreadsheetIntegrationRegistry = LucidSpreadsheetIntegrationRegistry;\nLucidSpreadsheetIntegrationRegistry.nextHookId = 0;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UnfurlCallbackType = void 0;\nvar UnfurlCallbackType;\n(function (UnfurlCallbackType) {\n    UnfurlCallbackType[\"Unfurl\"] = \"u\";\n    UnfurlCallbackType[\"AfterUnfurl\"] = \"a\";\n    UnfurlCallbackType[\"ExpandCallback\"] = \"e\";\n})(UnfurlCallbackType || (exports.UnfurlCallbackType = UnfurlCallbackType = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeUnfurlDetails = exports.deserializeUnfurlDetails = exports.isValidUnfurlDetails = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst unfurliframe_1 = __webpack_require__(/*! ./unfurliframe */ \"../../node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js\");\nconst unfurlthumbnail_1 = __webpack_require__(/*! ./unfurlthumbnail */ \"../../node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js\");\n/** @ignore */\nexports.isValidUnfurlDetails = (0, validators_1.objectValidator)({\n    'ProviderName': checks_1.isString,\n    'ProviderFaviconUrl': checks_1.isString,\n    'UnfurlTitle': (0, validators_1.option)(checks_1.isString),\n    'Iframe': (0, validators_1.option)(unfurliframe_1.isValidUnfurlIframe),\n    'Thumbnails': (0, validators_1.option)((0, validators_1.arrayValidator)(unfurlthumbnail_1.isValidUnfurlThumbnail)),\n    'PreviewImageUrl': (0, validators_1.option)(checks_1.isString),\n});\n/** @ignore */\nfunction deserializeUnfurlDetails(raw) {\n    var _a;\n    return {\n        providerName: raw['ProviderName'],\n        providerFaviconUrl: raw['ProviderFaviconUrl'],\n        unfurlTitle: raw['UnfurlTitle'],\n        iframe: raw['Iframe'] && (0, unfurliframe_1.deserializeUnfurlIframe)(raw['Iframe']),\n        thumbnails: (_a = raw['Thumbnails']) === null || _a === void 0 ? void 0 : _a.map((raw) => (0, unfurlthumbnail_1.deserializeUnfurlThumbnail)(raw)),\n        previewImageUrl: raw['PreviewImageUrl'],\n    };\n}\nexports.deserializeUnfurlDetails = deserializeUnfurlDetails;\n/** @ignore */\nfunction serializeUnfurlDetails(concrete) {\n    var _a;\n    return {\n        'ProviderName': concrete.providerName,\n        'ProviderFaviconUrl': concrete.providerFaviconUrl,\n        'UnfurlTitle': concrete.unfurlTitle,\n        'Iframe': concrete.iframe && (0, unfurliframe_1.serializeUnfurlIframe)(concrete.iframe),\n        'Thumbnails': (_a = concrete.thumbnails) === null || _a === void 0 ? void 0 : _a.map((raw) => (0, unfurlthumbnail_1.serializeUnfurlThumbnail)(raw)),\n        'PreviewImageUrl': concrete.previewImageUrl,\n    };\n}\nexports.serializeUnfurlDetails = serializeUnfurlDetails;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateIframeAttributes = exports.getIFrameWidth = exports.getIFrameHeight = exports.serializeUnfurlIframe = exports.deserializeUnfurlIframe = exports.isValidUnfurlIframe = exports.UnfurlIframeAspectRatio = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst iframeutils_1 = __webpack_require__(/*! ../iframe/iframeutils */ \"../../node_modules/lucid-extension-sdk/core/iframe/iframeutils.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * An enumeration of of the supported unfurl Iframe aspect ratio.\n * The iframe will be maximized to fit the screen responsively\n */\nvar UnfurlIframeAspectRatio;\n(function (UnfurlIframeAspectRatio) {\n    /**\n     * Aspect ratio 1:1, square\n     */\n    UnfurlIframeAspectRatio[\"Square\"] = \"1:1\";\n    /**\n     * Aspect ratio 16:9, wider rectangle\n     * This will be the default setting if not provided\n     */\n    UnfurlIframeAspectRatio[\"SixteenToNine\"] = \"16:9\";\n    /**\n     * Aspect ratio 9:16, taller rectangle\n     */\n    UnfurlIframeAspectRatio[\"NineToSixteen\"] = \"9:16\";\n    /**\n     * Aspect ratio 4:3, wider rectangle\n     */\n    UnfurlIframeAspectRatio[\"FourToThree\"] = \"4:3\";\n    /**\n     * Aspect ratio 3:4, taller rectangle\n     */\n    UnfurlIframeAspectRatio[\"ThreeToFour\"] = \"3:4\";\n})(UnfurlIframeAspectRatio || (exports.UnfurlIframeAspectRatio = UnfurlIframeAspectRatio = {}));\n/** @ignore */\nexports.isValidUnfurlIframe = (0, validators_1.objectValidator)({\n    'IframeUrl': checks_1.isString,\n    'AspectRatio': (0, validators_1.option)((0, validators_1.stringEnumValidator)(UnfurlIframeAspectRatio)),\n    'IframeTitle': (0, validators_1.option)(checks_1.isString),\n});\n/** @ignore */\nfunction deserializeUnfurlIframe(raw) {\n    return {\n        iframeUrl: raw['IframeUrl'],\n        aspectRatio: raw['AspectRatio'],\n        iframeTitle: raw['IframeTitle'],\n    };\n}\nexports.deserializeUnfurlIframe = deserializeUnfurlIframe;\n/** @ignore */\nfunction serializeUnfurlIframe(concrete) {\n    return {\n        'IframeUrl': concrete.iframeUrl,\n        'AspectRatio': concrete.aspectRatio,\n        'IframeTitle': concrete.iframeTitle,\n    };\n}\nexports.serializeUnfurlIframe = serializeUnfurlIframe;\n/** @ignore */\nfunction getIFrameHeight(unfurlIframeAspectRatio) {\n    switch (unfurlIframeAspectRatio) {\n        case UnfurlIframeAspectRatio.Square:\n            return 1;\n        case UnfurlIframeAspectRatio.SixteenToNine:\n            return 9;\n        case UnfurlIframeAspectRatio.NineToSixteen:\n            return 16;\n        case UnfurlIframeAspectRatio.FourToThree:\n            return 3;\n        case UnfurlIframeAspectRatio.ThreeToFour:\n            return 4;\n        default:\n            return 9;\n    }\n}\nexports.getIFrameHeight = getIFrameHeight;\n/** @ignore */\nfunction getIFrameWidth(unfurlIframeAspectRatio) {\n    switch (unfurlIframeAspectRatio) {\n        case UnfurlIframeAspectRatio.Square:\n            return 1;\n        case UnfurlIframeAspectRatio.SixteenToNine:\n            return 16;\n        case UnfurlIframeAspectRatio.NineToSixteen:\n            return 9;\n        case UnfurlIframeAspectRatio.FourToThree:\n            return 4;\n        case UnfurlIframeAspectRatio.ThreeToFour:\n            return 3;\n        default:\n            return 16;\n    }\n}\nexports.getIFrameWidth = getIFrameWidth;\nfunction generateIframeAttributes(unfurlIframe) {\n    const iframeAttributes = {\n        src: unfurlIframe.iframeUrl,\n        height: unfurlIframe.aspectRatio ? getIFrameHeight(unfurlIframe.aspectRatio) : iframeutils_1.DEFAULT_IFRAME_HEIGHT,\n        width: unfurlIframe.aspectRatio ? getIFrameWidth(unfurlIframe.aspectRatio) : iframeutils_1.DEFAULT_IFRAME_WIDTH,\n        title: unfurlIframe.iframeTitle,\n    };\n    return iframeAttributes;\n}\nexports.generateIframeAttributes = generateIframeAttributes;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unfurlRefreshErrorTypeValidator = exports.UnfurlRefreshErrorType = void 0;\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nvar UnfurlRefreshErrorType;\n(function (UnfurlRefreshErrorType) {\n    UnfurlRefreshErrorType[\"AuthorizationFailure\"] = \"Authorization failure\";\n    UnfurlRefreshErrorType[\"GenericFailure\"] = \"Generic failure\";\n})(UnfurlRefreshErrorType || (exports.UnfurlRefreshErrorType = UnfurlRefreshErrorType = {}));\nexports.unfurlRefreshErrorTypeValidator = (0, validators_1.stringEnumValidator)(UnfurlRefreshErrorType);\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeUnfurlThumbnail = exports.deserializeUnfurlThumbnail = exports.isValidUnfurlThumbnail = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/** @ignore */\nexports.isValidUnfurlThumbnail = (0, validators_1.objectValidator)({\n    'url': checks_1.isString,\n    'width': (0, validators_1.nullableOption)(checks_1.isNumber),\n    'height': (0, validators_1.nullableOption)(checks_1.isNumber),\n});\n/** @ignore */\nfunction deserializeUnfurlThumbnail(raw) {\n    var _a, _b;\n    return {\n        url: raw['url'],\n        width: (_a = raw['width']) !== null && _a !== void 0 ? _a : undefined,\n        height: (_b = raw['height']) !== null && _b !== void 0 ? _b : undefined,\n    };\n}\nexports.deserializeUnfurlThumbnail = deserializeUnfurlThumbnail;\n/** @ignore */\nfunction serializeUnfurlThumbnail(concrete) {\n    return {\n        'url': concrete.url,\n        'width': concrete.width,\n        'height': concrete.height,\n    };\n}\nexports.serializeUnfurlThumbnail = serializeUnfurlThumbnail;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/validators/validators.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/validators/validators.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.asAssertion = exports.validatorWithMessage = exports.minLengthValidator = exports.maxLengthValidator = exports.isDate = exports.isPositiveNumber = exports.isSize = exports.isPanelSize = exports.isBoundingBox = exports.isPointLike = exports.isOpacity = exports.isFalse = exports.isTrue = exports.isFlag = exports.isRestrictions = exports.isStringOrNegativeOne = exports.isBooleanOrEmptyString = exports.isNumberOrEmptyString = exports.isSet = exports.propertyValidator = exports.exclude = exports.both = exports.either = exports.isNullOption = exports.nullableOption = exports.option = exports.nullable = exports.objectOfValidator = exports.typedRecordValidator = exports.recordValidator = exports.strictObjectValidator = exports.partialObjectValidator = exports.objectValidator = exports.mapValidator = exports.someValidator = exports.someValue = exports.tupleValidator = exports.arrayValidator = exports.rangeValidator = exports.enumValidator = exports.stringEnumValidator = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst object_1 = __webpack_require__(/*! ../object */ \"../../node_modules/lucid-extension-sdk/core/object.js\");\n/*********************************************************************************\n * Validator generators:  These functions construct new composite validators\n *from elemental validators.\n ********************************************************************************/\n/**\n * Creates a validator which tests if the target is a string\n * and is one of the values in the specified enum (object).\n */\nfunction stringEnumValidator(enumMap) {\n    const enumValues = new Set();\n    for (const key in enumMap) {\n        const enumValue = enumMap[key];\n        if ((0, checks_1.isString)(enumValue)) {\n            enumValues.add(enumValue);\n        }\n    }\n    // this allows using Set:has on unknown type\n    const unknownEnumValues = enumValues;\n    return (x) => {\n        return unknownEnumValues.has(x);\n    };\n}\nexports.stringEnumValidator = stringEnumValidator;\n/**\n * Creates a validator which tests if the target is a value in the specified enum.\n * Note that numbers in enums are reverse-mapped by the TS transpiler, so the specified keys are also values.\n */\nfunction enumValidator(enumMap) {\n    return (x) => {\n        for (const key in enumMap) {\n            if (enumMap[key] === x) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.enumValidator = enumValidator;\n/**\n * Creates a validator which tests if the target is a number\n * and is equal to or between the min and max values.\n *\n */\nfunction rangeValidator(min, max) {\n    return (x) => {\n        return (0, checks_1.isNumber)(x) && x >= min && x <= max;\n    };\n}\nexports.rangeValidator = rangeValidator;\n/**\n * Creates a validator which tests if the target is an array\n * and if all elements of the array satisfy the given\n * sub-validator.\n *\n * @return A validator for the array type\n */\nfunction arrayValidator(subValidator) {\n    return (x) => {\n        return (0, checks_1.isArray)(x) && x.every(subValidator);\n    };\n}\nexports.arrayValidator = arrayValidator;\n/**\n * Creates a validator for a fixed width array where each entry\n * in the array can have a separate validator\n */\nfunction tupleValidator(...tupleValidators) {\n    return (x) => {\n        return (typeof x === 'object' &&\n            tupleValidators.length === x.length &&\n            tupleValidators.every((subX, index) => subX(x[index])));\n    };\n}\nexports.tupleValidator = tupleValidator;\n/**\n * Creates a validator that the given unknown is one of the supplied values\n */\nfunction someValue(...values) {\n    return (x) => {\n        for (const value of values) {\n            if (x === value) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.someValue = someValue;\n/**\n * Creates a validator that the given unknown matches at least one of the given validators\n */\nfunction someValidator(...validators) {\n    return (x) => {\n        for (const validator of validators) {\n            if (validator(x)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.someValidator = someValidator;\n/**\n * Creates a validator which tests if the target is an object\n * and if all values in the object satisfy the given sub-validator.\n * This does *not* perform any tests on the object keys, which\n * are allowed to be arbitrary strings.\n *\n * @return A validator for the map\n * Note that unlike objectValidator, this performs no validation on the names or\n * number of the keys and treats all values equally\n */\nfunction mapValidator(subValidator) {\n    return (x) => {\n        return (0, checks_1.isObject)(x) && !(0, checks_1.isArray)(x) && (0, object_1.objectEvery)(x, subValidator);\n    };\n}\nexports.mapValidator = mapValidator;\n/**\n * Creates a validator which tests if the target is an object\n * and if the structure of the object matches the structure of the passed-in\n * validator object.  The values in the validator object are in turn\n * validators.  This means that if the validator object has a (key,value)\n * pair of the form ('key', keyValidator), then in order for the target object\n * (x) to match, keyValidator(x['key']) must return true for all keys in the\n * validatorStructure.\n *\n * Note that you can use `lucid.validators.option` to create optional parameters\n * in validation structure.\n */\nfunction objectValidator(validatorStructure) {\n    return (subject) => {\n        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {\n            return false;\n        }\n        else {\n            return (0, object_1.objectEvery)(validatorStructure, (validator, key) => {\n                return validator(subject[key]);\n            });\n        }\n    };\n}\nexports.objectValidator = objectValidator;\n/**\n * Creates a validator which tests if the target is an object\n * and if the structure of the object matches the structure of the passed-in\n * validator object, but with every entry being optional.\n */\nfunction partialObjectValidator(validatorStructure) {\n    return (subject) => {\n        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {\n            return false;\n        }\n        else {\n            return (0, object_1.objectEvery)(validatorStructure, (validator, key) => {\n                return subject[key] === undefined || validator(subject[key]);\n            });\n        }\n    };\n}\nexports.partialObjectValidator = partialObjectValidator;\n/**\n * Similar to {@link objectValidator}, but if the object has any non-undefined keys, they must also be present in the validator structure.\n * This is useful for things where extra data is unwanted, like Property serialization.\n * the loose version is often prefered because this one makes backwards compatible changes to the data harder,\n * because it requires an additional PR when the data transfers between services:\n * 1. A PR that adds the option() to this validator; 2. A PR that sends the new data; 3. A PR to remove the option();\n * compared to the (non-strict)objectValidator steps:\n * 1. A PR that adds the option() to this validator and sends the new data; 2. A PR to remove the option();\n */\nfunction strictObjectValidator(validatorStructure) {\n    const looseValidator = objectValidator(validatorStructure);\n    return (subject) => {\n        return (looseValidator(subject) &&\n            (0, object_1.objectEvery)(subject, (subx, key) => subx === undefined || validatorStructure.hasOwnProperty(key)));\n    };\n}\nexports.strictObjectValidator = strictObjectValidator;\nfunction recordValidator(keyList, valueValidator) {\n    return (x) => {\n        return ((0, checks_1.isObject)(x) &&\n            !(0, checks_1.isArray)(x) &&\n            keyList.every((k) => k in x) &&\n            (0, object_1.objectEvery)(x, (val, key) => {\n                return valueValidator(val);\n            }));\n    };\n}\nexports.recordValidator = recordValidator;\nfunction typedRecordValidator(keyValidator, valueValidator) {\n    return (x) => {\n        if ((0, checks_1.isArray)(x) || !(0, checks_1.isObject)(x)) {\n            return false;\n        }\n        return Object.keys(x).every((key) => keyValidator(key)) && Object.values(x).every((val) => valueValidator(val));\n    };\n}\nexports.typedRecordValidator = typedRecordValidator;\nfunction objectOfValidator(subValidator) {\n    return (x) => {\n        if ((0, checks_1.isArray)(x) || !(0, checks_1.isObject)(x)) {\n            return false;\n        }\n        return Object.values(x).every((val) => subValidator(val));\n    };\n}\nexports.objectOfValidator = objectOfValidator;\n/**\n * Create a validator which allows the target to be either null or satisfy the\n * sub-validator.\n *\n * @return A validator for the array type\n */\nfunction nullable(subValidator) {\n    return (x) => {\n        return x === null || subValidator(x);\n    };\n}\nexports.nullable = nullable;\n/**\n * Create a validator which allows the target to be undefined or satisfy the\n * sub-validator.\n *\n * @return A validator for the array type\n */\nfunction option(subValidator) {\n    return (x) => {\n        return x === undefined || subValidator(x);\n    };\n}\nexports.option = option;\n/**\n * Create a validator which allows the target to be undefined, null, or satisfy\n * the sub-validator.\n *\n * @return A validator for the array type\n */\nfunction nullableOption(subValidator) {\n    return (x) => {\n        return x === null || x === undefined || subValidator(x);\n    };\n}\nexports.nullableOption = nullableOption;\nconst isNullOption = (value) => {\n    return value == null;\n};\nexports.isNullOption = isNullOption;\n/**\n * Create a validator that merges two validators.\n * This is useful for validating properties that have 2 disjoint sets of possible values.\n * e.g. {someObject: string}|false\n */\nfunction either(validatorA, validatorB) {\n    return (x) => {\n        return validatorA(x) || validatorB(x);\n    };\n}\nexports.either = either;\n/**\n * Create a validator that combines two validators.\n * This is useful for validating properties that have been composed of a generic and more specific values.\n */\nfunction both(validatorA, validatorB) {\n    return (x) => {\n        return validatorA(x) && validatorB(x);\n    };\n}\nexports.both = both;\n/**\n * Create a validator that allows types excluding those that satisfy an excludeValidator.\n */\nfunction exclude(validator, excludeValidator) {\n    return (x) => validator(x) && !excludeValidator(x);\n}\nexports.exclude = exclude;\n/**\n * Get a validator which returns whether the property calculation structure is\n * correct.\n */\nfunction propertyValidator(subValidator, preSaveActions) {\n    const processedValidator = (x) => {\n        const y = preSaveActions.reduce((px, psa) => psa(px), x);\n        return subValidator(y);\n    };\n    return strictObjectValidator({ 'Equation': checks_1.isString, 'StaticValue': processedValidator });\n}\nexports.propertyValidator = propertyValidator;\n/*********************************************************************************\n * Validators:  Some useful predefined validator functions.\n ********************************************************************************/\n/**\n * This validator only allows objects whose values are all booleans set to true.\n *\n * @return A validator for the map\n */\nfunction isSet(x) {\n    return (0, checks_1.isObject)(x) && !(0, checks_1.isArray)(x) && (0, object_1.objectEvery)(x, (val) => (0, checks_1.isBoolean)(val) && !!val);\n}\nexports.isSet = isSet;\n/**\n * This validator validates that value is either number or empty string\n */\nexports.isNumberOrEmptyString = either(checks_1.isNumber, (v) => v === '');\n/**\n * This validator validates that value is either boolean or empty string\n */\nexports.isBooleanOrEmptyString = either(checks_1.isBoolean, (v) => v === '');\n/**\n * This validator validates that value is either string or -1\n */\nexports.isStringOrNegativeOne = either(checks_1.isString, (v) => v === -1);\n/**\n * This validator validates model of lucid.model.restrictions\n */\nexports.isRestrictions = strictObjectValidator({\n    'b': nullableOption(checks_1.isBoolean),\n    'p': nullableOption(checks_1.isBoolean),\n    'c': nullableOption(checks_1.isBoolean),\n    'f': nullableOption(checks_1.isBoolean),\n    'o': nullableOption(checks_1.isBoolean),\n    'e': nullableOption(checks_1.isBoolean),\n    'fc': nullableOption(checks_1.isBoolean),\n    'fs': nullableOption(checks_1.isBoolean),\n    'l': nullableOption(checks_1.isBoolean),\n    'i': nullableOption(checks_1.isBoolean),\n    'u': nullableOption(checks_1.isBoolean),\n    'acap': nullableOption(checks_1.isBoolean),\n    'scap': nullableOption(checks_1.isBoolean),\n    'imageCategory': nullableOption(checks_1.isBoolean),\n    'pcad': nullableOption(checks_1.isBoolean),\n});\n/**\n * Returns true if the target is equal to either zero or one or is a boolean.\n *\n */\nfunction isFlag(x) {\n    return x === 0 || x === 1 || (0, checks_1.isBoolean)(x);\n}\nexports.isFlag = isFlag;\nfunction isTrue(x) {\n    return x === true;\n}\nexports.isTrue = isTrue;\nfunction isFalse(x) {\n    return x === false;\n}\nexports.isFalse = isFalse;\n/**\n * Returns if an object is a number between 0 and 100.\n *\n */\nexports.isOpacity = rangeValidator(0, 100);\n/**\n * Tests if the given target satisfies the PointLike interface.\n *\n */\nexports.isPointLike = objectValidator({ x: checks_1.isNumber, y: checks_1.isNumber });\n/**\n * Tests if the given target is a bounding box.\n *\n */\nexports.isBoundingBox = objectValidator({\n    x: checks_1.isNumber,\n    y: checks_1.isNumber,\n    w: checks_1.isNumber,\n    h: checks_1.isNumber,\n});\n/**\n * Tests if the given target is a panel size.\n *\n */\nexports.isPanelSize = objectValidator({\n    x: checks_1.isNumber,\n    y: checks_1.isNumber,\n    w: checks_1.isNumber,\n    h: checks_1.isNumber,\n    'identifier': nullableOption(checks_1.isString),\n});\nexports.isSize = objectValidator({\n    w: checks_1.isNumber,\n    h: checks_1.isNumber,\n});\nfunction isPositiveNumber(x) {\n    return (0, checks_1.isNumber)(x) && x >= 0;\n}\nexports.isPositiveNumber = isPositiveNumber;\nfunction isDate(x) {\n    return x instanceof Date;\n}\nexports.isDate = isDate;\nfunction maxLengthValidator(max) {\n    return (x) => (0, checks_1.isString)(x) && x.length <= max;\n}\nexports.maxLengthValidator = maxLengthValidator;\nfunction minLengthValidator(min) {\n    return (x) => (0, checks_1.isString)(x) && x.length >= min;\n}\nexports.minLengthValidator = minLengthValidator;\nfunction validatorWithMessage(validator, message, sub) {\n    return (x) => (validator(x) ? (sub ? sub(x) : true) : message);\n}\nexports.validatorWithMessage = validatorWithMessage;\nfunction asAssertion(validator) {\n    return (val) => {\n        if (!validator(val)) {\n            throw new Error();\n        }\n    };\n}\nexports.asAssertion = asAssertion;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/validators/validators.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/core/xhr.js":
/*!**********************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/core/xhr.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isXHRResponse = exports.isBinaryXHRResponse = exports.isTextXHRResponse = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ./validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst isBaseXHRResponse = (0, validators_1.objectValidator)({\n    url: checks_1.isString,\n    status: checks_1.isNumber,\n    headers: (0, validators_1.objectOfValidator)(checks_1.isString),\n    timeout: (0, validators_1.option)(checks_1.isBoolean),\n});\nexports.isTextXHRResponse = (0, validators_1.both)(isBaseXHRResponse, (0, validators_1.objectValidator)({\n    responseFormat: (0, checks_1.isLiteral)('utf8'),\n    responseText: checks_1.isString,\n}));\nexports.isBinaryXHRResponse = (0, validators_1.both)(isBaseXHRResponse, (0, validators_1.objectValidator)({\n    responseFormat: (0, checks_1.isLiteral)('binary'),\n    responseData: (0, checks_1.isInstanceOf)(Uint8Array),\n}));\nexports.isXHRResponse = (0, validators_1.either)(exports.isTextXHRResponse, exports.isBinaryXHRResponse);\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/core/xhr.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/branchedcollectionid.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/branchedcollectionid.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.patchCollectionIdFromPossibleBranchedCollectionId = exports.branchedCollectionId = void 0;\n/** @ignore */\nfunction branchedCollectionId(upstreamId) {\n    return upstreamId + '_b';\n}\nexports.branchedCollectionId = branchedCollectionId;\n/** @ignore */\nfunction patchCollectionIdFromPossibleBranchedCollectionId(branchId) {\n    if (branchId && branchId.endsWith('_b')) {\n        return branchId.substring(0, branchId.length - 2);\n    }\n    return undefined;\n}\nexports.patchCollectionIdFromPossibleBranchedCollectionId = patchCollectionIdFromPossibleBranchedCollectionId;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/branchedcollectionid.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/collectiondefinition.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/collectiondefinition.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeCollectionDefinition = exports.serializeCollectionDefinition = void 0;\nconst schemadefinition_1 = __webpack_require__(/*! ./schemadefinition */ \"../../node_modules/lucid-extension-sdk/data/schemadefinition.js\");\n/** @ignore */\nfunction serializeCollectionDefinition(def) {\n    return {\n        'Schema': (0, schemadefinition_1.serializeSchemaDefinition)(def.schema),\n        'Items': [...def.items.entries()],\n    };\n}\nexports.serializeCollectionDefinition = serializeCollectionDefinition;\n/** @ignore */\nfunction deserializeCollectionDefinition(raw) {\n    return {\n        schema: (0, schemadefinition_1.parseSchemaDefinition)(raw['Schema']),\n        items: new Map(raw['Items']),\n    };\n}\nexports.deserializeCollectionDefinition = deserializeCollectionDefinition;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/collectiondefinition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/collectionerrortypes.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/collectionerrortypes.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CollectionUpstreamSchemaStatus = void 0;\nexports.CollectionUpstreamSchemaStatus = '__CollectionUpstreamSchemaStatus__';\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/collectionerrortypes.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/collectionproxy.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/collectionproxy.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CollectionProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst propertystoreproxy_1 = __webpack_require__(/*! ../document/propertystoreproxy */ \"../../node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nconst branchedcollectionid_1 = __webpack_require__(/*! ./branchedcollectionid */ \"../../node_modules/lucid-extension-sdk/data/branchedcollectionid.js\");\nconst dataitemproxy_1 = __webpack_require__(/*! ./dataitemproxy */ \"../../node_modules/lucid-extension-sdk/data/dataitemproxy.js\");\nconst patchcollectionproxy_1 = __webpack_require__(/*! ./patchcollectionproxy */ \"../../node_modules/lucid-extension-sdk/data/patchcollectionproxy.js\");\nconst schemadefinition_1 = __webpack_require__(/*! ./schemadefinition */ \"../../node_modules/lucid-extension-sdk/data/schemadefinition.js\");\n/**\n * A collection is a set of data items, each with the same set of fields (though some data items may not have all\n * fields defined).\n */\nclass CollectionProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     *\n     * @param id ID of this collection on the current document\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The data items in this collection, organized by their primary key. The primary key is usually calculated\n         * from the content of the data item, but may differ from the expected value in some circumstances, e.g. if\n         * there are two data items that would have the same primary key.\n         */\n        this.items = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ldi\" /* CommandName.ListDataItems */, { 'id': this.id }), (primaryKey) => new dataitemproxy_1.DataItemProxy(primaryKey, this, this.client));\n    }\n    /**\n     * @returns a human-readable name for this collection\n     */\n    getName() {\n        return this.properties.get('Name');\n    }\n    getSyncCollectionId() {\n        const upstreamConfig = this.properties.get('UpstreamConfig');\n        if ((0, checks_1.isObjectUnsafe)(upstreamConfig) && (0, checks_1.isString)(upstreamConfig['SyncId'])) {\n            return upstreamConfig['SyncId'];\n        }\n        return undefined;\n    }\n    /**\n     * Some data collections may have local branches on the document, to store the set of changes that have been\n     * made by the user since the time the data was last refreshed from its source. For those collections, you\n     * can use this method to get the original data collection as it was last imported or refreshed.\n     *\n     * @returns the original collection from which this collection was branched, or undefined if this collection\n     * is not a branch\n     */\n    getBranchedFrom() {\n        const id = this.properties.get('BranchedFrom');\n        return id ? new CollectionProxy(id, this.client) : undefined;\n    }\n    /**\n     * @returns information about any changes made locally to the collection that have not been synchronized\n     * with the external data source.\n     */\n    getLocalChanges() {\n        const patchCollectionId = (0, branchedcollectionid_1.patchCollectionIdFromPossibleBranchedCollectionId)(this.id);\n        const original = this.getBranchedFrom();\n        if (!patchCollectionId || !original) {\n            return undefined;\n        }\n        return new patchcollectionproxy_1.PatchCollectionProxy(this.client, this, new CollectionProxy(patchCollectionId, this.client), original);\n    }\n    patchItems(patch) {\n        var _a, _b;\n        const changed = {};\n        if (patch.changed) {\n            for (const [primaryKey, record] of patch.changed) {\n                changed[primaryKey] = record;\n            }\n        }\n        return this.client.sendCommand(\"pdi\" /* CommandName.PatchDataItems */, {\n            'id': this.id,\n            'a': (_a = patch.added) !== null && _a !== void 0 ? _a : [],\n            'c': changed,\n            'd': (_b = patch.deleted) !== null && _b !== void 0 ? _b : [],\n        });\n    }\n    /**\n     * @returns an array of field names that are accessible on the items in this collection\n     */\n    getFields() {\n        return this.client.sendCommand(\"lcf\" /* CommandName.ListCollectionFields */, { 'id': this.id });\n    }\n    getSchema() {\n        // we wave to cast as unknown because of readonly being used in the type\n        return (0, schemadefinition_1.parseSchemaDefinition)(this.properties.get('Schema'));\n    }\n}\nexports.CollectionProxy = CollectionProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/collectionproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/dataerror.js":
/*!****************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/dataerror.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataError = void 0;\n/**\n * The requested data or formula result couldn't be calculated.\n */\nclass DataError {\n    /**\n     * @param error A human-readable description of the reason why the error occurred\n     * @param type The kind of error that occurred\n     */\n    constructor(error, type) {\n        this.error = error;\n        this.type = type;\n    }\n}\nexports.DataError = DataError;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/dataerror.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/dataitemproxy.js":
/*!********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/dataitemproxy.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataItemProxy = void 0;\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * One data item in a collection, consisting of key-value pairs\n */\nclass DataItemProxy {\n    /**\n     * @param primaryKey The current primary key of the data item. This may change if the fields on the data item change, rendering this proxy inoperable.\n     * @param collection The collection that contains this data item.\n     * @param client\n     */\n    constructor(primaryKey, collection, client) {\n        this.primaryKey = primaryKey;\n        this.collection = collection;\n        this.client = client;\n        /**\n         * The fields on this data item, organized by their name.\n         */\n        this.fields = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lcf\" /* CommandName.ListCollectionFields */, { 'id': this.collection.id }), (name) => this.client.sendCommand(\"gdif\" /* CommandName.GetDataItemField */, {\n            'c': this.collection.id,\n            'pk': this.primaryKey,\n            'f': name,\n        }));\n    }\n    /**\n     * @returns True if a data item exists in this collection at this primary key\n     */\n    exists() {\n        return this.client.sendCommand(\"die\" /* CommandName.DataItemExists */, { 'c': this.collection.id, 'pk': this.primaryKey });\n    }\n}\nexports.DataItemProxy = DataItemProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/dataitemproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/dataproxy.js":
/*!****************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/dataproxy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataProxy = void 0;\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst datasourceproxy_1 = __webpack_require__(/*! ./datasourceproxy */ \"../../node_modules/lucid-extension-sdk/data/datasourceproxy.js\");\n/**\n * The DataProxy class gives access to the tabular and graph data on the current Lucid document.\n *\n * Data collections are organized into data sources. One data sources is typically produced for\n * each data import, and may contain multiple collections.\n */\nclass DataProxy {\n    constructor(client) {\n        this.client = client;\n        /**\n         * Data sources on the current document, organized by their ID on this document. The ID will\n         * remain stable for as long as the data source exists on this document, but will vary from\n         * the data source ID on other documents if the same data is imported there.\n         */\n        this.dataSources = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lds\" /* CommandName.ListDataSources */, undefined), (dataSourceId) => new datasourceproxy_1.DataSourceProxy(dataSourceId, this.client));\n    }\n    /**\n     * Creates a new empty data source, which you can then add collections of data to.\n     *\n     * @param name Human-readable name of the new data source\n     * @param sourceConfig Any configuration values that might be useful to reference later, such\n     *  as the upstream origin of this data source\n     * @returns the newly created data source\n     */\n    addDataSource(name, sourceConfig) {\n        return new datasourceproxy_1.DataSourceProxy(this.client.sendCommand(\"cds\" /* CommandName.CreateDataSource */, { 'n': name, 's': sourceConfig }), this.client);\n    }\n}\nexports.DataProxy = DataProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/dataproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/datasourceproxy.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/datasourceproxy.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataSourceProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../core/data/fieldtypedefinition/fieldtypedefinition */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst propertystoreproxy_1 = __webpack_require__(/*! ../document/propertystoreproxy */ \"../../node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nconst collectionproxy_1 = __webpack_require__(/*! ./collectionproxy */ \"../../node_modules/lucid-extension-sdk/data/collectionproxy.js\");\n/**\n * A data source represents a set of related data collections on a document. Typically one data source\n * is produced for each data import.\n */\nclass DataSourceProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     * @param id ID of the dataSource on the current document\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The set of data collections in this data source, organized by ID on this document. The IDs will\n         * remain stable for as long as the collection exists on this document, but will vary from\n         * the collection ID on other documents if the same data is imported there.\n         */\n        this.collections = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lc\" /* CommandName.ListCollections */, { 'id': this.id }), (id) => new collectionproxy_1.CollectionProxy(id, this.client));\n    }\n    /**\n     * Create a new collection as part of this data source.\n     * @param name\n     * @param schema\n     * @returns The newly created collection\n     */\n    addCollection(name, schema) {\n        return new collectionproxy_1.CollectionProxy(this.client.sendCommand(\"cc\" /* CommandName.CreateCollection */, {\n            's': this.id,\n            'n': name,\n            'f': schema.fields.map((field) => {\n                return { 'n': field.name, 't': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type) };\n            }),\n            'p': schema.primaryKey,\n            'fl': schema.fieldLabels,\n        }), this.client);\n    }\n    /**\n     * @returns A human-readable name for this data source\n     */\n    getName() {\n        return this.properties.get('Name');\n    }\n    /**\n     * @returns The source configuration values set when this data source was created\n     */\n    getSourceConfig() {\n        const upstream = this.properties.get('Upstream');\n        if ((0, checks_1.isObjectUnsafe)(upstream)) {\n            return upstream['SourceConfig'];\n        }\n        return {};\n    }\n}\nexports.DataSourceProxy = DataSourceProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/datasourceproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataUpdateFilterType = void 0;\n/** Allows Lucid documents to determine what updates they will receive when changes happen in the data source */\nvar DataUpdateFilterType;\n(function (DataUpdateFilterType) {\n    /** All updates relevant to the data source will be sent to the document, new items created in the data source will be added to the document. Note that the in the `documentCollections` mapping in the `DataConnectorActionContext` will not have a list of all items in it with the DataUpdateFilterType selected */\n    DataUpdateFilterType[\"AllUpdates\"] = \"AllUpdates\";\n    /** All updates relevant to collections already present on the document will be sent to that document, new items added to those collections in the data source will be added to the document. Note that the `documentCollections` mapping in the `DataConnectorActionContext` will not have a list of all items in it with the DataUpdateFilterType selected */\n    DataUpdateFilterType[\"CurrentCollectionUpdates\"] = \"CurrentCollectionUpdates\";\n    /** All updates to items already present on the document will be sent to the document. New items created in the data source will not be created on the document. */\n    DataUpdateFilterType[\"CurrentItemUpdates\"] = \"CurrentItemUpdates\";\n})(DataUpdateFilterType || (exports.DataUpdateFilterType = DataUpdateFilterType = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/patchcollectionproxy.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/patchcollectionproxy.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PatchCollectionProxy = exports.PatchedDataItemProxy = void 0;\nconst dataitemproxy_1 = __webpack_require__(/*! ./dataitemproxy */ \"../../node_modules/lucid-extension-sdk/data/dataitemproxy.js\");\nclass PatchedDataItemProxy extends dataitemproxy_1.DataItemProxy {\n    constructor(primaryKey, collection, \n    /**\n     * The names of all fields that have been changed locally on this data item and\n     * not yet synced back to the external data source.\n     */\n    changedFields, \n    /**\n     * The original data item, before local changes. You can query the original values\n     * for the changedFields from this data item.\n     */\n    original, client) {\n        super(primaryKey, collection, client);\n        this.changedFields = changedFields;\n        this.original = original;\n    }\n}\nexports.PatchedDataItemProxy = PatchedDataItemProxy;\nclass PatchCollectionProxy {\n    /**\n     * Use CollectionProxy.getLocalChanges() to get a PatchCollectionProxy rather\n     * than constructing one directly.\n     */\n    constructor(client, branchedCollection, patchCollection, originalCollection) {\n        this.client = client;\n        this.branchedCollection = branchedCollection;\n        this.patchCollection = patchCollection;\n        this.originalCollection = originalCollection;\n    }\n    /**\n     * @returns all data items that have been added to this collection locally, but that\n     * have not yet been synced back to the external data source.\n     */\n    getAddedItems() {\n        //Note: We could get this list directly from the metadata collection associated with the\n        //patch collection, but at this time we're not sure we want to expose metadata collections\n        //to the extension API, so this somewhat less-performance-optimal solution seems like the\n        //best overall answer.\n        return this.patchCollection.items.filter((item, primaryKey) => !this.originalCollection.items.get(primaryKey).exists());\n    }\n    /**\n     * @returns all data items that were deleted from this collection locally, but that\n     * have not yet been deleted in the external data source.\n     */\n    getDeletedItems() {\n        //See comment in getAddedItems\n        return this.originalCollection.items.filter((item, primaryKey) => !this.branchedCollection.items.get(primaryKey).exists());\n    }\n    /**\n     * @returns all data items that have been changed locally, but that have not\n     * yet been synced back to the external data source.\n     */\n    getChangedItems() {\n        const changed = [];\n        for (const [primaryKey, patchItem] of this.patchCollection.items) {\n            const original = this.originalCollection.items.get(primaryKey);\n            if (original.exists()) {\n                //Not just using .keys() because we want to filter out undefined values,\n                //which the `for...of` iterator on patchItem.fields (MapProxy) does for us.\n                const changedFields = [];\n                for (const [key] of patchItem.fields) {\n                    changedFields.push(key);\n                }\n                changed.push(new PatchedDataItemProxy(primaryKey, this.branchedCollection, changedFields, original, this.client));\n            }\n        }\n        return changed;\n    }\n}\nexports.PatchCollectionProxy = PatchCollectionProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/patchcollectionproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/referencekeydefinition.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/referencekeydefinition.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseReferenceKeyDefinition = exports.serializeReferenceKeyDefinition = exports.isCollectionReferenceKeyDefinition = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializedreferencekey_1 = __webpack_require__(/*! ../core/data/referencekeys/serializedreferencekey */ \"../../node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js\");\nconst schemadefinition_1 = __webpack_require__(/*! ./schemadefinition */ \"../../node_modules/lucid-extension-sdk/data/schemadefinition.js\");\n/** @ignore */\nfunction isCollectionReferenceKeyDefinition(def) {\n    return (0, checks_1.isString)(def.collectionId);\n}\nexports.isCollectionReferenceKeyDefinition = isCollectionReferenceKeyDefinition;\n/** @ignore */\nfunction serializeReferenceKeyDefinition(def) {\n    if (isCollectionReferenceKeyDefinition(def)) {\n        return {\n            'cid': def.collectionId,\n            'pk': def.primaryKey,\n            'wl': def.fieldWhitelist,\n            'ro': def.readonly,\n        };\n    }\n    else {\n        return {\n            'sc': (0, schemadefinition_1.serializeSchemaDefinition)(def.schema),\n            'n': def.name,\n            'd': def.data,\n        };\n    }\n}\nexports.serializeReferenceKeyDefinition = serializeReferenceKeyDefinition;\n/** @ignore */\nfunction parseReferenceKeyDefinition(def) {\n    if ((0, serializedreferencekey_1.isTypedSerializedFlattenedReference)(def)) {\n        return {\n            schema: (0, schemadefinition_1.parseSchemaDefinition)(def['sc']),\n            name: def['n'],\n            data: def['d'],\n        };\n    }\n    else if ((0, serializedreferencekey_1.isUnTypedSerializedFlattenedReference)(def)) {\n        throw new Error('Untyped serialized flattened references not implemented');\n    }\n    else {\n        return {\n            collectionId: def['cid'],\n            primaryKey: def['pk'],\n            fieldWhitelist: def['wl'],\n            readonly: def['ro'],\n        };\n    }\n}\nexports.parseReferenceKeyDefinition = parseReferenceKeyDefinition;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/referencekeydefinition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/referencekeyproxy.js":
/*!************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/referencekeyproxy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReferenceKeyProxy = void 0;\nconst serializedreferencekey_1 = __webpack_require__(/*! ../core/data/referencekeys/serializedreferencekey */ \"../../node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js\");\nconst collectionproxy_1 = __webpack_require__(/*! ./collectionproxy */ \"../../node_modules/lucid-extension-sdk/data/collectionproxy.js\");\nconst referencekeydefinition_1 = __webpack_require__(/*! ./referencekeydefinition */ \"../../node_modules/lucid-extension-sdk/data/referencekeydefinition.js\");\nclass ReferenceKeyProxy {\n    constructor(elementId, key, client, settings) {\n        this.elementId = elementId;\n        this.key = key;\n        this.client = client;\n        this.settings = settings;\n    }\n    get collectionId() {\n        if ((0, serializedreferencekey_1.isSerializedFlattenedReference)(this.settings)) {\n            return undefined;\n        }\n        return this.settings['cid'];\n    }\n    get primaryKey() {\n        if ((0, serializedreferencekey_1.isSerializedFlattenedReference)(this.settings)) {\n            return undefined;\n        }\n        return this.settings['pk'];\n    }\n    get definition() {\n        return (0, referencekeydefinition_1.parseReferenceKeyDefinition)(this.settings);\n    }\n    getItem() {\n        const collectionId = this.collectionId;\n        if ((0, serializedreferencekey_1.isSerializedFlattenedReference)(this.settings) || !collectionId) {\n            throw new Error('Not implemented for flattened references');\n        }\n        return new collectionproxy_1.CollectionProxy(collectionId, this.client).items.get(this.settings['pk']);\n    }\n}\nexports.ReferenceKeyProxy = ReferenceKeyProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/referencekeyproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/data/schemadefinition.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/data/schemadefinition.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseSchemaDefinition = exports.parseFieldDefinition = exports.serializeSchemaDefinition = exports.serializeFieldDefinition = exports.serializeFieldConstraintDefinition = exports.isFieldConstraintDefinition = exports.minMaxFieldConstraintValidator = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../core/data/fieldtypedefinition/fieldtypedefinition */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst serializedfielddefinition_1 = __webpack_require__(/*! ../core/data/serializedfield/serializedfielddefinition */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nfunction minMaxFieldConstraintValidator(val) {\n    return (val === serializedfielddefinition_1.FieldConstraintType.MIN_VALUE ||\n        val === serializedfielddefinition_1.FieldConstraintType.MAX_VALUE ||\n        val === serializedfielddefinition_1.FieldConstraintType.MAX_LENGTH);\n}\nexports.minMaxFieldConstraintValidator = minMaxFieldConstraintValidator;\nexports.isFieldConstraintDefinition = (0, validators_1.both)((0, validators_1.objectValidator)({\n    'type': serializedfielddefinition_1.isFieldConstraintType,\n}), (0, validators_1.either)((0, validators_1.objectValidator)({ 'type': minMaxFieldConstraintValidator, 'value': checks_1.isNumber }), (0, validators_1.objectValidator)({ 'type': (0, validators_1.exclude)(serializedfielddefinition_1.isFieldConstraintType, minMaxFieldConstraintValidator), 'value': checks_1.isUndefined })));\n/** @ignore */\nfunction serializeFieldConstraintDefinition(constraint) {\n    return {\n        'Type': constraint.type,\n        'Details': constraint.value,\n    };\n}\nexports.serializeFieldConstraintDefinition = serializeFieldConstraintDefinition;\n/** @ignore */\nfunction serializeFieldDefinition(field) {\n    const serialized = {\n        'Name': field.name,\n        'Type': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type),\n    };\n    if (field.constraints) {\n        serialized['Constraints'] = field.constraints.map(serializeFieldConstraintDefinition);\n    }\n    if (field.mapping) {\n        serialized['Mapping'] = field.mapping;\n    }\n    return serialized;\n}\nexports.serializeFieldDefinition = serializeFieldDefinition;\n/** @ignore */\nfunction serializeSchemaDefinition(def) {\n    return {\n        'Fields': def.fields.map(serializeFieldDefinition),\n        'PrimaryKey': def.primaryKey,\n        'FieldLabelOverrides': def.fieldLabels,\n    };\n}\nexports.serializeSchemaDefinition = serializeSchemaDefinition;\n/** @ignore */\nfunction parseFieldDefinition(field) {\n    var _a;\n    return {\n        name: field['Name'],\n        type: (0, fieldtypedefinition_1.deserializeFieldTypeDefinition)(field['Type']),\n        constraints: (_a = field['Constraints']) === null || _a === void 0 ? void 0 : _a.map((constraint) => {\n            switch (constraint['Type']) {\n                case serializedfielddefinition_1.FieldConstraintType.MIN_VALUE:\n                case serializedfielddefinition_1.FieldConstraintType.MAX_VALUE:\n                case serializedfielddefinition_1.FieldConstraintType.MAX_LENGTH:\n                    if (!(0, checks_1.isNumber)(constraint['Details'])) {\n                        throw new Error('Invalid constraint format');\n                    }\n                    return { type: constraint['Type'], value: constraint['Details'] };\n                case serializedfielddefinition_1.FieldConstraintType.REQUIRED:\n                case serializedfielddefinition_1.FieldConstraintType.LOCKED:\n                case serializedfielddefinition_1.FieldConstraintType.SINGLE_LINE_ONLY:\n                case serializedfielddefinition_1.FieldConstraintType.NO_WHITESPACE:\n                case serializedfielddefinition_1.FieldConstraintType.UNIQUE_EDIT:\n                    return { type: constraint['Type'] };\n                default:\n                    throw new Error('Invalid constraint format');\n            }\n        }),\n        mapping: field['Mapping'],\n    };\n}\nexports.parseFieldDefinition = parseFieldDefinition;\n/** @ignore */\nfunction parseSchemaDefinition(def) {\n    return {\n        fields: def['Fields'].map(parseFieldDefinition),\n        primaryKey: def['PrimaryKey'],\n        fieldLabels: def['FieldLabelOverrides'],\n    };\n}\nexports.parseSchemaDefinition = parseSchemaDefinition;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/data/schemadefinition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/actions/action.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/actions/action.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataConnectorManageWebhookAction = exports.Webhook = exports.DataConnectorPatchAction = exports.DataConnectorSynchronousAction = exports.DataConnectorAsynchronousAction = exports.DataConnectorAction = exports.DataConnectorActionContext = void 0;\nconst dataconnectoractionkeys_1 = __webpack_require__(/*! ./dataconnectoractionkeys */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js\");\n/**\n * This holds all the contextual information about a give data action.\n */\nclass DataConnectorActionContext {\n    constructor(\n    /** The package ID of the extension that triggered this action */\n    packageId, \n    /** The version of the extension that triggered this action */\n    packageVersion, \n    /** The authorized OAuth2 credential that Lucid has for the 3rd party this extension works with */\n    userCredential, \n    /** The data connector name from manifest.json that triggered this action */\n    dataConnectorName, \n    /** The installation id of the extension/user that triggered this action */\n    installationId, \n    /** Set of items this document is tracking as a `Record<CollectionId, ItemPrimaryKey[]>` */\n    documentCollections, \n    /** Update filter type for this document */\n    updateFilterType) {\n        this.packageId = packageId;\n        this.packageVersion = packageVersion;\n        this.userCredential = userCredential;\n        this.dataConnectorName = dataConnectorName;\n        this.installationId = installationId;\n        this.documentCollections = documentCollections;\n        this.updateFilterType = updateFilterType;\n    }\n}\nexports.DataConnectorActionContext = DataConnectorActionContext;\n/** Base class for actions to be performed by data connectors */\nclass DataConnectorAction {\n    constructor(name, context) {\n        this.name = name;\n        this.context = context;\n    }\n}\nexports.DataConnectorAction = DataConnectorAction;\n/**\n * A generic \"asynchronous\" action to be performed by the data connector. This is an action that reports back to Lucid\n * by calling back in the DataSourceClient rather than returning a meaningful value.\n **/\nclass DataConnectorAsynchronousAction extends DataConnectorAction {\n    constructor(name, context, client, data) {\n        super(name, context);\n        this.client = client;\n        this.data = data;\n    }\n}\nexports.DataConnectorAsynchronousAction = DataConnectorAsynchronousAction;\n/**\n * A generic \"synchronous\" action to be performed by the data connector.\n **/\nclass DataConnectorSynchronousAction extends DataConnectorAction {\n    constructor(name, context, data) {\n        super(name, context);\n        this.data = data;\n    }\n}\nexports.DataConnectorSynchronousAction = DataConnectorSynchronousAction;\n/**\n * A patch action is a kind of synchronous style action. It occurs when data is changed in the Lucid editor. All the\n * changes are collected in the patches field.\n **/\nclass DataConnectorPatchAction extends DataConnectorAction {\n    constructor(context, \n    /** changes applied by Lucid */ patches, client, name = dataconnectoractionkeys_1.DataConnectorActionKeys.Patch) {\n        super(name, context);\n        this.patches = patches;\n        this.client = client;\n    }\n}\nexports.DataConnectorPatchAction = DataConnectorPatchAction;\n/**\n * A description of an existing webhook that Lucid is keeping track of.\n **/\nclass Webhook {\n    constructor(\n    /** Set of items this webhook is tracking as a `Record<CollectionId, ItemPrimaryKey[]>` */\n    documentCollections, \n    /** Arbitrary extra data to allow the data connector to better identitify the webhook. */\n    webhookData) {\n        this.documentCollections = documentCollections;\n        this.webhookData = webhookData;\n    }\n}\nexports.Webhook = Webhook;\n/**\n * A \"synchronous\" style action indicating that Lucid would like to setup a webhook in the third party.\n */\nclass DataConnectorManageWebhookAction extends DataConnectorAction {\n    constructor(context, \n    /**\n     * Token to be added to the newly created webhook so that when it fires it will have permissions to make changes\n     * to Lucid documents.\n     */\n    webhookToken, \n    /**\n     * A list of existing webhooks so you can be more granular about what you track. You may also find it useful to\n     * delete some of the existing webhooks. The response back to Lucid should include all existing webhooks (newly\n     * created or any of these that were not deleted).\n     **/\n    webhooks) {\n        super(dataconnectoractionkeys_1.DataConnectorActionKeys.ManageWebhook, context);\n        this.webhookToken = webhookToken;\n        this.webhooks = webhooks;\n    }\n}\nexports.DataConnectorManageWebhookAction = DataConnectorManageWebhookAction;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/actions/action.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/** List of keys that are special kinds of actions and thus have more specific result types than just unknown */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataConnectorActionKeys = void 0;\nvar DataConnectorActionKeys;\n(function (DataConnectorActionKeys) {\n    DataConnectorActionKeys[\"ManageWebhook\"] = \"ManageWebhook\";\n    DataConnectorActionKeys[\"Patch\"] = \"Patch\";\n    DataConnectorActionKeys[\"UnbatchedPatch\"] = \"UnbatchedPatch\";\n})(DataConnectorActionKeys || (exports.DataConnectorActionKeys = DataConnectorActionKeys = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeManageWebhookResponse = void 0;\n/** Convert the ManageWebhookResponse to Lucid's wire format */\nfunction serializeManageWebhookResponse(webhookResponse) {\n    return {\n        'documentCollections': webhookResponse.documentCollections,\n        'webhookData': webhookResponse.webhookData,\n    };\n}\nexports.serializeManageWebhookResponse = serializeManageWebhookResponse;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/actions/patch.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/actions/patch.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.schemaPatchParser = exports.SchemaPatch = exports.ThirdPartyColumnPatch = exports.ThirdPartyColumn = exports.itemPatchParser = exports.ItemPatch = exports.genericPatchParser = exports.Patch = void 0;\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../../core/data/fieldtypedefinition/fieldtypedefinition */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst patchresponsebody_1 = __webpack_require__(/*! ./patchresponsebody */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js\");\nconst serializedpatchtypes_1 = __webpack_require__(/*! ./serializedpatchtypes */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/serializedpatchtypes.js\");\nfunction objMap(obj, f) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = f(obj[key]);\n    }\n    return result;\n}\n/** A patch to be applied against the 3rd party datasource with changes coming from Lucid */\nclass Patch {\n    constructor(\n    /** The id of the patch */\n    id, \n    /** The syncSourceId of the changed data source */\n    syncSourceId, \n    /** The syncCollectionId of the changed collection */\n    syncCollectionId) {\n        this.id = id;\n        this.syncSourceId = syncSourceId;\n        this.syncCollectionId = syncCollectionId;\n    }\n    getChange(collections = []) {\n        return new patchresponsebody_1.PatchChange(this.id, this.syncSourceId, collections);\n    }\n}\nexports.Patch = Patch;\nconst genericPatchParser = (id, x) => {\n    var _a;\n    return (_a = (0, exports.itemPatchParser)(id, x)) !== null && _a !== void 0 ? _a : (0, exports.schemaPatchParser)(id, x);\n};\nexports.genericPatchParser = genericPatchParser;\nclass ItemPatch extends Patch {\n    constructor(\n    /** The id of the patch */\n    id, \n    /** Mapping of item primary keys to new items introduced by Lucid */\n    itemsAdded, \n    /** Mapping of item primary keys to sparse changesets of pre-existing items changed by Lucid */\n    itemsChanged, \n    /** List of item primary keys deleted by Lucid */\n    itemsDeleted, \n    /** */\n    itemOrderChanged, \n    /** The syncSourceId of the changed data source */\n    syncSourceId, \n    /** The syncCollectionId of the changed collection */\n    syncCollectionId) {\n        super(id, syncSourceId, syncCollectionId);\n        this.itemsAdded = itemsAdded;\n        this.itemsChanged = itemsChanged;\n        this.itemsDeleted = itemsDeleted;\n        this.itemOrderChanged = itemOrderChanged;\n    }\n    toJSON() {\n        return {\n            'Id': this.id,\n            'ItemsAdded': this.itemsAdded,\n            'ItemsChanged': this.itemsChanged,\n            'ItemsDeleted': this.itemsDeleted,\n            'ItemOrderChanged': this.itemOrderChanged,\n            'SyncSourceId': this.syncSourceId,\n            'SyncCollectionId': this.syncCollectionId,\n        };\n    }\n    clone() {\n        return new ItemPatch(this.id, objMap(this.itemsAdded, (item) => objMap(item, (v) => v)), objMap(this.itemsChanged, (item) => objMap(item, (v) => v)), [...this.itemsDeleted], this.itemOrderChanged && [...this.itemOrderChanged], this.syncSourceId, this.syncCollectionId);\n    }\n}\nexports.ItemPatch = ItemPatch;\nfunction _itemPatchParser(id, patch) {\n    var _a;\n    return new ItemPatch(id, patch['itemsAdded'], patch['itemsChanged'], patch['itemsDeleted'], (_a = patch['itemOrderChanged']) !== null && _a !== void 0 ? _a : undefined, patch['syncSourceId'], patch['syncCollectionId']);\n}\nconst itemPatchParser = (id, patch) => {\n    if ((0, serializedpatchtypes_1.patchItemValidator)(patch)) {\n        return _itemPatchParser(id, patch);\n    }\n    return undefined;\n};\nexports.itemPatchParser = itemPatchParser;\nclass ThirdPartyColumn {\n    constructor(name, fieldType) {\n        this.name = name;\n        this.fieldType = fieldType;\n    }\n    clone() {\n        return new ThirdPartyColumn(this.name, this.fieldType);\n    }\n    toJSON() {\n        return { 'Name': this.name, 'FieldType': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(this.fieldType) };\n    }\n    static deserialize(data) {\n        return new ThirdPartyColumn(data['name'], (0, fieldtypedefinition_1.deserializeFieldTypeDefinition)(data['fieldType']));\n    }\n}\nexports.ThirdPartyColumn = ThirdPartyColumn;\nclass ThirdPartyColumnPatch {\n    constructor(name, fieldType) {\n        this.name = name;\n        this.fieldType = fieldType;\n    }\n    clone() {\n        return new ThirdPartyColumnPatch(this.name, this.fieldType);\n    }\n    toJSON() {\n        return {\n            'Name': this.name,\n            'FieldType': this.fieldType != null ? (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(this.fieldType) : undefined,\n        };\n    }\n    static deserialize(data) {\n        var _a;\n        const result = new ThirdPartyColumnPatch((_a = data['name']) !== null && _a !== void 0 ? _a : undefined, data['fieldType'] != null ? (0, fieldtypedefinition_1.deserializeFieldTypeDefinition)(data['fieldType']) : undefined);\n        return result;\n    }\n}\nexports.ThirdPartyColumnPatch = ThirdPartyColumnPatch;\nclass SchemaPatch extends Patch {\n    constructor(\n    /** The id of the patch */\n    id, \n    /** Mapping of item primary keys to new items introduced by Lucid */\n    columnsAdded, \n    /** Mapping of item primary keys to sparse changesets of pre-existing items changed by Lucid */\n    columnsChanged, \n    /** List of item primary keys deleted by Lucid */\n    columnsDeleted, \n    /** */\n    columnOrdering, \n    /** The syncSourceId of the changed data source */\n    syncSourceId, \n    /** The syncCollectionId of the changed collection */\n    syncCollectionId) {\n        super(id, syncSourceId, syncCollectionId);\n        this.columnsAdded = columnsAdded;\n        this.columnsChanged = columnsChanged;\n        this.columnsDeleted = columnsDeleted;\n        this.columnOrdering = columnOrdering;\n    }\n    toJSON() {\n        return {\n            'Id': this.id,\n            'ColumnsAdded': this.columnsAdded.map((column) => column.toJSON()),\n            'ColumnsChanged': objMap(this.columnsChanged, (column) => column.toJSON()),\n            'ColumnsDeleted': this.columnsDeleted,\n            'ColumnOrdering': this.columnOrdering,\n            'SyncSourceId': this.syncSourceId,\n            'SyncCollectionId': this.syncCollectionId,\n        };\n    }\n    clone() {\n        return new SchemaPatch(this.id, this.columnsAdded.map((columnAdded) => columnAdded.clone()), objMap(this.columnsChanged, (columnChange) => columnChange.clone()), [...this.columnsDeleted], this.columnOrdering && [\n            ...this.columnOrdering.map(([base, target]) => [base, target]),\n        ], this.syncSourceId, this.syncCollectionId);\n    }\n}\nexports.SchemaPatch = SchemaPatch;\nfunction _schemaPatchParser(id, patch) {\n    var _a;\n    return new SchemaPatch(id, patch['columnsAdded'].map(ThirdPartyColumn.deserialize), objMap(patch['columnsChanged'], ThirdPartyColumnPatch.deserialize), patch['columnsDeleted'], (_a = patch['columnOrdering']) !== null && _a !== void 0 ? _a : undefined, patch['syncSourceId'], patch['syncCollectionId']);\n}\nconst schemaPatchParser = (id, patch) => {\n    if ((0, serializedpatchtypes_1.patchSchemaValidator)(patch)) {\n        return _schemaPatchParser(id, patch);\n    }\n    return undefined;\n};\nexports.schemaPatchParser = schemaPatchParser;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/actions/patch.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializePatchChanges = exports.serializePatchResponse = exports.PatchErrorTooltipField = exports.PatchChange = void 0;\nconst object_1 = __webpack_require__(/*! ../../core/object */ \"../../node_modules/lucid-extension-sdk/core/object.js\");\nconst datasourceupdatetypes_1 = __webpack_require__(/*! ../datasourceupdatetypes */ \"../../node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js\");\n/**\n * Reports a completed change back to Lucid\n */\nclass PatchChange {\n    constructor(patchId, syncId, collections) {\n        this.patchId = patchId;\n        this.syncId = syncId;\n        this.collections = collections;\n        this.errors = {};\n    }\n    setError(primaryKey, fieldName, error) {\n        if (!(primaryKey in this.errors)) {\n            this.errors[primaryKey] = {};\n        }\n        this.errors[primaryKey][fieldName] = error;\n    }\n    setTooltipError(primaryKey, error) {\n        this.setError(primaryKey, exports.PatchErrorTooltipField, error);\n    }\n    getErrors() {\n        return this.errors;\n    }\n}\nexports.PatchChange = PatchChange;\n/** Placeholder field name for tool tip errors */\nexports.PatchErrorTooltipField = '__canvasTooltipDataSyncError__';\n/** Convert a Patch change to our wire format */\nfunction serializePatchResponse(patchChange) {\n    return {\n        'syncId': patchChange.syncId,\n        'collections': patchChange.collections.map((c) => {\n            return {\n                'collectionId': c.collectionId,\n                'itemsPatch': (0, datasourceupdatetypes_1.serializeItemsPatch)(c.itemsPatch),\n            };\n        }),\n    };\n}\nexports.serializePatchResponse = serializePatchResponse;\nfunction serializePatchChanges(changes) {\n    const joinedErrors = {};\n    for (const changeGroup of changes) {\n        for (const change of changeGroup) {\n            for (const [primaryKey, fieldNames] of Object.entries(change.getErrors())) {\n                for (const [fieldName, error] of Object.entries(fieldNames)) {\n                    if (!(change.patchId in joinedErrors)) {\n                        joinedErrors[change.patchId] = {};\n                    }\n                    const patchErrors = joinedErrors[change.patchId];\n                    if (!(primaryKey in patchErrors)) {\n                        patchErrors[primaryKey] = {};\n                    }\n                    const primaryKeyErrors = patchErrors[primaryKey];\n                    primaryKeyErrors[fieldName] = error;\n                }\n            }\n        }\n    }\n    return {\n        'changes': (0, object_1.flatten)(changes.map((changeList) => changeList.map((change) => serializePatchResponse(change)))),\n        'errors': joinedErrors,\n    };\n}\nexports.serializePatchChanges = serializePatchChanges;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeActions = exports.actionsHeaderValidator = void 0;\nconst checks_1 = __webpack_require__(/*! ../../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../core/validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst dataupdatefiltertype_1 = __webpack_require__(/*! ../../data/dataupdatefiltertype */ \"../../node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js\");\nconst action_1 = __webpack_require__(/*! ./action */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/action.js\");\nconst dataconnectoractionkeys_1 = __webpack_require__(/*! ./dataconnectoractionkeys */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js\");\nexports.actionsHeaderValidator = (0, validators_1.objectValidator)({\n    'x-lucid-rsa-nonce': checks_1.isString,\n    'x-lucid-signature': checks_1.isString,\n});\nconst serializedActionsBaseValidator = (0, validators_1.objectValidator)({\n    action: (0, validators_1.objectValidator)({ name: checks_1.isString, data: checks_1.isUnknown }),\n    packageId: checks_1.isString,\n    packageVersion: (0, validators_1.nullableOption)(checks_1.isString),\n    dataConnectorName: checks_1.isString,\n    installationId: (0, validators_1.nullableOption)(checks_1.isString),\n    userCredential: (0, validators_1.nullableOption)(checks_1.isString),\n    documentUpdateToken: (0, validators_1.nullableOption)(checks_1.isString),\n    documentCollections: (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),\n    updateFilterType: (0, validators_1.enumValidator)(dataupdatefiltertype_1.DataUpdateFilterType),\n});\nconst serializedPatchDataValidator = (0, validators_1.objectValidator)({\n    packageVersion: checks_1.isString,\n    patches: (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({\n        patch: checks_1.isUnknown,\n        id: checks_1.isString,\n    })),\n    userCredential: checks_1.isString,\n    documentUpdateToken: checks_1.isString,\n});\nconst parseSerializedPatches = (patches, patchParser) => {\n    return patches\n        .map((patch) => {\n        const p = patch['patch'];\n        return patchParser(patch['id'], p);\n    })\n        .filter(checks_1.isDefAndNotNull);\n};\nconst serializedManageWebhookDataValidator = (0, validators_1.objectValidator)({\n    webhooks: (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({\n        documentCollections: (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),\n        webhookData: (0, validators_1.option)(checks_1.isUnknown),\n    })),\n    webhookToken: checks_1.isString,\n});\n/** Function to convert the lucid action wire format into a clean list of actions */\nfunction deserializeActions(client, actions, patchParser) {\n    const parsedActions = typeof actions === 'string' ? JSON.parse(actions) : actions;\n    if (!serializedActionsBaseValidator(parsedActions)) {\n        return;\n    }\n    const name = parsedActions['action']['name'];\n    const data = parsedActions['action']['data'];\n    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.Patch) {\n        if (!(0, validators_1.arrayValidator)(serializedPatchDataValidator)(data)) {\n            console.log(`Failing validation step`);\n            return;\n        }\n        const parsedData = data\n            .map((item) => {\n            const context = new action_1.DataConnectorActionContext(parsedActions['packageId'], item['packageVersion'], item['userCredential'], parsedActions['dataConnectorName'], parsedActions['dataConnectorName'], parsedActions['documentCollections'], parsedActions['updateFilterType']);\n            const patches = parseSerializedPatches(item['patches'], patchParser);\n            if (patches.length < item['patches'].length) {\n                return undefined;\n            }\n            return new action_1.DataConnectorPatchAction(context, patches, client.getDataSourceClient(item['documentUpdateToken']));\n        })\n            .filter(checks_1.isDefAndNotNull);\n        if (parsedData.length < data.length) {\n            console.log(`Failing validation step`);\n            return;\n        }\n        return parsedData;\n    }\n    if (!parsedActions['packageVersion'] || !parsedActions['userCredential']) {\n        return;\n    }\n    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch) {\n        if (!serializedPatchDataValidator(data)) {\n            return;\n        }\n        const context = new action_1.DataConnectorActionContext(parsedActions['packageId'], parsedActions['packageVersion'], parsedActions['userCredential'], parsedActions['dataConnectorName'], parsedActions['dataConnectorName'], parsedActions['documentCollections'], parsedActions['updateFilterType']);\n        const parsedPatches = parseSerializedPatches(data['patches'], patchParser);\n        if (parsedPatches.length < data['patches'].length) {\n            console.log(`Failing validation step`);\n            return;\n        }\n        return [\n            new action_1.DataConnectorPatchAction(context, parsedPatches, client.getDataSourceClient(data['documentUpdateToken']), dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch),\n        ];\n    }\n    const context = new action_1.DataConnectorActionContext(parsedActions['packageId'], parsedActions['packageVersion'], parsedActions['userCredential'], parsedActions['dataConnectorName'], parsedActions['dataConnectorName'], parsedActions['documentCollections'], parsedActions['updateFilterType']);\n    if (name == 'ManageWebhook') {\n        if (!serializedManageWebhookDataValidator(data)) {\n            return;\n        }\n        const webhooks = data['webhooks'].map((webhook) => new action_1.Webhook(webhook['documentCollections'], webhook['webhookData']));\n        return [new action_1.DataConnectorManageWebhookAction(context, data['webhookToken'], webhooks)];\n    }\n    if (parsedActions['documentUpdateToken']) {\n        return [\n            new action_1.DataConnectorAsynchronousAction(name, context, client.getDataSourceClient(parsedActions['documentUpdateToken']), data),\n        ];\n    }\n    return [new action_1.DataConnectorSynchronousAction(name, context, data)];\n}\nexports.deserializeActions = deserializeActions;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/actions/serializedpatchtypes.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/actions/serializedpatchtypes.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.patchValidator = exports.patchSchemaValidator = exports.thirdPartyColumnPatchValidator = exports.thirdPartyColumnValidator = exports.patchItemValidator = void 0;\nconst checks_1 = __webpack_require__(/*! ../../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../../core/data/fieldtypedefinition/fieldtypedefinition */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst validators_1 = __webpack_require__(/*! ../../core/validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nexports.patchItemValidator = (0, validators_1.objectValidator)({\n    itemsAdded: (0, validators_1.objectOfValidator)(checks_1.isObjectUnsafe),\n    itemsChanged: (0, validators_1.objectOfValidator)(checks_1.isObjectUnsafe),\n    itemsDeleted: (0, validators_1.arrayValidator)(checks_1.isString),\n    itemOrderChanged: (0, validators_1.nullableOption)((0, validators_1.arrayValidator)((0, validators_1.tupleValidator)(checks_1.isString, (0, validators_1.nullable)(checks_1.isString)))),\n    syncSourceId: checks_1.isString,\n    syncCollectionId: checks_1.isString,\n    adapterType: (0, checks_1.isLiteral)('EXTENSION_API'),\n    syncSchema: checks_1.isUnknown,\n});\nexports.thirdPartyColumnValidator = (0, validators_1.objectValidator)({\n    name: checks_1.isString,\n    fieldType: fieldtypedefinition_1.isSerializedFieldTypeDefinition,\n});\nexports.thirdPartyColumnPatchValidator = (0, validators_1.objectValidator)({\n    name: (0, validators_1.nullableOption)(checks_1.isString),\n    fieldType: (0, validators_1.nullableOption)(fieldtypedefinition_1.isSerializedFieldTypeDefinition),\n});\nexports.patchSchemaValidator = (0, validators_1.objectValidator)({\n    columnsAdded: (0, validators_1.arrayValidator)(exports.thirdPartyColumnValidator),\n    columnsChanged: (0, validators_1.mapValidator)(exports.thirdPartyColumnPatchValidator),\n    columnsDeleted: (0, validators_1.arrayValidator)(checks_1.isString),\n    columnOrdering: (0, validators_1.nullableOption)((0, validators_1.arrayValidator)((0, validators_1.tupleValidator)(checks_1.isString, (0, validators_1.nullable)(checks_1.isString)))),\n    syncSourceId: checks_1.isString,\n    syncCollectionId: checks_1.isString,\n    adapterType: (0, checks_1.isLiteral)('EXTENSION_API'),\n});\nexports.patchValidator = (0, validators_1.either)(exports.patchItemValidator, exports.patchSchemaValidator);\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/actions/serializedpatchtypes.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/dataconnector.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/dataconnector.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataConnector = exports.DataConnectorResponseError = exports.DataConnectorRequestState = exports.DataConnectorRequestError = exports.DataConnectorRunError = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst action_1 = __webpack_require__(/*! ./actions/action */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/action.js\");\nconst dataconnectoractionkeys_1 = __webpack_require__(/*! ./actions/dataconnectoractionkeys */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js\");\nconst managewebhookresponsebody_1 = __webpack_require__(/*! ./actions/managewebhookresponsebody */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js\");\nconst patch_1 = __webpack_require__(/*! ./actions/patch */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/patch.js\");\nconst patchresponsebody_1 = __webpack_require__(/*! ./actions/patchresponsebody */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js\");\nconst debugserver_1 = __webpack_require__(/*! ./debugserver */ \"../../node_modules/lucid-extension-sdk/dataconnector/debugserver.js\");\nconst itemrekeyer_1 = __webpack_require__(/*! ./itemrekeyer */ \"../../node_modules/lucid-extension-sdk/dataconnector/itemrekeyer.js\");\n/** Throw this from an action request handler to produce a non-200 response code and not have to return the expected\n * result type */\nclass DataConnectorRunError extends Error {\n    constructor(status, body, message) {\n        super(message !== null && message !== void 0 ? message : JSON.stringify(body));\n        this.status = status;\n        this.body = body;\n    }\n    static withMessage(status, message) {\n        return new DataConnectorRunError(status, { error: message }, message);\n    }\n}\nexports.DataConnectorRunError = DataConnectorRunError;\n/** Thrown by any failable http APIs */\nclass DataConnectorRequestError extends Error {\n    constructor(status, message, response, statusText) {\n        super(message);\n        this.status = status;\n        this.response = response;\n        this.statusText = statusText;\n    }\n    toString() {\n        return `${this.message} ${this.statusText ? this.statusText + ' ' : ''}(${this.status}) ${this.response}`;\n    }\n}\nexports.DataConnectorRequestError = DataConnectorRequestError;\nclass DataConnectorRequestState {\n    constructor(itemRekeyer) {\n        this.itemRekeyer = itemRekeyer;\n    }\n}\nexports.DataConnectorRequestState = DataConnectorRequestState;\n/** Thrown by any APIs the client didn't recognize when parsing */\nclass DataConnectorResponseError extends Error {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n    }\n}\nexports.DataConnectorResponseError = DataConnectorResponseError;\n/** Factory class to define a bunch of action handlers. */\nclass DataConnector {\n    constructor(client, optPatchParser) {\n        this.client = client;\n        this.actions = {};\n        this.routes = {};\n        this.patchParser = optPatchParser !== null && optPatchParser !== void 0 ? optPatchParser : patch_1.itemPatchParser;\n    }\n    /** Factory to define an action request handler */\n    defineAction(name, request, asynchronous = false) {\n        this.actions[name] = { actionResponder: request, asynchronous };\n        return this;\n    }\n    /** Factory to define an asynchronous action request handler */\n    defineAsynchronousAction(name, request) {\n        return this.defineAction(name, request, true);\n    }\n    /** Factory to define a route handler */\n    defineRoute(name, request) {\n        this.routes[name] = request;\n        return this;\n    }\n    /** Call a defined action handler and gather its serialized response */\n    async runAction(url, headers, body) {\n        const state = new DataConnectorRequestState(new itemrekeyer_1.ItemRekeyer());\n        const actions = await this.client.parseActions(url, headers, body, this.patchParser);\n        if (!actions) {\n            console.warn('Received bad request', url, headers, body);\n            return { status: 404, body: { error: 'Bad request' } };\n        }\n        const actionName = actions[0].name;\n        try {\n            const responses = [];\n            for (const action of actions) {\n                if (!(action.name in this.actions)) {\n                    throw DataConnectorRunError.withMessage(404, `Action ${action.name} is not implemented`);\n                }\n                const { actionResponder, asynchronous } = this.actions[action.name];\n                const response = (() => {\n                    if (asynchronous) {\n                        if (!(action instanceof action_1.DataConnectorAsynchronousAction)) {\n                            throw DataConnectorRunError.withMessage(400, `Passing uncredentialed action to ${action.name} which is defined to be asynchronous`);\n                        }\n                        return actionResponder(action, state);\n                    }\n                    else {\n                        return actionResponder(action, state);\n                    }\n                })();\n                responses.push(await response);\n            }\n            if (actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.ManageWebhook) {\n                const response = responses[0];\n                // leave the type on this variable because our return type isn't strict. This means that\n                // changes to serializeManageWebhookResponse's return type will need to consider this point\n                const body = (0, managewebhookresponsebody_1.serializeManageWebhookResponse)(response);\n                return { status: 200, body };\n            }\n            if (actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.Patch || actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch) {\n                const responsesCasted = responses;\n                // leave the type on this variable because our return type isn't strict. This means that\n                // changes to serializePatchChanges's return type will need to consider this point\n                const body = (0, patchresponsebody_1.serializePatchChanges)(responsesCasted);\n                return { status: 200, body };\n            }\n            else if (responses.length === 1) {\n                return { status: 200, body: responses[0] };\n            }\n            else {\n                return { status: 200, body: responses };\n            }\n        }\n        catch (e) {\n            const errorLogger = console.error ? console.error : console.log;\n            errorLogger(`Error running ${actionName} action`, e);\n            if (isDataConnectorRunError(e)) {\n                return { status: e.status, body: e.body };\n            }\n            else {\n                return { status: 500, body: { error: `error running ${actionName} action` } };\n            }\n        }\n    }\n    /** Add a route to the given express app (or generate a new app) to serve this data connector */\n    routeDebugServer(options) {\n        return (0, debugserver_1.routeDebugServer)(this, options);\n    }\n    /**\n     * Serve this data connector as a simple express app for debugging purposes\n     */\n    runDebugServer(options) {\n        (0, debugserver_1.runDebugServer)(this, options);\n    }\n}\nexports.DataConnector = DataConnector;\n// instanceof DataConnectorRunError will not work in some environments\nconst isDataConnectorRunError = (0, validators_1.objectValidator)({\n    status: checks_1.isNumber,\n    body: checks_1.isUnknown,\n});\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/dataconnector.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MockDataConnectorClient = exports.DataConnectorClient = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializedactions_1 = __webpack_require__(/*! ./actions/serializedactions */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js\");\nconst datasourceclient_1 = __webpack_require__(/*! ./datasourceclient */ \"../../node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js\");\nconst defaultfetchfunction_1 = __webpack_require__(/*! ./defaultfetchfunction */ \"../../node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js\");\nconst signaturevalidator_1 = __webpack_require__(/*! ./signaturevalidator */ \"../../node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js\");\nconst throwunsuccessful_1 = __webpack_require__(/*! ./throwunsuccessful */ \"../../node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js\");\nconst LUCID_URLS = { main: 'https://lucid.app/', api: 'https://api.lucid.co/' };\n/**\n * Client for requests to and from Lucid\n */\nclass DataConnectorClient {\n    constructor(cryptoDependencies, urls = LUCID_URLS, fetchMethod = defaultfetchfunction_1.globalFetch) {\n        this.cryptoDependencies = cryptoDependencies;\n        this.urls = urls;\n        this.fetchMethod = fetchMethod;\n        this.cachedPublicKey = undefined;\n    }\n    /** Get a client for DataSource related requests to Lucid */\n    getDataSourceClient(updateToken) {\n        return new datasourceclient_1.DataSourceClient(this.urls, updateToken, this.fetchMethod);\n    }\n    /** Get a validator to prove a given request came from Lucid */\n    async getSignatureValidator() {\n        return new signaturevalidator_1.SignatureValidator(this.cryptoDependencies, await this.getPublicKey());\n    }\n    /** Get Lucid's public key to verify requests came from Lucid if you don't want to use the SignatureValidator. Maybe\n     * you're not running in a NodeJS environment */\n    async getPublicKey() {\n        if (!this.cachedPublicKey) {\n            const url = `${this.urls.main}.well-known/pem/TPCP`;\n            const result = await this.fetchMethod(url);\n            await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting public key');\n            this.cachedPublicKey = await result.text();\n        }\n        return this.cachedPublicKey;\n    }\n    /** Validate and parse an action request from Lucid */\n    async parseActions(url, headers, actions, patchParser) {\n        if (!(0, serializedactions_1.actionsHeaderValidator)(headers)) {\n            return;\n        }\n        if (!(await this.getSignatureValidator()).validate(actions, headers, url)) {\n            return;\n        }\n        return (0, serializedactions_1.deserializeActions)(this, actions, patchParser);\n    }\n    /** @ignore */\n    async getSecretFromWebhook(webhookUpdateToken, WebhookValidationSecret) {\n        // todo: this should be using the public API\n        const result = await this.fetchMethod(`${this.urls.dataSync}webhookAuthorization`, {\n            headers: {\n                'data-update-token': webhookUpdateToken,\n                'webhook-validation-secret': JSON.stringify(WebhookValidationSecret),\n            },\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting secret from webhook');\n        const responseBody = await result.json();\n        if ((0, checks_1.isString)(responseBody)) {\n            return responseBody;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /** @ignore */\n    async getCustomWebhookData(webhookUpdateToken) {\n        const result = await this.fetchMethod(`${this.urls.dataSync}customWebhookData`, {\n            headers: { 'data-update-token': webhookUpdateToken },\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting custom webhook data');\n        return (await result.json());\n    }\n    /** @ignore */\n    async patchCustomWebhookData(webhookUpdateToken, patch) {\n        // todo: this should be using the public API\n        const result = await this.fetchMethod(`${this.urls.dataSync}customWebhookData`, {\n            method: 'PATCH',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': webhookUpdateToken,\n                'Lucid-Api-Version': '1',\n            },\n            body: JSON.stringify(patch),\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'patching custom webhook data');\n        return (await result.json());\n    }\n}\nexports.DataConnectorClient = DataConnectorClient;\n/** Use this for writing automated tests for your data connector */\nclass MockDataConnectorClient extends DataConnectorClient {\n    constructor() {\n        super(undefined);\n        /** set properties on this to modify how data source updates are mocked */\n        this.dataSourceClient = new datasourceclient_1.MockDataSourceClient();\n    }\n    /** @ignore */\n    getDataSourceClient(updateToken) {\n        return this.dataSourceClient;\n    }\n    /** Mocked version just always returns successful */\n    getSignatureValidator() {\n        return Promise.resolve(new signaturevalidator_1.MockSignatureValidator());\n    }\n    /** Mocked version returns an empty string */\n    getPublicKey() {\n        return Promise.resolve('');\n    }\n}\nexports.MockDataConnectorClient = MockDataConnectorClient;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MockDataSourceClient = exports.DataSourceClient = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst datasourcetype_1 = __webpack_require__(/*! ../core/data/datasource/datasourcetype */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\");\nconst upstreamconfig_1 = __webpack_require__(/*! ../core/data/datasource/upstreamconfig */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js\");\nconst upstreamupdatetype_1 = __webpack_require__(/*! ../core/data/datasource/upstreamupdatetype */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\");\nconst result_1 = __webpack_require__(/*! ../core/result */ \"../../node_modules/lucid-extension-sdk/core/result.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst dataconnector_1 = __webpack_require__(/*! ./dataconnector */ \"../../node_modules/lucid-extension-sdk/dataconnector/dataconnector.js\");\nconst datasourcemetadatatypes_1 = __webpack_require__(/*! ./datasourcemetadatatypes */ \"../../node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js\");\nconst datasourceupdatetypes_1 = __webpack_require__(/*! ./datasourceupdatetypes */ \"../../node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js\");\nconst defaultfetchfunction_1 = __webpack_require__(/*! ./defaultfetchfunction */ \"../../node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js\");\nconst throwunsuccessful_1 = __webpack_require__(/*! ./throwunsuccessful */ \"../../node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js\");\nconst QueryParamLengthLimit = 2000;\n/**\n * Authenticated client for DataSource related requests to Lucid.\n */\nclass DataSourceClient {\n    constructor(urls, updateToken, fetchMethod = defaultfetchfunction_1.globalFetch) {\n        this.urls = urls;\n        this.updateToken = updateToken;\n        this.fetchMethod = fetchMethod;\n        const dataSyncUrl = urls.dataSync;\n        this.metadataUrl = (0, checks_1.isString)(dataSyncUrl) ? `${dataSyncUrl}dataSource/metadata` : undefined;\n    }\n    formatBody({ dataSourceName, collections, updateFilterType, dataSourceConfiguration }) {\n        const updateData = {};\n        for (const collectionId in collections) {\n            updateData[collectionId] = (0, datasourceupdatetypes_1.serializeCollectionPatch)(collections[collectionId]);\n        }\n        const updateFilterTypeObj = updateFilterType ? { 'UpdateFilterType': updateFilterType } : {};\n        const upstreamConfig = {\n            dataSourceType: datasourcetype_1.DataSourceType.DataService,\n            updateType: upstreamupdatetype_1.UpstreamUpdateType.EVENTPULL,\n            patchType: dataSourceConfiguration === null || dataSourceConfiguration === void 0 ? void 0 : dataSourceConfiguration.patchType,\n            sourceConfig: Object.assign({}, updateFilterTypeObj),\n        };\n        return {\n            'updateData': updateData,\n            'name': dataSourceName,\n            'upstreamConfig': (0, upstreamconfig_1.serializeUpstreamConfig)(upstreamConfig),\n        };\n    }\n    /** Create or update a datasource. If you create a new collection it must be fully specified in terms of schema and\n     * and items. If it's just an update then the schema can be omitted (if unchanged) and items that already exist can\n     * be partial.*/\n    async update(request) {\n        const response = await this.fetchMethod(`${this.urls.api}data/dataSource/update`, {\n            'method': 'POST',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': this.updateToken,\n                'Lucid-Api-Version': '1',\n            },\n            'body': JSON.stringify(this.formatBody(request)),\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'updating data source');\n        // webhooks return 200 with an empty body\n        // document updates return valid json\n        // we can't use .json because that will fail for webhooks\n        // if we update the response type for webhook updates\n        // we can handle that here too. We should probably unify the responses\n        // to be meaningful\n        // we could just:\n        // return await response.text();\n        // but lets avoid users trying to interpret the response\n    }\n    /**\n     * When dealing with data, we can often have a very large number of collections in a single data source, and in\n     * turn, we may well end up get the values for a very large number of metadata values per collection.\n     * Because the endpoints for metadata use query params to encode the metadata names, and because metadata value\n     * reads can be easily parallelized, and because URLs have length limits, this function constructs an array of\n     * query params that are certain to be short enough that each individual query will be a safe length, while still\n     * getting *all* of the requested data.\n     * @param keys The metadata keys we are requesting from the data sync service for the corresponding data source.\n     * @param prefixes The metadata prefixes we are requesting from the data sync service for the corresponding data source.\n     * @returns An array of query params such that each query param is short enough to be safe, but all params combined\n     *             cover all requested metadata.\n     */\n    getLengthLimitedQueryParams(keys, prefixes) {\n        const keyQueryParams = keys.map(encodeURIComponent).map((keyVal) => `metadataKeys=${keyVal}`);\n        const prefixQueryParams = prefixes.map(encodeURIComponent).map((prefixVal) => `metadataPrefixes=${prefixVal}`);\n        const fullQueryParams = [];\n        let currentQueryParam = '';\n        let delimiter = '?';\n        [...keyQueryParams, ...prefixQueryParams].forEach((param) => {\n            currentQueryParam = currentQueryParam.concat(`${delimiter}${param}`);\n            if (currentQueryParam.length > QueryParamLengthLimit) {\n                fullQueryParams.push(currentQueryParam);\n                currentQueryParam = '';\n                delimiter = '?';\n            }\n            else {\n                delimiter = '&';\n            }\n        });\n        if (currentQueryParam.length > 0) {\n            fullQueryParams.push(currentQueryParam);\n        }\n        return fullQueryParams;\n    }\n    async getResponseOrError(url) {\n        const response = await this.fetchMethod(url, {\n            'method': 'GET',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': this.updateToken,\n                'Lucid-Api-Version': '1',\n            },\n        });\n        try {\n            await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'getting data source`s metadata');\n        }\n        catch (e) {\n            if (e instanceof dataconnector_1.DataConnectorResponseError) {\n                return { error: { url, body: e.response } };\n            }\n            throw e;\n        }\n        const responseBody = await response.json();\n        if ((0, validators_1.arrayValidator)(datasourcemetadatatypes_1.isSerializedMetadataRecord)(responseBody)) {\n            return {\n                value: responseBody.map((rawResponse) => {\n                    return {\n                        key: rawResponse['key'],\n                        value: rawResponse['value'],\n                    };\n                }),\n            };\n        }\n        else {\n            return {\n                error: { url, body: responseBody },\n            };\n        }\n    }\n    /** @ignore until metadata endpoints are made part of the public API */\n    async getMetadata(keys, prefixes = []) {\n        if (this.metadataUrl == null) {\n            throw new Error('Attempted to access data sync service metadata endpoints in environment where the URL does not exist!');\n        }\n        const queryParamsList = this.getLengthLimitedQueryParams(keys, prefixes);\n        const urlsWithParams = queryParamsList.map((query) => `${this.metadataUrl}${query}`);\n        const responsePromises = urlsWithParams.map((url) => this.getResponseOrError(url));\n        const responses = await Promise.all(responsePromises);\n        const records = [];\n        const errors = [];\n        responses.forEach((response) => {\n            if ((0, result_1.isSuccess)(response)) {\n                records.push(...response.value);\n            }\n            else {\n                errors.push(response.error);\n            }\n        });\n        if (errors.length > 0) {\n            const message = `Error(s) received accessing URL(s): ${errors.map(({ url }) => url).join(',')}`;\n            const allBodies = errors.map(({ body }) => body);\n            throw new dataconnector_1.DataConnectorResponseError(message, JSON.stringify(allBodies));\n        }\n        return records;\n    }\n    /** @ignore until metadata endpoints are made part of the public API */\n    async patchMetadata(patches) {\n        if (this.metadataUrl == null) {\n            throw new Error('Attempted to access data sync service metadata endpoints in environment where the URL does not exist!');\n        }\n        const serializedPatches = patches.map((patch) => {\n            return {\n                'key': patch.key,\n                'oldValue': patch.oldValue,\n                'newValue': patch.newValue,\n            };\n        });\n        const response = await this.fetchMethod(this.metadataUrl, {\n            'method': 'PATCH',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': this.updateToken,\n                'Lucid-Api-Version': '1',\n            },\n            body: JSON.stringify(serializedPatches),\n        });\n        if (response.status === 409) {\n            const responseBody = await response.json();\n            if ((0, validators_1.arrayValidator)(datasourcemetadatatypes_1.isSerializedMetadataRecord)(responseBody)) {\n                return {\n                    status: 'Conflict',\n                    records: responseBody.map((record) => {\n                        return {\n                            key: record['key'],\n                            value: record['value'],\n                        };\n                    }),\n                };\n            }\n            throw new dataconnector_1.DataConnectorResponseError(`Invalid conflict response to query at '${this.metadataUrl}'! Expected an array of serialized metadata records`, JSON.stringify(responseBody));\n        }\n        await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'patching data source`s metadata');\n        return { status: 'NoContent' };\n    }\n}\nexports.DataSourceClient = DataSourceClient;\n/**\n * A version of the DataSourceClient that you can use for any automated tests of your data connector.\n * Modify the `gotUpdate` field to change the behaviour of the update method.\n **/\nclass MockDataSourceClient extends DataSourceClient {\n    constructor() {\n        super({ main: '', api: '' }, '');\n        /** Assign this to your mocked update function */\n        this.gotUpdate = (request) => {\n            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);\n        };\n        /** Assign this to your mocked update function */\n        this.gotMetadata = (request) => {\n            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);\n        };\n        /** Assign this to your mocked update function */\n        this.patchedMetadata = (request) => {\n            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);\n        };\n    }\n    /** @ignore */\n    update(request) {\n        return Promise.resolve(this.gotUpdate(request));\n    }\n    /** @ignore */\n    getMetadata(keys, prefixes = []) {\n        return Promise.resolve(this.gotMetadata(keys, prefixes));\n    }\n    /** @ignore */\n    patchMetadata(patches) {\n        return Promise.resolve(this.patchedMetadata(patches));\n    }\n}\nexports.MockDataSourceClient = MockDataSourceClient;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedMetadataRecord = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nexports.isSerializedMetadataRecord = (0, validators_1.objectValidator)({\n    'key': checks_1.isString,\n    'value': checks_1.isUnknown,\n});\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.schemaOKStatus = exports.schemaOutOfSyncStatus = exports.serializeCollectionPatch = exports.serializeFieldDefinitionForApi = exports.serializeItemsPatch = exports.ItemsPatchExhaustive = exports.ItemsPatchInexhaustive = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../core/data/fieldtypedefinition/fieldtypedefinition */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst object_1 = __webpack_require__(/*! ../core/object */ \"../../node_modules/lucid-extension-sdk/core/object.js\");\nconst collectionerrortypes_1 = __webpack_require__(/*! ../data/collectionerrortypes */ \"../../node_modules/lucid-extension-sdk/data/collectionerrortypes.js\");\nclass ItemsPatchInexhaustive {\n    constructor(\n    /**\n     * Items to be added or changed in the collection. Mapping from item serialized primary key to\n     * the sparse patch of the item. See FormattedPrimaryKey.forItem.\n     **/\n    items, \n    /** Items to remove from the collection, based on the same primary key algorithm. */\n    itemsDeleted, errors) {\n        this.items = items;\n        this.itemsDeleted = itemsDeleted;\n        this.errors = errors;\n        this._brand = ItemsPatchInexhaustive;\n    }\n}\nexports.ItemsPatchInexhaustive = ItemsPatchInexhaustive;\nclass ItemsPatchExhaustive {\n    constructor(items, rekeyingMap, fieldNamesChanged, errors) {\n        this.items = items;\n        this.rekeyingMap = rekeyingMap;\n        this.fieldNamesChanged = fieldNamesChanged;\n        this.errors = errors;\n        this._brand = ItemsPatchExhaustive;\n    }\n}\nexports.ItemsPatchExhaustive = ItemsPatchExhaustive;\nfunction serializeErrors(errors) {\n    return errors && { 'errors': (0, object_1.fromEntries)(errors) };\n}\nfunction serializeRekeyingMap(rekeyingMap) {\n    return rekeyingMap && { 'rekeyingMap': (0, object_1.fromEntries)(rekeyingMap) };\n}\nfunction serializeFieldNamesChanged(fieldNamesChanged) {\n    return fieldNamesChanged && { 'fieldNamesChanged': (0, object_1.fromEntries)(fieldNamesChanged) };\n}\nfunction serializeItemsPatch(patch) {\n    var _a;\n    if (patch instanceof ItemsPatchExhaustive) {\n        return Object.assign(Object.assign(Object.assign({ 'exhaustiveItems': (0, object_1.fromEntries)(patch.items.entries()) }, serializeRekeyingMap(patch.rekeyingMap)), serializeFieldNamesChanged(patch.fieldNamesChanged)), serializeErrors(patch.errors));\n    }\n    else {\n        return Object.assign({ 'items': (0, object_1.fromEntries)(patch.items.entries()), 'itemsDeleted': (_a = patch.itemsDeleted) !== null && _a !== void 0 ? _a : [] }, serializeErrors(patch.errors));\n    }\n}\nexports.serializeItemsPatch = serializeItemsPatch;\nfunction serializeFieldConstraintForApi(constraint) {\n    return {\n        'type': constraint.type,\n        'details': constraint.value,\n    };\n}\n/** @ignore */\nfunction serializeFieldDefinitionForApi(field) {\n    var _a;\n    return {\n        'name': field.name,\n        'type': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type),\n        'constraints': ((_a = field.constraints) !== null && _a !== void 0 ? _a : []).map((x) => serializeFieldConstraintForApi(x)),\n        'mapping': field.mapping,\n    };\n}\nexports.serializeFieldDefinitionForApi = serializeFieldDefinitionForApi;\nfunction serializeSchemaForApi(schema) {\n    return {\n        'fields': schema.fields.map((x) => serializeFieldDefinitionForApi(x)),\n        'primaryKey': schema.primaryKey,\n        'fieldLabelOverrides': schema.fieldLabels,\n    };\n}\nfunction serializeRepresentsAsPropertyForApi(represents) {\n    return {\n        'Represents': represents, // key needs to match 'Represents' key in cake/app/webroot/ts/property/collection/collectionproperties.ts\n    };\n}\nfunction serializeNameAsPropertyForApi(name) {\n    return {\n        'Name': name, // key needs to match 'Name' key in cake/app/webroot/ts/property/collection/collectionproperties.ts\n    };\n}\nfunction serializeCollectionPatch(patch) {\n    const representsProperty = patch.represents && serializeRepresentsAsPropertyForApi(patch.represents);\n    const nameProperty = (0, checks_1.isString)(patch.name) ? serializeNameAsPropertyForApi(patch.name) : undefined;\n    const properties = (representsProperty || nameProperty) && Object.assign(Object.assign({}, representsProperty), nameProperty);\n    return {\n        'schema': patch.schema && serializeSchemaForApi(patch.schema),\n        'itemsPatch': serializeItemsPatch(patch.patch),\n        'properties': properties,\n    };\n}\nexports.serializeCollectionPatch = serializeCollectionPatch;\n/**\n * For the moment, when the upstream Google Sheet is changed in such a way that the schema has changed, we simply\n * stop updates from happening. We do need to alert the user that this has happened, though. This is a utility function\n * for creating the appropriate entry in the errors map so that the user can be alerted that updates have stopped\n * and what they need to do to fix it.\n *\n * The eventual, proposed fix is to allow schemas to have version numbers so that changes to the schema from Google\n * can simply be folded in to the on-document copies of the data and all following edits.\n *\n * @param oldPrimaryKey The primary key stored in the data sync service and which currently is used to interpret\n * patches.\n * @param newPrimaryKey The primary key as it has been changed in the real Google Sheets.\n * @returns The error map entry which alerts the document that this problem has happened.\n */\nfunction schemaOutOfSyncStatus(oldPrimaryKey, newPrimaryKey) {\n    return [\n        collectionerrortypes_1.CollectionUpstreamSchemaStatus,\n        {\n            'dict': {\n                'status': 'broken',\n                'onDocumentKey': JSON.stringify(oldPrimaryKey),\n                'upstreamKey': JSON.stringify(newPrimaryKey),\n            },\n        },\n    ];\n}\nexports.schemaOutOfSyncStatus = schemaOutOfSyncStatus;\n/**\n * For the moment, when the upstream Google Sheet is changed in such a way that the schema has changed, we simply\n * stop updates from happening. We do need to alert the user that this has happened, though. We also need to know when\n * the updates are happening properly so we can clear the error once the user has resolved the problem. Since the\n * only way to delete errors is to overwrite them, we simply overwrite the error to be OK on every successful\n * import.\n * @returns The error map entry which alerts the document that this problem has been resolved.\n */\nfunction schemaOKStatus() {\n    return [\n        collectionerrortypes_1.CollectionUpstreamSchemaStatus,\n        {\n            'dict': {\n                'status': 'ok',\n                'onDocumentKey': null,\n                'upstreamKey': null,\n            },\n        },\n    ];\n}\nexports.schemaOKStatus = schemaOKStatus;\nconst assertIsJustRenamed = () => undefined;\nassertIsJustRenamed();\nassertIsJustRenamed();\nassertIsJustRenamed();\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/debugserver.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/debugserver.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.runDebugServer = exports.routeDebugServer = void 0;\nconst object_1 = __webpack_require__(/*! ../core/object */ \"../../node_modules/lucid-extension-sdk/core/object.js\");\n/** @ignore */\nfunction routeDebugServer(dataConnector, options) {\n    var _a, _b;\n    const { express } = options;\n    const app = (_a = options.app) !== null && _a !== void 0 ? _a : options.express();\n    // We can't use Express's JSON parsing because we need to send the string of the request body\n    // directly for the route style flows. Some extensions compute a HMAC of from this data\n    app.use(express.raw({ type: () => true, limit: '100mb' }));\n    // CORS\n    app.use((req, res, next) => {\n        var _a, _b;\n        if ((_b = (_a = req.headers) === null || _a === void 0 ? void 0 : _a.origin) === null || _b === void 0 ? void 0 : _b.match(/.lucid(dev|staging|preprod|gov|govpreprod|).app$/)) {\n            res.header('Access-Control-Allow-Origin', req.headers.origin);\n            res.header('Vary', 'Origin');\n            res.header('Access-Control-Allow-Methods', 'GET, OPTIONS');\n            res.header('Access-Control-Allow-Headers', '*');\n        }\n        next();\n    });\n    const prefix = (_b = options.prefix) !== null && _b !== void 0 ? _b : '/';\n    console.log(`Routing ${prefix} (${Object.keys(dataConnector.actions).join(', ')})`);\n    if (dataConnector.routes) {\n        for (const routeName of Object.keys(dataConnector.routes)) {\n            console.log(`Routing ${prefix}?kind=route&name=${routeName}`);\n        }\n    }\n    app.post(prefix, async (req, res) => {\n        try {\n            const routeKind = req.query['kind'];\n            if (routeKind === 'action' || routeKind == undefined || routeKind === '') {\n                const { body, status } = await dataConnector.runAction(req.url, req.headers, req.body.toString());\n                res.status(status).json(body);\n            }\n            if (routeKind === 'route') {\n                const routeName = req.query['name'];\n                if (typeof routeName === 'string') {\n                    const route = dataConnector.routes[routeName];\n                    const reqHeaders = req.headers;\n                    const { body, status, headers } = await route({\n                        body: req.body.toString(),\n                        headers: reqHeaders,\n                        query: (0, object_1.fromEntries)(Object.entries(req.query).map(([key, value]) => [\n                            key,\n                            typeof value === 'string' ? value : undefined,\n                        ])),\n                    });\n                    for (const [name, value] of Object.entries(headers !== null && headers !== void 0 ? headers : {})) {\n                        if (typeof value === 'string') {\n                            res.setHeader(name, value);\n                        }\n                    }\n                    res.status(status);\n                    res.send(body);\n                }\n            }\n        }\n        catch (e) {\n            console.log(`Error serving Connector: ${prefix} Flow: ${req.query['name']}, Exception:`, e);\n            res.status(500).end();\n        }\n    });\n    return app;\n}\nexports.routeDebugServer = routeDebugServer;\n/** @ignore */\nfunction runDebugServer(dataConnector, options) {\n    var _a;\n    const port = (_a = options.port) !== null && _a !== void 0 ? _a : 3001;\n    const server = routeDebugServer(dataConnector, options).listen(port, () => {\n        const address = server.address();\n        const port = typeof address === 'string' ? address : address === null || address === void 0 ? void 0 : address.port;\n        console.log(`Listening on port ${port}`);\n    });\n}\nexports.runDebugServer = runDebugServer;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/debugserver.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.globalFetch = void 0;\n// this is used to allow extensions to compile without fetch existing for them.\n/** @ignore */\nexports.globalFetch = globalThis['fetch'];\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/itemrekeyer.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/itemrekeyer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ItemRekeyer = exports.RekeyingMap = void 0;\nconst fieldspecification_1 = __webpack_require__(/*! ../core/data/fieldspecification */ \"../../node_modules/lucid-extension-sdk/core/data/fieldspecification.js\");\nconst object_1 = __webpack_require__(/*! ../core/object */ \"../../node_modules/lucid-extension-sdk/core/object.js\");\nconst patch_1 = __webpack_require__(/*! ./actions/patch */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/patch.js\");\nconst datasourceupdatetypes_1 = __webpack_require__(/*! ./datasourceupdatetypes */ \"../../node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js\");\nfunction calculateRekeyingMap(itemsPatch, primaryKey) {\n    var _a, _b;\n    if (itemsPatch instanceof datasourceupdatetypes_1.ItemsPatchExhaustive) {\n        return itemsPatch.rekeyingMap;\n    }\n    else {\n        if (!primaryKey) {\n            return undefined;\n        }\n        const constPrimaryKey = primaryKey;\n        function primaryKeyIfChanged(oldPrimaryKey, item) {\n            const changedParts = constPrimaryKey.elements.map((field) => item[field]);\n            if (changedParts.find((x) => x !== undefined) === undefined) {\n                // this patch didn't touch the primary key\n                return undefined;\n            }\n            // we might need parts of the old primary key if only some of the primary key fields changed.\n            // As an optimization we could only compute this if at least one of the changedParts is\n            // undefined.\n            const oldParts = JSON.parse(`[${oldPrimaryKey}]`);\n            const newParts = changedParts.map((part, index) => (part !== undefined ? part : oldParts[index]));\n            const newPrimaryKey = fieldspecification_1.FormattedPrimaryKey.serializeList(newParts);\n            if (newPrimaryKey !== oldPrimaryKey) {\n                return newPrimaryKey;\n            }\n            else {\n                return undefined;\n            }\n        }\n        const itemsMap = [...itemsPatch.items.entries()]\n            .map(([key, value]) => [key, primaryKeyIfChanged(key, value)])\n            .filter((x) => x[1] !== undefined);\n        const deletedMap = (_b = (_a = itemsPatch.itemsDeleted) === null || _a === void 0 ? void 0 : _a.map((key) => [key, null])) !== null && _b !== void 0 ? _b : [];\n        const theMap = new Map([...itemsMap, ...deletedMap]);\n        return theMap.size > 0 ? theMap : undefined;\n    }\n}\nclass RekeyingMap {\n    constructor(map) {\n        this.map = map;\n    }\n    getNewKey(key) {\n        var _a;\n        return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : key;\n    }\n    getRecordWithNewKeys(items) {\n        return (0, object_1.fromEntries)(Object.entries(items).map(([key, value]) => [this.getNewKey(key), value]));\n    }\n    getRekeyedPatch(patch) {\n        var _a;\n        if (patch instanceof patch_1.ItemPatch) {\n            return new patch_1.ItemPatch(patch.id, this.getRecordWithNewKeys(patch.itemsAdded), this.getRecordWithNewKeys(patch.itemsChanged), patch.itemsDeleted.map((key) => this.getNewKey(key)), (_a = patch.itemOrderChanged) === null || _a === void 0 ? void 0 : _a.map(([a, b]) => [this.getNewKey(a), b && this.getNewKey(b)]), patch.syncSourceId, patch.syncCollectionId);\n        }\n        return patch.clone();\n    }\n}\nexports.RekeyingMap = RekeyingMap;\nclass ItemRekeyer {\n    constructor() {\n        this.rekeyingMaps = new Map();\n    }\n    addRekeyingsFor(collectionId, itemsPatch, primaryKey) {\n        var _a;\n        const rekeyingMap = calculateRekeyingMap(itemsPatch, primaryKey);\n        if (rekeyingMap) {\n            const existingMap = this.rekeyingMaps.get(collectionId);\n            const rekeyedExisting = [...((_a = existingMap === null || existingMap === void 0 ? void 0 : existingMap.map.entries()) !== null && _a !== void 0 ? _a : [])].map(([key, value]) => { var _a; return [key, value && ((_a = rekeyingMap.get(value)) !== null && _a !== void 0 ? _a : value)]; });\n            this.rekeyingMaps.set(collectionId, new RekeyingMap(new Map([...rekeyingMap.entries(), ...rekeyedExisting])));\n        }\n    }\n    getRekeyingMap(patch) {\n        return this.rekeyingMaps.get(patch.syncCollectionId);\n    }\n}\nexports.ItemRekeyer = ItemRekeyer;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/itemrekeyer.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MockSignatureValidator = exports.SignatureValidator = void 0;\n/**\n * Allows validation that requests originated from Lucid. This class can only be instanciated in a NodeJS environment.\n * Technically any environment that provides NodeJS compatible implementations of `globalThis.Buffer` and\n * `globalThis.require('crypto')` will work.\n */\nclass SignatureValidator {\n    constructor(dependencies, publicKey) {\n        this.dependencies = dependencies;\n        this.publicKey = dependencies.crypto.createPublicKey(publicKey);\n    }\n    /**\n     * Validate a given request came from Lucid.\n     * @param body The body of the request as a plain JavaScript object. This should be JSON.parse called on exactly the\n     *             request body that came from Lucid.\n     * @param headers The headers that are associated with the request. Only 'x-lucid-rsa-nonce' and 'x-lucid-signature'\n     *                are required.\n     * @param url     The url of the current endpoint that is being requested.\n     * @returns true if the request is valid\n     */\n    validate(body, headers, url) {\n        const [, params = ''] = url.split('?');\n        const nonce = headers['x-lucid-rsa-nonce'];\n        const signature = this.dependencies.Buffer.from(headers['x-lucid-signature'], 'base64');\n        const stringBody = typeof body === 'string' ? body : JSON.stringify(body);\n        const data = this.dependencies.Buffer.from(stringBody + nonce + params);\n        const verified = this.dependencies.crypto.verify('SHA384', data, this.publicKey, signature);\n        return verified;\n    }\n}\nexports.SignatureValidator = SignatureValidator;\n/** Mock signature validator, always returns true. */\nclass MockSignatureValidator {\n    validate() {\n        return true;\n    }\n}\nexports.MockSignatureValidator = MockSignatureValidator;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.throwUnsuccessful = void 0;\nconst dataconnector_1 = __webpack_require__(/*! ./dataconnector */ \"../../node_modules/lucid-extension-sdk/dataconnector/dataconnector.js\");\n/** @ignore */\nasync function throwUnsuccessful(result, message) {\n    if (Math.floor(result.status / 100) !== 2) {\n        throw new dataconnector_1.DataConnectorRequestError(result.status, message, await result.text(), result.statusText);\n    }\n}\nexports.throwUnsuccessful = throwUnsuccessful;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.findProxyClass = void 0;\nconst cardblockproxy_1 = __webpack_require__(/*! ./cardblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js\");\nconst customblockproxy_1 = __webpack_require__(/*! ./customblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js\");\nconst erdblockproxy_1 = __webpack_require__(/*! ./erdblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js\");\nconst legendblockproxy_1 = __webpack_require__(/*! ./legendblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js\");\nconst linkunfurlblockproxy_1 = __webpack_require__(/*! ./linkunfurlblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js\");\nconst swimlaneblockproxy_1 = __webpack_require__(/*! ./swimlaneblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js\");\nconst tableblockproxy_1 = __webpack_require__(/*! ./tableblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js\");\nconst allProxyClasses = [\n    cardblockproxy_1.CardBlockProxy,\n    customblockproxy_1.CustomBlockProxy,\n    erdblockproxy_1.ERDBlockProxy,\n    legendblockproxy_1.LegendBlockProxy,\n    linkunfurlblockproxy_1.LinkUnfurlBlockProxy,\n    swimlaneblockproxy_1.SwimLaneBlockProxy,\n    tableblockproxy_1.TableBlockProxy,\n];\nfunction findProxyClass(className) {\n    return allProxyClasses.find((proxy) => proxy.classNameRegex.test(className));\n}\nexports.findProxyClass = findProxyClass;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CardBlockProxy = void 0;\nconst cardfielddisplaysettings_1 = __webpack_require__(/*! ../../core/cardintegration/cardfielddisplaysettings */ \"../../node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockproxy.js\");\n/**\n * A generic lucid card block.\n * This shape has all of the base functionality as a BlockProxy, as well as additional card specific properties.\n */\nclass CardBlockProxy extends blockproxy_1.BlockProxy {\n    getSettings() {\n        return this.referenceKeys.get(this.referenceKeys.keys()[0]).definition;\n    }\n    getTitle() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Title];\n    }\n    getDescription() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Description];\n    }\n    getStatus() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Status];\n    }\n    getAssignee() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Assignee];\n    }\n    getStartTime() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.StartTime];\n    }\n    getEndTime() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.EndTime];\n    }\n    getEstimate() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Estimate];\n    }\n    /**\n     * @param title The title that you want to set for this card.\n     */\n    setTitle(title) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Title] = title;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param description The description that you want to set for this card.\n     */\n    setDescription(description) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Description] = description;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param status The status that you want to set for this card.\n     */\n    setStatus(status) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Status] = status;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param assignee The assignee that you want to set for this card.\n     */\n    setAssignee(assignee) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Assignee] = assignee;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param startTime The start time that you want to set for this card.\n     */\n    setStartTime(startTime) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.StartTime] = startTime;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param endTime The end time that you want to set for this card.\n     */\n    setEndTime(endTime) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.EndTime] = endTime;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param estimate The estimate that you want to set for this card.\n     */\n    setEstimate(estimate) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Estimate] = estimate;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n}\nexports.CardBlockProxy = CardBlockProxy;\nCardBlockProxy.classNameRegex = /^LucidCardBlock$/;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CustomBlockProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockproxy.js\");\n/**\n * Custom shapes defined in extension packages (or other stencil-providing means like Visio stencil imports)\n * are represented by a CustomBlockProxy.\n */\nclass CustomBlockProxy extends blockproxy_1.BlockProxy {\n    static registerCustomBlockClass(klass) {\n        let byLibrary = CustomBlockProxy.subclassRegistry.get(klass.library);\n        if (!byLibrary) {\n            byLibrary = new Map();\n            CustomBlockProxy.subclassRegistry.set(klass.library, byLibrary);\n        }\n        byLibrary.set(klass.shape, klass);\n    }\n    /**\n     * @ignore\n     */\n    static getCustomBlockClass(client, id) {\n        if (this.subclassRegistry.size > 0) {\n            const stencil = client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'id': id, 'p': 'Stencil' });\n            if ((0, checks_1.isObjectUnsafe)(stencil)) {\n                const sourceStencil = client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'p': 'Stencil-' + stencil['id'] });\n                if ((0, checks_1.isObjectUnsafe)(sourceStencil) && (0, checks_1.isObjectUnsafe)(sourceStencil['sourcePackage'])) {\n                    if (sourceStencil['sourcePackage']['packageId'] === lucid.getPackageId()) {\n                        const byLibrary = CustomBlockProxy.subclassRegistry.get(String(sourceStencil['sourcePackage']['library']));\n                        const klass = byLibrary === null || byLibrary === void 0 ? void 0 : byLibrary.get(String(sourceStencil['sourcePackage']['shape']));\n                        if (klass) {\n                            return klass;\n                        }\n                    }\n                }\n            }\n        }\n        return CustomBlockProxy;\n    }\n    isFromStencil(library, shape) {\n        const stencil = this.properties.get('Stencil');\n        if ((0, checks_1.isObjectUnsafe)(stencil)) {\n            const sourceStencil = this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'p': 'Stencil-' + stencil['id'] });\n            if ((0, checks_1.isObjectUnsafe)(sourceStencil) && (0, checks_1.isObjectUnsafe)(sourceStencil['sourcePackage'])) {\n                return (sourceStencil['sourcePackage']['packageId'] === lucid.getPackageId() &&\n                    sourceStencil['sourcePackage']['library'] === library &&\n                    sourceStencil['sourcePackage']['shape'] === shape);\n            }\n        }\n        return false;\n    }\n    getStencilTextAreaName(stencilTextAreaName) {\n        return this.textAreas.keys().find((name) => name.endsWith('_' + stencilTextAreaName));\n    }\n}\nexports.CustomBlockProxy = CustomBlockProxy;\nCustomBlockProxy.classNameRegex = /^CustomBlock$/;\nCustomBlockProxy.subclassRegistry = new Map();\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ERDBlockProxy = exports.ERDFieldProxy = void 0;\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockproxy.js\");\nclass ERDFieldProxy {\n    constructor(block, index) {\n        this.block = block;\n        this.index = index;\n    }\n    getName() {\n        return this.block.properties.get('Field' + this.index);\n    }\n    getType() {\n        var _a;\n        return (_a = this.block.properties.get('Type' + this.index)) !== null && _a !== void 0 ? _a : '';\n    }\n    getKey() {\n        var _a;\n        return (_a = this.block.properties.get('Key' + this.index)) !== null && _a !== void 0 ? _a : '';\n    }\n}\nexports.ERDFieldProxy = ERDFieldProxy;\nclass ERDBlockProxy extends blockproxy_1.BlockProxy {\n    getName() {\n        return this.properties.get('Name');\n    }\n    getFieldCount() {\n        return this.properties.get('Fields');\n    }\n    getFields() {\n        const fields = [];\n        const fieldCount = this.getFieldCount();\n        for (let i = 1; i <= fieldCount; i++) {\n            //These are 1-indexed in the property store\n            fields.push(new ERDFieldProxy(this, i));\n        }\n        return fields;\n    }\n}\nexports.ERDBlockProxy = ERDBlockProxy;\nERDBlockProxy.classNameRegex = /^ERDEntityBlock(2|3|4)?$/;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LegendBlockProxy = exports.ShapeLegendEntryProxy = exports.ColorLegendEntryProxy = exports.LegendEntryProxy = exports.LegendItemType = void 0;\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockproxy.js\");\nvar LegendItemType;\n(function (LegendItemType) {\n    LegendItemType[\"Color\"] = \"color\";\n    LegendItemType[\"Shape\"] = \"shape\";\n})(LegendItemType || (exports.LegendItemType = LegendItemType = {}));\nclass LegendEntryProxy {\n    constructor(legend, index, type) {\n        this.legend = legend;\n        this.index = index;\n        this.type = type;\n    }\n    getText() {\n        return this.legend.textAreas.get('LegendText_' + this.index);\n    }\n    setText(text) {\n        this.legend.textAreas.set('LegendText_' + this.index, text);\n    }\n}\nexports.LegendEntryProxy = LegendEntryProxy;\nclass ColorLegendEntryProxy extends LegendEntryProxy {\n    constructor(legend, index) {\n        super(legend, index, LegendItemType.Color);\n    }\n    getColor() {\n        return this.legend.properties.get('LegendItem_' + this.index)['Value'];\n    }\n}\nexports.ColorLegendEntryProxy = ColorLegendEntryProxy;\nclass ShapeLegendEntryProxy extends LegendEntryProxy {\n    constructor(legend, index) {\n        super(legend, index, LegendItemType.Shape);\n    }\n}\nexports.ShapeLegendEntryProxy = ShapeLegendEntryProxy;\nclass LegendBlockProxy extends blockproxy_1.BlockProxy {\n    getHeader() {\n        return this.textAreas.get('t_header');\n    }\n    getItems() {\n        const itemOrder = this.properties.get('ItemOrder');\n        return itemOrder.map((index) => {\n            const settings = this.properties.get('LegendItem_' + index);\n            switch (settings['Type']) {\n                case LegendItemType.Color:\n                    return new ColorLegendEntryProxy(this, index);\n                case LegendItemType.Shape:\n                    return new ShapeLegendEntryProxy(this, index);\n                default:\n                    return new LegendEntryProxy(this, index, settings['Type']);\n            }\n        });\n    }\n}\nexports.LegendBlockProxy = LegendBlockProxy;\nLegendBlockProxy.classNameRegex = /^LegendBlockV2$/;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExperimentalLinkUnfurlBlockProxy = exports.LinkUnfurlBlockProxy = void 0;\nconst iframeutils_1 = __webpack_require__(/*! ../../core/iframe/iframeutils */ \"../../node_modules/lucid-extension-sdk/core/iframe/iframeutils.js\");\nconst unfurliframe_1 = __webpack_require__(/*! ../../core/unfurl/unfurliframe */ \"../../node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockproxy.js\");\n/**\n * This is the kind of block that appears when a link is pasted onto the canvas of a Lucid editor.\n */\nclass LinkUnfurlBlockProxy extends blockproxy_1.BlockProxy {\n    /**\n     * Returns the title on the block, which is the main text shown on the block.\n     */\n    getTitle() {\n        return this.textAreas.get('t_LinkUnfurlTitle');\n    }\n    /**\n     * Sets the title on the block, which is the main text shown on the block.\n     */\n    setTitle(title) {\n        this.textAreas.set('t_LinkUnfurlTitle', title, { force: true });\n    }\n    /**\n     * Returns the description on the block.\n     */\n    getDescription() {\n        return this.textAreas.get('t_LinkUnfurlDescription');\n    }\n    /**\n     * Sets the description on the block.\n     */\n    setDescription(description) {\n        this.textAreas.set('t_LinkUnfurlDescription', description, { force: true });\n    }\n    /**\n     * Returns the name of the service the link belongs to, such as \"Lucid\" or \"Google\", as displayed below the title on\n     * the block.\n     */\n    getProviderName() {\n        return this.textAreas.get('t_LinkUnfurlProviderName');\n    }\n    /**\n     * Gets the URL the user will be redirected to when the user clicks the \"Pop Out\" action on the block.\n     */\n    getUrl() {\n        return this.properties.get('LinkUnfurlUrl');\n    }\n    /**\n     * Sets the URL the user will be redirected to when the user clicks the \"Pop Out\" action on the block.\n     */\n    setUrl(url) {\n        this.properties.set('LinkUnfurlUrl', url);\n    }\n    /**\n     * Sets the URL to be loaded in an iframe when the user clicks the \"Expand\" action on the block.\n     */\n    setIframe(unfurlIframe) {\n        const iframeAttributes = (0, unfurliframe_1.generateIframeAttributes)(unfurlIframe);\n        this.properties.set('LinkUnfurlIframeHtml', (0, iframeutils_1.generateIFrameHTML)(iframeAttributes));\n        this.properties.set('LinkUnfurlIframeHeight', iframeAttributes.height);\n        this.properties.set('LinkUnfurlIframeWidth', iframeAttributes.width);\n    }\n    /**\n     * Returns true if there is an iframe URL already set for this unfurl block\n     */\n    hasIframe() {\n        return !!this.properties.get('LinkUnfurlIframeHtml');\n    }\n    /**\n     * Sets the main thumbnail on the block\n     */\n    setPreviewThumbnailUrl(thumbnailUrl) {\n        this.properties.set('LinkUnfurlThumbnailUrl', thumbnailUrl);\n    }\n    /**\n     * Gets the main thumbnail on the block\n     */\n    getPreviewThumbnailUrl() {\n        return this.properties.get('LinkUnfurlThumbnailUrl');\n    }\n    /**\n     * Sets additional thumbnails on the block\n     */\n    setThumbnailUrls(thumbnails) {\n        this.properties.set('LinkUnfurlThumbnailUrls', thumbnails);\n    }\n    /**\n     * Gets the url for the favicon on the block\n     */\n    getFaviconUrl() {\n        return this.properties.get('LinkUnfurlFaviconUrl');\n    }\n    /**\n     * Sets the favicon on the block\n     */\n    setFaviconUrl(faviconUrl) {\n        this.properties.set('LinkUnfurlFaviconUrl', faviconUrl);\n    }\n    /**\n     * @ignore\n     * Initiates the PDF upload for this block. The result includes an uploadUrl which you can use to upload the PDF.\n     * The PDF uploaded at that url will be assocaite with this block (and any copy of it) in the editor until it is refreshed.\n     */\n    async experimentalStartPDFUpload() {\n        const result = await this.client.sendCommand(\"pdf\" /* CommandName.StartPDFUploadRequest */, this.id);\n        return result;\n    }\n}\nexports.LinkUnfurlBlockProxy = LinkUnfurlBlockProxy;\nLinkUnfurlBlockProxy.classNameRegex = /^LinkUnfurlBlock$/;\n/**\n * @ignore\n * @deprecated Use LinkUnfurlBlockProxy instead.\n */\nexports.ExperimentalLinkUnfurlBlockProxy = LinkUnfurlBlockProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SwimLaneBlockProxy = exports.SwimLanePrimaryLaneProxy = void 0;\nconst fillcolor_1 = __webpack_require__(/*! ../../core/properties/fillcolor */ \"../../node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockproxy.js\");\nclass SwimLanePrimaryLaneProxy {\n    constructor(swimlane, index) {\n        this.swimlane = swimlane;\n        this.index = index;\n    }\n    /**\n     * For horizontal lanes, the lane height.\n     * For vertical lanes, the lane width.\n     */\n    getSize() {\n        return this.swimlane.getPrimaryLaneSizes()[this.index];\n    }\n    getBoundingBox() {\n        const bb = this.swimlane.getBoundingBox();\n        const sizes = this.swimlane.getPrimaryLaneSizes();\n        if (this.swimlane.getPrimaryLanesVertical()) {\n            return {\n                x: bb.x + sizes.slice(0, this.index).reduce((a, b) => a + b, 0),\n                y: bb.y,\n                w: sizes[this.index],\n                h: bb.h,\n            };\n        }\n        else {\n            return {\n                x: bb.x,\n                y: bb.y + sizes.slice(0, this.index).reduce((a, b) => a + b, 0),\n                w: bb.w,\n                h: sizes[this.index],\n            };\n        }\n    }\n    getTitleTextAreaId() {\n        const existing = this.swimlane.properties.get('PrimaryLaneTextAreaIds')[this.index];\n        if (existing) {\n            return existing;\n        }\n        this.swimlane.updateTextAreaNames();\n        return this.swimlane.properties.get('PrimaryLaneTextAreaIds')[this.index];\n    }\n    getTitle() {\n        return this.swimlane.textAreas.get(this.getTitleTextAreaId());\n    }\n    setTitle(title) {\n        return this.swimlane.textAreas.set(this.getTitleTextAreaId(), title);\n    }\n    setFill(fill) {\n        this.swimlane.properties.set(`CellFill_0,${this.index}`, (0, fillcolor_1.serializeSimpleFill)(fill));\n    }\n}\nexports.SwimLanePrimaryLaneProxy = SwimLanePrimaryLaneProxy;\nclass SwimLaneBlockProxy extends blockproxy_1.BlockProxy {\n    getPrimaryLaneSizes() {\n        return this.properties.get('PrimaryLane');\n    }\n    setPrimaryLaneSizes(sizes) {\n        this.properties.set('PrimaryLane', sizes);\n        this.updateTextAreaNames();\n    }\n    getPrimaryLanes() {\n        return this.getPrimaryLaneSizes().map((size, index) => new SwimLanePrimaryLaneProxy(this, index));\n    }\n    getPrimaryLanesVertical() {\n        return this.properties.get('IsPrimaryLaneVertical');\n    }\n    getMagnetized() {\n        return this.properties.get('Magnetize');\n    }\n    setMagnetized(magnetize) {\n        this.properties.set('Magnetize', magnetize);\n    }\n    /** @ignore */\n    updateTextAreaNames() {\n        this.properties.set('PrimaryLaneTextAreaIds', this.getPrimaryLaneSizes().map((_, index) => 'Primary_' + index));\n    }\n    /**\n     * Swim lanes only use the normal BoundingBox property for location.\n     * For size, it uses the PrimaryLane and SecondaryLane properties.\n     */\n    setBoundingBox(bb) {\n        super.setBoundingBox(bb); //To get position correct\n        const minLaneSize = 40;\n        const oldBB = this.getBoundingBox();\n        const primarySizes = this.getPrimaryLaneSizes();\n        const secondarySizes = this.properties.get('SecondaryLane');\n        const adjustLanesByDelta = (lanes, delta, laneIndex = lanes.length - 1) => {\n            if (laneIndex >= 0 && laneIndex < lanes.length) {\n                lanes[laneIndex] += delta;\n                if (lanes[laneIndex] < minLaneSize) {\n                    const deltaLeft = minLaneSize - lanes[laneIndex];\n                    lanes[laneIndex] = minLaneSize;\n                    adjustLanesByDelta(lanes, deltaLeft, laneIndex - 1);\n                }\n            }\n        };\n        if (bb.w != oldBB.w) {\n            if (this.getPrimaryLanesVertical()) {\n                adjustLanesByDelta(primarySizes, bb.w - oldBB.w);\n                this.setPrimaryLaneSizes(primarySizes);\n            }\n            else {\n                adjustLanesByDelta(secondarySizes, bb.w - oldBB.w);\n                this.properties.set('SecondaryLane', secondarySizes);\n            }\n        }\n        if (bb.h != oldBB.h) {\n            if (this.getPrimaryLanesVertical()) {\n                adjustLanesByDelta(secondarySizes, bb.h - oldBB.h);\n                this.properties.set('SecondaryLane', secondarySizes);\n            }\n            else {\n                adjustLanesByDelta(primarySizes, bb.h - oldBB.h);\n                this.setPrimaryLaneSizes(primarySizes);\n            }\n        }\n    }\n}\nexports.SwimLaneBlockProxy = SwimLaneBlockProxy;\nSwimLaneBlockProxy.classNameRegex = /^AdvancedSwimLaneBlock$/;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TableBlockProxy = exports.TableColumnProxy = exports.TableRowProxy = exports.TableCellProxy = void 0;\nconst fillcolor_1 = __webpack_require__(/*! ../../core/properties/fillcolor */ \"../../node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockproxy.js\");\nclass TableCellProxy {\n    constructor(table, row, column) {\n        this.table = table;\n        this.row = row;\n        this.column = column;\n    }\n    getText() {\n        return this.table.textAreas.get(`Cell_${this.row},${this.column}`);\n    }\n    setText(text) {\n        return this.table.textAreas.set(`Cell_${this.row},${this.column}`, text);\n    }\n    getTextStyle() {\n        return this.table.textStyles.get(`Cell_${this.row},${this.column}`);\n    }\n    setTextStyle(style) {\n        this.table.textStyles.set(`Cell_${this.row},${this.column}`, style);\n    }\n    setFill(fill) {\n        this.table.properties.set(`CellFill_${this.row},${this.column}`, (0, fillcolor_1.serializeSimpleFill)(fill));\n    }\n    /**\n     * Cells in a table can be merged together with adjacent cells into one larger cell. In this case, the upper-\n     * left cell remains visible but is enlarged to cover additional cells, and the other cells are hidden.\n     *\n     * @returns the size of this cell, in how many cells horizontally and vertically have been merged into it.\n     * For most cells, this will be {w:1, h:1}, but if it has been merged with the cell to the right of it, it\n     * would be {w:2, h:1}.\n     */\n    getMergedCellSize() {\n        var _a;\n        return ((_a = this.table.properties.get(`CellSize_${this.row},${this.column}`)) !== null && _a !== void 0 ? _a : { w: 1, h: 1 });\n    }\n    /**\n    /**\n     * Cells in a table can be merged together with adjacent cells into one larger cell. In this case, the upper-\n     * left cell remains visible but is enlarged to cover additional cells, and the other cells are hidden.\n     *\n     * @param size the desired size of this cell, in how many cells horizontally and vertically are merged into it.\n     * This normally {w:1, h:1} for a normal cell, or {w:2, h:1} to merge a cell with the one to the right of it, etc.\n     */\n    setMergedCellSize(size) {\n        this.table.properties.set(`CellSize_${this.row},${this.column}`, size);\n    }\n    /**\n     * @returns the pixel width of the cell, including any cells it is merged with.\n     */\n    getWidth() {\n        return this.table\n            .getColumnWidths()\n            .slice(this.column, this.column + this.getMergedCellSize().w)\n            .reduce((a, b) => a + b, 0);\n    }\n    /**\n     * @returns the pixel height of the cell, including any cells it is merged with.\n     */\n    getHeight() {\n        return this.table\n            .getRowHeights()\n            .slice(this.row, this.row + this.getMergedCellSize().h)\n            .reduce((a, b) => a + b, 0);\n    }\n    getBoundingBox() {\n        const tableBB = this.table.getBoundingBox();\n        const x = tableBB.x +\n            this.table\n                .getColumnWidths()\n                .slice(0, this.column)\n                .reduce((a, b) => a + b, 0);\n        const y = tableBB.y +\n            this.table\n                .getRowHeights()\n                .slice(0, this.row)\n                .reduce((a, b) => a + b, 0);\n        return { x, y, w: this.getWidth(), h: this.getHeight() };\n    }\n}\nexports.TableCellProxy = TableCellProxy;\nclass TableRowProxy {\n    constructor(table, row) {\n        this.table = table;\n        this.row = row;\n    }\n    getCells() {\n        return this.table.getColumnWidths().map((_, index) => new TableCellProxy(this.table, this.row, index));\n    }\n    getHeight() {\n        var _a;\n        return (_a = this.table.getRowHeights()[this.row]) !== null && _a !== void 0 ? _a : 1;\n    }\n}\nexports.TableRowProxy = TableRowProxy;\nclass TableColumnProxy {\n    constructor(table, col) {\n        this.table = table;\n        this.col = col;\n    }\n    getCells() {\n        return this.table.getRowHeights().map((_, index) => new TableCellProxy(this.table, this.col, index));\n    }\n    getWidth() {\n        var _a;\n        return (_a = this.table.getColumnWidths()[this.col]) !== null && _a !== void 0 ? _a : 1;\n    }\n}\nexports.TableColumnProxy = TableColumnProxy;\nclass TableBlockProxy extends blockproxy_1.BlockProxy {\n    /**\n     *\n     * @param referenceCell The cell to add the new column before or after.\n     * @param before If true, the new column will be added before the reference cell, otherwise it will be added after.\n     * @returns The TableColumnProxy for the newly added column.\n     */\n    addColumn(referenceCell, before = false) {\n        const col = this.client.sendCommand(\"atc\" /* CommandName.AddTableColumn */, {\n            'id': this.id,\n            'r': referenceCell.row,\n            'c': referenceCell.column,\n            'b': before,\n        });\n        return new TableColumnProxy(this, col);\n    }\n    /**\n     *\n     * @param referenceCell The cell to add the new row before or after.\n     * @param before If true, the new row will be added before the reference cell, otherwise it will be added after.\n     * @returns The TableRowProxy for the newly added row.\n     */\n    addRow(referenceCell, before = false) {\n        const row = this.client.sendCommand(\"atr\" /* CommandName.AddTableRow */, {\n            'id': this.id,\n            'r': referenceCell.row,\n            'c': referenceCell.column,\n            'b': before,\n        });\n        return new TableRowProxy(this, row);\n    }\n    /**\n     * @param column The index of the column to delete.\n     */\n    deleteColumn(column) {\n        return this.client.sendCommand(\"dtc\" /* CommandName.DeleteTableColumn */, { 'id': this.id, 'i': column });\n    }\n    /**\n     * @param row The index of the row to delete.\n     */\n    deleteRow(row) {\n        return this.client.sendCommand(\"dtr\" /* CommandName.DeleteTableRow */, { 'id': this.id, 'i': row });\n    }\n    /**\n     * @param textAreaKey The text area key of a cell in the table\n     * @returns The TableCellProxy represented by the text area key, or undefined if the text area key does not exist in the table.\n     */\n    getCellByTextAreaKey(textAreaKey) {\n        const value = textAreaKey.match(/(\\d+)/g);\n        if (value && value.length === 2) {\n            const row = +value[0];\n            const column = +value[1];\n            return new TableCellProxy(this, row, column);\n        }\n        return undefined;\n    }\n    getRowCount() {\n        return this.getRowHeights().length;\n    }\n    getColumnCount() {\n        return this.getColumnWidths().length;\n    }\n    getRows() {\n        return this.getRowHeights().map((_, index) => new TableRowProxy(this, index));\n    }\n    getRowHeights() {\n        return this.properties.get('RowHeights');\n    }\n    getColumnWidths() {\n        return this.properties.get('ColWidths');\n    }\n    setColumnWidths(widths) {\n        this.properties.set('ColWidths', widths);\n    }\n    setRowHeights(heights) {\n        this.properties.set('RowHeights', heights);\n    }\n    getAutoResizeColumns() {\n        return this.properties.get('AutoColWidth');\n    }\n    getAutoResizeRows() {\n        return this.properties.get('AutoRowHeight');\n    }\n    setAutoResizeColumns(auto) {\n        this.properties.set('AutoColWidth', auto);\n    }\n    setAutoResizeRows(auto) {\n        this.properties.set('AutoRowHeight', auto);\n    }\n    /**\n     * @param margin The inset margin to be used, it control the margin for each table cell.\n     */\n    setInsetMargin(margin) {\n        this.properties.set('InsetMargin', margin);\n    }\n}\nexports.TableBlockProxy = TableBlockProxy;\nTableBlockProxy.classNameRegex = /^DefaultTableBlock$/;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/blockdefinition.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/blockdefinition.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/blockdefinition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/blockproxy.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/blockproxy.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlockProxy = void 0;\nconst badgeposition_1 = __webpack_require__(/*! ../core/properties/datagraphic/badgeposition */ \"../../node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nconst staticdatagraphicsettings_1 = __webpack_require__(/*! ../core/properties/datagraphic/staticdatagraphicsettings */ \"../../node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js\");\nconst fillcolor_1 = __webpack_require__(/*! ../core/properties/fillcolor */ \"../../node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst shadow_1 = __webpack_require__(/*! ../core/properties/shadow */ \"../../node_modules/lucid-extension-sdk/core/properties/shadow.js\");\nconst math_1 = __webpack_require__(/*! ../math */ \"../../node_modules/lucid-extension-sdk/math.js\");\nconst itemproxy_1 = __webpack_require__(/*! ./itemproxy */ \"../../node_modules/lucid-extension-sdk/document/itemproxy.js\");\n/**\n * A block is a single shape on the document. A BlockProxy provides an interface to\n * read and write the content of an existing block, and is typically accessed through\n * [PageProxy.blocks](#classes_document_pageproxy-PageProxy_blocks) or another\n * similar mechanism.\n */\nclass BlockProxy extends itemproxy_1.ItemProxy {\n    /**\n     * @returns The class name of this block. This name is not necessarily human-readable,\n     * and will remain consistent over time, e.g. \"ProcessBlock\"..\n     */\n    getClassName() {\n        return this.properties.get('ClassName');\n    }\n    /**\n     * @returns The amount this block is rotated around its own center, in radians.\n     */\n    getRotation() {\n        return this.properties.get('Rotation');\n    }\n    /**\n     * @returns An axis-aligned bounding box containing this full item after any rotation it might have\n     */\n    getRotatedBoundingBox() {\n        return (0, math_1.rotatedBoundingBox)(this.getBoundingBox(), this.getRotation());\n    }\n    /**\n     * @param radians Angle the block should be rotated\n     */\n    setRotation(radians) {\n        this.properties.set('Rotation', radians);\n    }\n    /**\n     * @returns The current drop shadow on this block, or undefined if no shadow is set\n     */\n    getShadow() {\n        const raw = this.properties.get('Shadow');\n        if (!raw) {\n            return undefined;\n        }\n        return (0, shadow_1.deserializeShadow)(raw);\n    }\n    /**\n     * @param shadow The drop shadow to set on the block, or undefined to clear the drop shadow\n     */\n    setShadow(shadow) {\n        if (shadow) {\n            this.properties.set('Shadow', (0, shadow_1.serializeShadow)(shadow));\n        }\n        else {\n            this.properties.set('Shadow', null);\n        }\n    }\n    /**\n     * Set the fill style used (by most kinds of blocks) to fill in their main opaque areas.\n     * This can be a string color (e.g. `'#ff00ff80'`) or an image fill.\n     */\n    setFillStyle(fillStyle) {\n        this.properties.set('FillColor', (0, fillcolor_1.serializeSimpleFill)(fillStyle));\n    }\n    /**\n     * @returns An array of lines that have one or both endpoints connected to this block.\n     */\n    getConnectedLines() {\n        const ids = this.client.sendCommand(\"gcl\" /* CommandName.GetConnectedLines */, this.id);\n        return ids.map((id) => this.client.getLineProxy(id));\n    }\n    /**\n     * @param settings Information about the static data graphic icon to set on this block.\n     */\n    setSimpleStaticDataGraphic(settings) {\n        if (settings) {\n            this.properties.set('StaticDataGraphic', (0, staticdatagraphicsettings_1.serializeSimpleStaticDataGraphicSettings)(settings));\n        }\n        else {\n            this.properties.set('StaticDataGraphic', undefined);\n        }\n    }\n    /**\n     * @returns Settings for the simple static data graphic currently set on this block, or undefined\n     * if no simple data graphic is currently set. Note that if a data graphic exists that is not an\n     * icon, this will return undefined. This function will not consider data graphics set via\n     * conditional formatting rules.\n     */\n    getSimpleStaticDataGraphic() {\n        const settings = this.properties.get('StaticDataGraphic');\n        if ((0, staticdatagraphicsettings_1.isSerializedSimpleStaticDataGraphicSettings)(settings)) {\n            return (0, staticdatagraphicsettings_1.deserializeSimpleStaticDataGraphicSettings)(settings);\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Lock this block's aspect ratio to its current value.\n     * This can be reversed with unlockAspectRatio.\n     */\n    lockAspectRatio() {\n        const bb = this.getBoundingBox();\n        this.properties.set('AspectRatio', bb.w / bb.h);\n    }\n    /**\n     * Unlock the aspect ratio of this block, allowing it to be stretched vertically or horizontally independently.\n     */\n    unlockAspectRatio() {\n        this.properties.set('AspectRatio', undefined);\n    }\n    /**\n     * @returns The line width used by most kinds of blocks to render their outline.\n     */\n    getLineWidth() {\n        return this.properties.get('LineWidth');\n    }\n    /**\n     * @param width The line width to be used (by most kinds of blocks) to render this block's outline\n     */\n    setLineWidth(width) {\n        this.properties.set('LineWidth', width);\n    }\n    /**\n     * Link a text area to a data field, so that editing the text area will also update the\n     * associated data, and vice versa.\n     *\n     * To use this, first establish a reference key on this block with\n     * [setReferenceKey](/extension-sdk/#classes_document_blockproxy-BlockProxy_setreferencekey).\n     *\n     * @param textAreaKey\n     * @param referenceKey\n     * @param field\n     */\n    linkText(textAreaKey, referenceKey, field) {\n        if (!this.textAreas.keys().includes(textAreaKey)) {\n            throw new Error('Invalid text area key');\n        }\n        if (!this.referenceKeys.keys().includes(referenceKey)) {\n            throw new Error('Invalid reference key');\n        }\n        this.properties.set(textAreaKey + '_Link', {\n            'ref': referenceKey,\n            'f': field,\n        });\n    }\n    /**\n     * @param position The postion where the data sync state icon should be displayed on the block. If this position is\n     * set to undefined then the state icon position will fallback to the default position for the block.\n     */\n    setDataSyncStateIconPosition(position) {\n        this.properties.set('DataSyncStateIconPosition', position ? (0, badgeposition_1.serializeBadgeEnumPosition)(position) : null);\n    }\n}\nexports.BlockProxy = BlockProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/blockproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CardConfigProxy = void 0;\nconst documentelementproxy_1 = __webpack_require__(/*! ./documentelementproxy */ \"../../node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js\");\nclass CardConfigProxy extends documentelementproxy_1.DocumentElementProxy {\n    /**\n     * @param id The ID of this card config element\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n    }\n}\nexports.CardConfigProxy = CardConfigProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentElementProxy = void 0;\nconst propertystoreproxy_1 = __webpack_require__(/*! ../propertystoreproxy */ \"../../node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nclass DocumentElementProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     * @param id The ID of this document element\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n    }\n}\nexports.DocumentElementProxy = DocumentElementProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentElementType = void 0;\n/**\n * An enumeration of document element types. A Document element represents a collection of data that is stored on a document.\n */\nvar DocumentElementType;\n(function (DocumentElementType) {\n    DocumentElementType[\"DataTransformation\"] = \"DerivedStructure\";\n    DocumentElementType[\"Path\"] = \"Path\";\n    DocumentElementType[\"Tag\"] = \"Tag\";\n    DocumentElementType[\"CommentThreadMetadata\"] = \"ThreadMetadata\";\n    DocumentElementType[\"FontStylePreset\"] = \"FontStylePreset\";\n    DocumentElementType[\"IntraDocumentMutex\"] = \"Mutex\";\n    DocumentElementType[\"Rule\"] = \"Rule\";\n    DocumentElementType[\"DocumentFormula\"] = \"Formula\";\n    DocumentElementType[\"TaskCardFieldsConfig\"] = \"TaskCardFieldsConfig\";\n    DocumentElementType[\"GeneratorView\"] = \"GeneratorView\";\n    DocumentElementType[\"ShapeStylePreset\"] = \"ShapeStylePreset\";\n    DocumentElementType[\"ShapeSpecificDefaultProperties\"] = \"ShapeSpecificDefaultProperties\";\n    DocumentElementType[\"TrackedFormulaLocation\"] = \"TrackedFormulaLocation\";\n})(DocumentElementType || (exports.DocumentElementType = DocumentElementType = {}));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RuleProxy = exports.RuleEffect = exports.RuleCondition = void 0;\nconst badgeposition_1 = __webpack_require__(/*! ../../core/properties/datagraphic/badgeposition */ \"../../node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nconst mapproxy_1 = __webpack_require__(/*! ../mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst ruledefinition_1 = __webpack_require__(/*! ../ruledefinition */ \"../../node_modules/lucid-extension-sdk/document/ruledefinition.js\");\nconst documentelementproxy_1 = __webpack_require__(/*! ./documentelementproxy */ \"../../node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js\");\nclass RuleCondition {\n    constructor(rule, client, key) {\n        this.rule = rule;\n        this.client = client;\n        this.key = key;\n        this.definition = this.rule.properties.get(this.key);\n        /** What kind of condition is this? e.g. a formula evaluation, checking for non-empty text, etc. */\n        this.type = this.definition['Type'];\n        /**\n         * If this.type == ConditionType.Text, this is a TextConditions.\n         * If this.type == ConditionType.ShapeData, this is a ShapeDataConditions.\n         * If this.type == ConditionType.ShapeType, this is a ShapeTypeConditions.\n         * If this.type == ConditionType.ConnectedShapes, this is a ConnectedShapesConditions.\n         */\n        this.condition = this.definition['Condition'];\n        /**\n         * For formula conditions, the formula string.\n         *\n         * For other conditions,the value against which the condition is tested. For example, a condition with\n         *  type = ConditionType.ShapeData\n         *  condition = ShapeDataConditions.GreaterThan\n         *  field = 'TheField'\n         *  value = 14\n         *\n         * will trigger when the shape data field \"TheField\" has a value that is greater than 14.\n         */\n        this.value = this.definition['Value'];\n        /** For shape data conditions, the name of the shape data field to test */\n        this.field = this.definition['Label'];\n        /** For shape data conditions, the name to display to the end user to identify the field name */\n        this.fieldLabel = this.definition['DisplayLabel'];\n    }\n    /** Update this condition to reflect a new definition */\n    update(definition) {\n        this.rule.properties.set(this.key, (0, ruledefinition_1.serializeConditionDefinition)(definition));\n        this.definition = this.rule.properties.get(this.key);\n    }\n}\nexports.RuleCondition = RuleCondition;\nclass RuleEffect {\n    constructor(rule, client, key) {\n        this.rule = rule;\n        this.client = client;\n        this.key = key;\n        this.definition = this.rule.properties.get(this.key);\n        this.conditions = new mapproxy_1.MapProxy(() => this.definition['ConditionOrder'].map((order) => 'Condition_' + order), (key) => new RuleCondition(this.rule, this.client, key));\n        /** How multiple conditions are combined (AND vs OR) */\n        this.combination = this.definition['Combination'];\n        /** What kind of effect is displayed? Formatting vs. icons vs. dynamic stencil, etc. */\n        this.formatType = this.definition['FormatType'];\n        /** For formatType = RuleFormattingType.FORMATTING, what styles are applied to blocks, lines, and pages? */\n        this.formatting = this.definition['Formatting'];\n        /** For formatType = RuleFormattingType.DATA_GRAPHICS, a description of which icon appears and where */\n        this.dataGraphic = this.definition['DataGraphic'] && {\n            set: this.definition['DataGraphic']['Set'],\n            index: this.definition['DataGraphic']['Index'],\n            position: (0, badgeposition_1.deserializeBadgeEnumPosition)(this.definition['DataGraphic']['Position']),\n            color: this.definition['DataGraphic']['Color'],\n            image: this.definition['DataGraphic']['Image'] && {\n                url: this.definition['DataGraphic']['Image']['url'],\n                w: this.definition['DataGraphic']['Image']['w'],\n                h: this.definition['DataGraphic']['Image']['h'],\n            },\n        };\n    }\n    /** Update this effect to reflect a new definition */\n    update(definition) {\n        //Find the maximum used condition index in the entire rule, in case we need to add more.\n        let nextConditionIndex = 1;\n        for (const effect of this.rule.effects.values()) {\n            nextConditionIndex = Math.max(nextConditionIndex, ...effect.definition.ConditionOrder.map((index) => index + 1));\n        }\n        const conditionIndexes = this.definition.ConditionOrder;\n        definition.conditions.forEach((condition, index) => {\n            let conditionIndex = conditionIndexes[index];\n            if (conditionIndex === undefined) {\n                //Added a new condition\n                conditionIndex = nextConditionIndex;\n                conditionIndexes.push(nextConditionIndex++);\n            }\n            const conditionKey = 'Condition_' + conditionIndex;\n            this.rule.properties.set(conditionKey, (0, ruledefinition_1.serializeConditionDefinition)(condition));\n        });\n        this.rule.properties.set(this.key, (0, ruledefinition_1.serializeEffectDefinition)(definition, conditionIndexes.slice(0, definition.conditions.length)));\n    }\n}\nexports.RuleEffect = RuleEffect;\nclass RuleProxy extends documentelementproxy_1.DocumentElementProxy {\n    /**\n     * @param id The ID of this conditional formatting rule\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        this.effects = new mapproxy_1.MapProxy(() => this.properties.get('EffectOrder').map((order) => 'Effect_' + order), (key) => new RuleEffect(this, this.client, key));\n    }\n    getName() {\n        return this.properties.get('Name');\n    }\n    setName(name) {\n        this.properties.set('Name', name);\n    }\n    getOrder() {\n        return this.properties.get('Order');\n    }\n    /**\n     * Delete this conditional formatting rule from the document\n     */\n    delete() {\n        this.client.sendCommand(\"dde\" /* CommandName.DeleteDocumentElement */, this.id);\n    }\n    /** @ignore */\n    static getRuleProperties(definition) {\n        const properties = {\n            'EffectOrder': definition.effects.map((effect, index) => index + 1),\n            'SourceType': 0,\n            'Name': definition.name,\n        };\n        let nextConditionIndex = 1;\n        let nextEffectIndex = 1;\n        for (const effect of definition.effects) {\n            const effectKey = 'Effect_' + nextEffectIndex++;\n            const conditionOrder = [];\n            for (const condition of effect.conditions) {\n                conditionOrder.push(nextConditionIndex);\n                const conditionKey = 'Condition_' + nextConditionIndex++;\n                properties[conditionKey] = (0, ruledefinition_1.serializeConditionDefinition)(condition);\n            }\n            properties[effectKey] = (0, ruledefinition_1.serializeEffectDefinition)(effect, conditionOrder);\n        }\n        return properties;\n    }\n    /** Update this rule to reflect a new definition */\n    update(definition) {\n        const properties = RuleProxy.getRuleProperties(definition);\n        for (const key in properties) {\n            this.properties.set(key, properties[key]);\n        }\n    }\n}\nexports.RuleProxy = RuleProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/documentproxy.js":
/*!************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/documentproxy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentProxy = void 0;\nconst cardconfigproxy_1 = __webpack_require__(/*! ./documentelement/cardconfigproxy */ \"../../node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js\");\nconst documentelementtype_1 = __webpack_require__(/*! ./documentelement/documentelementtype */ \"../../node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js\");\nconst ruleproxy_1 = __webpack_require__(/*! ./documentelement/ruleproxy */ \"../../node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./elementproxy */ \"../../node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst itemproxy_1 = __webpack_require__(/*! ./itemproxy */ \"../../node_modules/lucid-extension-sdk/document/itemproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst pageproxy_1 = __webpack_require__(/*! ./pageproxy */ \"../../node_modules/lucid-extension-sdk/document/pageproxy.js\");\n/**\n * The currently-open Lucid document\n */\nclass DocumentProxy extends elementproxy_1.ElementProxy {\n    static getNextHookName() {\n        return '__documentproxy__hook' + DocumentProxy.nextHookId++;\n    }\n    constructor(client) {\n        super(client.sendCommand(\"gdid\" /* CommandName.GetDocumentId */, undefined), client);\n        /**\n         * The set of pages on this document, organized by ID\n         */\n        this.pages = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lp\" /* CommandName.ListPages */, undefined), (pageId) => new pageproxy_1.PageProxy(pageId, this.client));\n        this.cardIntegrationConfigs = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lde\" /* CommandName.ListDocumentElements */, { 't': documentelementtype_1.DocumentElementType.TaskCardFieldsConfig }), (id) => new cardconfigproxy_1.CardConfigProxy(id, this.client));\n        this.rules = new mapproxy_1.MapProxy(() => this.client\n            .sendCommand(\"lde\" /* CommandName.ListDocumentElements */, { 't': documentelementtype_1.DocumentElementType.Rule })\n            //Filter down to only the rules with source User (i.e. ones visible in the UI, not ones created internally by the app)\n            .filter((id) => this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'id': id, 'p': 'SourceType' }) === 0), (id) => new ruleproxy_1.RuleProxy(id, this.client));\n    }\n    /**\n     * An iterator over all blocks on all pages of the document\n     */\n    *allBlocks() {\n        for (const page of this.pages.values()) {\n            for (const block of page.blocks.values()) {\n                yield block;\n            }\n        }\n    }\n    /**\n     * An iterator over all lines on all pages of the document\n     */\n    *allLines() {\n        for (const page of this.pages.values()) {\n            for (const line of page.lines.values()) {\n                yield line;\n            }\n        }\n    }\n    /**\n     * Add a new page to the current document\n     * @param def Definition of the page to add\n     * @returns The created page\n     */\n    addPage(def) {\n        const id = this.client.sendCommand(\"cp\" /* CommandName.CreatePage */, undefined);\n        const page = new pageproxy_1.PageProxy(id, this.client);\n        page.setTitle(def.title);\n        return page;\n    }\n    /**\n     * Updates the title of this document\n     * @param title The new title for this document\n     */\n    setTitle(title) {\n        this.properties.set('Title', title);\n    }\n    /**\n     * @returns The title of this document\n     */\n    getTitle() {\n        return this.properties.get('Title');\n    }\n    /** @ignore */\n    getDocumentChunks(types) {\n        const chunks = this.client.sendCommand(\"gdc\" /* CommandName.GetDocumentChunks */, { 't': types });\n        return chunks.map((chunk) => {\n            return {\n                boundingBox: chunk['bb'],\n                items: chunk['i']\n                    .map((id) => this.client.getElementProxy(id))\n                    .filter((element) => element instanceof itemproxy_1.ItemProxy),\n                text: chunk['t'],\n                description: chunk['d'],\n            };\n        });\n    }\n    /**\n     * Infrequently, you may need to watch for *any* changes to the document. These changes may be\n     * the local user adding content, or a data integration sending updated records to a data collection,\n     * or a remote user hitting undo, or any user entering or exiting an intra-document mutex.\n     *\n     * Because these changes may happen rapidly, the callback you provide here will only be called on\n     * a heavily-debounced schedule. The callback will happen between 1-10 seconds after changes are\n     * made to the document, depending on the frequency with which changes are happening.\n     * @param callback\n     * @returns A handle that can be passed into `unhookAllChanges`\n     */\n    hookAllChanges(callback) {\n        const actionName = DocumentProxy.getNextHookName();\n        this.client.registerAction(actionName, () => {\n            callback();\n        });\n        this.client.sendCommand(\"hac\" /* CommandName.HookAllChanges */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * @param handle Return value from `hookAllChanges`\n     */\n    unhookAllChanges(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"uac\" /* CommandName.UnhookAllChanges */, { 'n': handle });\n    }\n    /**\n     * Watch for new blocks, lines, or groups added to this document. The callback will\n     * be called with new items created by the current user, but will not be called with items\n     * created\n     *\n     *  - As part of a generated diagram, e.g. org chart\n     *  - By another user on the same document\n     *\n     * @param callback\n     * @returns A handle that can be passed to `unhookCreateItems`\n     */\n    hookCreateItems(callback) {\n        const actionName = DocumentProxy.getNextHookName();\n        this.client.registerAction(actionName, (msg) => {\n            callback(msg['ids'].map((id) => this.client.getItemProxy(id)));\n        });\n        this.client.sendCommand(\"hci\" /* CommandName.HookCreateItems */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * @param handle Return value from `hookCreateItems`\n     */\n    unhookCreateItems(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"uci\" /* CommandName.UnhookCreateItems */, { 'n': handle });\n    }\n    addRule(definition) {\n        let maxOrder = 0;\n        for (const rule of this.rules.values()) {\n            maxOrder = Math.max(maxOrder, rule.getOrder());\n        }\n        const id = this.client.sendCommand(\"cde\" /* CommandName.CreateDocumentElement */, {\n            't': documentelementtype_1.DocumentElementType.Rule,\n            'p': Object.assign(Object.assign({}, ruleproxy_1.RuleProxy.getRuleProperties(definition)), { 'Order': maxOrder + 1 }),\n        });\n        if (id === undefined) {\n            return undefined;\n        }\n        return new ruleproxy_1.RuleProxy(id, this.client);\n    }\n    /**\n     * Watch for new blocks, lines, or groups deleted from this document. The callback will\n     * be called with items deleted by the current user, but will not be called with items\n     * deleted\n     *\n     *  - As part of a generated diagram, e.g. org chart\n     *  - By another user on the same document\n     *\n     * @param callback\n     * @returns A handle that can be passed to `unhookDeleteItems`\n     */\n    hookDeleteItems(callback) {\n        const actionName = DocumentProxy.getNextHookName();\n        this.client.registerAction(actionName, (msg) => {\n            callback(msg['ids']);\n        });\n        this.client.sendCommand(\"hdi\" /* CommandName.HookDeleteItems */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * @param handle Return value from `hookDeleteItems`\n     */\n    unhookDeleteItems(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"udi\" /* CommandName.UnhookDeleteItems */, { 'n': handle });\n    }\n    async duplicateItems(ids) {\n        return await this.client.sendCommand(\"dis\" /* CommandName.DuplicateItems */, { 'ids': ids });\n    }\n}\nexports.DocumentProxy = DocumentProxy;\nDocumentProxy.nextHookId = 0;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/documentproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/elementproxy.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/elementproxy.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ElementProxy = void 0;\nconst referencekeydefinition_1 = __webpack_require__(/*! ../data/referencekeydefinition */ \"../../node_modules/lucid-extension-sdk/data/referencekeydefinition.js\");\nconst referencekeyproxy_1 = __webpack_require__(/*! ../data/referencekeyproxy */ \"../../node_modules/lucid-extension-sdk/data/referencekeyproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst propertystoreproxy_1 = __webpack_require__(/*! ./propertystoreproxy */ \"../../node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nconst shapedataproxy_1 = __webpack_require__(/*! ./shapedataproxy */ \"../../node_modules/lucid-extension-sdk/document/shapedataproxy.js\");\n/**\n * An element is anything on a Lucid document that can have properties and shape data:\n *  * [The document itself](#classes_document_documentproxy-DocumentProxy)\n *  * [Pages](#classes_document_pageproxy-PageProxy)\n *  * [Blocks](#classes_document_blockproxy-BlockProxy)\n *  * [Lines](#classes_document_lineproxy-LineProxy)\n *  * [Groups](#classes_document_groupproxy-GroupProxy)\n */\nclass ElementProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     * Set a reference key on this element, replacing any existing reference at the specified key.\n     *\n     * @param key\n     * @param settings\n     */\n    setReferenceKey(key, settings) {\n        this.client.sendCommand(\"srk\" /* CommandName.SetReferenceKey */, {\n            'id': this.id,\n            'k': key,\n            'v': (0, referencekeydefinition_1.serializeReferenceKeyDefinition)(settings),\n        });\n    }\n    /**\n     * Remove the specified reference key from this element.\n     * @param key\n     */\n    removeReferenceKey(key) {\n        this.client.sendCommand(\"srk\" /* CommandName.SetReferenceKey */, { 'id': this.id, 'k': key });\n    }\n    /**\n     *\n     * @param id ID of this element\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        /**\n         * The shape data set directly on this element (not including any shape data inherited from the page or a containing group).\n         */\n        this.shapeData = new shapedataproxy_1.ShapeDataProxy(this.id, this.client);\n        /**\n         * All shape data accessible on this element, including shape data inherited from the page or a containing group.\n         * This collection is read-only.\n         */\n        this.allShapeData = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lsd\" /* CommandName.ListShapeData */, { 'id': this.id, 'i': true }), (name) => shapedataproxy_1.ShapeDataProxy.parseData(this.client.sendCommand(\"gsd\" /* CommandName.GetShapeData */, {\n            'id': this.id,\n            'n': name,\n        })));\n        /**\n         * The set of reference keys, organized by their ID, which can be either a string or number.\n         *\n         * For more information, see the [Developer Guide](/extension-api#guide-reference-keys).\n         */\n        this.referenceKeys = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lrk\" /* CommandName.ListReferenceKeys */, { 'id': this.id }), (key) => new referencekeyproxy_1.ReferenceKeyProxy(this.id, key, this.client, this.client.sendCommand(\"grk\" /* CommandName.GetReferenceKey */, { 'id': this.id, 'k': key })));\n    }\n    /**\n     * @returns `true` if this element still exists on the document, or `false` otherwise\n     */\n    exists() {\n        return this.client.sendCommand(\"ee\" /* CommandName.ElementExists */, { 'id': this.id });\n    }\n    /**\n     * Execute a formula in the context of this element\n     * @param formula The formula text, e.g. \"@a + @b\" to add together the shape data values a and b.\n     * @returns The result of the formula, or an error.\n     */\n    executeFormula(formula) {\n        return shapedataproxy_1.ShapeDataProxy.parseData(this.client.sendCommand(\"ef\" /* CommandName.ExecuteFormula */, { 'id': this.id || '', 'f': formula }));\n    }\n}\nexports.ElementProxy = ElementProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/elementproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/groupproxy.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/groupproxy.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GroupProxy = void 0;\nconst itemproxy_1 = __webpack_require__(/*! ./itemproxy */ \"../../node_modules/lucid-extension-sdk/document/itemproxy.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./lineproxy */ \"../../node_modules/lucid-extension-sdk/document/lineproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * A group of items on a page.\n */\nclass GroupProxy extends itemproxy_1.ItemProxy {\n    constructor() {\n        super(...arguments);\n        /**\n         * The blocks that are directly contained in this group, organized by ID.\n         */\n        this.blocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { 'id': this.id }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines that are directly contained in this group, organized by ID.\n         */\n        this.lines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { 'id': this.id }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups that are directly contained in this group, organized by ID.\n         */\n        this.groups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { 'id': this.id }), (id) => new GroupProxy(id, this.client));\n        /**\n         * The blocks that are contained in this group, including those nested in deeper groups, organized by ID.\n         */\n        this.allBlocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { 'id': this.id, 'd': true }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines that are contained in this group, including those nested in deeper groups, organized by ID.\n         */\n        this.allLines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { 'id': this.id, 'd': true }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups that are contained in this group, including those nested in deeper groups, organized by ID.\n         */\n        this.allGroups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { 'id': this.id, 'd': true }), (id) => new GroupProxy(id, this.client));\n    }\n}\nexports.GroupProxy = GroupProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/groupproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/imagedefinition.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/imagedefinition.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.imageToBlockDefinition = void 0;\n/**\n * Turns an image definition into a block definition.\n */\nfunction imageToBlockDefinition(definition) {\n    return {\n        className: 'UserImage2Block',\n        boundingBox: definition.boundingBox,\n        fillStyle: definition.fillStyle,\n        properties: {\n            opactiy: definition.opacity,\n            lineColor: definition.lineColor,\n            lineWidth: definition.lineWidth,\n            strokeStyle: definition.strokeStyle,\n            rounding: definition.rounding,\n            rotation: definition.rotation,\n        },\n    };\n}\nexports.imageToBlockDefinition = imageToBlockDefinition;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/imagedefinition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/itemproxy.js":
/*!********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/itemproxy.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ItemProxy = void 0;\nconst offsettype_1 = __webpack_require__(/*! ../core/offsettype */ \"../../node_modules/lucid-extension-sdk/core/offsettype.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./elementproxy */ \"../../node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * A block, line, or group on a page of the current document.\n */\nclass ItemProxy extends elementproxy_1.ElementProxy {\n    /**\n     * @param id ID of this item\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The plain text in each of the text areas on this item, organized by text area name.\n         */\n        this.textAreas = new mapproxy_1.WriteableMapProxy(() => this.client.sendCommand(\"lta\" /* CommandName.ListTextAreas */, this.id), (name) => this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, {\n            'id': this.id,\n            'p': name,\n        }), (name, plainText, options) => this.client.sendCommand(\"st\" /* CommandName.SetText */, {\n            'id': this.id,\n            'n': name,\n            't': plainText,\n            'f': options === null || options === void 0 ? void 0 : options.force,\n        }));\n        /**\n         * The text style in each of the text areas on this item, organized by text area name.\n         */\n        this.textStyles = new mapproxy_1.WriteableMapProxy(() => this.textAreas.keys(), (name) => this.client.sendCommand(\"gts\" /* CommandName.GetTextStyle */, {\n            'id': this.id,\n            'n': name,\n        }), (name, style) => this.client.sendCommand(\"sts\" /* CommandName.SetTextStyle */, {\n            'id': this.id,\n            'n': name,\n            's': style,\n        }));\n    }\n    /**\n     * @returns The bounding box of this item relative to its containing page. As pages may change size\n     * to fit the content on them, note that these coordinates may be negative or very large.\n     *\n     * If this is a rotated block, the bounding box returned here is where the block would be if it were\n     * unrotated.\n     */\n    getBoundingBox() {\n        return this.properties.get('BoundingBox');\n    }\n    /**\n     * Attempts to move and resize this item to fit into the given bounding box. If this item (or another\n     * item it contains) has size or aspect ratio restrictions, it may not be possible to fit the requested\n     * location exactly.\n     *\n     * This is done by moving this item to the requested location, then attempting to resize it from the\n     * bottom-right corner to the requested size.\n     *\n     * @param bb The bounding box to attempt to make this item fill\n     */\n    setBoundingBox(bb) {\n        const current = this.getBoundingBox();\n        if (current.x !== bb.x || current.y !== bb.y) {\n            this.offset(offsettype_1.OffsetType.MOVE, { x: bb.x - current.x, y: bb.y - current.y });\n        }\n        if (current.w !== bb.w || current.h !== bb.h) {\n            this.offset(offsettype_1.OffsetType.SE, {\n                x: bb.w - current.w,\n                y: bb.h - current.h,\n            });\n        }\n    }\n    /**\n     * @returns The ID of the page containing this item\n     */\n    getPageId() {\n        return this.client.sendCommand(\"gip\" /* CommandName.GetItemPageId */, this.id);\n    }\n    /**\n     * @returns The page containing this item\n     */\n    getPage() {\n        return this.client.getPageProxy(this.getPageId());\n    }\n    /**\n     * @returns The x/y location of this item\n     */\n    getLocation() {\n        const bb = this.getBoundingBox();\n        return { x: bb.x, y: bb.y };\n    }\n    /**\n     * Moves this item so that its upper-left corner is positioned at the given location (prior to any rotation)\n     * @param location The target location\n     */\n    setLocation(location) {\n        const current = this.getBoundingBox();\n        if (current.x !== location.x || current.y !== location.y) {\n            this.offset(offsettype_1.OffsetType.MOVE, { x: location.x - current.x, y: location.y - current.y });\n        }\n    }\n    /**\n     * Offset this item in the given direction by the given amount.\n     * @param type The type of offset to apply to this item\n     * @param offset The amount to offset\n     */\n    offset(type, offset) {\n        this.client.sendCommand(\"oi\" /* CommandName.OffsetItems */, { 'ids': [this.id], 't': type, 'o': offset });\n    }\n    /**\n     * Measure the amount of space necessary to render the text in the given text area, given a\n     * width to measure that text within.\n     * @param name Name of the text area whose content we should measure\n     * @param maxWidth Width of the area in which to measure this text. The result will usually be no wider than this, but if a single word is long enough to go beyond this maxWidth, the width of that word will be returned.\n     * @returns The size of rectangle necessary to render this text area's content.\n     */\n    measureText(name, maxWidth) {\n        return this.client.sendCommand(\"mt\" /* CommandName.MeasureText */, { 'id': this.id, 'n': name, 'w': maxWidth });\n    }\n    /**\n     * Delete this item from the document\n     */\n    delete() {\n        this.client.sendCommand(\"di\" /* CommandName.DeleteItem */, this.id);\n    }\n    /**\n     * @returns An array of blocks whose bounding boxes contain this item's upper-left corner\n     */\n    getContainers() {\n        const containers = this.executeFormula('LABEL(CONTAINEDBY)');\n        return containers.map((id) => this.client.getBlockProxy(id));\n    }\n    /**\n     * @param operation How to adjust the Z order of this item relative to the other items it overlaps on the page\n     */\n    changeZOrder(operation) {\n        this.client.sendCommand(\"z\" /* CommandName.ZOrder */, { 'i': [this.id], 'o': operation });\n    }\n    /**\n     * @param rule Rule to apply to this item\n     */\n    applyRule(rule) {\n        const ids = this.properties.get('RuleList');\n        if (!ids.includes(rule.id)) {\n            ids.push(rule.id);\n            this.properties.set('RuleList', ids);\n        }\n    }\n    /**\n     * @param rule Rule to remove from this item\n     */\n    unapplyRule(rule) {\n        const ids = this.properties.get('RuleList');\n        if (ids.includes(rule.id)) {\n            this.properties.set('RuleList', ids.filter((id) => id !== rule.id));\n        }\n    }\n}\nexports.ItemProxy = ItemProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/itemproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/linedefinition.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/linedefinition.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPositionEndpointDefinition = exports.isLineEndpointDefinition = exports.isBlockEndpointDefinition = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst blockproxy_1 = __webpack_require__(/*! ./blockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockproxy.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./lineproxy */ \"../../node_modules/lucid-extension-sdk/document/lineproxy.js\");\n/**\n * Checks if the endpoint is a BlockEndpointDefinition.\n */\nfunction isBlockEndpointDefinition(endpoint) {\n    return (0, validators_1.objectValidator)({\n        connection: (0, checks_1.isInstanceOf)(blockproxy_1.BlockProxy),\n        linkX: checks_1.isNumber,\n        linkY: checks_1.isNumber,\n        inside: (0, validators_1.option)(checks_1.isBoolean),\n        autoLink: (0, validators_1.option)(checks_1.isBoolean),\n        padding: (0, validators_1.option)(checks_1.isNumber),\n    })(endpoint);\n}\nexports.isBlockEndpointDefinition = isBlockEndpointDefinition;\n/**\n * Checks if the endpoint is a LineEndpointDefinition.\n */\nfunction isLineEndpointDefinition(endpoint) {\n    return (0, validators_1.objectValidator)({\n        connection: (0, checks_1.isInstanceOf)(lineproxy_1.LineProxy),\n        position: checks_1.isNumber,\n    })(endpoint);\n}\nexports.isLineEndpointDefinition = isLineEndpointDefinition;\n/**\n * Checks if the endpoint is a PositionEndpointDefinition.\n */\nfunction isPositionEndpointDefinition(endpoint) {\n    return (0, validators_1.objectValidator)({\n        x: checks_1.isNumber,\n        y: checks_1.isNumber,\n    })(endpoint);\n}\nexports.isPositionEndpointDefinition = isPositionEndpointDefinition;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/linedefinition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/lineproxy.js":
/*!********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/lineproxy.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LineProxy = exports.LineShape = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst blockproxy_1 = __webpack_require__(/*! ./blockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockproxy.js\");\nconst itemproxy_1 = __webpack_require__(/*! ./itemproxy */ \"../../node_modules/lucid-extension-sdk/document/itemproxy.js\");\nconst linetextareapositioning_1 = __webpack_require__(/*! ./linetextareapositioning */ \"../../node_modules/lucid-extension-sdk/document/linetextareapositioning.js\");\nvar LineShape;\n(function (LineShape) {\n    LineShape[\"Curve\"] = \"curve\";\n    LineShape[\"Elbow\"] = \"elbow\";\n    LineShape[\"Diagonal\"] = \"diagonal\";\n})(LineShape || (exports.LineShape = LineShape = {}));\n/**\n * A line on the current Lucid document\n */\nclass LineProxy extends itemproxy_1.ItemProxy {\n    getConnection(ep) {\n        let proxy;\n        if (ep['Block']) {\n            proxy = this.client.getBlockProxy(ep['Block']);\n        }\n        if (ep['Line']) {\n            proxy = this.client.getLineProxy(ep['Line']);\n        }\n        if (proxy && !proxy.exists()) {\n            return undefined;\n        }\n        return proxy;\n    }\n    isBlockEndpointDefinition(ep) {\n        return ep.connection instanceof blockproxy_1.BlockProxy;\n    }\n    isLineEndpointDefinition(ep) {\n        return ep.connection instanceof LineProxy;\n    }\n    parseLineEndpointDefinition(raw) {\n        const connection = this.getConnection(raw);\n        if (connection instanceof LineProxy) {\n            return {\n                connection,\n                style: raw['Style'],\n                position: raw['Position'],\n                x: raw['x'],\n                y: raw['y'],\n            };\n        }\n        else if (connection) {\n            return {\n                connection,\n                style: raw['Style'],\n                linkX: raw['LinkX'],\n                linkY: raw['LinkY'],\n                inside: raw['Inside'],\n                autoLink: raw['AutoLink'],\n                padding: raw['Padding'],\n                x: raw['x'],\n                y: raw['y'],\n            };\n        }\n        else {\n            return {\n                style: raw['Style'],\n                x: raw['x'],\n                y: raw['y'],\n            };\n        }\n    }\n    serializeLineEndpointDefinition(ep) {\n        if (this.isBlockEndpointDefinition(ep)) {\n            const bb = ep.connection.getBoundingBox();\n            return {\n                'Style': ep.style,\n                'x': bb.x + bb.w * ep.linkX,\n                'y': bb.y + bb.h * ep.linkY,\n                'Block': ep.connection.id,\n                'LinkX': ep.linkX,\n                'LinkY': ep.linkY,\n                'Inside': ep.inside,\n                'AutoLink': ep.autoLink,\n                'Padding': ep.padding,\n            };\n        }\n        else if (this.isLineEndpointDefinition(ep)) {\n            return Object.assign({ 'Style': ep.style, 'Line': ep.connection.id, 'LineP': ep.position }, ep.connection.getRelativePosition(ep.position));\n        }\n        else {\n            return {\n                'Style': ep.style,\n                'x': ep.x,\n                'y': ep.y,\n            };\n        }\n    }\n    /**\n     * @returns The definition of the first endpoint of this line\n     */\n    getEndpoint1() {\n        return this.parseLineEndpointDefinition(this.properties.get('Endpoint1'));\n    }\n    /**\n     * @returns The definition of the second endpoint of this line\n     */\n    getEndpoint2() {\n        return this.parseLineEndpointDefinition(this.properties.get('Endpoint2'));\n    }\n    /**\n     * Update the first endpoint of this line\n     * @param endpoint Line endpoint definition\n     */\n    setEndpoint1(endpoint) {\n        this.properties.set('Endpoint1', this.serializeLineEndpointDefinition(endpoint));\n    }\n    /**\n     * Update the second endpoint of this line\n     * @param endpoint Line endpoint definition\n     */\n    setEndpoint2(endpoint) {\n        this.properties.set('Endpoint2', this.serializeLineEndpointDefinition(endpoint));\n    }\n    /**\n     * @returns The block or line connected to the first endpoint of this line, or `undefined` if none\n     */\n    getUpstreamConnection() {\n        return this.getEndpoint1().connection;\n    }\n    /**\n     * @returns The block or line connected to the second endpoint of this line, or `undefined` if none\n     */\n    getDownstreamConnection() {\n        return this.getEndpoint2().connection;\n    }\n    /**\n     * @returns A list of lines whose endpoints are connected to this line\n     */\n    getConnectedLines() {\n        const ids = this.client.sendCommand(\"gcl\" /* CommandName.GetConnectedLines */, this.id);\n        return ids.map((id) => this.client.getLineProxy(id));\n    }\n    /**\n     * @param relative A distance, between 0 and 1, between the first and second endpoint of this line\n     * @returns The coordinate of that relative position, relative to the containing page\n     */\n    getRelativePosition(relative) {\n        return this.client.sendCommand(\"grlp\" /* CommandName.GetRelativeLinePosition */, { 'id': this.id, 'p': relative });\n    }\n    /**\n     *\n     * @param name\n     * @returns The position of the given text area on this line, if it exists, or undefined if it does not exist.\n     */\n    getTextAreaPosition(name) {\n        const serializedTextAreas = this.properties.get('TextAreas');\n        if ((0, checks_1.isObjectUnsafe)(serializedTextAreas)) {\n            const rawEntry = serializedTextAreas[name];\n            if ((0, linetextareapositioning_1.isSerializedLineTextAreaPositioning)(rawEntry)) {\n                return (0, linetextareapositioning_1.deserializeLineTextAreaPositioning)(rawEntry);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Updates the position of the given text area, if it exists. If not, an error is thrown.\n     * @param name\n     * @param position\n     */\n    setTextAreaPosition(name, position) {\n        this.properties.set('TextAreas', { [name]: (0, linetextareapositioning_1.serializeLineTextAreaPositioning)(position) });\n    }\n    /**\n     * Adds a new text area to this line at the given location with the given initial plain text.\n     * The text will be styled with the document theme, if any.\n     * @param text\n     * @param position\n     * @returns The name of the text area added\n     */\n    addTextArea(text, position) {\n        return this.client.sendCommand(\"alta\" /* CommandName.AddLineTextArea */, {\n            'id': this.id,\n            'p': (0, linetextareapositioning_1.serializeLineTextAreaPositioning)(position),\n            't': text,\n        });\n    }\n    /**\n     * Deletes the given text area from the line, if it exists.\n     * @param name\n     */\n    deleteTextArea(name) {\n        this.properties.set('TextAreas', { [name]: null });\n    }\n    getShape() {\n        return this.properties.get('Shape');\n    }\n    setShape(shape) {\n        this.properties.set('Shape', shape);\n    }\n}\nexports.LineProxy = LineProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/lineproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/linetextareapositioning.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/linetextareapositioning.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeLineTextAreaPositioning = exports.deserializeLineTextAreaPositioning = exports.isSerializedLineTextAreaPositioning = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\n/** @ignore */\nfunction isSerializedLineTextAreaPositioning(raw) {\n    return ((0, checks_1.isObjectUnsafe)(raw) &&\n        (0, checks_1.isNumber)(raw['Location']) &&\n        (0, checks_1.isNumber)(raw['Side']) &&\n        ((0, checks_1.isBoolean)(raw['AllowOverBlock']) || (0, checks_1.isUndefined)(raw['AllowOverBlock'])));\n}\nexports.isSerializedLineTextAreaPositioning = isSerializedLineTextAreaPositioning;\n/** @ignore */\nfunction deserializeLineTextAreaPositioning(raw) {\n    return {\n        location: raw['Location'],\n        side: raw['Side'],\n        allowOverBlock: raw['AllowOverBlock'],\n    };\n}\nexports.deserializeLineTextAreaPositioning = deserializeLineTextAreaPositioning;\n/** @ignore */\nfunction serializeLineTextAreaPositioning(data) {\n    return {\n        'Location': data.location,\n        'Side': data.side,\n        'AllowOverBlock': data.allowOverBlock,\n    };\n}\nexports.serializeLineTextAreaPositioning = serializeLineTextAreaPositioning;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/linetextareapositioning.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/mapproxy.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/mapproxy.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WriteableMapProxy = exports.MapProxy = void 0;\n/**\n * A data structure similar to a normal Map which accesses its data through API\n * commands to the Lucid app. This structure is iterable with `for...of`.\n */\nclass MapProxy {\n    constructor(getKeys, getItem) {\n        this.getKeys = getKeys;\n        this.getItem = getItem;\n    }\n    /** @ignore */\n    *[Symbol.iterator]() {\n        for (const key of this.keys()) {\n            const value = this.get(key);\n            if (value !== undefined) {\n                yield [key, value];\n            }\n        }\n    }\n    *values() {\n        for (const key of this.keys()) {\n            const value = this.get(key);\n            if (value !== undefined) {\n                yield value;\n            }\n        }\n    }\n    find(filter) {\n        for (const [key, value] of this) {\n            if (filter(value, key)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    filter(filter) {\n        const filtered = [];\n        for (const [key, value] of this) {\n            if (filter(value, key)) {\n                filtered.push(value);\n            }\n        }\n        return filtered;\n    }\n    map(callback) {\n        const mapped = [];\n        for (const [key, value] of this) {\n            mapped.push(callback(value, key));\n        }\n        return mapped;\n    }\n    keys() {\n        return this.getKeys();\n    }\n    get size() {\n        return this.keys().length;\n    }\n    get(key) {\n        return this.getItem(key);\n    }\n    first() {\n        const keys = this.keys();\n        if (keys.length == 0) {\n            return undefined;\n        }\n        return this.get(keys[0]);\n    }\n}\nexports.MapProxy = MapProxy;\nclass WriteableMapProxy extends MapProxy {\n    constructor(getKeys, getItem, setter) {\n        super(getKeys, getItem);\n        this.setter = setter;\n    }\n    set(key, value, options = {}) {\n        return this.setter(key, value, options);\n    }\n}\nexports.WriteableMapProxy = WriteableMapProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/mapproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/pagedefinition.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/pagedefinition.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/pagedefinition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/pageproxy.js":
/*!********************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/pageproxy.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PageProxy = void 0;\nconst commandtypes_1 = __webpack_require__(/*! ../commandtypes */ \"../../node_modules/lucid-extension-sdk/commandtypes.js\");\nconst ruleproxy_1 = __webpack_require__(/*! ./documentelement/ruleproxy */ \"../../node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./elementproxy */ \"../../node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst groupproxy_1 = __webpack_require__(/*! ./groupproxy */ \"../../node_modules/lucid-extension-sdk/document/groupproxy.js\");\nconst imagedefinition_1 = __webpack_require__(/*! ./imagedefinition */ \"../../node_modules/lucid-extension-sdk/document/imagedefinition.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./lineproxy */ \"../../node_modules/lucid-extension-sdk/document/lineproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * One page in the current Lucid document\n */\nclass PageProxy extends elementproxy_1.ElementProxy {\n    /**\n     * @param id The ID of this page\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The blocks contained directly on this page, not including ones inside groups\n         */\n        this.blocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { id: this.id }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines contained directly on this page, not including ones inside groups\n         */\n        this.lines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { id: this.id }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups contained directly on this page, not including ones inside groups\n         */\n        this.groups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { id: this.id }), (id) => new groupproxy_1.GroupProxy(id, this.client));\n        /**\n         * The blocks contained on this page, including ones inside groups\n         */\n        this.allBlocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { id: this.id, d: true }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines contained on this page, including ones inside groups\n         */\n        this.allLines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { id: this.id, d: true }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups contained on this page, including ones inside groups\n         */\n        this.allGroups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { id: this.id, d: true }), (id) => new groupproxy_1.GroupProxy(id, this.client));\n        /**\n         * All blocks, lines, and groups on the page, including ones inside groups\n         */\n        this.allItems = new mapproxy_1.MapProxy(() => [...this.allBlocks.keys(), ...this.allLines.keys(), ...this.allGroups.keys()], (id) => this.client.getItemProxy(id));\n    }\n    /**\n     * @returns All conditional formatting rules that are applied to every item on this page\n     */\n    getRulesAppliedToAllItems() {\n        const ids = this.properties.get('ChildRuleList');\n        return ids.map((id) => new ruleproxy_1.RuleProxy(id, this.client));\n    }\n    /**\n     * @param rule Rule to apply to all items on this page\n     */\n    applyRuleToAllItems(rule) {\n        const ids = this.properties.get('ChildRuleList');\n        if (!ids.includes(rule.id)) {\n            ids.push(rule.id);\n            this.properties.set('ChildRuleList', ids);\n        }\n    }\n    /**\n     * @param rule Rule to remove from the list applied to all items on this page\n     */\n    unapplyRuleToAllItems(rule) {\n        const ids = this.properties.get('ChildRuleList');\n        if (ids.includes(rule.id)) {\n            this.properties.set('ChildRuleList', ids.filter((id) => id !== rule.id));\n        }\n    }\n    /**\n     * Find available space on this page for adding new content.\n     * @param searchX Place to start the search\n     * @param searchY Place to start the search\n     * @param width\n     * @param height\n     * @returns a reference to the page and origin (upper-left point) of the space you can add new\n     * content of the given size to.\n     */\n    findAvailableSpace(searchX, searchY, width, height) {\n        const result = this.client.sendCommand(\"fas\" /* CommandName.FindAvailableSpace */, {\n            'p': this.id,\n            'x': searchX,\n            'y': searchY,\n            'w': width,\n            'h': height,\n        });\n        return {\n            page: this,\n            x: result['x'],\n            y: result['y'],\n        };\n    }\n    /**\n     * Add a new block to this page.\n     *\n     * IMPORTANT: Because code for block classes are loaded incrementally, you MUST call\n     * EditorClient.loadBlockClasses with the given block class name (and wait for it to\n     * resolve) before attempting to create a block. If you don't, an error will be thrown.\n     *\n     * @param def The definition of the new block to add\n     * @returns The added block\n     */\n    addBlock(def) {\n        const id = this.client.sendCommand(\"cb\" /* CommandName.CreateBlock */, {\n            'p': this.id,\n            'c': def.className,\n            's': def.stencil,\n        });\n        const block = this.client.getBlockProxy(id);\n        block.setBoundingBox(def.boundingBox);\n        if (def.properties) {\n            for (const key in def.properties) {\n                block.properties.set(key, def.properties[key]);\n            }\n        }\n        if (def.fillStyle !== undefined) {\n            block.setFillStyle(def.fillStyle);\n        }\n        if (def.lineWidth !== undefined) {\n            block.setLineWidth(def.lineWidth);\n        }\n        return block;\n    }\n    /**\n     * Creates a new group from a list of items.\n     *\n     * @param blocks A non-empty array of items to group\n     * @returns The added group\n     */\n    groupBlocks(blocks) {\n        const id = this.client.sendCommand(\"cg\" /* CommandName.CreateGroup */, {\n            'p': this.id,\n            'i': blocks.map((block) => block.id),\n        });\n        return new groupproxy_1.GroupProxy(id, this.client);\n    }\n    /**\n     * Add a new line to this page.\n     * @param def The definition of the new line to add\n     * @returns The added line\n     */\n    addLine(def) {\n        const id = this.client.sendCommand(\"cl\" /* CommandName.CreateLine */, {\n            'p': this.id,\n        });\n        const line = new lineproxy_1.LineProxy(id, this.client);\n        line.setEndpoint1(def.endpoint1);\n        line.setEndpoint2(def.endpoint2);\n        return line;\n    }\n    /**\n     * Add a new image to this page.\n     * @param def The definition of the new image to add\n     * @returns The added image\n     */\n    async addImage(def) {\n        await this.client.loadBlockClasses(['UserImage2Block']);\n        return this.addBlock((0, imagedefinition_1.imageToBlockDefinition)(def));\n    }\n    /**\n     * Add a diagram described by Mermaid markup to this page.\n     *\n     * See https://mermaid.js.org/intro/syntax-reference.html for information on Mermaid markup syntax.\n     *\n     * @param diagramType The type of the diagram. Note that this is redundant because the Mermaid markup also contains\n     *                         the diagram type.\n     * @param mermaid Mermaid markup text describing the diagram to add.\n     * @param origin Where to place the diagram on the page. If absent some free\n     *                  space within or near the current viewport is automatically chosen.\n     * @param exactPlacement If true and if origin is specified, places the diagram exactly at the specified origin\n     *                          instead of trying to find free space.\n     * @returns An array of the proxies for all the objects in the added diagram.\n     */\n    async addDiagramFromMermaid(diagramType, mermaid, origin, exactPlacement) {\n        return (await this.client.sendCommand(\"adfm\" /* CommandName.AddDiagramFromMermaid */, {\n            't': diagramType,\n            'm': mermaid,\n            'o': origin,\n            'e': exactPlacement,\n        })).map((id) => this.client.getItemProxy(id));\n    }\n    /**\n     * Updates the page of this page\n     * @param title The new title for this page\n     */\n    setTitle(title) {\n        this.properties.set('Title', title);\n    }\n    /**\n     * @returns the title of this page\n     */\n    getTitle() {\n        return this.properties.get('Title');\n    }\n    /**\n     * Delete this page from the document if possible\n     */\n    delete() {\n        this.client.sendCommand(\"dp\" /* CommandName.DeletePage */, this.id);\n    }\n    /**\n     *\n     * @param boundingBox An area of this page to search for blocks, lines, and groups\n     * @param searchType\n     * @returns Items in the given bounding box, based on the search type\n     */\n    findItems(boundingBox, searchType) {\n        return this.client\n            .sendCommand(\"gia\" /* CommandName.GetItemsAt */, { 'p': this.id, 'bb': boundingBox, 's': searchType })\n            .map((id) => this.client.getItemProxy(id));\n    }\n    /**\n     * Import links onto this page as link unfurl blocks\n     *\n     * NOTE: links will be unfurled by Lucid based on extensions installed by user\n     *\n     * @param links links to be imported onto the canvas as link unfurl blocks\n     */\n    async importLinks(links) {\n        return await this.client.sendCommand(\"il\" /* CommandName.ImportLinks */, { 'p': this.id, 'l': links });\n    }\n    /**\n     * @param items\n     * @returns A string representing the content of the items provided, including immediate surrounding context if\n     * necessary, in a format that is easily understandable by LLMs like ChatGPT. Also a map of IDs, from the shortened\n     * IDs provided for the items in the context to the actual Lucid item IDs.\n     */\n    getLLMContextForItems(items, contextType = commandtypes_1.GetLLMContextType.Relational) {\n        //We don't check that the items are on this page here; that is done in the implementation\n        //of the API command. It would be a lot of extra API calls for no benefit.\n        const result = this.client.sendCommand(\"llm\" /* CommandName.GetLLMContextFromItems */, {\n            'p': this.id,\n            'i': items.map((item) => item.id),\n            't': contextType,\n        });\n        return {\n            prompt: result['p'],\n            idToLucidId: new Map(Object.entries(result['id'])),\n        };\n    }\n    /**\n     *\n     * @param items If specified, only include these items in the resulting SVG\n     * @param includeBackground If true, include the background of the page in the SVG. Otherwise the background is transparent.\n     * @param viewBox If specified, crop the resulting SVG to the specified bounding box in page coordinates\n     * @returns A promise resolving to an SVG string\n     */\n    getSvg(items, includeBackground = false, viewBox) {\n        return this.client.sendCommand(\"gsvg\" /* CommandName.GetSvg */, {\n            'p': this.id,\n            'bb': viewBox,\n            'bg': includeBackground,\n            'i': items === null || items === void 0 ? void 0 : items.map((item) => item.id),\n        });\n    }\n    /**\n     * @returns the page number of this page\n     */\n    getPageNumber() {\n        return this.properties.get('Order');\n    }\n    /**\n     * Duplicates the page represented by the page proxy\n     */\n    async duplicate() {\n        await this.client.duplicatePages([this.getPageNumber()]);\n    }\n}\nexports.PageProxy = PageProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/pageproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/propertystoreproxy.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/propertystoreproxy.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PropertyStoreProxy = void 0;\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * Base class for anything on a Lucid document that has an ID and properties.\n */\nclass PropertyStoreProxy {\n    /**\n     *\n     * @param id ID of this element\n     * @param client\n     */\n    constructor(id, client) {\n        this.id = id;\n        this.client = client;\n        /**\n         * All properties available on this element, organized by name.\n         * Not all properties are writeable (e.g. \"ClassName\" on a block).\n         * To move or resize elements, use setLocation() or setBoundingBox() or offset() instead.\n         */\n        this.properties = new mapproxy_1.WriteableMapProxy(() => this.client.sendCommand(\"lpr\" /* CommandName.ListProperties */, { 'id': this.id }), (name) => this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, {\n            'id': this.id,\n            'p': name,\n        }), (name, value) => {\n            if (name === 'BoundingBox') {\n                throw new Error('Do not use properties.set() to move or resize items; use setLocation() or setBoundingBox() or offset()');\n            }\n            this.client.sendCommand(\"sp\" /* CommandName.SetProperty */, {\n                'id': this.id,\n                'p': name,\n                'v': value,\n            });\n        });\n    }\n}\nexports.PropertyStoreProxy = PropertyStoreProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/propertystoreproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/ruledefinition.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/ruledefinition.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeEffectDefinition = exports.serializeConditionDefinition = void 0;\nconst badgeposition_1 = __webpack_require__(/*! ../core/properties/datagraphic/badgeposition */ \"../../node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nconst datagraphicindexes_1 = __webpack_require__(/*! ../core/properties/datagraphic/datagraphicindexes */ \"../../node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js\");\nconst conditiontype_1 = __webpack_require__(/*! ../core/rules/conditiontype */ \"../../node_modules/lucid-extension-sdk/core/rules/conditiontype.js\");\nconst serializedeffect_1 = __webpack_require__(/*! ../core/rules/serializedeffect */ \"../../node_modules/lucid-extension-sdk/core/rules/serializedeffect.js\");\n/** @ignore */\nfunction serializeConditionDefinition(condition) {\n    switch (condition.type) {\n        case conditiontype_1.ConditionType.Formula:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': 0,\n                'Value': condition.formula,\n            };\n        case conditiontype_1.ConditionType.Text:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': condition.condition,\n                'Value': condition.value,\n            };\n        case conditiontype_1.ConditionType.ShapeData:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': condition.condition,\n                'Value': condition.value,\n                'Label': condition.field,\n                'DisplayLabel': condition.fieldLabel,\n            };\n        case conditiontype_1.ConditionType.ShapeType:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': condition.condition,\n                'Value': condition.classNames,\n            };\n        default:\n            throw new Error('Unsupported ConditionType');\n    }\n}\nexports.serializeConditionDefinition = serializeConditionDefinition;\n/** @ignore */\nfunction serializeEffectDefinition(effect, conditionOrder) {\n    var _a;\n    return {\n        'ConditionOrder': conditionOrder,\n        'Combination': effect.combination,\n        'FormatType': effect.formatType,\n        'Formatting': effect.formatType === serializedeffect_1.RuleFormattingType.FORMATTING\n            ? {\n                'Block': {\n                    'FillColor': JSON.stringify(effect.formatting.fillColor),\n                    'LineColor': JSON.stringify(effect.formatting.borderColor),\n                    'LineWidth': JSON.stringify(effect.formatting.borderWidth),\n                    'StrokeStyle': JSON.stringify(effect.formatting.borderStyle),\n                },\n                'Line': {\n                    'LineColor': JSON.stringify(effect.formatting.lineColor),\n                    'LineWidth': JSON.stringify(effect.formatting.lineWidth),\n                    'StrokeStyle': JSON.stringify(effect.formatting.lineStyle),\n                },\n            }\n            : {},\n        'DataGraphic': effect.formatType === serializedeffect_1.RuleFormattingType.DATA_GRAPHICS\n            ? effect.dataGraphic.set === datagraphicindexes_1.DataGraphicIconSets.CUSTOM_ICONS\n                ? {\n                    'Set': effect.dataGraphic.set,\n                    'Index': 0,\n                    'Position': (0, badgeposition_1.serializeBadgeEnumPosition)(effect.dataGraphic.position),\n                    'Image': {\n                        'url': effect.dataGraphic.image.url,\n                        'w': effect.dataGraphic.image.width,\n                        'h': effect.dataGraphic.image.height,\n                    },\n                }\n                : {\n                    'Set': effect.dataGraphic.set,\n                    'Index': (_a = effect.dataGraphic.index) !== null && _a !== void 0 ? _a : 0,\n                    'Position': (0, badgeposition_1.serializeBadgeEnumPosition)(effect.dataGraphic.position),\n                    'Color': effect.dataGraphic.color,\n                }\n            : undefined,\n        'Tooltip': effect.tooltip,\n    };\n}\nexports.serializeEffectDefinition = serializeEffectDefinition;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/ruledefinition.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/shapedataproxy.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/shapedataproxy.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShapeDataProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializeddataerror_1 = __webpack_require__(/*! ../core/serializeddataerror */ \"../../node_modules/lucid-extension-sdk/core/serializeddataerror.js\");\nconst shapedatainheritance_1 = __webpack_require__(/*! ../core/shapedatainheritance */ \"../../node_modules/lucid-extension-sdk/core/shapedatainheritance.js\");\nconst dataerror_1 = __webpack_require__(/*! ../data/dataerror */ \"../../node_modules/lucid-extension-sdk/data/dataerror.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * The shape data fields on a single element of the current document\n */\nclass ShapeDataProxy extends mapproxy_1.WriteableMapProxy {\n    /**\n     * @param id The ID of the element, or undefined for the document itself\n     * @param client\n     */\n    constructor(id, client) {\n        super(() => this.client.sendCommand(\"lsd\" /* CommandName.ListShapeData */, { 'id': this.id }), (name) => ShapeDataProxy.parseData(this.client.sendCommand(\"gsd\" /* CommandName.GetShapeData */, {\n            'id': this.id,\n            'n': name,\n        })), (name, value) => {\n            if ((0, serializeddataerror_1.isSerializedDataError)(value)) {\n                throw new Error('Cannot store an error value');\n            }\n            if (this.keys().includes(name)) {\n                this.client.sendCommand(\"ssd\" /* CommandName.SetShapeData */, { 'id': this.id, 'n': name, 'v': value });\n            }\n            else {\n                this.client.sendCommand(\"asd\" /* CommandName.AddShapeData */, {\n                    'id': this.id,\n                    'i': shapedatainheritance_1.ShapeDataInheritance.NONE,\n                    'n': name,\n                    'v': value,\n                });\n            }\n        });\n        this.id = id;\n        this.client = client;\n    }\n    /**\n     * Add shape data to this element that is inherited by its descendants.\n     *\n     * If you add an inheritable shape data to a page, whose formula is \"=@Cost * 4\", then\n     * each item on that page will have a new shape data entry (in `allShapeData`) by that\n     * name with the value calculated in the context of that individual item.\n     *\n     * Inheritable shape data on a page affects all items on the page. Inheritable shape\n     * data on a group affects all items inside that group.\n     *\n     * @param name Name of the new shape data\n     * @param value Value (or formula, if starting with \"=\") of the new shape data\n     */\n    addInheritable(name, value) {\n        this.client.sendCommand(\"asd\" /* CommandName.AddShapeData */, {\n            'id': this.id,\n            'i': shapedatainheritance_1.ShapeDataInheritance.VALUE,\n            'n': name,\n            'v': value,\n        });\n    }\n    /**\n     * Delete the specified shape data from this element\n     * @param key\n     */\n    delete(key) {\n        if (this.keys().includes(key)) {\n            this.client.sendCommand(\"dsd\" /* CommandName.DeleteShapeData */, { 'id': this.id, 'n': key });\n        }\n    }\n    /** @ignore */\n    static parseData(raw) {\n        if ((0, serializeddataerror_1.isSerializedDataError)(raw)) {\n            return new dataerror_1.DataError(raw['error'], raw['type']);\n        }\n        //TODO, eventually: parse these\n        return raw;\n    }\n    /**\n     * @param key Name of the shape data to read\n     * @returns The value if it is a string, or an empty string if it does not exist or is not a string.\n     */\n    getString(key) {\n        const val = this.get(key);\n        if (!(0, checks_1.isString)(val)) {\n            return '';\n        }\n        return val;\n    }\n}\nexports.ShapeDataProxy = ShapeDataProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/shapedataproxy.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/document/text/textstyle.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/document/text/textstyle.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPartialTextStyle = exports.TextMarkupNames = void 0;\nconst checks_1 = __webpack_require__(/*! ../../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../core/validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * Text styles that can be read and written with ItemProxy.textStyles.\n */\nvar TextMarkupNames;\n(function (TextMarkupNames) {\n    TextMarkupNames[\"Family\"] = \"font\";\n    TextMarkupNames[\"Bold\"] = \"bold\";\n    TextMarkupNames[\"Italic\"] = \"italic\";\n    TextMarkupNames[\"Underline\"] = \"underline\";\n    TextMarkupNames[\"Size\"] = \"size\";\n    TextMarkupNames[\"Color\"] = \"color\";\n    TextMarkupNames[\"HAlign\"] = \"align\";\n})(TextMarkupNames || (exports.TextMarkupNames = TextMarkupNames = {}));\nexports.isPartialTextStyle = (0, validators_1.partialObjectValidator)({\n    [TextMarkupNames.Family]: checks_1.isString,\n    [TextMarkupNames.Bold]: checks_1.isBoolean,\n    [TextMarkupNames.Italic]: checks_1.isBoolean,\n    [TextMarkupNames.Underline]: checks_1.isBoolean,\n    [TextMarkupNames.Size]: checks_1.isNumber,\n    [TextMarkupNames.Color]: checks_1.isString,\n    [TextMarkupNames.HAlign]: checks_1.isString,\n});\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/document/text/textstyle.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/editorclient.js":
/*!**************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/editorclient.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EditorClient = void 0;\nconst commandtypes_1 = __webpack_require__(/*! ./commandtypes */ \"../../node_modules/lucid-extension-sdk/commandtypes.js\");\nconst base64_1 = __webpack_require__(/*! ./core/base64 */ \"../../node_modules/lucid-extension-sdk/core/base64.js\");\nconst checks_1 = __webpack_require__(/*! ./core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst unfurldetails_1 = __webpack_require__(/*! ./core/unfurl/unfurldetails */ \"../../node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js\");\nconst unfurlrefresherrortype_1 = __webpack_require__(/*! ./core/unfurl/unfurlrefresherrortype */ \"../../node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js\");\nconst collectionproxy_1 = __webpack_require__(/*! ./data/collectionproxy */ \"../../node_modules/lucid-extension-sdk/data/collectionproxy.js\");\nconst blockproxyregistry_1 = __webpack_require__(/*! ./document/blockclasses/blockproxyregistry */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js\");\nconst customblockproxy_1 = __webpack_require__(/*! ./document/blockclasses/customblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js\");\nconst linkunfurlblockproxy_1 = __webpack_require__(/*! ./document/blockclasses/linkunfurlblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js\");\nconst blockproxy_1 = __webpack_require__(/*! ./document/blockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockproxy.js\");\nconst documentproxy_1 = __webpack_require__(/*! ./document/documentproxy */ \"../../node_modules/lucid-extension-sdk/document/documentproxy.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./document/elementproxy */ \"../../node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst groupproxy_1 = __webpack_require__(/*! ./document/groupproxy */ \"../../node_modules/lucid-extension-sdk/document/groupproxy.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./document/lineproxy */ \"../../node_modules/lucid-extension-sdk/document/lineproxy.js\");\nconst pageproxy_1 = __webpack_require__(/*! ./document/pageproxy */ \"../../node_modules/lucid-extension-sdk/document/pageproxy.js\");\nconst unfurleventmessage_1 = __webpack_require__(/*! ./message/unfurleventmessage */ \"../../node_modules/lucid-extension-sdk/message/unfurleventmessage.js\");\nfunction parseRawXHRResponse(responseFormat, raw) {\n    var _a, _b, _c, _d;\n    return Object.assign({ url: (_a = raw === null || raw === void 0 ? void 0 : raw['url']) !== null && _a !== void 0 ? _a : '', status: (_b = raw === null || raw === void 0 ? void 0 : raw['s']) !== null && _b !== void 0 ? _b : 0, headers: (_c = raw === null || raw === void 0 ? void 0 : raw['h']) !== null && _c !== void 0 ? _c : {}, timeout: raw === null || raw === void 0 ? void 0 : raw['to'] }, (responseFormat === 'utf8'\n        ? {\n            responseFormat,\n            responseText: (_d = raw === null || raw === void 0 ? void 0 : raw['t']) !== null && _d !== void 0 ? _d : 'An unknown error occurred',\n        }\n        : {\n            responseFormat,\n            responseData: (raw === null || raw === void 0 ? void 0 : raw['t']) ? (0, base64_1.decodeBase64)(raw['t']) : new Uint8Array(0),\n        }));\n}\nclass EditorClient {\n    getUniqueActionName() {\n        while (this.actionExists('a' + this.nextId)) {\n            this.nextId++;\n        }\n        return 'a' + this.nextId;\n    }\n    /**\n     * Get which Lucid product this editor extension has been loaded in.\n     */\n    getProduct() {\n        return this.sendCommand(\"gpr\" /* CommandName.GetProduct */, undefined);\n    }\n    /**\n     * Unload this extension immediately, removing any custom menu items etc., until the user refreshes the browser tab.\n     */\n    killExtension() {\n        this.sendCommand(\"k\" /* CommandName.KillExtension */, undefined);\n    }\n    /**\n     * Unload this extension, and then re-execute it.\n     */\n    reloadExtension() {\n        this.sendCommand(\"r\" /* CommandName.ReloadExtension */, undefined);\n    }\n    /**\n     * Initiate a browser file download of custom content\n     * @param filename Filename of the downloaded file\n     * @param data The content to put into the file, either in plain text or as base64-encoded binary data\n     * @param mime The MIME type to tell the browser it is downloading\n     * @param base64 If true, base64 decode the data before downloading it\n     */\n    download(filename, data, mime, base64) {\n        this.sendCommand(\"d\" /* CommandName.Download */, {\n            'f': filename,\n            'd': data,\n            'm': mime,\n            'b64': base64,\n        });\n    }\n    /**\n     * Upload an image and return a URL that can be used for displaying that image on the canvas. Note: the URL is\n     * public - anyone with the URL can access the image.\n     * @param data The binary image contents, or a base64-encoded string\n     * @param mediaType The media type, e.g. 'image/png'\n     * @returns A promise that resolves with the URL of the created image.\n     *\n     */\n    async createUserImage(mediaType, data) {\n        const result = await this.sendCommand(\"cui\" /* CommandName.CreateUserImage */, {\n            't': mediaType,\n            'd': (0, checks_1.isString)(data) ? data : (0, base64_1.encodeBase64)(data),\n        });\n        return result['u'];\n    }\n    /**\n     * @ignore\n     * @deprecated Use createUserImage instead.\n     */\n    experimentalCreateUserImage(mediaType, data) {\n        return this.createUserImage(mediaType, data);\n    }\n    async performDataAction(options) {\n        if (options.asynchronous === undefined) {\n            options.asynchronous = true;\n        }\n        const result = await this.sendCommand(\"da\" /* CommandName.DataAction */, {\n            'fn': options.actionName,\n            'a': options.asynchronous,\n            's': options.syncDataSourceIdNonce,\n            'fd': options.actionData,\n            'n': options.dataConnectorName,\n        });\n        if ('t' in result) {\n            return {\n                'status': result['c'],\n                'text': result['t'],\n            };\n        }\n        return {\n            'status': result['c'],\n            'json': result['j'],\n        };\n    }\n    /**\n     * If the extension package containing this editor extension has configurable settings,\n     * show a standard modal allowing the user to view or change those settings.\n     *\n     * If the user does not have permission to change settings on this installation of this\n     * extension, or if no settings exist, an error is thrown.\n     *\n     * @returns A promise that resolves when the user closes the settings modal.\n     */\n    async showPackageSettingsModal() {\n        return this.sendCommand(\"spsm\" /* CommandName.ShowPackageSettingsModal */, undefined);\n    }\n    /**\n     * If the extension package containing this editor extension has configurable settings, set the\n     * value of those settings for this installation of this extension. A subset of setting values\n     * can be provided to update those values while leaving others unchanged.\n     *\n     * If the user does not have permission to change settings on this installation of this\n     * extension, or if no settings exist, an error is thrown.\n     */\n    async setPackageSettings(settings) {\n        let settingsAsRecord = {};\n        if (settings instanceof Map) {\n            for (const [key, value] of settings.entries()) {\n                settingsAsRecord[key] = value;\n            }\n        }\n        else {\n            settingsAsRecord = settings;\n        }\n        return this.sendCommand(\"sps\" /* CommandName.SetPackageSettings */, settingsAsRecord);\n    }\n    /**\n     * If the extension package containing this editor extension has configurable settings,\n     * fetch the current values of those settings for this installation of this extension.\n     *\n     * Only settings that have been set by the installing user will have a value in the map,\n     * other settings will be missing.\n     *\n     * @returns A promise that resolves to a map of setting names to current setting values\n     */\n    async getPackageSettings() {\n        return new Map(Object.entries(await this.sendCommand(\"gps\" /* CommandName.GetPackageSettings */, undefined)));\n    }\n    /**\n     * @returns True if the current user is allowed to edit package settings on this installation\n     * of this extension (if any settings exist), or false otherwise.\n     */\n    async canEditPackageSettings() {\n        return this.sendCommand(\"ceps\" /* CommandName.CanEditPackageSettings */, undefined);\n    }\n    async awaitDataImport(dataConnectorName, syncDataSourceId, syncCollectionId, primaryKeys, timeout = 30000) {\n        return new collectionproxy_1.CollectionProxy(await this.sendCommand(\"ai\" /* CommandName.AwaitImport */, {\n            'n': dataConnectorName,\n            's': syncDataSourceId,\n            'c': syncCollectionId,\n            'pk': primaryKeys,\n            't': timeout,\n        }), this);\n    }\n    /** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\n    async awaitDataSourceImport(dataConnectorName, syncDataSourceIdNonce) {\n        return await this.sendCommand(\"adi\" /* CommandName.AwaitDataSourceImport */, {\n            'n': dataConnectorName,\n            's': syncDataSourceIdNonce,\n        });\n    }\n    xhr(request) {\n        let streamCallback;\n        if (request.streamCallback) {\n            streamCallback = this.getUniqueActionName();\n            this.registerAction(streamCallback, (msg) => { var _a; return (_a = request.streamCallback) === null || _a === void 0 ? void 0 : _a.call(request, msg['d']); });\n        }\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"xhr\" /* CommandName.SendXHR */, {\n            'url': request.url,\n            'm': request.method,\n            'd': request.data,\n            'h': request.headers,\n            'ms': request.timeoutMs,\n            'f': responseFormat,\n            's': streamCallback,\n        })\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        })\n            .finally(() => {\n            if (streamCallback) {\n                this.deleteAction(streamCallback);\n            }\n        });\n    }\n    asyncOAuthXhr(providerName, request) {\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"aoauth\" /* CommandName.SendAsyncOAuthRequest */, Object.assign({ 'url': request.url, 'm': request.method, 'd': request.data, 'h': request.headers, 'ms': request.timeoutMs, 'p': providerName, 'f': responseFormat }, (request.postResultTo ? { 'prt': request.postResultTo } : {})))\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        });\n    }\n    oauthXhr(providerName, request) {\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"oauth\" /* CommandName.SendOAuthRequest */, Object.assign({ 'url': request.url, 'm': request.method, 'd': request.data, 'h': request.headers, 'ms': request.timeoutMs, 'p': providerName, 'f': responseFormat }, (request.postResultTo ? { 'prt': request.postResultTo } : {})))\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        });\n    }\n    triggerAuthFlow(providerName) {\n        return this.sendCommand(\"tauth\" /* CommandName.TriggerAuthFlow */, {\n            'p': providerName,\n        });\n    }\n    /**\n     * Returns an OAuth token for the given provider, prompting the user to grant access if necessary\n     *\n     * @param providerName Name of the OAuth provider\n     * @returns An oauth token, or undefined if a valid token cannot be obtained\n     */\n    async getOAuthToken(providerName) {\n        return await this.sendCommand(\"got\" /* CommandName.GetOAuthToken */, { 'p': providerName });\n    }\n    /**\n     * Fetch the OAuth Client Id if there is one\n     *\n     * @param providerName Name of the OAuth provider\n     * @returns A oauth client id or undefined if it doesn't exist\n     */\n    async getOAuthClientId(providerName) {\n        return await this.sendCommand(\"goci\" /* CommandName.GetOAuthClientId */, { 'p': providerName });\n    }\n    permanentTokenXhr(providerName, request) {\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"perm\" /* CommandName.SendPermanentTokenRequest */, {\n            'url': request.url,\n            'm': request.method,\n            'd': request.data,\n            'h': request.headers,\n            'ms': request.timeoutMs,\n            'p': providerName,\n            'f': responseFormat,\n        })\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        });\n    }\n    /**\n     * Register a named action. These actions can be triggered from custom UI, for example as the action of a\n     * custom menu item.\n     *\n     * Some actions may return a value that is used by the core application, e.g. a `visibleAction` for a menu\n     * item. However, if you return a `Promise` from your callback, that value will be discarded and your\n     * action will return `undefined` instead. The ability to provide a callback that returns a Promise is only\n     * a convenience so that you can register actions with `async` callbacks for easy async/await.\n     *\n     * Throws an error if the same action name is registered multiple times.\n     *\n     * @param name name of the action\n     * @param callback function to execute when this action is invoked\n     */\n    registerAction(name, callback) {\n        if (this.actionExists(name)) {\n            throw new Error('Action already exists: ' + name);\n        }\n        this.callbacks.set(name, callback);\n    }\n    /**\n     * Register a named action that receives file upload data. These callbacks can be used in\n     * Menu.addMenuItem as the file action.\n     * @param name The name of the action\n     * @param callback Function to execute when this action is invoked\n     */\n    registerFileUploadAction(name, callback) {\n        this.registerAction(name, (msg) => {\n            callback(msg['f'].map((rawFile) => {\n                if (rawFile['b']) {\n                    return { fileName: rawFile['n'], text: rawFile['t'], binary: (0, base64_1.decodeBase64)(rawFile['b']) };\n                }\n                else {\n                    return { fileName: rawFile['n'], text: rawFile['t'] };\n                }\n            }));\n        });\n    }\n    /**\n     * Registers a handler for link unfurling.\n     * @param domain The domain\n     * @param callbacks The callbacks to call when a link matching the domain is pasted.\n     */\n    registerUnfurlHandler(domain, callbacks) {\n        const unfurlAction = this.getUniqueActionName();\n        let afterUnfurlAction = undefined;\n        let expandAction = undefined;\n        this.registerAction(unfurlAction, async (rawMsg) => {\n            const msg = (0, unfurleventmessage_1.deserializeUnfurlEventMessage)(rawMsg);\n            try {\n                const result = await callbacks.unfurlCallback(msg.url);\n                if (result && !(0, unfurlrefresherrortype_1.unfurlRefreshErrorTypeValidator)(result)) {\n                    return (0, unfurldetails_1.serializeUnfurlDetails)(result);\n                }\n            }\n            catch (err) {\n                return unfurlrefresherrortype_1.UnfurlRefreshErrorType.GenericFailure;\n            }\n            return undefined;\n        });\n        if (callbacks.afterUnfurlCallback) {\n            afterUnfurlAction = this.getUniqueActionName();\n            this.registerAction(afterUnfurlAction, async (rawMsg) => {\n                var _a;\n                const msg = (0, unfurleventmessage_1.deserializeUnfurlEventMessage)(rawMsg);\n                if (msg.blockId) {\n                    const proxy = this.getBlockProxy(msg.blockId);\n                    if (proxy instanceof linkunfurlblockproxy_1.LinkUnfurlBlockProxy) {\n                        await ((_a = callbacks.afterUnfurlCallback) === null || _a === void 0 ? void 0 : _a.call(callbacks, proxy, msg.url));\n                    }\n                }\n                return undefined;\n            });\n        }\n        if (callbacks.expandCallback) {\n            expandAction = this.getUniqueActionName();\n            this.registerAction(expandAction, async (rawMsg) => {\n                var _a;\n                const msg = (0, unfurleventmessage_1.deserializeUnfurlEventMessage)(rawMsg);\n                if (msg.blockId) {\n                    const proxy = this.getBlockProxy(msg.blockId);\n                    if (proxy instanceof linkunfurlblockproxy_1.LinkUnfurlBlockProxy) {\n                        await ((_a = callbacks.expandCallback) === null || _a === void 0 ? void 0 : _a.call(callbacks, proxy, msg.url));\n                    }\n                }\n            });\n        }\n        this.sendCommand(\"ru\" /* CommandName.RegisterUnfurl */, {\n            'd': domain,\n            'ua': unfurlAction,\n            'aua': afterUnfurlAction,\n            'e': expandAction,\n        });\n    }\n    /**\n     * @ignore\n     * @deprecated Use registerUnfurlHandler instead.\n     */\n    experimentalRegisterUnfurlHandler(domain, callbacks) {\n        return this.registerUnfurlHandler(domain, callbacks);\n    }\n    /**\n     * Remove the callback for a given action. If the action is later invoked, nothing will happen.\n     * @param name name of the action to unregister\n     */\n    deleteAction(name) {\n        this.callbacks.delete(name);\n    }\n    /**\n     * @param name name of the action to check\n     * @returns true if a callback has been registered for this action; false otherwise\n     */\n    actionExists(name) {\n        return this.callbacks.has(name);\n    }\n    //Note: UnionToIntersection here fixes the type of params required if you're passing in something that's not a single\n    //specific command name, to require the type of all possible command names you could pass in, intersected. So if you\n    //call this with a CommandName.ListBlocks|CommandName.ListLines it will work as expected but if you just pass in a\n    //CommandName, there won't be any possible params you could pass that would meet all the requirements (string & undefined & ...)\n    /**\n     * Execute an API command. This is the low-level API that most of this SDK wraps. It is not expected that you should\n     * ever need to use this directly.\n     *\n     * @param name name of the API command to execute\n     * @param params data to pass to the API command\n     * @returns the output of the given API command\n     */\n    sendCommand(name, params) {\n        return lucid.executeCommand(name, params);\n    }\n    /**\n     * Create and return a proxy for accessing a block with the given ID. If the block is of a type that has a specific\n     * proxy implementation (e.g. an ERD block) then a specialized subclass of BlockProxy may be returned.\n     *\n     * @param id ID of the block to create a proxy for\n     * @returns the given block\n     */\n    getBlockProxy(id) {\n        const className = this.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'id': id, 'p': 'ClassName' });\n        let proxy = (0, blockproxyregistry_1.findProxyClass)(className);\n        if (proxy === customblockproxy_1.CustomBlockProxy) {\n            proxy = customblockproxy_1.CustomBlockProxy.getCustomBlockClass(this, id);\n        }\n        if (proxy) {\n            return new proxy(id, this);\n        }\n        else {\n            return new blockproxy_1.BlockProxy(id, this);\n        }\n    }\n    /**\n     * Because code for block classes are loaded incrementally, you MUST call\n     * loadBlockClasses with the given block class name (and wait for it to\n     * resolve) before attempting to create a block. If you don't, an error\n     * will be thrown.\n     *\n     * @param classNames the block classes to load\n     * @returns a promise that resolves when the block classes can be used to create new blocks on the document\n     */\n    loadBlockClasses(classNames) {\n        return this.sendCommand(\"lbc\" /* CommandName.LoadBlockClasses */, classNames);\n    }\n    /**\n     * Import one or pages of the specified document or template into the current document\n     * as new pages.\n     * NOTE: The indices of the pages to import will change if the pages are rearranged\n     * on the source document or template.\n     *\n     * @param documentId The ID of the document or template to import\n     * @param pageNums An array of zero-indexed page indices to import from the document or template\n     * @returns a promise that resolves to void when the pages have been imported or the\n     * the import failed\n     */\n    async importPage(documentId, pageNums) {\n        return await this.sendCommand(\"imp\" /* CommandName.ImportPage */, { 'id': documentId, 'n': pageNums });\n    }\n    /**\n     * Duplicates one or more pages of the current document as new pages.\n     *\n     * @param pageNums An array of zero-indexed page indices to duplicate from the current document\n     * @returns a promise that resolves to void when the pages have been duplicated or the\n     * the duplication failed\n     */\n    async duplicatePages(pageNums) {\n        return await this.sendCommand(\"imp\" /* CommandName.ImportPage */, {\n            'id': this.sendCommand(\"gdid\" /* CommandName.GetDocumentId */, undefined),\n            'n': pageNums,\n        });\n    }\n    /**\n     * Load the requested shape library's content, and if it was found, return a block definition ready to be\n     * created.\n     *\n     * Example usage:\n     * ```inline:typescript\n     * const client = new EditorClient();\n     * const viewport = new Viewport(client);\n     *\n     * const page = viewport.getCurrentPage();\n     * if (page) {\n     *     const def = await page.getCustomShapeDefinition('libraryName', 'shapeName');\n     *     if (def) {\n     *         //Customize the shape about to be created\n     *         def.boundingBox.x = 500;\n     *         def.boundingBox.y = 500;\n     *\n     *         //Create the shape itself\n     *         const block = page.addBlock(def);\n     *\n     *         //Set any data fields on the shape as needed\n     *         block.shapeData.set('Value', 50);\n     *     }\n     * }\n     * ```\n     * @param library Name of the shape library in this extension to search for\n     * @param shape Name of the shape within that library to search for\n     * @returns\n     */\n    async getCustomShapeDefinition(library, shape) {\n        await this.loadBlockClasses(['CustomBlock']);\n        const shapeData = await this.sendCommand(\"gcs\" /* CommandName.GetCustomShape */, { 'l': library, 's': shape });\n        if (shapeData) {\n            return {\n                className: 'CustomBlock',\n                boundingBox: shapeData['bb'],\n                stencil: shapeData['s'],\n                properties: shapeData['p'],\n            };\n        }\n        return undefined;\n    }\n    /**\n     * @param callback A callback that processes the bootstrap data, if any, stored on the document and\n     * associated with this editor extension. If this callback is async (returns a promise), then the\n     * bootstrap data is not cleared off of the document until that promise resolves.\n     *\n     * @param markExtensionAsRequired If bootstrap data is available for this editor extension, this will mark the\n     * document as requiring the extension. Once marked, if the extension is not installed the user will be\n     * notified about the extension being required on document load. The minimum extension version required by the\n     * document is the version provided in the request body when creating the document.\n     *\n     * @return a promise that resolves immediately if there is no available bootstrap data, or else after\n     * the callback successfully completes. This promise will reject/throw if the callback throws or\n     * returns a promise that rejects, or if there is another editor session processing the same bootstrap\n     * data at the same time.\n     */\n    async processAndClearBootstrapData(callback, markExtensionAsRequired) {\n        const name = this.getUniqueActionName();\n        this.registerAction(name, (msg) => {\n            return callback(msg['d']);\n        });\n        await this.sendCommand(\"b\" /* CommandName.Bootstrap */, { 'c': name, 'm': markExtensionAsRequired });\n        this.deleteAction(name);\n    }\n    /**\n     * @param id ID of the line to create a proxy for\n     * @returns the given line\n     */\n    getLineProxy(id) {\n        return new lineproxy_1.LineProxy(id, this);\n    }\n    /**\n     * @param id ID of the page to create a proxy for\n     * @returns the given page\n     */\n    getPageProxy(id) {\n        return new pageproxy_1.PageProxy(id, this);\n    }\n    /**\n     * @param id ID of the item to create a proxy for\n     * @returns the given item\n     */\n    getItemProxy(id) {\n        const type = this.sendCommand(\"get\" /* CommandName.GetElementType */, { 'id': id });\n        switch (type) {\n            case 'block':\n                return this.getBlockProxy(id);\n            case 'line':\n                return this.getLineProxy(id);\n            case 'group':\n                return new groupproxy_1.GroupProxy(id, this);\n            default:\n                throw new Error('Element ' + id + ' is not an Item; type found is ' + type);\n        }\n    }\n    /**\n     * @param id ID of the item to create a proxy for\n     * @returns the given item, or undefined if the item does not exist or an error occurs\n     */\n    tryGetItemProxy(id) {\n        try {\n            const item = this.getItemProxy(id);\n            if (item.exists()) {\n                return item;\n            }\n        }\n        catch (_a) { }\n        return undefined;\n    }\n    /**\n     * @param id ID of the element to create a proxy for\n     * @returns the given element\n     */\n    getElementProxy(id) {\n        const type = this.sendCommand(\"get\" /* CommandName.GetElementType */, { 'id': id });\n        switch (type) {\n            case 'block':\n                return this.getBlockProxy(id);\n            case 'line':\n                return this.getLineProxy(id);\n            case 'page':\n                return this.getPageProxy(id);\n            case 'document':\n                return new documentproxy_1.DocumentProxy(this);\n            case 'group':\n                return new groupproxy_1.GroupProxy(id, this);\n            default:\n                return new elementproxy_1.ElementProxy(id, this);\n        }\n    }\n    /**\n     * @hidden\n     */\n    listenToEditor() {\n        lucid.listen((msg) => {\n            var _a;\n            return (_a = this.callbacks.get(msg['id'])) === null || _a === void 0 ? void 0 : _a(msg);\n        });\n    }\n    /**\n     * Display an alert modal to the user\n     * @param text Body text to display in the alert modal\n     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json\n     * @param buttonText Text for the OK button; defaults to \"OK\" (or a translation)\n     * @returns a Promise that resolves true if the user clicks OK, false if they otherwise dismiss the modal\n     */\n    alert(text, title, buttonText) {\n        return this.sendCommand(\"a\" /* CommandName.Alert */, { 't': title, 'b': text, 'bt': buttonText });\n    }\n    /**\n     * Display a confirm modal to the user\n     * @param text Body text to display in the alert modal\n     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json\n     * @param okText Text for the OK button; defaults to \"OK\" (or a translation)\n     * @param cancelText Text for the Cancel button; defaults to \"Cancel\" (or a translation)\n     * @returns a Promise that resolves true if the user clicks OK, false if they click Cancel or otherwise dismiss the modal\n     */\n    confirm(text, title, okText, cancelText) {\n        return this.sendCommand(\"c\" /* CommandName.Confirm */, { 't': title, 'b': text, 'o': okText, 'c': cancelText });\n    }\n    /**\n     * Display a prompt modal to the user\n     * @param text Body text to display in the alert modal\n     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json\n     * @returns a Promise that resolves to a string if a user enters one, or undefined if they cancel\n     */\n    prompt(text, title) {\n        return this.sendCommand(\"p\" /* CommandName.Prompt */, { 't': title, 'b': text });\n    }\n    /**\n     * Executes the given callback within a mutex scoped to the current document, extension, and the given name.\n     * If another editor session currently has the given mutex name locked within the same extension package ID\n     * on this same document, this function's returned promise will resolve to false. Otherwise, the mutex will\n     * be locked for the duration of the callback and the returned promise will resolve to true.\n     * @param name Name of the intra-document mutex to attempt to lock\n     * @param callback Code to execute while the mutex is locked, if it is successfully locked\n     * @returns A promise resolving to a boolean indicating whether the mutex was successfully locked\n     */\n    async withIntraDocumentMutex(name, callback) {\n        const action = this.getUniqueActionName();\n        this.registerAction(action, callback);\n        try {\n            return await this.sendCommand(\"wm\" /* CommandName.WithMutex */, { 'n': name, 'a': action });\n        }\n        finally {\n            this.deleteAction(action);\n        }\n    }\n    /**\n     * @param callback Callback that will be executed with the user's local undo/redo history suppressed. This is\n     * useful when you want to make changes to a document that will not be erased if the user uses undo or redo,\n     * for example adding shape data onto shapes as a result of a background process that collects data from a\n     * remote API.\n     */\n    withSilentActions(callback) {\n        const action = this.getUniqueActionName();\n        this.registerAction(action, () => {\n            const result = callback();\n            if ((0, checks_1.isPromise)(result)) {\n                throw new Error('withSilentActions cannot be used with an async callback');\n            }\n        });\n        try {\n            this.sendCommand(\"wsa\" /* CommandName.WithSilentActions */, { 'a': action });\n        }\n        finally {\n            this.deleteAction(action);\n        }\n    }\n    /**\n     * Hash a particular string using the given algorithm.\n     *\n     * Hashing can be very slow in extensions, so we provide this utility function to instead run hashing algorithms\n     * in the client.\n     *\n     * @param algorithm Which hashing algorithm to apply to the string. We currently only support SHA256.\n     * @param string The raw string we are calculating the hash of.\n     * @returns The hashed string.\n     */\n    /** @ignore because our documentation gets generated incorrectly for an as-yet unknown reason. It seems to refer to the HashAlgorithmEnum with an incorrect link. */\n    hash(algorithm, string) {\n        return this.sendCommand(\"hsh\" /* CommandName.CalculateHash */, { 'a': algorithm, 's': string });\n    }\n    constructor() {\n        this.nextId = 0;\n        this.callbacks = new Map();\n        this.listenToEditor();\n    }\n}\nexports.EditorClient = EditorClient;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/editorclient.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./commandtypes */ \"../../node_modules/lucid-extension-sdk/commandtypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/base64 */ \"../../node_modules/lucid-extension-sdk/core/base64.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/cardfielddisplaysettings */ \"../../node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/cardintegrationconfig */ \"../../node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/cardintegrationdefinitions */ \"../../node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationdefinitions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/lucidcardintegration */ \"../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/lucidcardintegrationregistry */ \"../../node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/datasourcetype */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/datasourceutils */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/metadatatypes */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/serializeddatasourceproperties */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/serializedimporteddatasource */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/serializedupstreamconfig */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/upstreamconfig */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/upstreampatchtype */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/upstreamupdatetype */ \"../../node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldspecification */ \"../../node_modules/lucid-extension-sdk/core/data/fieldspecification.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/basefieldtypedefinition */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/collectionenumfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/fieldtypearray */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/fieldtypedefinition */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/literalfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/ndimensionalfieldtypearray */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/scalarfieldtype */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/semantickind */ \"../../node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/referencekeys/serializedreferencekey */ \"../../node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializeddataitems */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializedfielddefinition */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializedfields */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializedschema */ \"../../node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/dataerrortype */ \"../../node_modules/lucid-extension-sdk/core/dataerrortype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/guards */ \"../../node_modules/lucid-extension-sdk/core/guards.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/humanreadableerror */ \"../../node_modules/lucid-extension-sdk/core/humanreadableerror.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/iframe/iframeutils */ \"../../node_modules/lucid-extension-sdk/core/iframe/iframeutils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/jsonserializable */ \"../../node_modules/lucid-extension-sdk/core/jsonserializable.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/lucidproduct */ \"../../node_modules/lucid-extension-sdk/core/lucidproduct.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/object */ \"../../node_modules/lucid-extension-sdk/core/object.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/offsettype */ \"../../node_modules/lucid-extension-sdk/core/offsettype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/optionalkey */ \"../../node_modules/lucid-extension-sdk/core/optionalkey.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/datagraphic/badgeposition */ \"../../node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/datagraphic/datagraphicindexes */ \"../../node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/datagraphic/staticdatagraphicsettings */ \"../../node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/fillcolor */ \"../../node_modules/lucid-extension-sdk/core/properties/fillcolor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/shadow */ \"../../node_modules/lucid-extension-sdk/core/properties/shadow.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/strokestyle */ \"../../node_modules/lucid-extension-sdk/core/properties/strokestyle.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/rules/conditions */ \"../../node_modules/lucid-extension-sdk/core/rules/conditions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/rules/conditiontype */ \"../../node_modules/lucid-extension-sdk/core/rules/conditiontype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/rules/serializedeffect */ \"../../node_modules/lucid-extension-sdk/core/rules/serializedeffect.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/serializeddataerror */ \"../../node_modules/lucid-extension-sdk/core/serializeddataerror.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/shapedatainheritance */ \"../../node_modules/lucid-extension-sdk/core/shapedatainheritance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/spreadsheetintegration/lucidspreadsheetintegration */ \"../../node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/spreadsheetintegration/lucidspreadsheetintegrationregistry */ \"../../node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurlcallbacks */ \"../../node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurldetails */ \"../../node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurliframe */ \"../../node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurlrefresherrortype */ \"../../node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurlthumbnail */ \"../../node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/validators/validators */ \"../../node_modules/lucid-extension-sdk/core/validators/validators.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/xhr */ \"../../node_modules/lucid-extension-sdk/core/xhr.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/collectiondefinition */ \"../../node_modules/lucid-extension-sdk/data/collectiondefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/collectionproxy */ \"../../node_modules/lucid-extension-sdk/data/collectionproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataerror */ \"../../node_modules/lucid-extension-sdk/data/dataerror.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataitemproxy */ \"../../node_modules/lucid-extension-sdk/data/dataitemproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataproxy */ \"../../node_modules/lucid-extension-sdk/data/dataproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/datasourceproxy */ \"../../node_modules/lucid-extension-sdk/data/datasourceproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataupdatefiltertype */ \"../../node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/referencekeydefinition */ \"../../node_modules/lucid-extension-sdk/data/referencekeydefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/referencekeyproxy */ \"../../node_modules/lucid-extension-sdk/data/referencekeyproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/schemadefinition */ \"../../node_modules/lucid-extension-sdk/data/schemadefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/action */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/action.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/managewebhookresponsebody */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/patchresponsebody */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/serializedactions */ \"../../node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/dataconnector */ \"../../node_modules/lucid-extension-sdk/dataconnector/dataconnector.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/dataconnectorclient */ \"../../node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/datasourceclient */ \"../../node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/datasourcemetadatatypes */ \"../../node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/datasourceupdatetypes */ \"../../node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/signaturevalidator */ \"../../node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/blockproxyregistry */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/cardblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/customblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/erdblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/legendblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/linkunfurlblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/swimlaneblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/tableblockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockdefinition */ \"../../node_modules/lucid-extension-sdk/document/blockdefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockproxy */ \"../../node_modules/lucid-extension-sdk/document/blockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/documentproxy */ \"../../node_modules/lucid-extension-sdk/document/documentproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/elementproxy */ \"../../node_modules/lucid-extension-sdk/document/elementproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/groupproxy */ \"../../node_modules/lucid-extension-sdk/document/groupproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/itemproxy */ \"../../node_modules/lucid-extension-sdk/document/itemproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/linedefinition */ \"../../node_modules/lucid-extension-sdk/document/linedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/lineproxy */ \"../../node_modules/lucid-extension-sdk/document/lineproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/linetextareapositioning */ \"../../node_modules/lucid-extension-sdk/document/linetextareapositioning.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/mapproxy */ \"../../node_modules/lucid-extension-sdk/document/mapproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/pagedefinition */ \"../../node_modules/lucid-extension-sdk/document/pagedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/pageproxy */ \"../../node_modules/lucid-extension-sdk/document/pageproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/propertystoreproxy */ \"../../node_modules/lucid-extension-sdk/document/propertystoreproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/shapedataproxy */ \"../../node_modules/lucid-extension-sdk/document/shapedataproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/text/textstyle */ \"../../node_modules/lucid-extension-sdk/document/text/textstyle.js\"), exports);\n__exportStar(__webpack_require__(/*! ./editorclient */ \"../../node_modules/lucid-extension-sdk/editorclient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./index */ \"../../node_modules/lucid-extension-sdk/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./math */ \"../../node_modules/lucid-extension-sdk/math.js\"), exports);\n__exportStar(__webpack_require__(/*! ./message/unfurleventmessage */ \"../../node_modules/lucid-extension-sdk/message/unfurleventmessage.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/alertmodal */ \"../../node_modules/lucid-extension-sdk/ui/alertmodal.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/iframeui */ \"../../node_modules/lucid-extension-sdk/ui/iframeui.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/menu */ \"../../node_modules/lucid-extension-sdk/ui/menu.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/modal */ \"../../node_modules/lucid-extension-sdk/ui/modal.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/panel */ \"../../node_modules/lucid-extension-sdk/ui/panel.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/viewport */ \"../../node_modules/lucid-extension-sdk/ui/viewport.js\"), exports);\n__exportStar(__webpack_require__(/*! ./user/userproxy */ \"../../node_modules/lucid-extension-sdk/user/userproxy.js\"), exports);\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/index.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/math.js":
/*!******************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/math.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rotateAroundFn = exports.toCornersAsArray = exports.boxFrom4Points = exports.rotateBox = exports.rotatedBoundingBox = exports.boxCenter = exports.clip = exports.percentBoxesOverlap = exports.boxesOverlap = exports.isBoxWithin = exports.padBox = exports.combinedBoundingBox = void 0;\nfunction combinedBoundingBox(boxes) {\n    if (boxes.length == 0) {\n        return undefined;\n    }\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n    for (const box of boxes) {\n        minX = Math.min(minX, box.x);\n        maxX = Math.max(maxX, box.x + box.w);\n        minY = Math.min(minY, box.y);\n        maxY = Math.max(maxY, box.y + box.h);\n    }\n    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };\n}\nexports.combinedBoundingBox = combinedBoundingBox;\nfunction padBox(box, padding) {\n    return { x: box.x - padding, y: box.y - padding, w: box.w + padding * 2, h: box.h + padding * 2 };\n}\nexports.padBox = padBox;\n/**\n * Is box a completely within box b?\n */\nfunction isBoxWithin(a, b) {\n    return a.x >= b.x && a.y >= b.y && a.x + a.w <= b.x + b.w && a.y + a.h <= b.y + b.h;\n}\nexports.isBoxWithin = isBoxWithin;\n/**\n * Do two boxes overlap?\n */\nfunction boxesOverlap(a, b) {\n    return a.x + a.w >= b.x && a.y + a.h >= b.y && b.x + b.w >= a.x && b.y + b.h >= a.y;\n}\nexports.boxesOverlap = boxesOverlap;\n/**\n * return the percentage of a that overlaps with b.\n * if a is entirely within b, it returns 1 (or a number a little less than 1\n * (e.g., 0.99999999999) due to numerical inaccuracy); if a is entirely\n * outside b, it returns 0.\n */\nfunction percentBoxesOverlap(a, b) {\n    const intersection = clip(a, b);\n    // if either dimension is negative return zero\n    if (intersection.w <= 0 || intersection.h <= 0) {\n        return 0;\n    }\n    const area = intersection.w * intersection.h;\n    return area / (a.w * a.h);\n}\nexports.percentBoxesOverlap = percentBoxesOverlap;\n/**\n * Gets the intersection of two boxes\n * @return a clipped to b\n */\nfunction clip(a, b) {\n    const x = Math.max(a.x, b.x);\n    const y = Math.max(a.y, b.y);\n    const w = Math.min(a.x + a.w, b.x + b.w) - x;\n    const h = Math.min(a.y + a.h, b.y + b.h) - y;\n    return { x, y, w, h };\n}\nexports.clip = clip;\nfunction boxCenter(b) {\n    return { x: b.x + b.w / 2, y: b.y + b.h / 2 };\n}\nexports.boxCenter = boxCenter;\n/**\n * Returns the bounding box that would surround the given\n * box when rotated the given amount.\n */\nfunction rotatedBoundingBox(b, angle, center) {\n    if (!angle) {\n        return b;\n    }\n    center = center || boxCenter(b);\n    return boxFrom4Points.apply(null, rotateBox(b, angle, center));\n}\nexports.rotatedBoundingBox = rotatedBoundingBox;\nfunction rotateBox(b, angle, center) {\n    const ret = toCornersAsArray(b);\n    center = center || boxCenter(b);\n    if (angle != 0) {\n        return ret.map(rotateAroundFn(center, angle));\n    }\n    return ret;\n}\nexports.rotateBox = rotateBox;\nfunction boxFrom4Points(a, b, c, d) {\n    const xMin = Math.min(a.x, b.x, c.x, d.x);\n    const xMax = Math.max(a.x, b.x, c.x, d.x);\n    const yMin = Math.min(a.y, b.y, c.y, d.y);\n    const yMax = Math.max(a.y, b.y, c.y, d.y);\n    return { x: xMin, y: yMin, w: xMax - xMin, h: yMax - yMin };\n}\nexports.boxFrom4Points = boxFrom4Points;\nfunction toCornersAsArray(box) {\n    return [\n        { x: box.x, y: box.y },\n        { x: box.x + box.w, y: box.y },\n        { x: box.x + box.w, y: box.y + box.h },\n        { x: box.x, y: box.y + box.h },\n    ];\n}\nexports.toCornersAsArray = toCornersAsArray;\nfunction rotateAroundFn(anchor, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    return (p) => {\n        const anchorX = anchor.x;\n        const anchorY = anchor.y;\n        const x = p.x - anchorX;\n        const y = p.y - anchorY;\n        return { x: x * cos - y * sin + anchorX, y: y * cos + x * sin + anchorY };\n    };\n}\nexports.rotateAroundFn = rotateAroundFn;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/math.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/message/unfurleventmessage.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/message/unfurleventmessage.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeUnfurlEventMessage = exports.deserializeUnfurlEventMessage = void 0;\n/** @ignore */\nfunction deserializeUnfurlEventMessage(raw) {\n    return {\n        id: raw['id'],\n        url: raw['u'],\n        unfurlCallbackType: raw['t'],\n        blockId: raw['b'],\n    };\n}\nexports.deserializeUnfurlEventMessage = deserializeUnfurlEventMessage;\n/** @ignore */\nfunction serializeUnfurlEventMessage(concrete) {\n    return {\n        'id': concrete.id,\n        'u': concrete.url,\n        't': concrete.unfurlCallbackType,\n        'b': concrete.blockId,\n    };\n}\nexports.serializeUnfurlEventMessage = serializeUnfurlEventMessage;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/message/unfurleventmessage.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/ui/alertmodal.js":
/*!***************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/ui/alertmodal.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlertModal = void 0;\nconst modal_1 = __webpack_require__(/*! ./modal */ \"../../node_modules/lucid-extension-sdk/ui/modal.js\");\n/**\n * A simple example modal that displays a message to the user\n * TODO: Replace with a dedicated command\n * @ignore\n */\nclass AlertModal extends modal_1.Modal {\n    constructor(client, title, message) {\n        super(client, {\n            width: 300,\n            height: 200,\n            title: title,\n            content: `\n<html>\n<head>\n<style type=\"text/css\">\np {\n    font-family: 'Graphik LC Web', sans-serif;\n    font-size:14px;\n    text-align:center;\n}\n</style>\n</head>\n<body>\n<p id=\"message\"></p>\n<script type=\"text/javascript\">\n    var p = document.getElementById('message');\n    p.innerText = ${JSON.stringify(message)};\n</script>\n</body>\n</html>\n            `,\n        });\n    }\n}\nexports.AlertModal = AlertModal;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/ui/alertmodal.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/ui/iframeui.js":
/*!*************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/ui/iframeui.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IframeUI = exports.IncomingUIMessageType = void 0;\nconst defer_1 = __webpack_require__(/*! ../core/defer */ \"../../node_modules/lucid-extension-sdk/core/defer.js\");\n/** @ignore */\nvar IncomingUIMessageType;\n(function (IncomingUIMessageType) {\n    IncomingUIMessageType[IncomingUIMessageType[\"Closed\"] = 1] = \"Closed\";\n    IncomingUIMessageType[IncomingUIMessageType[\"PostMessageFromFrame\"] = 2] = \"PostMessageFromFrame\";\n    IncomingUIMessageType[IncomingUIMessageType[\"FrameLoaded\"] = 3] = \"FrameLoaded\";\n    IncomingUIMessageType[IncomingUIMessageType[\"FramePosition\"] = 4] = \"FramePosition\";\n})(IncomingUIMessageType || (exports.IncomingUIMessageType = IncomingUIMessageType = {}));\n/**\n * Base class for defining and interacting with custom UI elements whose contents are displayed\n * in an iframe.\n */\nclass IframeUI {\n    constructor(client) {\n        this.client = client;\n        this.id = ++IframeUI.nextId;\n        this.messageActionName = IframeUI.uiMessageActionNamePrefix + this.id;\n        /** True after the iframe has fired an onload event (not all scripts are necessarily finished executing) */\n        this.loaded = false;\n        this.frameLoadedPromise = (0, defer_1.defer)();\n        /**\n         * The location of this frame within the top-level browser window. This is always updated immediately before\n         * `messageFromFrame` is called.\n         */\n        this.framePosition = { x: 0, y: 0, w: 1, h: 1 };\n    }\n    /** @ignore */\n    static isUIMessageActionName(name) {\n        return name.startsWith(IframeUI.uiMessageActionNamePrefix);\n    }\n    /**\n     * Subclasses must call hookMessages some time before the UI is displayed. A Modal\n     * will call this when the open() method is called, where a Panel will need to do\n     * this in the constructor to watch for the user opening the panel.\n     */\n    hookMessages() {\n        this.client.registerAction(this.messageActionName, (message) => {\n            switch (message['t']) {\n                case IncomingUIMessageType.Closed:\n                    this.loaded = false;\n                    this.frameClosed();\n                    break;\n                case IncomingUIMessageType.PostMessageFromFrame:\n                    this.messageFromFrame(message['data']);\n                    break;\n                case IncomingUIMessageType.FramePosition:\n                    this.framePosition = message['data'];\n                    break;\n                case IncomingUIMessageType.FrameLoaded:\n                    this.loaded = true;\n                    this.frameLoadedPromise.resolve();\n                    this.frameLoaded();\n                    break;\n            }\n        });\n    }\n    /**\n     * Subclasses must call unhookMessages to allow them to be garbage collected.\n     */\n    unhookMessages() {\n        this.client.deleteAction(this.messageActionName);\n    }\n    /**\n     * Send a message to this UI component's iframe via window.postMessage.\n     * @param data Data to send to the iframe\n     */\n    async sendMessage(data) {\n        await this.frameLoadedPromise;\n        this.client.sendCommand(\"suim\" /* CommandName.SendUIMessage */, {\n            'n': this.messageActionName,\n            'd': data,\n        });\n    }\n    /**\n     * Receives messages sent from the iframe via parent.postMessage(<data>, '*')\n     * @param message data sent from the iframe\n     */\n    messageFromFrame(message) { }\n    /**\n     * Called when the iframe has been constructed, its srcdoc set, and the window loaded event has fired\n     */\n    frameLoaded() { }\n    /**\n     * Called when the iframe has been removed from the DOM\n     */\n    frameClosed() { }\n}\nexports.IframeUI = IframeUI;\nIframeUI.nextId = 0;\nIframeUI.uiMessageActionNamePrefix = '__ui_message__';\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/ui/iframeui.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/ui/menu.js":
/*!*********************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/ui/menu.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Menu = exports.MenuLocation = exports.MenuType = void 0;\n/**\n * Type of menu you're adding.\n * Consider using addDropdownMenuItem, addContextMenuItem, or addContentDockMenuItem for easier to use entrypoints and clearer requirements.\n */\nvar MenuType;\n(function (MenuType) {\n    /** The main drop down menus. */\n    MenuType[MenuType[\"Main\"] = 1] = \"Main\";\n    /** The context menu that appears when the user right-clicks the canvas. */\n    MenuType[MenuType[\"Context\"] = 2] = \"Context\";\n    /** The side dock in Lucidspark and Teamspaces */\n    MenuType[MenuType[\"ContentDock\"] = 3] = \"ContentDock\";\n})(MenuType || (exports.MenuType = MenuType = {}));\n/**\n * Semantic locations to place a new menu item.\n */\nvar MenuLocation;\n(function (MenuLocation) {\n    /** Default location: a new top-level menu entry for this extension, or the end of the context menu */\n    MenuLocation[MenuLocation[\"Extension\"] = 1] = \"Extension\";\n    MenuLocation[MenuLocation[\"Edit\"] = 2] = \"Edit\";\n    MenuLocation[MenuLocation[\"View\"] = 3] = \"View\";\n    MenuLocation[MenuLocation[\"Share\"] = 4] = \"Share\";\n    MenuLocation[MenuLocation[\"Export\"] = 5] = \"Export\";\n    MenuLocation[MenuLocation[\"Import\"] = 6] = \"Import\";\n})(MenuLocation || (exports.MenuLocation = MenuLocation = {}));\nclass Menu {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Generic function to create a new menu item to trigger custom code.\n     * You can use addDropdownMenuItem, addContextMenuItem, or addContentDockMenuItem for easier to use entrypoints.\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addMenuItem(item) {\n        if (item.action && !this.client.actionExists(item.action)) {\n            throw new Error('Unregistered action: ' + item.action);\n        }\n        if (item.visibleAction && !this.client.actionExists(item.visibleAction)) {\n            throw new Error('Unregistered action: ' + item.visibleAction);\n        }\n        if (item.disabledAction && !this.client.actionExists(item.disabledAction)) {\n            throw new Error('Unregistered action: ' + item.disabledAction);\n        }\n        if (item.menuType == MenuType.ContentDock && !item.iconUrl) {\n            throw new Error('MenuType.ContentDock requires icon url');\n        }\n        if (item.menuType == MenuType.ContentDock && !item.action) {\n            throw new Error('MenuType.ContentDock requires action');\n        }\n        this.client.sendCommand(\"ami\" /* CommandName.AddMenuItem */, {\n            'l': item.label,\n            'i': item.iconUrl,\n            'a': item.action,\n            'v': item.visibleAction,\n            'd': item.disabledAction,\n            't': item.menuType,\n            'loc': item.location,\n            'f': item.file\n                ? {\n                    'a': item.file.action,\n                    'ac': item.file.accept,\n                    's': item.file.singleFileOnly,\n                    'b': item.file.binary,\n                }\n                : undefined,\n        });\n    }\n    /**\n     * Create a menu in the basic drop down top menus. In Lucidspark this will just be under the generic menu.\n     * In Lucidchart you can configure this to be in any of the other drop down menus.\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addDropdownMenuItem(item) {\n        var _a;\n        this.addMenuItem({\n            label: item.label,\n            action: item.action,\n            visibleAction: item.visibleAction,\n            disabledAction: item.disabledAction,\n            menuType: MenuType.Main,\n            location: (_a = item.location) !== null && _a !== void 0 ? _a : MenuLocation.Extension,\n            file: item.file,\n        });\n    }\n    /**\n     * Create a menu in the right click context menu. Appears in both Lucidspark and Lucidchart.\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addContextMenuItem(item) {\n        this.addMenuItem({\n            label: item.label,\n            action: item.action,\n            visibleAction: item.visibleAction,\n            disabledAction: item.disabledAction,\n            menuType: MenuType.Context,\n            location: MenuLocation.Extension,\n            file: item.file,\n        });\n    }\n    /**\n     * Create an icon tied to an action (required) that appears in the left toolbar in Lucidspark and Teamspaces (not in Lucidchart).\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addContentDockMenuItem(item) {\n        this.addMenuItem({\n            label: item.label,\n            iconUrl: item.iconUrl,\n            action: item.action,\n            visibleAction: item.visibleAction,\n            disabledAction: item.disabledAction,\n            menuType: MenuType.ContentDock,\n            location: MenuLocation.Extension,\n            file: item.file,\n        });\n    }\n}\nexports.Menu = Menu;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/ui/menu.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/ui/modal.js":
/*!**********************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/ui/modal.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Modal = void 0;\nconst iframeui_1 = __webpack_require__(/*! ./iframeui */ \"../../node_modules/lucid-extension-sdk/ui/iframeui.js\");\n/**\n * Extend this class to show a custom modal to the user, whose contents are displayed in a sandboxed\n * iframe controlled by your extension.\n *\n * To pass a message to a script running in the modal, call sendMessage. The data you pass in will be\n * sent to the iframe with window.postMessage.\n *\n * To pass messages back from the modal to this class, call parent.postMessage from within the iframe.\n * The data sent will be passed along to the messageFromFrame implementation on your Modal class.\n */\nclass Modal extends iframeui_1.IframeUI {\n    constructor(client, config) {\n        super(client);\n        this.config = config;\n        this.visible = false;\n    }\n    frameClosed() {\n        this.visible = false;\n        this.unhookMessages();\n    }\n    async show() {\n        if (!this.visible) {\n            this.hookMessages();\n            await this.client.sendCommand(\"sm\" /* CommandName.ShowModal */, {\n                'n': this.messageActionName,\n                't': this.config.title,\n                'w': this.config.width,\n                'h': this.config.height,\n                'cl': this.config.chromeless,\n                'fs': this.config.fullScreen,\n                'tb': this.config.transparentBackground,\n                'c': this.config.content,\n                'u': this.config.url,\n            });\n            this.visible = true;\n        }\n    }\n    /**\n     * If this modal is currently visible, close it, destroying the iframe.\n     */\n    hide() {\n        if (this.visible) {\n            this.client.sendCommand(\"hm\" /* CommandName.HideModal */, { 'n': this.messageActionName });\n            this.visible = false;\n        }\n    }\n}\nexports.Modal = Modal;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/ui/modal.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/ui/panel.js":
/*!**********************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/ui/panel.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Panel = exports.PanelLocation = void 0;\nconst iframeui_1 = __webpack_require__(/*! ./iframeui */ \"../../node_modules/lucid-extension-sdk/ui/iframeui.js\");\n/**\n * Semantic locations to place a new menu item.\n */\nvar PanelLocation;\n(function (PanelLocation) {\n    /** In Lucidchart, create a sibling to the Contextual Panel */\n    PanelLocation[PanelLocation[\"RightDock\"] = 1] = \"RightDock\";\n    /** In Lucidchart, create a sibling to the shape toolbox */\n    PanelLocation[PanelLocation[\"ContentDock\"] = 2] = \"ContentDock\";\n    /** In Lucidchart & Lucidspark, add to the image dock */\n    PanelLocation[PanelLocation[\"ImageSearchTab\"] = 3] = \"ImageSearchTab\";\n})(PanelLocation || (exports.PanelLocation = PanelLocation = {}));\n/**\n * Extend this class to show a custom panel to the user, whose contents are displayed in a sandboxed\n * iframe controlled by your extension.\n *\n * To pass a message to a script running in the panel, call sendMessage. The data you pass in will be\n * sent to the iframe with window.postMessage.\n *\n * To pass messages back from the panel to this class, call parent.postMessage from within the iframe.\n * The data sent will be passed along to the messageFromFrame implementation on your Panel class.\n */\nclass Panel extends iframeui_1.IframeUI {\n    constructor(client, config) {\n        super(client);\n        this.config = config;\n        this.hookMessages();\n        this.client.sendCommand(\"rp\" /* CommandName.RegisterPanel */, {\n            'n': this.messageActionName,\n            't': this.config.title,\n            'l': this.config.location,\n            'c': this.config.content,\n            'u': this.config.url,\n            'v': this.config.visibleAction,\n            'i': this.config.iconUrl,\n            'to': this.config.toolTip,\n            'p': this.config.persist,\n            'w': this.config.width,\n            'h': this.config.height,\n        });\n    }\n    /**\n     * Show this panel if the panel is in the rightDock and it is not already visible.\n     */\n    show() {\n        if (this.config.location == PanelLocation.RightDock) {\n            this.client.sendCommand(\"spn\" /* CommandName.ShowPanel */, { 'n': this.messageActionName });\n        }\n    }\n    /**\n     * Hide this panel if the panel is in the rightDock and it is currently visible.\n     */\n    hide() {\n        if (this.config.location == PanelLocation.RightDock) {\n            this.client.sendCommand(\"hp\" /* CommandName.HidePanel */, { 'n': this.messageActionName });\n        }\n    }\n}\nexports.Panel = Panel;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/ui/panel.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/ui/viewport.js":
/*!*************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/ui/viewport.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Viewport = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"../../node_modules/lucid-extension-sdk/core/checks.js\");\nconst fillcolor_1 = __webpack_require__(/*! ../core/properties/fillcolor */ \"../../node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst imagedefinition_1 = __webpack_require__(/*! ../document/imagedefinition */ \"../../node_modules/lucid-extension-sdk/document/imagedefinition.js\");\nconst itemproxy_1 = __webpack_require__(/*! ../document/itemproxy */ \"../../node_modules/lucid-extension-sdk/document/itemproxy.js\");\nconst pageproxy_1 = __webpack_require__(/*! ../document/pageproxy */ \"../../node_modules/lucid-extension-sdk/document/pageproxy.js\");\nconst math_1 = __webpack_require__(/*! ../math */ \"../../node_modules/lucid-extension-sdk/math.js\");\nclass Viewport {\n    constructor(client) {\n        this.client = client;\n    }\n    static nextHookName() {\n        return '__viewport__hook' + Viewport.nextHookId++;\n    }\n    /**\n     * @param deep If true, and groups are selected, include the contents of those groups in the array\n     * @returns An array of currently-selected items on the currently-visible page\n     */\n    getSelectedItems(deep) {\n        const ids = this.client.sendCommand(\"gs\" /* CommandName.GetSelection */, { 'd': deep });\n        return ids\n            .map((id) => this.client.getElementProxy(id))\n            .filter((proxy) => proxy instanceof itemproxy_1.ItemProxy);\n    }\n    /**\n     * Unselect all currently-selected items, and select the subset of the given items that exist on\n     * the currently-visible page.\n     * @param items\n     */\n    setSelectedItems(items) {\n        this.client.sendCommand(\"ss\" /* CommandName.SetSelection */, { 'i': items.map((i) => i.id) });\n    }\n    /**\n     * Find available space on the current page for adding new content.\n     * @param width\n     * @param height\n     * @returns a reference to the page and origin (upper-left point) of the space you can add new\n     * content of the given size to.\n     */\n    findAvailableSpace(width, height) {\n        const result = this.client.sendCommand(\"fas\" /* CommandName.FindAvailableSpace */, { 'w': width, 'h': height });\n        return {\n            page: new pageproxy_1.PageProxy(result['p'], this.client),\n            x: result['x'],\n            y: result['y'],\n        };\n    }\n    /**\n     * @returns the page currently being viewed\n     */\n    getCurrentPage() {\n        const id = this.client.sendCommand(\"gcp\" /* CommandName.GetCurrentPage */, undefined);\n        return id == null ? id : new pageproxy_1.PageProxy(id, this.client);\n    }\n    /**\n     * View the given page in the viewport\n     * @param page The page to view\n     */\n    setCurrentPage(page) {\n        this.client.sendCommand(\"scp\" /* CommandName.SetCurrentPage */, page.id);\n    }\n    /**\n     * @returns the box for the current viewport location\n     */\n    getVisibleRect() {\n        return this.client.sendCommand(\"gvr\" /* CommandName.GetVisibleRect */, undefined);\n    }\n    /**\n     * Switch to the page containing these items, if necessary, and then animate the viewport\n     * to zoom in and focus on these items.\n     * @param items The items the camera should zoom to\n     */\n    focusCameraOnItems(items) {\n        const bb = (0, math_1.combinedBoundingBox)(items.map((e) => e.getBoundingBox()));\n        if (bb && items[0]) {\n            //TODO: A reasonable max zoom level (e.g. 200%)\n            this.client.sendCommand(\"av\" /* CommandName.AnimateViewport */, {\n                'bb': (0, math_1.padBox)(bb, 80),\n                'p': items[0].getPage().id,\n            });\n        }\n    }\n    /**\n     * If {@link callback} returns false, text editing is prevented.\n     * If {@link callback} returns true, text editing continues as normal.\n     *\n     * If {@link callback} returns a {@link TextEditCompletionCallback}(/extension-sdk/#modules_ui_viewport_texteditcompletioncallback),\n     * then text editing is allowed, but that completion callback is called.\n     *\n     * when the user finishes editing that text. That completion callback may return true or false to allow or deny the edit, or\n     * also may return a replacement string to use instead of the text the user actually typed. If replacement text is provided,\n     * it will be styled as close to the original as possible, but styles that apply to only parts of the original text will be\n     * discarded.\n     *\n     * @param callback Called just before the user starts editing text.\n     * @param eager Whether to trigger the callback eagerly during text edit\n     *\n     * @returns A handle representing this hook, which can be passed to unhookTextEdit to remove this hook.\n     */\n    hookTextEdit(callback, eager) {\n        const actionName = Viewport.nextHookName();\n        this.client.registerAction(actionName, async (textHookParam) => {\n            const element = this.client.getElementProxy(textHookParam['i']);\n            if (element instanceof itemproxy_1.ItemProxy) {\n                const result = await callback(element, textHookParam['t'], textHookParam['v']);\n                if ((0, checks_1.isBoolean)(result)) {\n                    return result;\n                }\n                else {\n                    const completeName = Viewport.nextHookName();\n                    this.client.registerAction(completeName, (textCompleteParam) => {\n                        this.client.deleteAction(completeName);\n                        return result(textCompleteParam['v']);\n                    });\n                    return completeName;\n                }\n            }\n            else {\n                //Shouldn't be possible, but just in case allow text editing as normal\n                return true;\n            }\n        });\n        this.client.sendCommand(\"hte\" /* CommandName.HookTextEdit */, { 'n': actionName, 'e': !!eager });\n        return actionName;\n    }\n    /**\n     * Remove a hook set by hookTextEdit.\n     *\n     * @param handle The return value of hookTextEdit.\n     */\n    unhookTextEdit(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"ute\" /* CommandName.UnhookTextEdit */, { 'n': handle });\n    }\n    /**\n     * @param callback Called when the user changes their selection of items\n     *\n     * @returns A handle representing this hook, which can be passed to unhookSelection to remove this hook.\n     */\n    hookSelection(callback) {\n        const actionName = Viewport.nextHookName();\n        this.client.registerAction(actionName, async (param) => {\n            const elements = param['ids']\n                .map((id) => this.client.getElementProxy(id))\n                .filter((element) => element instanceof itemproxy_1.ItemProxy);\n            callback(elements);\n        });\n        this.client.sendCommand(\"hs\" /* CommandName.HookSelection */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * Remove a hook set by hookSelection.\n     *\n     * @param handle The return value of hookSelection.\n     */\n    unhookSelection(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"us\" /* CommandName.UnhookSelection */, { 'n': handle });\n    }\n    /**\n     * Start an interaction of the current user dragging a new block onto the current page, exactly\n     * as if they started dragging that block out of the normal toolbox. At the time this function is\n     * called, the user's primary mouse button should be down (e.g. in a mousedown event handler).\n     *\n     * @param definition Definition of the block to create if and where the user drops it on-canvas\n     * @returns A promise resolving to a reference to the created block, if successfully dropped,\n     *  or undefined if the user cancels the drag interaction.\n     */\n    async startDraggingNewBlock(definition) {\n        var _a;\n        const properties = (_a = definition.properties) !== null && _a !== void 0 ? _a : {};\n        if (definition.fillStyle !== undefined) {\n            properties['FillColor'] = (0, fillcolor_1.serializeSimpleFill)(definition.fillStyle);\n        }\n        if (definition.lineWidth !== undefined) {\n            properties['LineWidth'] = definition.lineWidth;\n        }\n        const maybeBlockId = await this.client.sendCommand(\"sdc\" /* CommandName.StartDragBlockToCanvas */, {\n            'c': definition.className,\n            'sz': {\n                'w': definition.boundingBox.w,\n                'h': definition.boundingBox.h,\n            },\n            'p': properties,\n            's': definition.stencil,\n        });\n        return maybeBlockId ? this.client.getBlockProxy(maybeBlockId) : undefined;\n    }\n    /**\n     * Start an interaction of the current user dragging a new image onto the current page, exactly\n     * as if they started dragging that image out of the normal toolbox. At the time this function is\n     * called, the user's primary mouse button should be down (e.g. in a mousedown event handler).\n     *\n     * @param definition Definition of the image to create if and where the user drops it on-canvas\n     * @returns A promise resolving to a reference to the created image, if successfully dropped,\n     *  or undefined if the user cancels the drag interaction.\n     */\n    async startDraggingNewImage(definition) {\n        await this.client.loadBlockClasses(['UserImage2Block']);\n        return await this.startDraggingNewBlock((0, imagedefinition_1.imageToBlockDefinition)(definition));\n    }\n    /**\n     * If startDraggingNewBlock has been called, and the drag-new-block interaction is still active,\n     * cancel that interaction.\n     */\n    cancelDraggingNewBlock() {\n        this.client.sendCommand(\"cdc\" /* CommandName.CancelDragBlockToCanvas */, undefined);\n    }\n    /**\n     * If startDraggingNewImage has been called, and the drag-new-image interaction is still active,\n     * cancel that interaction.\n     */\n    cancelDraggingNewImage() {\n        this.cancelDraggingNewBlock();\n    }\n    /**\n     * After calling startDraggingNewBlock, call this to simulate the user moving the mouse at the\n     * given location within the top-level browser window.\n     *\n     * This has no effect if the drag-new-block interaction is not active.\n     *\n     * To convert a position in a Panel's iframe to a position in the top-level browser window,\n     * add the IframeUI.framePosition.\n     */\n    dragPointerMove(x, y) {\n        this.client.sendCommand(\"dpm\" /* CommandName.DragPointerMove */, { x, y });\n    }\n    /**\n     * After calling startDraggingNewBlock, call this to simulate the user releasing the mouse\n     * button at the given location within the top-level browser window.\n     *\n     * This has no effect if the drag-new-block interaction is not active.\n     *\n     * To convert a position in a Panel's iframe to a position in the top-level browser window,\n     * add the IframeUI.framePosition.\n     */\n    dragPointerUp(x, y) {\n        this.client.sendCommand(\"dpu\" /* CommandName.DragPointerUp */, { x, y });\n    }\n}\nexports.Viewport = Viewport;\nViewport.nextHookId = 0;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/ui/viewport.js?");

/***/ }),

/***/ "../../node_modules/lucid-extension-sdk/user/userproxy.js":
/*!****************************************************************!*\
  !*** ../../node_modules/lucid-extension-sdk/user/userproxy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UserProxy = void 0;\n/**\n * The UserProxy class gives access to the current user on the current Lucid document.\n */\nclass UserProxy {\n    constructor(client) {\n        this.client = client;\n        this.id = this.client.sendCommand(\"guid\" /* CommandName.GetUserId */, undefined);\n    }\n    /**\n     * @returns the permission the user has on the current document.\n     */\n    getAccessPermssionOnDocument() {\n        return this.client.sendCommand(\"gdap\" /* CommandName.GetDocumentAccessPermission */, undefined);\n    }\n}\nexports.UserProxy = UserProxy;\n\n\n//# sourceURL=webpack:///../../node_modules/lucid-extension-sdk/user/userproxy.js?");

/***/ }),

/***/ "./src/core/ModelDefinitionPageBuilder.ts":
/*!************************************************!*\
  !*** ./src/core/ModelDefinitionPageBuilder.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelDefinitionPageBuilder = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nclass ModelDefinitionPageBuilder {\n    constructor(storageAdapter) {\n        this.storageAdapter = storageAdapter;\n        this.loggingEnabled = false;\n    }\n    /**\n     * Method to toggle logging\n     */\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    /**\n     * Checks if logging is enabled\n     */\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    /**\n     * Logs a message if logging is enabled\n     */\n    log(message, level = 'log') {\n        if (this.isLoggingEnabled()) {\n            console[level](`[${this.constructor.name}] ${message}`);\n        }\n    }\n    /**\n     * Builds a ModelDefinition from an existing converted page\n     */\n    buildFromConvertedPage(page) {\n        try {\n            this.log(`Starting model definition build for page ${page.id}`);\n            this.log(`Page title: ${page.getTitle()}`);\n            // Get the model data from the page\n            const modelData = this.storageAdapter.getElementData(page);\n            if (!modelData) {\n                this.log('No model data found on page', 'error');\n                return null;\n            }\n            this.log(`Found model data with ID: ${modelData.id}`);\n            // Create initial ModelDefinition\n            const modelDefinition = new shared_1.ModelDefinition(modelData);\n            // Verify the critical functions exist\n            if (!modelDefinition.activities || typeof modelDefinition.activities.add !== 'function') {\n                this.log('ModelDefinition activities not properly initialized', 'error');\n                return null;\n            }\n            if (!modelDefinition.connectors || typeof modelDefinition.connectors.add !== 'function') {\n                this.log('ModelDefinition connectors not properly initialized', 'error');\n                return null;\n            }\n            if (!modelDefinition.resources || typeof modelDefinition.resources.add !== 'function') {\n                this.log('ModelDefinition resources not properly initialized', 'error');\n                return null;\n            }\n            if (!modelDefinition.generators || typeof modelDefinition.generators.add !== 'function') {\n                this.log('ModelDefinition generators not properly initialized', 'error');\n                return null;\n            }\n            if (!modelDefinition.entities || typeof modelDefinition.entities.add !== 'function') {\n                this.log('ModelDefinition entities not properly initialized', 'error');\n                return null;\n            }\n            // Process all blocks (shapes)\n            this.log(`Processing ${page.allBlocks.size} blocks`);\n            for (const [blockId, block] of page.allBlocks) {\n                this.log(`Processing block ${blockId}`);\n                const elementData = this.storageAdapter.getElementData(block);\n                const metadata = this.storageAdapter.getMetadata(block);\n                if (!elementData || !metadata) {\n                    this.log(`Missing data or metadata for block ${blockId}`, 'warn');\n                    continue;\n                }\n                try {\n                    this.log(`Block ${blockId} type: ${metadata.type}`);\n                    switch (metadata.type) {\n                        case shared_1.SimulationObjectType.Activity:\n                            modelDefinition.activities.add(elementData);\n                            this.log(`Added activity ${blockId}`);\n                            break;\n                        case shared_1.SimulationObjectType.Generator:\n                            modelDefinition.generators.add(elementData);\n                            this.log(`Added generator ${blockId}`);\n                            break;\n                        case shared_1.SimulationObjectType.Resource:\n                            modelDefinition.resources.add(elementData);\n                            this.log(`Added resource ${blockId}`);\n                            break;\n                        case shared_1.SimulationObjectType.Entity:\n                            modelDefinition.entities.add(elementData);\n                            this.log(`Added entity ${blockId}`);\n                            break;\n                        default:\n                            this.log(`Unknown type ${metadata.type} for block ${blockId}`, 'warn');\n                    }\n                }\n                catch (error) {\n                    this.log(`Error adding ${metadata.type} ${blockId}: ${error instanceof Error ? error.message : 'Unknown error'}`, 'error');\n                }\n            }\n            // Process all lines (connectors)\n            this.log(`Processing ${page.allLines.size} lines`);\n            for (const [lineId, line] of page.allLines) {\n                this.log(`Processing line ${lineId}`);\n                const connectorData = this.storageAdapter.getElementData(line);\n                const metadata = this.storageAdapter.getMetadata(line);\n                if (!connectorData || !metadata) {\n                    this.log(`Missing data or metadata for line ${lineId}`, 'warn');\n                    continue;\n                }\n                if (metadata.type === shared_1.SimulationObjectType.Connector) {\n                    try {\n                        modelDefinition.connectors.add(connectorData);\n                        this.log(`Added connector ${lineId} from ${connectorData.sourceId} to ${connectorData.targetId}`);\n                    }\n                    catch (error) {\n                        this.log(`Error adding connector ${lineId}: ${error instanceof Error ? error.message : 'Unknown error'}`, 'error');\n                    }\n                }\n                else {\n                    this.log(`Unexpected type ${metadata.type} for line ${lineId}`, 'warn');\n                }\n            }\n            // Log summary\n            this.logModelDefinitionSummary(modelDefinition);\n            return modelDefinition;\n        }\n        catch (error) {\n            this.log(`Error building ModelDefinition: ${error instanceof Error ? error.message : 'Unknown error'}`, 'error');\n            return null;\n        }\n    }\n    /**\n     * Logs a summary of the ModelDefinition contents\n     */\n    logModelDefinitionSummary(modelDefinition) {\n        if (!this.isLoggingEnabled())\n            return;\n        this.log('Model Definition Summary:');\n        this.log(`- Model ID: ${modelDefinition.id}`);\n        this.log(`- Model Name: ${modelDefinition.name}`);\n        this.log(`- Activities: ${modelDefinition.activities.size()}`);\n        this.log(`- Generators: ${modelDefinition.generators.size()}`);\n        this.log(`- Resources: ${modelDefinition.resources.size()}`);\n        this.log(`- Entities: ${modelDefinition.entities.size()}`);\n        this.log(`- Connectors: ${modelDefinition.connectors.size()}`);\n    }\n}\nexports.ModelDefinitionPageBuilder = ModelDefinitionPageBuilder;\n\n\n//# sourceURL=webpack:///./src/core/ModelDefinitionPageBuilder.ts?");

/***/ }),

/***/ "./src/core/ModelManager.ts":
/*!**********************************!*\
  !*** ./src/core/ModelManager.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelManager = void 0;\nconst ModelValidationService_1 = __webpack_require__(/*! ../services/validation/ModelValidationService */ \"./src/services/validation/ModelValidationService.ts\");\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"../../node_modules/lucid-extension-sdk/index.js\");\nconst ModelDefinitionPageBuilder_1 = __webpack_require__(/*! ./ModelDefinitionPageBuilder */ \"./src/core/ModelDefinitionPageBuilder.ts\");\nconst RemoveModelFromPage_1 = __webpack_require__(/*! ../services/conversion/RemoveModelFromPage */ \"./src/services/conversion/RemoveModelFromPage.ts\");\nconst ModelStructureBuilder_1 = __webpack_require__(/*! ../services/accordion/ModelStructureBuilder */ \"./src/services/accordion/ModelStructureBuilder.ts\");\nclass ModelManager {\n    constructor(storageAdapter) {\n        this.loggingEnabled = false;\n        this.modelDefinition = null;\n        this.currentPage = null;\n        this.currentValidationResult = null;\n        // Change tracking\n        this.changeTracker = {\n            modelDefinitionDirty: false,\n            validationDirty: false,\n            lastModelDefinitionUpdate: 0,\n            lastValidationUpdate: 0,\n            pendingChanges: new Set()\n        };\n        this.storageAdapter = storageAdapter;\n        this.validationService = new ModelValidationService_1.ModelValidationService();\n        this.log('ModelManager initialized');\n    }\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    log(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.log(`${ModelManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    logError(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.error(`${ModelManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    /**\n     * Marks the model as needing rebuild and validation\n     */\n    markModelDirty(elementId) {\n        this.changeTracker.modelDefinitionDirty = true;\n        this.changeTracker.validationDirty = true;\n        if (elementId) {\n            this.changeTracker.pendingChanges.add(elementId);\n        }\n    }\n    /**\n     * Checks if caches are still valid based on timeouts\n     */\n    checkCacheTimeouts() {\n        const now = Date.now();\n        // Check ModelDefinition cache timeout\n        if (now - this.changeTracker.lastModelDefinitionUpdate > ModelManager.MODEL_DEF_CACHE_TIMEOUT) {\n            this.changeTracker.modelDefinitionDirty = true;\n        }\n        // Check validation cache timeout\n        if (now - this.changeTracker.lastValidationUpdate > ModelManager.VALIDATION_CACHE_TIMEOUT) {\n            this.changeTracker.validationDirty = true;\n        }\n    }\n    /**\n     * Gets the current ModelDefinition, rebuilding if necessary\n     */\n    async ensureModelDefinition() {\n        this.checkCacheTimeouts();\n        if (this.changeTracker.modelDefinitionDirty && this.currentPage) {\n            this.log('Rebuilding ModelDefinition due to pending changes:', Array.from(this.changeTracker.pendingChanges));\n            const builder = new ModelDefinitionPageBuilder_1.ModelDefinitionPageBuilder(this.storageAdapter);\n            try {\n                const newModelDefinition = builder.buildFromConvertedPage(this.currentPage);\n                if (!newModelDefinition) {\n                    throw new Error('Builder returned null ModelDefinition');\n                }\n                if (!(newModelDefinition instanceof shared_1.ModelDefinition)) {\n                    throw new Error(`Invalid ModelDefinition type: ${typeof newModelDefinition}`);\n                }\n                // Verify activities manager\n                if (!newModelDefinition.activities) {\n                    throw new Error('activities property is undefined');\n                }\n                if (!(newModelDefinition.activities instanceof shared_1.ActivityListManager)) {\n                    throw new Error(`activities is not an ActivityListManager: ${typeof newModelDefinition.activities}`);\n                }\n                if (typeof newModelDefinition.activities.add !== 'function') {\n                    throw new Error(`activities.add is not a function: ${typeof newModelDefinition.activities.add}`);\n                }\n                // ModelDefinitionLogger.logModelDefinition(newModelDefinition)\n                this.modelDefinition = newModelDefinition;\n                this.changeTracker.modelDefinitionDirty = false;\n                this.changeTracker.lastModelDefinitionUpdate = Date.now();\n                this.changeTracker.pendingChanges.clear();\n                return this.modelDefinition;\n            }\n            catch (error) {\n                this.logError('Error ensuring ModelDefinition:', error);\n                throw error;\n            }\n        }\n        return this.modelDefinition;\n    }\n    /**\n     * Initializes a new model definition with data from storage\n     */\n    async initializeModel(modelData, pageProxy) {\n        this.currentPage = pageProxy;\n        // Force a rebuild for initialization\n        this.markModelDirty();\n        await this.ensureModelDefinition();\n        // Store the model data\n        this.storageAdapter.setElementData(pageProxy, modelData, shared_1.SimulationObjectType.Model);\n        await this.validateModel();\n    }\n    /**\n     * Registers a simulation element\n     */\n    async registerElement(element, elementProxy) {\n        if (element.type === shared_1.SimulationObjectType.Model) {\n            this.modelDefinition = new shared_1.ModelDefinition(element);\n            this.markModelDirty();\n            return;\n        }\n        const modelDef = await this.ensureModelDefinition();\n        if (!modelDef) {\n            throw new Error('Model not initialized');\n        }\n        // Register with appropriate list manager\n        switch (element.type) {\n            case shared_1.SimulationObjectType.Activity:\n                modelDef.activities.add(element);\n                break;\n            case shared_1.SimulationObjectType.Connector:\n                modelDef.connectors.add(element);\n                break;\n            case shared_1.SimulationObjectType.Generator:\n                modelDef.generators.add(element);\n                break;\n            case shared_1.SimulationObjectType.Resource:\n                modelDef.resources.add(element);\n                break;\n            case shared_1.SimulationObjectType.Entity:\n                modelDef.entities.add(element);\n                break;\n            default:\n                throw new Error(`Unknown element type: ${element.type}`);\n        }\n        this.markModelDirty(element.id);\n        await this.validateModelIfNeeded();\n    }\n    /**\n     * Updates an existing element\n     */\n    async updateElement(element) {\n        const modelDef = await this.ensureModelDefinition();\n        if (!modelDef || !this.currentPage) {\n            throw new Error('Model not initialized');\n        }\n        const elementProxy = this.findElementProxy(element.id);\n        if (!elementProxy) {\n            throw new Error(`No element found for ID: ${element.id}`);\n        }\n        // Update in appropriate list manager\n        switch (element.type) {\n            case shared_1.SimulationObjectType.Activity:\n                modelDef.activities.add(element);\n                break;\n            case shared_1.SimulationObjectType.Connector:\n                modelDef.connectors.add(element);\n                break;\n            case shared_1.SimulationObjectType.Generator:\n                modelDef.generators.add(element);\n                break;\n            case shared_1.SimulationObjectType.Resource:\n                modelDef.resources.add(element);\n                break;\n            case shared_1.SimulationObjectType.Entity:\n                modelDef.entities.add(element);\n                break;\n        }\n        // Update storage\n        this.storageAdapter.updateElementData(elementProxy, element);\n        this.markModelDirty(element.id);\n        await this.validateModelIfNeeded();\n    }\n    /**\n     * Removes an element\n     */\n    async removeElement(elementId) {\n        const modelDef = await this.ensureModelDefinition();\n        if (!modelDef || !this.currentPage)\n            return;\n        const elementProxy = this.findElementProxy(elementId);\n        if (!elementProxy) {\n            console.warn(`No element found for ID: ${elementId}`);\n            return;\n        }\n        // Remove from all list managers\n        modelDef.activities.remove(elementId);\n        modelDef.connectors.remove(elementId);\n        modelDef.generators.remove(elementId);\n        modelDef.resources.remove(elementId);\n        modelDef.entities.remove(elementId);\n        // Remove from storage\n        this.storageAdapter.clearElementData(elementProxy);\n        this.markModelDirty(elementId);\n        await this.validateModelIfNeeded();\n    }\n    /**\n     * Validates the model only if needed\n     */\n    async validateModelIfNeeded() {\n        this.checkCacheTimeouts();\n        if (!this.changeTracker.validationDirty) {\n            return this.currentValidationResult;\n        }\n        return await this.validateModel();\n    }\n    /**\n     * Forces a model validation\n     */\n    async validateModel() {\n        const modelDef = await this.ensureModelDefinition();\n        if (!modelDef) {\n            this.currentValidationResult = {\n                isValid: false,\n                errorCount: 1,\n                warningCount: 0,\n                messages: [{\n                        type: 'error',\n                        message: 'No model initialized'\n                    }]\n            };\n            return this.currentValidationResult;\n        }\n        const result = await this.validationService.validate(modelDef);\n        const errorCount = result.messages.filter(m => m.type === 'error').length;\n        const warningCount = result.messages.filter(m => m.type === 'warning').length;\n        this.currentValidationResult = Object.assign(Object.assign({}, result), { errorCount,\n            warningCount });\n        this.changeTracker.validationDirty = false;\n        this.changeTracker.lastValidationUpdate = Date.now();\n        return this.currentValidationResult;\n    }\n    // Other helper methods remain the same...\n    findElementProxy(elementId) {\n        if (!this.currentPage)\n            return null;\n        return this.currentPage.allBlocks.get(elementId) ||\n            this.currentPage.allLines.get(elementId);\n    }\n    getModel() {\n        var _a, _b;\n        return (_b = (_a = this.modelDefinition) === null || _a === void 0 ? void 0 : _a.model) !== null && _b !== void 0 ? _b : null;\n    }\n    async getModelDefinition() {\n        return await this.ensureModelDefinition();\n    }\n    getCurrentValidation() {\n        return this.currentValidationResult;\n    }\n    /**\n     * Gets an element by ID from any list manager\n     */\n    getElementById(id) {\n        if (!this.modelDefinition)\n            return undefined;\n        return this.modelDefinition.activities.get(id) ||\n            this.modelDefinition.connectors.get(id) ||\n            this.modelDefinition.generators.get(id) ||\n            this.modelDefinition.resources.get(id) ||\n            this.modelDefinition.entities.get(id);\n    }\n    /**\n     * Gets elements by type\n     */\n    getElementsByType(type) {\n        if (!this.modelDefinition)\n            return [];\n        switch (type) {\n            case shared_1.SimulationObjectType.Activity:\n                return this.modelDefinition.activities.getAll();\n            case shared_1.SimulationObjectType.Connector:\n                return this.modelDefinition.connectors.getAll();\n            case shared_1.SimulationObjectType.Generator:\n                return this.modelDefinition.generators.getAll();\n            case shared_1.SimulationObjectType.Resource:\n                return this.modelDefinition.resources.getAll();\n            case shared_1.SimulationObjectType.Entity:\n                return this.modelDefinition.entities.getAll();\n            default:\n                return [];\n        }\n    }\n    clear() {\n        if (this.modelDefinition && this.currentPage) {\n            for (const [, block] of this.currentPage.allBlocks) {\n                this.storageAdapter.clearElementData(block);\n            }\n            for (const [, line] of this.currentPage.allLines) {\n                this.storageAdapter.clearElementData(line);\n            }\n        }\n        this.modelDefinition = null;\n        this.currentPage = null;\n        this.currentValidationResult = null;\n        // Reset change tracking\n        this.changeTracker = {\n            modelDefinitionDirty: false,\n            validationDirty: false,\n            lastModelDefinitionUpdate: 0,\n            lastValidationUpdate: 0,\n            pendingChanges: new Set()\n        };\n    }\n    isQuodsiModel(page) {\n        return this.storageAdapter.isQuodsiModel(page);\n    }\n    getElementData(element) {\n        return this.storageAdapter.getElementData(element);\n    }\n    getMetadata(element) {\n        return this.storageAdapter.getMetadata(element);\n    }\n    setElementData(element, data, type, metadata) {\n        // Use the metadata if provided, otherwise use default metadata\n        const actualMetadata = metadata || {\n            id: element.id,\n            version: this.storageAdapter.CURRENT_VERSION\n        };\n        this.storageAdapter.setElementData(element, data, type, actualMetadata);\n        this.markModelDirty(element.id);\n    }\n    clearElementData(element) {\n        this.storageAdapter.clearElementData(element);\n        this.markModelDirty(element.id);\n    }\n    get CURRENT_VERSION() {\n        return this.storageAdapter.CURRENT_VERSION;\n    }\n    setExpandedNodes(page, nodes) {\n        this.storageAdapter.setExpandedNodes(page, nodes);\n    }\n    getExpandedNodes(page) {\n        return this.storageAdapter.getExpandedNodes(page);\n    }\n    /**\n     * Removes the model from the specified page and clears manager state\n     */\n    removeModelFromPage(page) {\n        if (!page) {\n            throw new Error('No page provided for model removal');\n        }\n        try {\n            // Create instance of RemoveModelFromPage\n            const remover = new RemoveModelFromPage_1.RemoveModelFromPage(page, this.storageAdapter);\n            // Remove the model\n            remover.removeModel();\n            // Clear all internal state\n            this.clear();\n        }\n        catch (error) {\n            this.logError('[ModelManager] Error removing model:', error);\n            throw new Error(`Failed to remove model: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    getStorageAdapter() {\n        return this.storageAdapter;\n    }\n    findPathToNode(modelStructure, nodeId) {\n        const pathNodes = new Set();\n        this.findPathToNodeRecursive(modelStructure.elements, nodeId, pathNodes);\n        return pathNodes;\n    }\n    findPathToNodeRecursive(elements, targetId, path) {\n        var _a;\n        for (const element of elements) {\n            if (element.id === targetId) {\n                return true;\n            }\n            if ((_a = element.children) === null || _a === void 0 ? void 0 : _a.length) {\n                if (this.findPathToNodeRecursive(element.children, targetId, path)) {\n                    path.add(element.id);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    isUnconvertedElement(element) {\n        return this.getElementData(element) === null;\n    }\n    /**\n     * Handles saving simulation element data and metadata\n     */\n    async saveElementData(element, data, type, page) {\n        // Handle conversion to NONE type (removing simulation data)\n        if (type === shared_1.SimulationObjectType.None) {\n            const existingElement = this.getElementById(element.id);\n            if (existingElement) {\n                this.removeElement(element.id);\n            }\n            return;\n        }\n        // Handle type conversion with no data\n        if (type && (!data || Object.keys(data).length === 0)) {\n            await this.handleTypeConversion(element, type, page);\n            return;\n        }\n        // Handle regular data update\n        await this.handleDataUpdate(element, data, type, page);\n    }\n    /**\n     * Handles converting an element to a new simulation type\n     */\n    async handleTypeConversion(element, newType, page) {\n        // Ensure model exists\n        if (!this.getModel()) {\n            const model = {\n                id: page.id,\n                name: page.getTitle() || 'New Model',\n                type: shared_1.SimulationObjectType.Model\n            };\n            await this.initializeModel(model, page);\n        }\n        // Create initial data\n        const elementName = this.getDefaultElementName(element);\n        const convertedData = {\n            id: element.id,\n            type: newType,\n            name: elementName\n        };\n        // Register and save\n        this.registerElement(convertedData, element);\n        this.setElementData(element, convertedData, newType, {\n            id: element.id,\n            version: this.CURRENT_VERSION\n        });\n    }\n    /**\n     * Handles updating element data\n     */\n    async handleDataUpdate(element, updateData, type, page) {\n        // Ensure model exists\n        if (!this.getModel()) {\n            const model = {\n                id: page.id,\n                name: page.getTitle() || 'New Model',\n                type: shared_1.SimulationObjectType.Model\n            };\n            await this.initializeModel(model, page);\n        }\n        // Preserve or set element name\n        const elementName = this.getDefaultElementName(element);\n        const elementData = Object.assign(Object.assign({ id: element.id, type: type }, updateData), { name: (updateData && typeof updateData === 'object' && !Array.isArray(updateData) && 'name' in updateData)\n                ? updateData.name || elementName\n                : elementName });\n        // Register and save\n        this.registerElement(elementData, element);\n        this.setElementData(element, elementData, type, {\n            id: element.id,\n            version: this.CURRENT_VERSION\n        });\n    }\n    /**\n     * Gets default name for an element based on its type\n     */\n    getDefaultElementName(element) {\n        return element instanceof lucid_extension_sdk_1.BlockProxy ?\n            (element.id || 'Unnamed Block') :\n            'Unnamed Connector';\n    }\n    async getModelStructure() {\n        const modelDef = await this.getModelDefinition();\n        if (modelDef) {\n            return ModelStructureBuilder_1.ModelStructureBuilder.buildModelStructure(modelDef);\n        }\n        return undefined;\n    }\n}\nexports.ModelManager = ModelManager;\nModelManager.LOG_PREFIX = '[ModelManager]';\n// Cache timeouts (in milliseconds)\nModelManager.VALIDATION_CACHE_TIMEOUT = 5000; // 5 seconds\nModelManager.MODEL_DEF_CACHE_TIMEOUT = 10000; // 10 seconds\n\n\n//# sourceURL=webpack:///./src/core/ModelManager.ts?");

/***/ }),

/***/ "./src/core/StorageAdapter.ts":
/*!************************************!*\
  !*** ./src/core/StorageAdapter.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageAdapter = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nclass StorageAdapter {\n    constructor() {\n        this.loggingEnabled = false;\n        this.log('StorageAdapter initialized');\n    }\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    log(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.log(`${StorageAdapter.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    logError(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.error(`${StorageAdapter.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    /**\n     * Checks if an element has been converted to a Quodsi model element\n     */\n    isQuodsiModel(element) {\n        try {\n            const meta = this.getMetadata(element);\n            return meta !== null && meta.type === shared_1.SimulationObjectType.Model;\n        }\n        catch (error) {\n            this.logError('Error checking model status:', error);\n            return false;\n        }\n    }\n    /**\n     * Gets the expanded nodes state for a page\n     */\n    getExpandedNodes(page) {\n        try {\n            this.log('Getting expanded nodes for page:', page.id);\n            const expandedNodesStr = page.shapeData.get(StorageAdapter.EXPANDED_NODES_KEY);\n            if (!expandedNodesStr || typeof expandedNodesStr !== 'string') {\n                this.log('No expanded nodes found');\n                return [];\n            }\n            const nodes = JSON.parse(expandedNodesStr);\n            this.log('Retrieved expanded nodes:', nodes);\n            return nodes;\n        }\n        catch (error) {\n            this.logError('Error getting expanded nodes:', error);\n            return [];\n        }\n    }\n    /**\n     * Sets the expanded nodes state for a page\n     */\n    setExpandedNodes(page, nodeIds) {\n        try {\n            this.log('Setting expanded nodes for page:', {\n                pageId: page.id,\n                nodes: nodeIds\n            });\n            const serializedNodes = JSON.stringify(nodeIds);\n            page.shapeData.set(StorageAdapter.EXPANDED_NODES_KEY, serializedNodes);\n            this.log('Successfully set expanded nodes');\n        }\n        catch (error) {\n            this.logError('Error setting expanded nodes:', error);\n            throw error;\n        }\n    }\n    /**\n     * Clears the expanded nodes state for a page\n     */\n    clearExpandedNodes(page) {\n        try {\n            page.shapeData.delete(StorageAdapter.EXPANDED_NODES_KEY);\n            this.log('Successfully cleared expanded nodes');\n        }\n        catch (error) {\n            this.logError('Error clearing expanded nodes:', error);\n            throw error;\n        }\n    }\n    /**\n     * Sets both data and metadata for an element, keeping them properly separated\n     */\n    setElementData(element, data, type, options = {}) {\n        try {\n            // Create clean metadata without any data fields\n            const meta = {\n                type,\n                version: options.version || this.CURRENT_VERSION,\n                lastModified: new Date().toISOString(),\n                id: data.id // Use the ID from the data object\n            };\n            // Create a clean data object without metadata fields\n            const cleanData = this.stripMetadataFields(data);\n            // Serialize both separately\n            const serializedData = JSON.stringify(cleanData);\n            const serializedMeta = JSON.stringify(meta);\n            // Store separately\n            element.shapeData.set(StorageAdapter.DATA_KEY, serializedData);\n            element.shapeData.set(StorageAdapter.META_KEY, serializedMeta);\n            this.log('Successfully set element data:', {\n                elementId: data.id,\n                type: type,\n                dataKeys: Object.keys(cleanData)\n            });\n        }\n        catch (error) {\n            this.logError('Error setting element data:', error);\n            throw error;\n        }\n    }\n    /**\n     * Updates only the data portion of an element's storage\n     */\n    updateElementData(element, data) {\n        try {\n            const existingMeta = this.getMetadata(element);\n            if (!existingMeta) {\n                throw new Error('No metadata found for element');\n            }\n            // Clean the data object before storing\n            const cleanData = this.stripMetadataFields(data);\n            const serializedData = JSON.stringify(cleanData);\n            // Update data\n            element.shapeData.set(StorageAdapter.DATA_KEY, serializedData);\n            // Update lastModified in metadata\n            existingMeta.lastModified = new Date().toISOString();\n            const serializedMeta = JSON.stringify(existingMeta);\n            element.shapeData.set(StorageAdapter.META_KEY, serializedMeta);\n            this.log('Successfully updated element data:', {\n                elementId: data.id,\n                type: existingMeta.type\n            });\n        }\n        catch (error) {\n            this.logError('Error updating element data:', error);\n            throw new Error(`Failed to update element data: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n     * Strips metadata fields from a data object\n     */\n    stripMetadataFields(data) {\n        const cleanData = Object.assign({}, data);\n        // Remove metadata fields if they exist, except 'id' which is needed in both\n        const metadataFields = ['version', 'type', 'lastModified'];\n        metadataFields.forEach(field => {\n            delete cleanData[field];\n        });\n        return cleanData;\n    }\n    /**\n     * Retrieves metadata for an element\n     */\n    getMetadata(element) {\n        try {\n            const metaStr = element.shapeData.get(StorageAdapter.META_KEY);\n            if (!metaStr || typeof metaStr !== 'string')\n                return null;\n            return JSON.parse(metaStr);\n        }\n        catch (error) {\n            this.logError('Error getting metadata:', error);\n            return null;\n        }\n    }\n    /**\n     * Retrieves data portion for an element\n     */\n    getElementData(element) {\n        try {\n            this.log('Getting element data:', {\n                elementId: element.id,\n                elementType: typeof element,\n                contextInfo: 'Attempting to retrieve stored data'\n            });\n            const dataStr = element.shapeData.get(StorageAdapter.DATA_KEY);\n            this.log('Raw data string:', {\n                exists: !!dataStr,\n                isString: typeof dataStr === 'string',\n                valueType: typeof dataStr,\n                preview: typeof dataStr === 'string' ?\n                    `${dataStr.slice(0, 100)}${dataStr.length > 100 ? '...' : ''}` :\n                    String(dataStr)\n            });\n            if (!dataStr || typeof dataStr !== 'string') {\n                this.log('No valid data found for element:', element.id);\n                return null;\n            }\n            const parsedData = JSON.parse(dataStr);\n            this.log('Successfully parsed element data:', {\n                elementId: element.id,\n                parsedDataKeys: Object.keys(parsedData),\n                timestamp: new Date().toISOString()\n            });\n            return parsedData;\n        }\n        catch (error) {\n            this.logError('Error getting element data:', {\n                elementId: element.id,\n                error: error instanceof Error ? error.message : 'Unknown error',\n                stack: error instanceof Error ? error.stack : undefined,\n                timestamp: new Date().toISOString()\n            });\n            return null;\n        }\n    }\n    /**\n     * Gets both data and metadata as a complete storage format\n     */\n    getCompleteStorage(element) {\n        try {\n            const meta = this.getMetadata(element);\n            const data = this.getElementData(element);\n            if (!meta || !data)\n                return null;\n            return { data, meta };\n        }\n        catch (error) {\n            this.logError('Error getting complete storage:', error);\n            return null;\n        }\n    }\n    /**\n     * Removes all Quodsi-related data from an element\n     */\n    clearElementData(element) {\n        try {\n            const keys = [StorageAdapter.DATA_KEY, StorageAdapter.META_KEY];\n            for (const key of keys) {\n                // Check if the data exists first\n                const value = element.shapeData.get(key);\n                if (value !== undefined) {\n                    try {\n                        element.shapeData.delete(key);\n                    }\n                    catch (_a) {\n                        // If delete fails, try setting to empty string as fallback\n                        element.shapeData.set(key, '');\n                    }\n                    this.log(`Cleared ${key} from element:`, element.id);\n                }\n                else {\n                    this.log(`No ${key} found on element:`, element.id);\n                }\n            }\n        }\n        catch (error) {\n            this.logError('Error clearing element data:', error);\n            throw new Error(`Failed to clear element data: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n     * Validates that an element has both required storage components\n     */\n    validateStorage(element) {\n        try {\n            const dataStr = element.shapeData.get(StorageAdapter.DATA_KEY);\n            const metaStr = element.shapeData.get(StorageAdapter.META_KEY);\n            return typeof dataStr === 'string' && typeof metaStr === 'string';\n        }\n        catch (error) {\n            this.logError('Error validating storage:', error);\n            return false;\n        }\n    }\n    /**\n     * Gets the current version number used by the storage adapter\n     */\n    get CURRENT_VERSION() {\n        return StorageAdapter.CURRENT_VERSION;\n    }\n}\nexports.StorageAdapter = StorageAdapter;\nStorageAdapter.DATA_KEY = 'q_data';\nStorageAdapter.META_KEY = 'q_meta';\nStorageAdapter.EXPANDED_NODES_KEY = 'q_expanded_nodes';\nStorageAdapter.CURRENT_VERSION = '1.0.0';\nStorageAdapter.LOG_PREFIX = '[StorageAdapter]';\n\n\n//# sourceURL=webpack:///./src/core/StorageAdapter.ts?");

/***/ }),

/***/ "./src/extension.ts":
/*!**************************!*\
  !*** ./src/extension.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"../../node_modules/lucid-extension-sdk/index.js\");\nconst ModelManager_1 = __webpack_require__(/*! ./core/ModelManager */ \"./src/core/ModelManager.ts\");\nconst ModelPanel_1 = __webpack_require__(/*! ./panels/ModelPanel */ \"./src/panels/ModelPanel.ts\");\nconst StorageAdapter_1 = __webpack_require__(/*! ./core/StorageAdapter */ \"./src/core/StorageAdapter.ts\");\nconst client = new lucid_extension_sdk_1.EditorClient();\nconst viewport = new lucid_extension_sdk_1.Viewport(client);\n// Initialize storage adapter\nconst storageAdapter = new StorageAdapter_1.StorageAdapter();\n// Initialize the messaging singleton\n// const messaging = ExtensionMessaging.getInstance(); \n// Initialize core model management with storage adapter\nconst modelManager = new ModelManager_1.ModelManager(storageAdapter);\n// Initialize panel with model manager instance\nconsole.info('[extension] About to create ModelPanel');\nconst modelPanel = new ModelPanel_1.ModelPanel(client, modelManager);\nmodelPanel.setLogging(true);\nconsole.info('[extension] Created ModelPanel2');\n// Hook selection changes\nviewport.hookSelection((items) => {\n    modelPanel.handleSelectionChange(items);\n});\n\n\n//# sourceURL=webpack:///./src/extension.ts?");

/***/ }),

/***/ "./src/managers/SelectionManager.ts":
/*!******************************************!*\
  !*** ./src/managers/SelectionManager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SelectionManager = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nclass SelectionManager {\n    constructor(modelManager) {\n        this.selectionChangeListeners = [];\n        this.loggingEnabled = false;\n        this.modelManager = modelManager;\n        this.currentSelection = {\n            pageId: '',\n            selectedIds: [],\n            selectionType: shared_1.SelectionType.NONE\n        };\n        this.log('SelectionManager initialized');\n    }\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    log(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.log(`${SelectionManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    logError(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.error(`${SelectionManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    async determineSelectionState(currentPage, items) {\n        this.log('Determining selection state', {\n            pageId: currentPage.id,\n            itemCount: items.length,\n            items: items.map(i => i.id)\n        });\n        const type = await this.determineSelectionType(items);\n        const state = {\n            pageId: currentPage.id,\n            selectedIds: items.map(item => item.id),\n            selectionType: type\n        };\n        this.log('Selection state determined', state);\n        return state;\n    }\n    async determineSelectionType(items) {\n        this.log('Determining selection type', { itemCount: items.length });\n        if (items.length === 0) {\n            this.log('No items selected, returning NONE');\n            return shared_1.SelectionType.NONE;\n        }\n        if (items.length > 1) {\n            this.log('Multiple items selected, returning MULTIPLE');\n            return shared_1.SelectionType.MULTIPLE;\n        }\n        const item = items[0];\n        this.log('Processing single item selection', { itemId: item.id });\n        if (this.modelManager.isUnconvertedElement(item)) {\n            this.log('Item is unconverted', { itemId: item.id });\n            return shared_1.SelectionType.UNCONVERTED_ELEMENT;\n        }\n        const metadata = await this.modelManager.getMetadata(item);\n        this.log('Retrieved metadata', { itemId: item.id, metadata });\n        if (!(metadata === null || metadata === void 0 ? void 0 : metadata.type) || metadata.type === shared_1.SimulationObjectType.None) {\n            this.log('Invalid or None type metadata, treating as unconverted', { itemId: item.id });\n            return shared_1.SelectionType.UNCONVERTED_ELEMENT;\n        }\n        const selectionType = this.mapElementTypeToSelectionType(metadata.type);\n        this.log('Mapped element type to selection type', {\n            itemId: item.id,\n            elementType: metadata.type,\n            selectionType\n        });\n        return selectionType;\n    }\n    mapElementTypeToSelectionType(elementType) {\n        var _a;\n        this.log('Mapping element type to selection type', { elementType });\n        // Create a type-safe mapping object\n        const mapping = {\n            [shared_1.SimulationObjectType.Activity]: shared_1.SelectionType.ACTIVITY,\n            [shared_1.SimulationObjectType.Connector]: shared_1.SelectionType.CONNECTOR,\n            [shared_1.SimulationObjectType.Entity]: shared_1.SelectionType.ENTITY,\n            [shared_1.SimulationObjectType.Generator]: shared_1.SelectionType.GENERATOR,\n            [shared_1.SimulationObjectType.Resource]: shared_1.SelectionType.RESOURCE,\n            [shared_1.SimulationObjectType.Model]: shared_1.SelectionType.MODEL\n        };\n        const result = (_a = mapping[elementType]) !== null && _a !== void 0 ? _a : shared_1.SelectionType.UNKNOWN_BLOCK;\n        this.log('Type mapping result', { elementType, result });\n        return result;\n    }\n    validateSelection(selection) {\n        this.log('Validating selection state', selection);\n        const isValid = (selection &&\n            typeof selection.pageId === 'string' &&\n            Array.isArray(selection.selectedIds) &&\n            typeof selection.selectionType === 'number');\n        if (!isValid) {\n            this.logError('Invalid selection state', selection);\n        }\n        return isValid;\n    }\n    onSelectionChange(listener) {\n        this.log('Adding selection change listener');\n        this.selectionChangeListeners.push(listener);\n    }\n    getCurrentSelection() {\n        this.log('Getting current selection', this.currentSelection);\n        return this.currentSelection;\n    }\n    setCurrentSelection(selection) {\n        this.log('Setting current selection', selection);\n        if (!this.validateSelection(selection)) {\n            this.logError('Invalid selection state, not updating', selection);\n            return;\n        }\n        this.currentSelection = selection;\n        this.notifySelectionChange();\n    }\n    notifySelectionChange() {\n        this.log('Notifying selection change listeners', {\n            listenerCount: this.selectionChangeListeners.length\n        });\n        this.selectionChangeListeners.forEach((listener, index) => {\n            try {\n                this.log(`Executing listener ${index}`);\n                listener(this.currentSelection);\n            }\n            catch (error) {\n                this.logError(`Error in selection change listener ${index}:`, error);\n            }\n        });\n    }\n}\nexports.SelectionManager = SelectionManager;\nSelectionManager.LOG_PREFIX = '[SelectionManager]';\n\n\n//# sourceURL=webpack:///./src/managers/SelectionManager.ts?");

/***/ }),

/***/ "./src/managers/TreeStateManager.ts":
/*!******************************************!*\
  !*** ./src/managers/TreeStateManager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TreeStateManager = void 0;\nclass TreeStateManager {\n    constructor(modelManager) {\n        this.expandedNodes = new Set();\n        this.stateChangeListeners = [];\n        this.loggingEnabled = false;\n        this.modelManager = modelManager;\n        this.log('TreeStateManager initialized');\n    }\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    log(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.log(`${TreeStateManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    logError(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.error(`${TreeStateManager.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    handleNodeToggle(nodeId, expanded, currentPage) {\n        this.log('Handling node toggle', { nodeId, expanded, pageId: currentPage === null || currentPage === void 0 ? void 0 : currentPage.id });\n        try {\n            if (!nodeId) {\n                throw new Error('Node ID is required');\n            }\n            if (!currentPage) {\n                throw new Error('Current page is required');\n            }\n            if (expanded) {\n                this.expandedNodes.add(nodeId);\n                this.log('Node expanded', { nodeId });\n            }\n            else {\n                this.expandedNodes.delete(nodeId);\n                this.log('Node collapsed', { nodeId });\n            }\n            const expandedNodesArray = Array.from(this.expandedNodes);\n            this.log('Saving expanded nodes to storage', { nodes: expandedNodesArray });\n            this.modelManager.setExpandedNodes(currentPage, expandedNodesArray);\n            this.notifyStateChange(expandedNodesArray);\n        }\n        catch (error) {\n            this.logError('Error handling node toggle:', error);\n            throw error;\n        }\n    }\n    updateTreeState(expandedNodes, currentPage) {\n        this.log('Updating tree state', {\n            nodeCount: expandedNodes.length,\n            pageId: currentPage === null || currentPage === void 0 ? void 0 : currentPage.id\n        });\n        try {\n            if (!this.validateState(expandedNodes)) {\n                throw new Error('Invalid expanded nodes state');\n            }\n            if (!currentPage) {\n                throw new Error('Current page is required');\n            }\n            this.expandedNodes = new Set(expandedNodes);\n            this.log('Tree state updated', { nodes: expandedNodes });\n            this.modelManager.setExpandedNodes(currentPage, expandedNodes);\n            this.notifyStateChange(expandedNodes);\n        }\n        catch (error) {\n            this.logError('Error updating tree state:', error);\n            throw error;\n        }\n    }\n    expandPath(modelStructure, nodeId) {\n        this.log('Expanding path to node', { nodeId });\n        const pathNodes = this.modelManager.findPathToNode(modelStructure, nodeId);\n        this.log('Found path nodes', { pathNodes });\n        pathNodes.forEach(id => {\n            this.expandedNodes.add(id);\n            this.log('Added node to expanded set', { nodeId: id });\n        });\n    }\n    validateState(nodes) {\n        this.log('Validating tree state', { nodeCount: nodes === null || nodes === void 0 ? void 0 : nodes.length });\n        const isValid = Array.isArray(nodes) && nodes.every(node => typeof node === 'string');\n        if (!isValid) {\n            this.logError('Invalid tree state', nodes);\n        }\n        return isValid;\n    }\n    getExpandedNodes() {\n        const nodes = Array.from(this.expandedNodes);\n        this.log('Getting expanded nodes', { nodes });\n        return nodes;\n    }\n    loadSavedState(page) {\n        this.log('Loading saved state', { pageId: page === null || page === void 0 ? void 0 : page.id });\n        const savedNodes = this.modelManager.getExpandedNodes(page);\n        this.log('Retrieved saved nodes', { savedNodes });\n        if (savedNodes === null || savedNodes === void 0 ? void 0 : savedNodes.length) {\n            this.expandedNodes = new Set(savedNodes);\n            this.log('Restored expanded nodes', { nodes: savedNodes });\n        }\n        else {\n            this.log('No saved nodes found');\n        }\n    }\n    onStateChange(listener) {\n        this.log('Adding state change listener');\n        this.stateChangeListeners.push(listener);\n    }\n    notifyStateChange(nodes) {\n        this.log('Notifying state change listeners', {\n            listenerCount: this.stateChangeListeners.length\n        });\n        this.stateChangeListeners.forEach((listener, index) => {\n            try {\n                this.log(`Executing listener ${index}`);\n                listener(nodes);\n            }\n            catch (error) {\n                this.logError(`Error in state change listener ${index}:`, error);\n            }\n        });\n    }\n}\nexports.TreeStateManager = TreeStateManager;\nTreeStateManager.LOG_PREFIX = '[TreeStateManager]';\n\n\n//# sourceURL=webpack:///./src/managers/TreeStateManager.ts?");

/***/ }),

/***/ "./src/managers/index.ts":
/*!*******************************!*\
  !*** ./src/managers/index.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./SelectionManager */ \"./src/managers/SelectionManager.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./TreeStateManager */ \"./src/managers/TreeStateManager.ts\"), exports);\n\n\n//# sourceURL=webpack:///./src/managers/index.ts?");

/***/ }),

/***/ "./src/panels/ModelPanel.ts":
/*!**********************************!*\
  !*** ./src/panels/ModelPanel.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelPanel = void 0;\n// panels/ModelPanel.ts\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"../../node_modules/lucid-extension-sdk/index.js\");\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst ConversionService_1 = __webpack_require__(/*! ../services/conversion/ConversionService */ \"./src/services/conversion/ConversionService.ts\");\nconst managers_1 = __webpack_require__(/*! ../managers */ \"./src/managers/index.ts\");\nclass ModelPanel extends lucid_extension_sdk_1.Panel {\n    constructor(client, modelManager) {\n        super(client, {\n            title: 'Quodsi Model',\n            url: 'quodsim-react/index.html',\n            location: lucid_extension_sdk_1.PanelLocation.RightDock,\n            iconUrl: 'https://lucid.app/favicon.ico',\n            width: 300\n        });\n        this.loggingEnabled = false;\n        this.reactAppReady = false;\n        this.expandedNodes = new Set();\n        this.currentModelStructure = undefined;\n        this.currentSelection = {\n            pageId: '',\n            selectedIds: [],\n            selectionType: shared_1.SelectionType.NONE\n        };\n        this.isHandlingSelectionChange = false;\n        // Initialize services and managers but don't perform any operations yet\n        this.messaging = shared_1.ExtensionMessaging.getInstance();\n        this.modelManager = modelManager;\n        this.selectionManager = new managers_1.SelectionManager(modelManager);\n        this.treeStateManager = new managers_1.TreeStateManager(modelManager);\n        this.conversionService = new ConversionService_1.ConversionService(this.modelManager);\n        // Set up event handlers\n        this.setupModelMessageHandlers();\n        // Wait for React app ready message before doing any model operations\n        this.messaging.onMessage(shared_1.MessageTypes.REACT_APP_READY, () => {\n            this.handleReactReady();\n        });\n        this.log('Model Panel initialized');\n    }\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n        this.log(`Logging ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    log(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.log(`${ModelPanel.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    logError(message, ...args) {\n        if (this.isLoggingEnabled()) {\n            console.error(`${ModelPanel.LOG_PREFIX} ${message}`, ...args);\n        }\n    }\n    setupModelMessageHandlers() {\n        this.logError('Setting up message handlers START');\n        // React App Ready - already handled by BasePanel\n        // Model Operations\n        this.messaging.onMessage(shared_1.MessageTypes.REACT_APP_READY, () => {\n            this.logError('REACT_APP_READY message received in handler');\n            this.handleReactReady();\n        });\n        // Setup error handler\n        this.messaging.onMessage(shared_1.MessageTypes.ERROR, (payload) => {\n            this.logError('Error received:', payload);\n        });\n        this.messaging.onMessage(shared_1.MessageTypes.REMOVE_MODEL, () => this.handleRemoveModel());\n        this.messaging.onMessage(shared_1.MessageTypes.CONVERT_PAGE, () => this.handleConvertRequest());\n        this.messaging.onMessage(shared_1.MessageTypes.VALIDATE_MODEL, () => this.handleValidateModel());\n        this.messaging.onMessage(shared_1.MessageTypes.MODEL_SAVED, (data) => this.handleModelSaved(data));\n        // Element Operations\n        this.messaging.onMessage(shared_1.MessageTypes.GET_ELEMENT_DATA, (data) => this.handleGetElementData(data.elementId));\n        this.messaging.onMessage(shared_1.MessageTypes.UPDATE_ELEMENT_DATA, (data) => this.handleUpdateElementData(data));\n        // Tree State Management\n        this.messaging.onMessage(shared_1.MessageTypes.TREE_NODE_TOGGLE, (data) => this.handleTreeNodeToggle(data.nodeId, data.expanded));\n        this.messaging.onMessage(shared_1.MessageTypes.TREE_STATE_UPDATE, (data) => this.handleTreeStateUpdate(data.expandedNodes));\n        this.messaging.onMessage(shared_1.MessageTypes.TREE_NODE_EXPAND_PATH, (data) => this.handleExpandPath(data.nodeId));\n        // Component Operations with type safety\n        const componentOperations = [\n            { type: shared_1.MessageTypes.ACTIVITY_SAVED, objectType: shared_1.SimulationObjectType.Activity },\n            { type: shared_1.MessageTypes.CONNECTOR_SAVED, objectType: shared_1.SimulationObjectType.Connector },\n            { type: shared_1.MessageTypes.ENTITY_SAVED, objectType: shared_1.SimulationObjectType.Entity },\n            { type: shared_1.MessageTypes.GENERATOR_SAVED, objectType: shared_1.SimulationObjectType.Generator },\n            { type: shared_1.MessageTypes.RESOURCE_SAVED, objectType: shared_1.SimulationObjectType.Resource }\n        ];\n        componentOperations.forEach(({ type, objectType }) => {\n            this.messaging.onMessage(type, (payload) => {\n                this.handleUpdateElementData({\n                    elementId: payload.elementId,\n                    data: payload.data,\n                    type: objectType\n                });\n            });\n        });\n        this.logError('Setting up message handlers END');\n    }\n    async updateModelStructure() {\n        // Get model structure from ModelManager\n        this.currentModelStructure = await this.modelManager.getModelStructure();\n        this.log('Model structure updated:', this.currentModelStructure);\n        // Validate model\n        const validationResult = await this.modelManager.validateModel();\n        this.log('Model validation result:', validationResult);\n        // If we're not in a selection change context, notify the React app of the validation update\n        if (!this.isHandlingSelectionChange) {\n            this.sendTypedMessage(shared_1.MessageTypes.VALIDATION_RESULT, validationResult);\n        }\n    }\n    /**\n     * Handles tree node expansion state changes\n     */\n    handleTreeNodeToggle(nodeId, expanded) {\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        if (!currentPage)\n            return;\n        this.treeStateManager.handleNodeToggle(nodeId, expanded, currentPage);\n        this.sendTreeStateUpdate();\n    }\n    /**\n     * Handles bulk tree state updates\n     */\n    handleTreeStateUpdate(expandedNodes) {\n        this.log('Tree state update:', { expandedNodes });\n        this.expandedNodes = new Set(expandedNodes);\n        // Get current page and save to storage\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        if (currentPage) {\n            this.log('Saving expanded nodes to storage:', expandedNodes);\n            this.modelManager.setExpandedNodes(currentPage, expandedNodes);\n        }\n        this.sendTreeStateUpdate();\n    }\n    /**\n     * Expands the path to a specific node\n     */\n    handleExpandPath(nodeId) {\n        if (!this.currentModelStructure)\n            return;\n        // Get path nodes from ModelManager\n        const pathNodes = this.modelManager.findPathToNode(this.currentModelStructure, nodeId);\n        // Add all nodes in path to expanded set\n        pathNodes.forEach(id => this.expandedNodes.add(id));\n        this.sendTreeStateUpdate();\n    }\n    /**\n     * Sends current tree state to React app\n     */\n    sendTreeStateUpdate() {\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        if (!currentPage)\n            return;\n        this.sendTypedMessage(shared_1.MessageTypes.TREE_STATE_SYNC, {\n            expandedNodes: Array.from(this.expandedNodes),\n            pageId: currentPage.id\n        });\n    }\n    async initializeModelManager() {\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        if (!currentPage || !this.modelManager.isQuodsiModel(currentPage)) {\n            this.log('Page is not a Quodsi model, skipping initialization');\n            return;\n        }\n        try {\n            const modelData = this.modelManager.getElementData(currentPage);\n            if (modelData) {\n                await this.modelManager.initializeModel(modelData, currentPage);\n                this.log('Model initialization complete');\n            }\n        }\n        catch (error) {\n            this.logError('Error initializing model:', error);\n            throw new Error(`Failed to initialize model: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n     * Shows the panel\n     */\n    show() {\n        this.log('Show called');\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        this.log('Current page at show:', currentPage);\n        this.initializeModelManager(); // Re-initialize when panel is shown\n        super.show();\n    }\n    /**\n     * Hides the panel\n     */\n    hide() {\n        this.log('Hide called');\n        super.hide();\n    }\n    async handleValidateRequest() {\n        const validationResult = await this.modelManager.validateModel();\n        // Send separate validation result message for explicit validation requests\n        this.sendTypedMessage(shared_1.MessageTypes.VALIDATION_RESULT, validationResult);\n    }\n    async handleSelectionChange(items) {\n        this.isHandlingSelectionChange = true;\n        try {\n            const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n            const currentPage = viewport.getCurrentPage();\n            if (!currentPage)\n                return;\n            await this.updateModelStructure();\n            const selectionState = await this.selectionManager.determineSelectionState(currentPage, items);\n            this.selectionManager.setCurrentSelection(selectionState);\n            if (this.reactAppReady) {\n                await this.sendSelectionBasedMessage(selectionState, items, currentPage);\n            }\n        }\n        catch (error) {\n            this.handleError('Error handling selection change:', error);\n        }\n        finally {\n            this.isHandlingSelectionChange = false;\n        }\n    }\n    async sendSelectionBasedMessage(selectionState, items, currentPage) {\n        // Convert ElementProxy to PageProxy if needed\n        const page = new lucid_extension_sdk_1.PageProxy(currentPage.id, this.client);\n        // Early check - if page is not a model, always send PAGE_NO_MODEL\n        if (!this.modelManager.isQuodsiModel(page)) {\n            this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_PAGE_NO_MODEL, {\n                pageId: page.id\n            });\n            return;\n        }\n        const modelStructure = this.currentModelStructure || { elements: [], hierarchy: {} };\n        const expandedNodes = this.treeStateManager.getExpandedNodes();\n        const validationResult = await this.modelManager.validateModel();\n        const basePayload = {\n            selectionState,\n            modelStructure,\n            expandedNodes,\n            validationResult\n        };\n        switch (selectionState.selectionType) {\n            case shared_1.SelectionType.NONE: {\n                // Build model item data for the page since it's a model\n                const modelItemData = await this.buildModelItemData(page);\n                const payload = Object.assign(Object.assign({}, basePayload), { pageSelection: {\n                        pageId: currentPage.id\n                    }, modelStructure, // Already in basePayload\n                    modelItemData // Add the page's model data\n                 });\n                this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_PAGE_WITH_MODEL, payload);\n                break;\n            }\n            case shared_1.SelectionType.MULTIPLE: {\n                const modelItemData = await Promise.all(items.map(item => this.buildModelItemData(item)));\n                const payload = Object.assign(Object.assign({}, basePayload), { multipleSelection: {\n                        pageId: currentPage.id,\n                        selectedIds: items.map(item => item.id)\n                    }, modelItemData });\n                this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_MULTIPLE, payload);\n                break;\n            }\n            case shared_1.SelectionType.UNCONVERTED_ELEMENT: {\n                if (items.length === 1) {\n                    const item = items[0];\n                    const modelItemData = await this.buildModelItemData(item);\n                    modelItemData.isUnconverted = true;\n                    const unconvertedSelection = {\n                        pageId: currentPage.id,\n                        selectedId: item.id,\n                        elementType: item instanceof lucid_extension_sdk_1.BlockProxy ? shared_1.DiagramElementType.BLOCK : shared_1.DiagramElementType.LINE\n                    };\n                    const payload = Object.assign(Object.assign({}, basePayload), { unconvertedSelection,\n                        modelItemData });\n                    this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_UNCONVERTED, payload);\n                }\n                break;\n            }\n            case shared_1.SelectionType.ACTIVITY:\n            case shared_1.SelectionType.CONNECTOR:\n            case shared_1.SelectionType.ENTITY:\n            case shared_1.SelectionType.GENERATOR:\n            case shared_1.SelectionType.RESOURCE:\n            case shared_1.SelectionType.MODEL: {\n                if (items.length === 1) {\n                    const item = items[0];\n                    const metadata = this.modelManager.getMetadata(item);\n                    if (metadata) {\n                        const modelItemData = await this.buildModelItemData(item);\n                        const simulationSelection = {\n                            pageId: currentPage.id,\n                            selectedId: item.id,\n                            objectType: metadata.type\n                        };\n                        const payload = Object.assign(Object.assign({}, basePayload), { simulationSelection,\n                            modelItemData,\n                            modelStructure });\n                        this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_SIMULATION_OBJECT, payload);\n                    }\n                }\n                break;\n            }\n            default: {\n                // Fallback to legacy selection changed message\n                const elementData = await Promise.all(items.map(item => this.buildModelItemData(item)));\n                const payload = {\n                    selectionState,\n                    elementData,\n                    modelStructure,\n                    expandedNodes,\n                    validationResult\n                };\n                this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED, payload);\n                break;\n            }\n        }\n    }\n    handleError(message, error) {\n        this.logError(`${message}`, error);\n        this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n            error: error instanceof Error ? error.message : 'Unknown error'\n        });\n    }\n    // Keep this as the primary builder\n    async buildModelItemData(item) {\n        const rawData = this.modelManager.getElementData(item);\n        const metadata = this.modelManager.getMetadata(item);\n        // Determine name based on item type\n        let name;\n        if (item instanceof lucid_extension_sdk_1.PageProxy) {\n            name = item.getTitle() || 'Untitled Model';\n        }\n        else if (item instanceof lucid_extension_sdk_1.BlockProxy) {\n            name = item.id || 'Unnamed Block';\n        }\n        else {\n            name = 'Unnamed Connector';\n        }\n        // Ensure metadata has all required fields\n        const defaultMetadata = Object.assign({ type: item instanceof lucid_extension_sdk_1.PageProxy ? shared_1.SimulationObjectType.Model : shared_1.SimulationObjectType.None, version: this.modelManager.CURRENT_VERSION, lastModified: new Date().toISOString(), id: item.id }, (metadata || {}));\n        // Handle unconverted elements\n        if (item instanceof lucid_extension_sdk_1.ItemProxy && this.modelManager.isUnconvertedElement(item)) {\n            defaultMetadata.isUnconverted = true;\n        }\n        // Convert Lucid JsonObject to shared JsonObject type\n        const convertedData = rawData ? JSON.parse(JSON.stringify(rawData)) : {};\n        return {\n            id: item.id,\n            data: convertedData,\n            metadata: defaultMetadata,\n            name\n        };\n    }\n    // Helper method for building multiple items\n    async buildModelItemDataArray(items) {\n        return Promise.all(items.map(item => this.buildModelItemData(item)));\n    }\n    /**\n     * Handles model removal request\n     */\n    handleRemoveModel() {\n        this.log('Handling remove model request');\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        const document = new lucid_extension_sdk_1.DocumentProxy(this.client);\n        if (!currentPage) {\n            this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                error: 'No active page found'\n            });\n            return;\n        }\n        try {\n            // Use ModelManager to remove the model\n            this.modelManager.removeModelFromPage(currentPage);\n            // Notify React app of successful removal\n            this.sendTypedMessage(shared_1.MessageTypes.MODEL_REMOVED);\n            // Refresh the panel state after removal\n            this.sendInitialState(currentPage, false, document.id);\n        }\n        catch (error) {\n            this.logError('Model removal error:', error);\n            this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                error: error instanceof Error ? error.message : 'Unknown error'\n            });\n        }\n    }\n    handleReactReady() {\n        if (this.reactAppReady) {\n            this.logError('React app already ready, skipping initialization');\n            return;\n        }\n        this.logError('handleReactReady');\n        this.reactAppReady = true;\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        const document = new lucid_extension_sdk_1.DocumentProxy(this.client);\n        if (!currentPage) {\n            this.logError('No active page found during React ready');\n            return;\n        }\n        // Now initialize the model in response to a user-triggered event\n        this.initializeModelManager().then(() => {\n            const isModel = this.modelManager.isQuodsiModel(currentPage);\n            // If not a model, send appropriate message\n            if (!isModel) {\n                this.sendTypedMessage(shared_1.MessageTypes.SELECTION_CHANGED_PAGE_NO_MODEL, {\n                    pageId: currentPage.id\n                });\n                return;\n            }\n            // Only send initial state and handle selection if it is a model\n            this.sendInitialState(currentPage, true, document.id);\n            // Update selection using new pattern\n            if (this.currentSelection.selectedIds.length > 0) {\n                const selectedItems = viewport.getSelectedItems();\n                this.handleSelectionChange(selectedItems).catch(error => this.handleError('Error sending selection update:', error));\n            }\n        });\n    }\n    /**\n     * Sends initial state to React app\n     */\n    sendInitialState(page, isModel, documentId) {\n        this.log('Sending initial state with full details:', {\n            isModel,\n            pageId: page.id,\n            documentId,\n            pageTitle: page.getTitle(),\n            canConvert: this.conversionService ? this.conversionService.canConvertPage(page) : false,\n            hasModelData: isModel ? 'yes' : 'no'\n        });\n        this.updateModelStructure();\n        // Load saved expanded nodes from storage\n        const savedExpandedNodes = this.modelManager.getExpandedNodes(page);\n        this.log('Loaded expanded nodes from storage:', savedExpandedNodes);\n        if (savedExpandedNodes === null || savedExpandedNodes === void 0 ? void 0 : savedExpandedNodes.length) {\n            this.expandedNodes = new Set(savedExpandedNodes);\n        }\n        this.sendTypedMessage(shared_1.MessageTypes.INITIAL_STATE, {\n            isModel,\n            pageId: page.id,\n            documentId,\n            canConvert: this.conversionService ? this.conversionService.canConvertPage(page) : false,\n            modelData: isModel ? this.modelManager.getElementData(page) : null,\n            selectionState: this.currentSelection,\n            modelStructure: this.currentModelStructure,\n            expandedNodes: Array.from(this.expandedNodes)\n        });\n    }\n    /**\n     * Handles page conversion request\n     */\n    async handleConvertRequest() {\n        this.log('Handling convert request');\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        const document = new lucid_extension_sdk_1.DocumentProxy(this.client);\n        if (!currentPage) {\n            this.sendTypedMessage(shared_1.MessageTypes.CONVERSION_ERROR, {\n                error: 'No active page found'\n            });\n            return;\n        }\n        try {\n            // this.sendTypedMessage(MessageTypes.CONVERSION_STARTED); --Not implemented in QuodsiApp yet\n            const result = await this.conversionService.convertPage(currentPage);\n            // this.sendTypedMessage(MessageTypes.CONVERSION_COMPLETE, result);--Not implemented in QuodsiApp yet\n            const selectedItems = viewport.getSelectedItems();\n            await this.handleSelectionChange(selectedItems);\n        }\n        catch (error) {\n            this.logError('Conversion error:', error);\n            this.sendTypedMessage(shared_1.MessageTypes.CONVERSION_ERROR, {\n                error: error instanceof Error ? error.message : 'Unknown error'\n            });\n        }\n    }\n    /**\n     * Handles element data request\n     */\n    async handleGetElementData(elementId) {\n        const element = this.client.getElementProxy(elementId); // or whatever method you currently use\n        if (!element) {\n            this.logError('Element not found:', elementId);\n            return;\n        }\n        const rawData = this.modelManager.getElementData(element);\n        const metadata = this.modelManager.getMetadata(element) || {};\n        // Add isUnconverted flag if this element is in our unconverted set\n        // Check if element is unconverted\n        if (this.modelManager.isUnconvertedElement(element)) {\n            metadata.isUnconverted = true;\n        }\n        const referenceData = {};\n        // Build reference data based on element type\n        if ((metadata === null || metadata === void 0 ? void 0 : metadata.type) === shared_1.SimulationObjectType.Generator) {\n            const modelDef = await this.modelManager.getModelDefinition();\n            if (modelDef) {\n                referenceData.entities = modelDef.entities.getAll().map(e => ({\n                    id: e.id,\n                    name: e.name\n                }));\n            }\n        }\n        // Use your existing message sending code but include the updated metadata\n        this.sendTypedMessage(shared_1.MessageTypes.ELEMENT_DATA, {\n            id: elementId,\n            data: rawData,\n            metadata: metadata,\n            referenceData: referenceData\n        });\n    }\n    /**\n     * Handles element data update\n     */\n    async handleUpdateElementData(updateData) {\n        this.log('Received element update data:', updateData);\n        try {\n            const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n            const currentPage = viewport.getCurrentPage();\n            if (!currentPage) {\n                throw new Error('No active page found');\n            }\n            // Get the element from viewport\n            const selectedItems = viewport.getSelectedItems();\n            const element = selectedItems.find(item => item.id === updateData.elementId);\n            if (!element) {\n                throw new Error(`Element not found in selection: ${updateData.elementId}`);\n            }\n            // Save element data using ModelManager\n            await this.modelManager.saveElementData(element, updateData.data, updateData.type, currentPage);\n            // Send success message\n            this.sendTypedMessage(shared_1.MessageTypes.UPDATE_SUCCESS, {\n                elementId: updateData.elementId\n            });\n            // Update validation and selection state\n            await this.modelManager.validateModel();\n            // Only update selection if this element is selected\n            if (this.currentSelection.selectedIds.includes(updateData.elementId)) {\n                await this.handleSelectionChange(selectedItems);\n            }\n        }\n        catch (error) {\n            this.logError('Error updating element:', error);\n            this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                error: `Failed to update element: ${error instanceof Error ? error.message : String(error)}`\n            });\n        }\n    }\n    /**\n     * Handles model validation request\n     */\n    async handleValidateModel() {\n        this.log('Handling validate model');\n        const validationResult = await this.modelManager.validateModel();\n        // Send separate validation result message for explicit validation requests\n        this.sendTypedMessage(shared_1.MessageTypes.VALIDATION_RESULT, validationResult);\n    }\n    /**\n     * Handles model saved message\n     */\n    handleModelSaved(data) {\n        this.log('Handling model saved');\n        const viewport = new lucid_extension_sdk_1.Viewport(this.client);\n        const currentPage = viewport.getCurrentPage();\n        if (currentPage) {\n            try {\n                this.modelManager.setElementData(currentPage, data, shared_1.SimulationObjectType.Model);\n                this.modelManager.updateElement(Object.assign({ id: currentPage.id, type: shared_1.SimulationObjectType.Model }, data));\n                this.sendTypedMessage(shared_1.MessageTypes.UPDATE_SUCCESS, {\n                    elementId: currentPage.id\n                });\n            }\n            catch (error) {\n                this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                    error: `Failed to save model: ${error}`\n                });\n            }\n        }\n    }\n    sendTypedMessage(type, payload) {\n        const message = {\n            messagetype: type,\n            data: payload !== null && payload !== void 0 ? payload : null\n        };\n        this.sendMessage(message);\n    }\n    // Message frame handling\n    messageFromFrame(message) {\n        if (!(0, shared_1.isValidMessage)(message)) {\n            this.logError('Invalid message format:', message);\n            this.sendTypedMessage(shared_1.MessageTypes.ERROR, {\n                error: 'Invalid message format'\n            });\n            return;\n        }\n        this.messaging.handleIncomingMessage(message);\n    }\n}\nexports.ModelPanel = ModelPanel;\nModelPanel.LOG_PREFIX = '[ModelPanel]';\n\n\n//# sourceURL=webpack:///./src/panels/ModelPanel.ts?");

/***/ }),

/***/ "./src/services/accordion/ModelStructureBuilder.ts":
/*!*********************************************************!*\
  !*** ./src/services/accordion/ModelStructureBuilder.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelStructureBuilder = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nclass ModelStructureBuilder {\n    static buildModelStructure(modelData) {\n        console.group('ModelStructureBuilder.buildModelStructure');\n        if (!modelData) {\n            console.warn('Empty model data');\n            console.groupEnd();\n            return { elements: [], hierarchy: {} };\n        }\n        const elements = [];\n        const hierarchy = {};\n        // Create root node for ModelDefinition\n        const rootElement = {\n            id: modelData.id,\n            name: modelData.name,\n            type: shared_1.SimulationObjectType.Model,\n            hasChildren: true,\n            children: []\n        };\n        elements.push(rootElement);\n        // Create nodes for each manager type\n        const managerTypes = [\n            { id: 'activities', name: 'Activities', type: shared_1.SimulationObjectType.Activity, items: modelData.activities },\n            { id: 'connectors', name: 'Connectors', type: shared_1.SimulationObjectType.Connector, items: modelData.connectors },\n            { id: 'resources', name: 'Resources', type: shared_1.SimulationObjectType.Resource, items: modelData.resources },\n            { id: 'generators', name: 'Generators', type: shared_1.SimulationObjectType.Generator, items: modelData.generators },\n            { id: 'entities', name: 'Entities', type: shared_1.SimulationObjectType.Entity, items: modelData.entities }\n        ];\n        // Add manager nodes and their items\n        managerTypes.forEach(manager => {\n            const managerId = `${modelData.id}_${manager.id}`;\n            const managerElement = {\n                id: managerId,\n                name: manager.name,\n                type: manager.type,\n                hasChildren: manager.items.getAll().length > 0,\n                children: []\n            };\n            elements.push(managerElement);\n            hierarchy[modelData.id] = hierarchy[modelData.id] || [];\n            hierarchy[modelData.id].push(managerId);\n            // Add individual items under each manager\n            manager.items.getAll().forEach(item => {\n                const itemElement = {\n                    id: item.id,\n                    name: item.name,\n                    type: manager.type,\n                    hasChildren: false,\n                    children: []\n                };\n                elements.push(itemElement);\n                hierarchy[managerId] = hierarchy[managerId] || [];\n                hierarchy[managerId].push(item.id);\n            });\n        });\n        console.debug('Build complete:', { totalElements: elements.length });\n        console.groupEnd();\n        return { elements, hierarchy };\n    }\n}\nexports.ModelStructureBuilder = ModelStructureBuilder;\n\n\n//# sourceURL=webpack:///./src/services/accordion/ModelStructureBuilder.ts?");

/***/ }),

/***/ "./src/services/conversion/ConversionService.ts":
/*!******************************************************!*\
  !*** ./src/services/conversion/ConversionService.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConversionService = void 0;\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nconst shared_2 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nclass ConversionService extends shared_1.QuodsiLogger {\n    constructor(modelManager) {\n        super();\n        this.modelManager = modelManager;\n        this.LOG_PREFIX = '[ConversionService]';\n        // Get storageAdapter from modelManager if needed\n        this.storageAdapter = modelManager.getStorageAdapter();\n        this.setLogging(false);\n    }\n    /**\n     * Checks if a page can be converted to a model\n     */\n    canConvertPage(page) {\n        if (!page || !page.allBlocks || !page.allLines) {\n            return false;\n        }\n        // Check if page already has model data\n        if (this.storageAdapter.isQuodsiModel(page)) {\n            return false;\n        }\n        // Must have at least one block to be convertible\n        return page.allBlocks.size > 0;\n    }\n    /**\n     * Converts a LucidChart page to a Quodsi simulation model\n     */\n    async convertPage(page) {\n        this.log('[ConversionService] Starting page conversion');\n        try {\n            // First, remove any existing model data\n            if (this.storageAdapter.isQuodsiModel(page)) {\n                this.log('[ConversionService] Removing existing model data');\n                this.modelManager.removeModelFromPage(page);\n            }\n            // Initialize the model BEFORE doing anything else\n            const model = new shared_1.Model(page.id, page.getTitle() || 'New Model', shared_1.ModelDefaults.DEFAULT_REPS, shared_1.ModelDefaults.DEFAULT_FORECAST_DAYS, shared_1.ModelDefaults.DEFAULT_SEED, shared_1.ModelDefaults.DEFAULT_CLOCK_UNIT, shared_1.ModelDefaults.DEFAULT_SIMULATION_TIME_TYPE, shared_1.ModelDefaults.DEFAULT_WARMUP_PERIOD, shared_1.ModelDefaults.DEFAULT_CLOCK_UNIT, shared_1.ModelDefaults.DEFAULT_RUN_PERIOD, shared_1.ModelDefaults.DEFAULT_CLOCK_UNIT, null, null, null);\n            // Store the model data first\n            this.storageAdapter.setElementData(page, model, shared_1.SimulationObjectType.Model);\n            // Then initialize in the model manager\n            await this.modelManager.initializeModel(model, page);\n            // Verify model was initialized\n            if (!this.storageAdapter.isQuodsiModel(page)) {\n                throw new Error('Failed to initialize model on page');\n            }\n            // Now do the analysis and conversion\n            const analysis = this.analyzePage(page);\n            const convertedBlocks = await this.convertBlocks(page, analysis);\n            this.log('[ConversionService] Blocks converted:', convertedBlocks);\n            const convertedConnectors = await this.convertConnections(page, analysis);\n            this.log('[ConversionService] Connectors converted:', convertedConnectors);\n            const validationResult = await this.modelManager.validateModel();\n            this.log('[ConversionService] Validation result:', validationResult);\n            return {\n                success: true,\n                modelId: page.id,\n                elementCount: {\n                    activities: convertedBlocks.activities,\n                    generators: convertedBlocks.generators,\n                    resources: convertedBlocks.resources,\n                    connectors: convertedConnectors\n                }\n            };\n        }\n        catch (error) {\n            this.logError('[ConversionService] Conversion failed:', error);\n            throw error;\n        }\n    }\n    /**\n     * Analyzes the page structure\n     */\n    analyzePage(page) {\n        var _a, _b;\n        this.log('Analyzing page structure');\n        const blockAnalysis = new Map();\n        // Log all blocks first\n        this.log('All blocks:', Array.from(page.allBlocks.keys()));\n        this.log('All lines:', Array.from(page.allLines.keys()));\n        // Analyze connections\n        for (const [lineId, line] of page.allLines) {\n            const endpoint1 = line.getEndpoint1();\n            const endpoint2 = line.getEndpoint2();\n            this.log(`Analyzing line ${lineId}:`, {\n                hasEndpoint1Connection: !!(endpoint1 === null || endpoint1 === void 0 ? void 0 : endpoint1.connection),\n                hasEndpoint2Connection: !!(endpoint2 === null || endpoint2 === void 0 ? void 0 : endpoint2.connection),\n                endpoint1Id: (_a = endpoint1 === null || endpoint1 === void 0 ? void 0 : endpoint1.connection) === null || _a === void 0 ? void 0 : _a.id,\n                endpoint2Id: (_b = endpoint2 === null || endpoint2 === void 0 ? void 0 : endpoint2.connection) === null || _b === void 0 ? void 0 : _b.id\n            });\n            if (endpoint1.connection && endpoint2.connection) {\n                const sourceId = endpoint1.connection.id;\n                const targetId = endpoint2.connection.id;\n                // Update block analysis for both source and target\n                this.updateBlockAnalysis(blockAnalysis, sourceId, 'outgoing');\n                this.updateBlockAnalysis(blockAnalysis, targetId, 'incoming');\n            }\n        }\n        this.log('Pre-type determination analysis:', Array.from(blockAnalysis.entries()).map(([id, analysis]) => ({\n            id,\n            incomingCount: analysis.incomingCount,\n            outgoingCount: analysis.outgoingCount,\n            currentType: analysis.elementType\n        })));\n        // Determine element types based on connection patterns and block types\n        this.determineElementTypes(blockAnalysis, page);\n        return {\n            blockAnalysis\n        };\n    }\n    /**\n     * Initializes the model data on the page\n     */\n    async initializeModel(page) {\n        this.log('Initializing model');\n        const model = new shared_1.Model(page.id, page.getTitle() || 'New Model', shared_1.ModelDefaults.DEFAULT_REPS, shared_1.ModelDefaults.DEFAULT_FORECAST_DAYS, shared_1.ModelDefaults.DEFAULT_SEED, shared_1.ModelDefaults.DEFAULT_CLOCK_UNIT, shared_1.ModelDefaults.DEFAULT_SIMULATION_TIME_TYPE, shared_1.ModelDefaults.DEFAULT_WARMUP_PERIOD, shared_1.ModelDefaults.DEFAULT_CLOCK_UNIT, shared_1.ModelDefaults.DEFAULT_RUN_PERIOD, shared_1.ModelDefaults.DEFAULT_CLOCK_UNIT, null, null, null);\n        // Store model data and initialize in manager\n        this.modelManager.initializeModel(model, page);\n    }\n    /**\n     * Converts blocks to simulation elements\n     */\n    async convertBlocks(page, analysis) {\n        this.log('Starting block conversion');\n        let activities = 0;\n        let generators = 0;\n        let resources = 0;\n        for (const [blockId, block] of page.allBlocks) {\n            const blockAnalysis = analysis.blockAnalysis.get(blockId);\n            if (!(blockAnalysis === null || blockAnalysis === void 0 ? void 0 : blockAnalysis.elementType)) {\n                this.logError(`Missing element type for block ${blockId}`);\n                continue;\n            }\n            try {\n                this.log(`Creating element for block ${blockId}:`, {\n                    type: blockAnalysis.elementType,\n                    blockClass: block.getClassName()\n                });\n                // Create element using factory\n                const element = shared_2.SimulationObjectTypeFactory.createElement(blockAnalysis.elementType, blockId);\n                element.name = this.getBlockName(block);\n                // Store element data using StorageAdapter\n                this.storageAdapter.setElementData(block, // ElementProxy\n                element, // data object with id\n                blockAnalysis.elementType // SimulationObjectType\n                );\n                // Verify storage\n                const storedData = this.storageAdapter.getElementData(block);\n                this.log(`Stored element data verification for ${blockId}:`, storedData);\n                // Register with model manager\n                await this.modelManager.registerElement(element, block);\n                // Update counts\n                switch (blockAnalysis.elementType) {\n                    case shared_1.SimulationObjectType.Activity:\n                        activities++;\n                        break;\n                    case shared_1.SimulationObjectType.Generator:\n                        generators++;\n                        break;\n                    case shared_1.SimulationObjectType.Resource:\n                        resources++;\n                        break;\n                }\n                this.log(`Successfully converted block ${blockId}:`, {\n                    type: element.type,\n                    name: element.name,\n                    stored: !!storedData\n                });\n            }\n            catch (error) {\n                this.logError(`Failed to convert block ${blockId}:`, error);\n                throw error;\n            }\n        }\n        return { activities, generators, resources };\n    }\n    /**\n     * Converts connections to simulation connectors\n     */\n    async convertConnections(page, analysis) {\n        this.log('Converting connections');\n        let connectorCount = 0;\n        // First, calculate outgoing connections per block\n        const outgoingConnectionCounts = new Map();\n        for (const [lineId, line] of page.allLines) {\n            const endpoint1 = line.getEndpoint1();\n            if (endpoint1 === null || endpoint1 === void 0 ? void 0 : endpoint1.connection) {\n                const sourceId = endpoint1.connection.id;\n                outgoingConnectionCounts.set(sourceId, (outgoingConnectionCounts.get(sourceId) || 0) + 1);\n            }\n        }\n        this.log('Outgoing connection counts:', Array.from(outgoingConnectionCounts).reduce((obj, [key, value]) => {\n            obj[key] = value;\n            return obj;\n        }, {}));\n        // Now create connectors with calculated probabilities\n        for (const [lineId, line] of page.allLines) {\n            try {\n                this.log(`Processing line ${lineId}`);\n                const endpoint1 = line.getEndpoint1();\n                const endpoint2 = line.getEndpoint2();\n                if (!(endpoint1 === null || endpoint1 === void 0 ? void 0 : endpoint1.connection) || !(endpoint2 === null || endpoint2 === void 0 ? void 0 : endpoint2.connection)) {\n                    console.warn(`Line ${lineId} has invalid endpoints`);\n                    continue;\n                }\n                const sourceId = endpoint1.connection.id;\n                const outgoingCount = outgoingConnectionCounts.get(sourceId) || 1;\n                const probability = 1.0 / outgoingCount;\n                // Create connector using factory\n                const connector = shared_2.SimulationObjectTypeFactory.createElement(shared_1.SimulationObjectType.Connector, lineId);\n                // Set connector properties\n                connector.name = `Connector ${lineId}`;\n                connector.sourceId = sourceId;\n                connector.targetId = endpoint2.connection.id;\n                connector.probability = probability;\n                connector.connectType = shared_1.ConnectType.Probability;\n                // Store connector data\n                this.storageAdapter.setElementData(line, connector, shared_1.SimulationObjectType.Connector);\n                // Verify storage\n                const storedData = this.storageAdapter.getElementData(line);\n                this.log(`Stored connector data verification for ${lineId}:`, {\n                    sourceId: connector.sourceId,\n                    targetId: connector.targetId,\n                    probability: connector.probability,\n                    stored: !!storedData\n                });\n                // Register with model manager\n                await this.modelManager.registerElement(connector, line);\n                connectorCount++;\n            }\n            catch (error) {\n                this.logError(`Failed to convert connection ${lineId}:`, error);\n                throw error;\n            }\n        }\n        this.log(`Converted ${connectorCount} connections`);\n        return connectorCount;\n    }\n    /**\n     * Updates block analysis with connection information\n     */\n    updateBlockAnalysis(analysis, blockId, connectionType) {\n        let blockInfo = analysis.get(blockId);\n        if (!blockInfo) {\n            blockInfo = {\n                incomingCount: 0,\n                outgoingCount: 0,\n                elementType: undefined\n            };\n            analysis.set(blockId, blockInfo);\n        }\n        if (connectionType === 'incoming') {\n            blockInfo.incomingCount++;\n        }\n        else {\n            blockInfo.outgoingCount++;\n        }\n    }\n    /**\n     * Determines element types based on connection patterns\n     */\n    blockSpecificLogic(block, analysis) {\n        const blockClass = block.getClassName();\n        // Map specific block classes to simulation types\n        if (blockClass) {\n            if (blockClass === 'TerminatorBlockV2') {\n                analysis.elementType = shared_1.SimulationObjectType.Generator;\n            }\n            else if (blockClass === 'ProcessBlock' ||\n                blockClass === 'DecisionBlock' ||\n                blockClass === 'ActionBlock') {\n                analysis.elementType = shared_1.SimulationObjectType.Activity;\n            }\n            // Don't set Resource type based on block class alone\n        }\n    }\n    /**\n     * Determines element types based on connection patterns\n     */\n    determineElementTypes(blockAnalysis, page) {\n        this.log('Starting element type determination');\n        // First pass: Identify types based on block classes\n        for (const [blockId, block] of page.allBlocks) {\n            const analysis = blockAnalysis.get(blockId) || {\n                incomingCount: 0,\n                outgoingCount: 0,\n                elementType: undefined\n            };\n            blockAnalysis.set(blockId, analysis);\n            //this.blockSpecificLogic(block, analysis)\n        }\n        // Second pass: Use connection patterns for remaining untyped blocks\n        for (const [blockId, analysis] of blockAnalysis) {\n            if (!analysis.elementType) {\n                // Default to Activity for connected blocks\n                if (analysis.incomingCount === 0 && analysis.outgoingCount > 0) {\n                    analysis.elementType = shared_1.SimulationObjectType.Generator;\n                }\n                else if (analysis.incomingCount > 0) {\n                    analysis.elementType = shared_1.SimulationObjectType.Activity;\n                }\n                else {\n                    // For disconnected blocks, make them Resources\n                    // analysis.elementType = SimulationObjectType.Resource;\n                }\n            }\n        }\n        // Log final type determination\n        for (const [blockId, analysis] of blockAnalysis) {\n            this.log(`Final type for block ${blockId}:`, {\n                elementType: analysis.elementType,\n                incomingCount: analysis.incomingCount,\n                outgoingCount: analysis.outgoingCount\n            });\n        }\n    }\n    /**\n     * Gets a suitable name for a block\n     */\n    getBlockName(block) {\n        // Try to get text from the block's text areas\n        if (block.textAreas && block.textAreas.size > 0) {\n            for (const text of block.textAreas.values()) {\n                if (text && text.trim()) {\n                    return text.trim();\n                }\n            }\n        }\n        // Fallback to a generic name based on block type\n        const className = block.getClassName() || 'Block';\n        return `New ${className}`;\n    }\n}\nexports.ConversionService = ConversionService;\n\n\n//# sourceURL=webpack:///./src/services/conversion/ConversionService.ts?");

/***/ }),

/***/ "./src/services/conversion/RemoveModelFromPage.ts":
/*!********************************************************!*\
  !*** ./src/services/conversion/RemoveModelFromPage.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemoveModelFromPage = void 0;\nclass RemoveModelFromPage {\n    constructor(page, storageAdapter) {\n        this.page = page;\n        this.storageAdapter = storageAdapter;\n    }\n    /**\n     * Removes all model-related data from the page and its elements\n     */\n    removeModel() {\n        // Clear model data from page\n        this.storageAdapter.clearElementData(this.page);\n        // Clear data from all blocks\n        for (const [, block] of this.page.allBlocks) {\n            this.storageAdapter.clearElementData(block);\n        }\n        // Clear data from all lines\n        for (const [, line] of this.page.allLines) {\n            this.storageAdapter.clearElementData(line);\n        }\n    }\n    /**\n     * Clears all model-related data from an element\n     */\n    clearElementData(element) {\n        try {\n            // Clear data using StorageAdapter\n            this.storageAdapter.clearElementData(element);\n            // Clear legacy data properties\n            this.clearLegacyData(element);\n        }\n        catch (error) {\n            console.error(`[RemoveModelFromPage] Error clearing data from element ${element.id}:`, error);\n            throw error;\n        }\n    }\n    /**\n     * Clears legacy data properties (q_objecttype and q_data)\n     */\n    clearLegacyData(element) {\n        for (const key of RemoveModelFromPage.LEGACY_KEYS) {\n            try {\n                // Check if the property exists first\n                const value = element.shapeData.get(key);\n                if (value !== undefined) {\n                    try {\n                        element.shapeData.delete(key);\n                        console.log(`[RemoveModelFromPage] Successfully deleted '${key}' from element ${element.id}`);\n                    }\n                    catch (_a) {\n                        // If delete fails, try setting to empty string as fallback\n                        element.shapeData.set(key, '');\n                        console.log(`[RemoveModelFromPage] Set '${key}' to empty on element ${element.id} (delete failed)`);\n                    }\n                }\n                else {\n                    console.log(`[RemoveModelFromPage] No '${key}' found on element ${element.id}`);\n                }\n            }\n            catch (error) {\n                console.warn(`[RemoveModelFromPage] Error handling '${key}' for element ${element.id}:`, error);\n            }\n        }\n    }\n}\nexports.RemoveModelFromPage = RemoveModelFromPage;\nRemoveModelFromPage.LEGACY_KEYS = [\n    'q_objecttype',\n    'q_data',\n    'q_status_current',\n    'q_status_prior'\n];\n\n\n//# sourceURL=webpack:///./src/services/conversion/RemoveModelFromPage.ts?");

/***/ }),

/***/ "./src/services/validation/ActivityValidation.ts":
/*!*******************************************************!*\
  !*** ./src/services/validation/ActivityValidation.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ActivityValidation = void 0;\nconst ValidationRule_1 = __webpack_require__(/*! ./ValidationRule */ \"./src/services/validation/ValidationRule.ts\");\nconst ValidationMessages_1 = __webpack_require__(/*! ./ValidationMessages */ \"./src/services/validation/ValidationMessages.ts\");\nclass ActivityValidation extends ValidationRule_1.ValidationRule {\n    validate(state, messages) {\n        const activities = state.modelDefinition.activities.getAll();\n        activities.forEach(activity => {\n            this.validateActivityConnectivity(activity.id, state, messages);\n            this.validateActivityData(activity, messages);\n            this.validateOperationSequence(activity, state, messages);\n            this.validateBufferConstraints(activity, state, messages);\n        });\n        this.validateActivityInteractions(state, messages);\n    }\n    validateActivityConnectivity(activityId, state, messages) {\n        /**\n         * Validates that an activity is properly connected.\n         * Ensures it has at least one incoming or outgoing connection.\n         */\n        this.log(`Validating connectivity for Activity ID: ${activityId}`);\n        const relationships = state.activityRelationships.get(activityId);\n        if (!relationships) {\n            this.log(`Activity ID ${activityId} is isolated.`);\n            messages.push(ValidationMessages_1.ValidationMessages.isolatedElement(\"Activity\", activityId));\n            return;\n        }\n        if (relationships.incomingConnectors.size === 0 && relationships.outgoingConnectors.size === 0) {\n            this.log(`Activity ID ${activityId} has no incoming or outgoing connections.`);\n            messages.push(ValidationMessages_1.ValidationMessages.isolatedElement(\"Activity\", activityId));\n        }\n        if (relationships.incomingConnectors.size === 0) {\n            this.log(`Activity ID ${activityId} has no incoming connections.`);\n            messages.push(ValidationMessages_1.ValidationMessages.noConnections(\"Activity\", activityId, \"incoming\"));\n        }\n        if (relationships.outgoingConnectors.size === 0) {\n            this.log(`Activity ID ${activityId} has no outgoing connections.`);\n            messages.push(ValidationMessages_1.ValidationMessages.noConnections(\"Activity\", activityId, \"outgoing\"));\n        }\n    }\n    validateActivityData(activity, messages) {\n        /**\n         * Validates the core data of an activity, including its name, capacity, and buffer sizes.\n         */\n        var _a;\n        this.log(`Validating data for Activity ID: ${activity.id}`);\n        if (!((_a = activity.name) === null || _a === void 0 ? void 0 : _a.trim())) {\n            this.log(`Activity ID ${activity.id} has a missing name.`);\n            messages.push(ValidationMessages_1.ValidationMessages.missingName(\"Activity\", activity.id));\n        }\n        if (typeof activity.capacity !== \"number\" || activity.capacity < 1) {\n            this.log(`Activity ID ${activity.id} has an invalid capacity: ${activity.capacity}`);\n            messages.push(ValidationMessages_1.ValidationMessages.invalidCapacity(\"Activity\", activity.id));\n        }\n        this.validateBufferCapacities(activity, messages);\n        this.validateOperationSteps(activity, messages);\n    }\n    validateBufferCapacities(activity, messages) {\n        /**\n         * Validates the input and output buffer capacities of an activity.\n         */\n        this.log(`Validating buffer capacities for Activity ID: ${activity.id}`);\n        if (typeof activity.inputBufferCapacity !== \"number\" || activity.inputBufferCapacity < 0) {\n            this.log(`Activity ID ${activity.id} has an invalid input buffer capacity: ${activity.inputBufferCapacity}`);\n            messages.push(ValidationMessages_1.ValidationMessages.invalidBufferCapacity(\"Activity\", activity.id, \"input\"));\n        }\n        else if (activity.inputBufferCapacity > ActivityValidation.MAX_BUFFER_SIZE) {\n            this.log(`Activity ID ${activity.id} has a large input buffer capacity: ${activity.inputBufferCapacity}`);\n            messages.push(ValidationMessages_1.ValidationMessages.largeBufferCapacity(\"Activity\", activity.id, \"input\"));\n        }\n        if (typeof activity.outputBufferCapacity !== \"number\" || activity.outputBufferCapacity < 0) {\n            this.log(`Activity ID ${activity.id} has an invalid output buffer capacity: ${activity.outputBufferCapacity}`);\n            messages.push(ValidationMessages_1.ValidationMessages.invalidBufferCapacity(\"Activity\", activity.id, \"output\"));\n        }\n        else if (activity.outputBufferCapacity > ActivityValidation.MAX_BUFFER_SIZE) {\n            this.log(`Activity ID ${activity.id} has a large output buffer capacity: ${activity.outputBufferCapacity}`);\n            messages.push(ValidationMessages_1.ValidationMessages.largeBufferCapacity(\"Activity\", activity.id, \"output\"));\n        }\n    }\n    validateOperationSteps(activity, messages) {\n        /**\n         * Validates the operation steps defined for an activity.\n         */\n        this.log(`Validating operation steps for Activity ID: ${activity.id}`);\n        if (!Array.isArray(activity.operationSteps)) {\n            this.log(`Activity ID ${activity.id} has no operation steps defined.`);\n            messages.push(ValidationMessages_1.ValidationMessages.missingOperationSteps(activity.id));\n            return;\n        }\n        if (activity.operationSteps.length === 0) {\n            this.log(`Activity ID ${activity.id} has an empty operation step list.`);\n            messages.push(ValidationMessages_1.ValidationMessages.noOperationSteps(activity.id));\n            return;\n        }\n        activity.operationSteps.forEach((step, index) => {\n            this.validateOperationStep(activity.id, step, index, messages);\n        });\n    }\n    validateOperationStep(activityId, step, index, messages) {\n        /**\n         * Validates a single operation step within an activity.\n         */\n        var _a, _b;\n        this.log(`Validating operation step ${index + 1} for Activity ID: ${activityId}`);\n        if (!((_a = step.duration) === null || _a === void 0 ? void 0 : _a.durationLength)) {\n            this.log(`Operation step ${index + 1} for Activity ID ${activityId} has an invalid duration.`);\n            messages.push(ValidationMessages_1.ValidationMessages.invalidStepDuration(activityId, index + 1));\n        }\n        else {\n            const duration = step.duration.durationLength;\n            if (duration < ActivityValidation.MIN_CYCLE_TIME || duration > ActivityValidation.MAX_CYCLE_TIME) {\n                this.log(`Operation step ${index + 1} for Activity ID ${activityId} has an unusual duration: ${duration}`);\n                messages.push(ValidationMessages_1.ValidationMessages.unusualStepDuration(activityId, index + 1, duration));\n            }\n        }\n        if ((_b = step.resourceSetRequest) === null || _b === void 0 ? void 0 : _b.requests) {\n            this.validateResourceRequests(activityId, step.resourceSetRequest.requests, index, messages);\n        }\n    }\n    validateResourceRequests(activityId, requests, stepIndex, messages) {\n        /**\n         * Validates resource requests within an operation step for potential issues.\n         */\n        this.log(`Validating resource requests for step ${stepIndex + 1} of Activity ID: ${activityId}`);\n        const seenResources = new Set();\n        requests.forEach(request => {\n            var _a;\n            if ((_a = request.resource) === null || _a === void 0 ? void 0 : _a.id) {\n                if (seenResources.has(request.resource.id)) {\n                    this.log(`Duplicate resource request detected for step ${stepIndex + 1} of Activity ID ${activityId}`);\n                    messages.push(ValidationMessages_1.ValidationMessages.duplicateResourceRequest(activityId, stepIndex + 1));\n                }\n                seenResources.add(request.resource.id);\n                if (typeof request.quantity !== \"number\" || request.quantity < 1) {\n                    this.log(`Invalid resource quantity for step ${stepIndex + 1} of Activity ID ${activityId}`);\n                    messages.push(ValidationMessages_1.ValidationMessages.invalidResourceQuantity(activityId, stepIndex + 1));\n                }\n            }\n        });\n    }\n    validateBufferConstraints(activity, state, messages) {\n        /**\n         * Validates that buffer constraints are sufficient to handle incoming flow.\n         */\n        this.log(`Validating buffer constraints for Activity ID: ${activity.id}`);\n        const relationships = state.activityRelationships.get(activity.id);\n        if (!relationships)\n            return;\n        const incomingCapacity = Array.from(relationships.incomingConnectors).reduce((total, connectorId) => {\n            const connector = state.connections.get(connectorId);\n            if (connector) {\n                const sourceActivity = state.modelDefinition.activities.get(connector.sourceId);\n                if (sourceActivity) {\n                    total += sourceActivity.capacity;\n                }\n            }\n            return total;\n        }, 0);\n        if (incomingCapacity > activity.inputBufferCapacity * 2) {\n            this.log(`Activity ID ${activity.id} has insufficient input buffer capacity.`);\n            messages.push(ValidationMessages_1.ValidationMessages.smallInputBuffer(activity.id));\n        }\n    }\n    validateActivityInteractions(state, messages) {\n        /**\n         * Validates interactions among activities to detect deadlocks or circular dependencies.\n         */\n        this.log(\"Validating activity interactions for potential deadlocks.\");\n        const activities = state.modelDefinition.activities.getAll();\n        const visited = new Set();\n        const stack = new Set();\n        activities.forEach(activity => {\n            if (!visited.has(activity.id)) {\n                this.detectCycles(activity.id, state, visited, stack, messages);\n            }\n        });\n    }\n    detectCycles(activityId, state, visited, stack, messages) {\n        /**\n         * Detects cycles within the activity graph.\n         */\n        visited.add(activityId);\n        stack.add(activityId);\n        const relationships = state.activityRelationships.get(activityId);\n        if (relationships) {\n            relationships.outgoingConnectors.forEach(connectorId => {\n                const connector = state.connections.get(connectorId);\n                if (connector) {\n                    const targetId = connector.targetId;\n                    if (!visited.has(targetId)) {\n                        this.detectCycles(targetId, state, visited, stack, messages);\n                    }\n                    else if (stack.has(targetId)) {\n                        this.log(`Circular dependency detected involving Activity ID ${activityId}`);\n                        messages.push(ValidationMessages_1.ValidationMessages.circularDependency(activityId));\n                    }\n                }\n            });\n        }\n        stack.delete(activityId);\n    }\n    validateOperationSequence(activity, state, messages) {\n        /**\n         * Validates the sequence of operations within an activity to ensure logical consistency.\n         */\n        var _a;\n        this.log(`Validating operation sequence for Activity ID: ${activity.id}`);\n        if (!((_a = activity.operationSteps) === null || _a === void 0 ? void 0 : _a.length))\n            return;\n        let hasResourceRequest = false;\n        activity.operationSteps.forEach((step, index) => {\n            var _a, _b;\n            if ((_b = (_a = step.resourceSetRequest) === null || _a === void 0 ? void 0 : _a.requests) === null || _b === void 0 ? void 0 : _b.length) {\n                hasResourceRequest = true;\n            }\n        });\n        if (hasResourceRequest) {\n            this.log(`Resource requests detected but no release logic for Activity ID: ${activity.id}`);\n            messages.push(ValidationMessages_1.ValidationMessages.resourceLeak(activity.id));\n        }\n    }\n}\nexports.ActivityValidation = ActivityValidation;\nActivityValidation.MAX_BUFFER_SIZE = 10000;\nActivityValidation.MIN_CYCLE_TIME = 0.001;\nActivityValidation.MAX_CYCLE_TIME = 86400; // 24 hours in seconds\n\n\n//# sourceURL=webpack:///./src/services/validation/ActivityValidation.ts?");

/***/ }),

/***/ "./src/services/validation/ConnectorValidation.ts":
/*!********************************************************!*\
  !*** ./src/services/validation/ConnectorValidation.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectorValidation = void 0;\nconst ValidationRule_1 = __webpack_require__(/*! ./ValidationRule */ \"./src/services/validation/ValidationRule.ts\");\nconst ValidationMessages_1 = __webpack_require__(/*! ./ValidationMessages */ \"./src/services/validation/ValidationMessages.ts\");\nconst shared_1 = __webpack_require__(/*! @quodsi/shared */ \"../../shared/dist/index.js\");\nclass ConnectorValidation extends ValidationRule_1.ValidationRule {\n    validate(state, messages) {\n        const connectors = state.modelDefinition.connectors.getAll();\n        const connectorsBySource = this.groupConnectorsBySource(connectors);\n        this.log(\"Starting validation of individual connectors.\");\n        connectors.forEach(connector => {\n            this.validateConnectorEndpoints(connector, state, messages);\n            this.validateConnectorData(connector, messages);\n            this.validateConnectorType(connector, messages);\n        });\n        this.log(\"Validating probability distributions for connector groups.\");\n        connectorsBySource.forEach((sourceConnectors, sourceId) => {\n            this.validateProbabilityGroup(sourceId, sourceConnectors, messages);\n        });\n        this.log(\"Detecting circular references in connectors.\");\n        this.detectCircularReferences(state, messages);\n        this.log(\"Completed validation of connectors.\");\n    }\n    groupConnectorsBySource(connectors) {\n        const groups = new Map();\n        connectors.forEach(connector => {\n            const sourceConnectors = groups.get(connector.sourceId) || [];\n            sourceConnectors.push(connector);\n            groups.set(connector.sourceId, sourceConnectors);\n        });\n        return groups;\n    }\n    validateConnectorEndpoints(connector, state, messages) {\n        /**\n         * Validates that the endpoints of a connector (source and target) are valid.\n         */\n        this.log(`Validating endpoints for Connector ID: ${connector.id}`);\n        const sourceActivity = state.modelDefinition.activities.get(connector.sourceId);\n        if (!sourceActivity) {\n            this.log(`Connector ID ${connector.id} has an invalid source ID: ${connector.sourceId}`);\n            messages.push(ValidationMessages_1.ValidationMessages.invalidConnection(connector.id, 'source', connector.sourceId));\n        }\n        const targetActivity = state.modelDefinition.activities.get(connector.targetId);\n        if (!targetActivity) {\n            this.log(`Connector ID ${connector.id} has an invalid target ID: ${connector.targetId}`);\n            messages.push(ValidationMessages_1.ValidationMessages.invalidConnection(connector.id, 'target', connector.targetId));\n        }\n        if (connector.sourceId === connector.targetId) {\n            this.log(`Connector ID ${connector.id} is self-referencing.`);\n            messages.push(ValidationMessages_1.ValidationMessages.isolatedElement('Connector', connector.id));\n        }\n    }\n    validateConnectorData(connector, messages) {\n        /**\n         * Validates the data properties of a connector, including name, probability, and operation steps.\n         */\n        this.log(`Validating data for Connector ID: ${connector.id}`);\n        if (!connector.name || connector.name.trim().length === 0) {\n            this.log(`Connector ID ${connector.id} has a missing name.`);\n            messages.push(ValidationMessages_1.ValidationMessages.missingName('Connector', connector.id));\n        }\n        if (typeof connector.probability !== 'number' ||\n            connector.probability < 0 ||\n            connector.probability > 1) {\n            this.log(`Connector ID ${connector.id} has an invalid probability: ${connector.probability}`);\n            messages.push({\n                type: 'error',\n                message: `Connector ${connector.id} has invalid probability (must be between 0 and 1)`,\n                elementId: connector.id\n            });\n        }\n        if (connector.operationSteps && connector.operationSteps.length > 0) {\n            connector.operationSteps.forEach((step, index) => {\n                if (!step.duration) {\n                    this.log(`Connector ID ${connector.id} operation step ${index + 1} has no duration.`);\n                    messages.push({\n                        type: 'error',\n                        message: `Connector ${connector.id} operation step ${index + 1} has no duration specified`,\n                        elementId: connector.id\n                    });\n                }\n            });\n        }\n    }\n    validateConnectorType(connector, messages) {\n        /**\n         * Validates the type of the connector to ensure it is a valid `ConnectType`.\n         */\n        this.log(`Validating type for Connector ID: ${connector.id}`);\n        if (!Object.values(shared_1.ConnectType).includes(connector.connectType)) {\n            this.log(`Connector ID ${connector.id} has an invalid connect type: ${connector.connectType}`);\n            messages.push({\n                type: 'error',\n                message: `Connector ${connector.id} has invalid connect type: ${connector.connectType}`,\n                elementId: connector.id\n            });\n        }\n    }\n    validateProbabilityGroup(sourceId, connectors, messages) {\n        /**\n         * Validates the probability distribution of connectors originating from the same source.\n         */\n        this.log(`Validating probability group for Source ID: ${sourceId}`);\n        const probabilityConnectors = connectors.filter(c => c.connectType === shared_1.ConnectType.Probability);\n        if (probabilityConnectors.length > 0) {\n            const totalProbability = probabilityConnectors.reduce((sum, connector) => sum + connector.probability, 0);\n            if (Math.abs(totalProbability - 1.0) > ConnectorValidation.PROBABILITY_TOLERANCE) {\n                this.log(`Probability sum for Source ID ${sourceId} is invalid: ${totalProbability.toFixed(4)}`);\n                messages.push({\n                    type: 'error',\n                    message: `Outgoing connection probabilities from activity ${sourceId} sum to ${totalProbability.toFixed(4)} (should be 1.0)`,\n                    elementId: sourceId\n                });\n            }\n        }\n        if (connectors.length > ConnectorValidation.MAX_OUTGOING_CONNECTIONS) {\n            this.log(`Source ID ${sourceId} has too many outgoing connections: ${connectors.length}`);\n            messages.push({\n                type: 'warning',\n                message: `Activity ${sourceId} has unusually high number of outgoing connections (${connectors.length})`,\n                elementId: sourceId\n            });\n        }\n    }\n    detectCircularReferences(state, messages) {\n        /**\n         * Detects circular references in the graph of connectors.\n         */\n        this.log(\"Detecting circular references in connectors.\");\n        const visited = new Set();\n        const stack = new Set();\n        const detectCycle = (nodeId, path = []) => {\n            if (stack.has(nodeId)) {\n                this.log(`Circular reference detected: ${[...path, nodeId].join(' -> ')}`);\n                messages.push({\n                    type: 'warning',\n                    message: `Circular reference detected: ${[...path, nodeId].join(' -> ')}`,\n                    elementId: nodeId\n                });\n                return true;\n            }\n            if (visited.has(nodeId))\n                return false;\n            visited.add(nodeId);\n            stack.add(nodeId);\n            const outgoingConnectors = state.modelDefinition.connectors.getAll()\n                .filter(c => c.sourceId === nodeId);\n            for (const connector of outgoingConnectors) {\n                if (detectCycle(connector.targetId, [...path, nodeId])) {\n                    return true;\n                }\n            }\n            stack.delete(nodeId);\n            return false;\n        };\n        state.modelDefinition.activities.getAll().forEach(activity => {\n            if (!visited.has(activity.id)) {\n                detectCycle(activity.id);\n            }\n        });\n    }\n}\nexports.ConnectorValidation = ConnectorValidation;\nConnectorValidation.PROBABILITY_TOLERANCE = 0.0001;\nConnectorValidation.MAX_OUTGOING_CONNECTIONS = 20;\n\n\n//# sourceURL=webpack:///./src/services/validation/ConnectorValidation.ts?");

/***/ }),

/***/ "./src/services/validation/ElementCountsValidation.ts":
/*!************************************************************!*\
  !*** ./src/services/validation/ElementCountsValidation.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ElementCountsValidation = void 0;\nconst ValidationRule_1 = __webpack_require__(/*! ./ValidationRule */ \"./src/services/validation/ValidationRule.ts\");\n/**\n * Validates basic element counts and requirements.\n */\nclass ElementCountsValidation extends ValidationRule_1.ValidationRule {\n    validate(state, messages) {\n        const { modelDefinition } = state;\n        this.log(\"Starting validation of element counts.\");\n        if (modelDefinition.generators.size() === 0) {\n            this.log(\"Validation failed: Model has no generators.\");\n            messages.push({\n                type: 'error',\n                message: 'Model must have at least one generator'\n            });\n        }\n        if (modelDefinition.activities.size() === 0) {\n            this.log(\"Validation failed: Model has no activities.\");\n            messages.push({\n                type: 'error',\n                message: 'Model must have at least one activity'\n            });\n        }\n        if (modelDefinition.resources.size() === 0) {\n            this.log(\"Validation warning: Model has no resources defined.\");\n            messages.push({\n                type: 'warning',\n                message: 'Model has no resources defined'\n            });\n        }\n        if (modelDefinition.entities.size() === 0) {\n            this.log(\"Validation failed: Model has no entities.\");\n            messages.push({\n                type: 'error',\n                message: 'Model must have at least one entity'\n            });\n        }\n        this.log(\"Completed validation of element counts.\");\n    }\n}\nexports.ElementCountsValidation = ElementCountsValidation;\n\n\n//# sourceURL=webpack:///./src/services/validation/ElementCountsValidation.ts?");

/***/ }),

/***/ "./src/services/validation/EntityValidation.ts":
/*!*****************************************************!*\
  !*** ./src/services/validation/EntityValidation.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityValidation = void 0;\nconst ValidationRule_1 = __webpack_require__(/*! ./ValidationRule */ \"./src/services/validation/ValidationRule.ts\");\nconst ValidationMessages_1 = __webpack_require__(/*! ./ValidationMessages */ \"./src/services/validation/ValidationMessages.ts\");\nclass EntityValidation extends ValidationRule_1.ValidationRule {\n    validate(state, messages) {\n        const entities = state.modelDefinition.entities.getAll();\n        this.log(\"Starting validation of entities.\");\n        // Check if there's at least one entity defined\n        if (entities.length === 0) {\n            this.log(\"Validation failed: No entities defined.\");\n            messages.push(ValidationMessages_1.ValidationMessages.missingRequiredElement('entity'));\n            return;\n        }\n        // Validate each entity\n        entities.forEach(entity => {\n            this.validateEntityData(entity, messages);\n            this.validateEntityUsage(entity, state, messages);\n        });\n        this.log(\"Completed validation of entities.\");\n    }\n    validateEntityData(entity, messages) {\n        /**\n         * Validates the basic data properties of an entity.\n         */\n        this.log(`Validating data for Entity ID: ${entity.id}`);\n        if (!entity.name || entity.name.trim().length === 0) {\n            this.log(`Entity ID ${entity.id} has a missing name.`);\n            messages.push(ValidationMessages_1.ValidationMessages.missingName('Entity', entity.id));\n        }\n        if (!entity.id || entity.id.trim().length === 0) {\n            this.log(`Entity ID ${entity.id} has missing or invalid ID.`);\n            messages.push({\n                type: 'error',\n                message: `Entity has missing or invalid ID`,\n                elementId: entity.id\n            });\n        }\n        if (entity.name === 'New Entity') {\n            this.log(`Entity ID ${entity.id} is using the default name.`);\n            messages.push({\n                type: 'warning',\n                message: `Entity ${entity.id} is using default name`,\n                elementId: entity.id\n            });\n        }\n    }\n    validateEntityUsage(entity, state, messages) {\n        /**\n         * Validates the usage of an entity within the model.\n         */\n        this.log(`Validating usage for Entity ID: ${entity.id}`);\n        const isUsedByGenerator = state.modelDefinition.generators.getAll()\n            .some(generator => generator.entityId === entity.id);\n        if (!isUsedByGenerator) {\n            this.log(`Entity ID ${entity.id} is not used by any generator.`);\n            messages.push({\n                type: 'warning',\n                message: `Entity ${entity.id} is not used by any generator`,\n                elementId: entity.id\n            });\n        }\n        const entities = state.modelDefinition.entities.getAll();\n        const duplicateNames = entities.filter(e => e.id !== entity.id && e.name.trim().toLowerCase() === entity.name.trim().toLowerCase());\n        if (duplicateNames.length > 0) {\n            this.log(`Entity ID ${entity.id} has a name conflict with other entities.`);\n            messages.push({\n                type: 'warning',\n                message: `Entity ${entity.id} has a name that conflicts with other entities`,\n                elementId: entity.id\n            });\n        }\n    }\n}\nexports.EntityValidation = EntityValidation;\n\n\n//# sourceURL=webpack:///./src/services/validation/EntityValidation.ts?");

/***/ }),

/***/ "./src/services/validation/GeneratorValidation.ts":
/*!********************************************************!*\
  !*** ./src/services/validation/GeneratorValidation.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GeneratorValidation = void 0;\nconst ValidationRule_1 = __webpack_require__(/*! ./ValidationRule */ \"./src/services/validation/ValidationRule.ts\");\nconst ValidationMessages_1 = __webpack_require__(/*! ./ValidationMessages */ \"./src/services/validation/ValidationMessages.ts\");\nclass GeneratorValidation extends ValidationRule_1.ValidationRule {\n    validate(state, messages) {\n        const generators = state.modelDefinition.generators.getAll();\n        generators.forEach(generator => {\n            this.validateGeneratorConnectivity(generator, state, messages);\n            this.validateGeneratorData(generator, state, messages);\n            this.validateDurationSettings(generator, messages);\n            this.validateEntitySettings(generator, state, messages);\n        });\n        this.validateGeneratorInteractions(generators, messages);\n    }\n    validateGeneratorConnectivity(generator, state, messages) {\n        /**\n         * Validates the connectivity of a Generator to ensure it has at least one outgoing connection.\n         * Logs the validation process and any connectivity issues if logging is enabled.\n         */\n        this.log(`Starting connectivity validation for Generator ID: ${generator.id}, Name: ${generator.name}`);\n        // Check for outgoing connections using the connections map\n        const hasOutgoingConnections = Array.from(state.connections.values())\n            .some(connection => connection.sourceId === generator.id);\n        if (!hasOutgoingConnections) {\n            this.log(`Validation failed: Generator ID ${generator.id} has no outgoing connections.`);\n            messages.push(ValidationMessages_1.ValidationMessages.isolatedElement('Generator', generator.id));\n        }\n        else {\n            this.log(`Validation passed: Generator ID ${generator.id} has outgoing connections.`);\n        }\n        this.log(`Completed connectivity validation for Generator ID: ${generator.id}`);\n    }\n    validateGeneratorData(generator, state, messages) {\n        /**\n         * Validates the data properties of a given Generator.\n         * Ensures the Generator has a valid name, valid entities per creation,\n         * periodic occurrences, max entities constraints, and referenced activity key IDs exist.\n         */\n        this.log(`Starting validation for Generator ID: ${generator.id}, Name: ${generator.name}`);\n        // Validate the Generator's name\n        if (!generator.name || generator.name.trim().length === 0) {\n            this.log(`Validation failed: Generator ID ${generator.id} has an empty or missing name.`);\n            messages.push(ValidationMessages_1.ValidationMessages.missingName('Generator', generator.id));\n        }\n        // Validate entities per creation\n        if (typeof generator.entitiesPerCreation !== 'number' ||\n            generator.entitiesPerCreation < GeneratorValidation.MIN_ENTITIES_PER_CREATION ||\n            generator.entitiesPerCreation > GeneratorValidation.MAX_ENTITIES_PER_CREATION) {\n            this.log(`Validation failed: Generator ID ${generator.id} has invalid entitiesPerCreation (${generator.entitiesPerCreation}).`);\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('entities per creation', generator.id, `Must be between ${GeneratorValidation.MIN_ENTITIES_PER_CREATION} and ${GeneratorValidation.MAX_ENTITIES_PER_CREATION}`));\n        }\n        // Validate periodic occurrences\n        if (generator.periodicOccurrences !== Infinity &&\n            (typeof generator.periodicOccurrences !== 'number' ||\n                generator.periodicOccurrences < GeneratorValidation.MIN_PERIODIC_OCCURRENCES)) {\n            this.log(`Validation failed: Generator ID ${generator.id} has invalid periodicOccurrences (${generator.periodicOccurrences}).`);\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('periodic occurrences', generator.id, 'Must be Infinity or a number greater than 0'));\n        }\n        // Validate maxEntities\n        if (generator.maxEntities !== Infinity &&\n            (typeof generator.maxEntities !== 'number' ||\n                generator.maxEntities < GeneratorValidation.MIN_MAX_ENTITIES ||\n                generator.maxEntities > GeneratorValidation.MAX_MAX_ENTITIES)) {\n            this.log(`Validation failed: Generator ID ${generator.id} has invalid maxEntities (${generator.maxEntities}).`);\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('maximum entities limit', generator.id, `Must be Infinity or between ${GeneratorValidation.MIN_MAX_ENTITIES} and ${GeneratorValidation.MAX_MAX_ENTITIES}`));\n        }\n        // Validate activity key ID if specified\n        if (generator.activityKeyId) {\n            const activityExists = state.modelDefinition.activities.get(generator.activityKeyId);\n            if (!activityExists) {\n                this.log(`Validation failed: Generator ID ${generator.id} references a non-existent activity (${generator.activityKeyId}).`);\n                messages.push({\n                    type: 'error',\n                    message: `Generator ${generator.id} references non-existent activity ${generator.activityKeyId}`,\n                    elementId: generator.id\n                });\n            }\n        }\n        this.log(`Completed validation for Generator ID: ${generator.id}`);\n    }\n    validateDurationSettings(generator, messages) {\n        /**\n         * Validates the duration settings of a Generator.\n         * Ensures that the period interval duration and start duration are valid and logically consistent.\n         */\n        var _a, _b;\n        this.log(`Starting duration settings validation for Generator ID: ${generator.id}`);\n        if (!generator.periodIntervalDuration || !generator.periodIntervalDuration.durationLength) {\n            this.log(`Validation failed: Generator ID ${generator.id} has invalid period interval duration.`);\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('period interval duration', generator.id, 'Must have a valid duration length'));\n        }\n        if (!generator.periodicStartDuration || !generator.periodicStartDuration.durationLength) {\n            this.log(`Validation failed: Generator ID ${generator.id} has invalid periodic start duration.`);\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('periodic start duration', generator.id, 'Must have a valid duration length'));\n        }\n        if (((_a = generator.periodIntervalDuration) === null || _a === void 0 ? void 0 : _a.durationLength) && ((_b = generator.periodicStartDuration) === null || _b === void 0 ? void 0 : _b.durationLength)) {\n            if (generator.periodicStartDuration.durationLength > generator.periodIntervalDuration.durationLength) {\n                this.log(`Warning: Generator ID ${generator.id} has start duration longer than interval duration.`);\n                messages.push({\n                    type: 'warning',\n                    message: `Generator ${generator.id} has start duration longer than interval duration`,\n                    elementId: generator.id\n                });\n            }\n        }\n        this.log(`Completed duration settings validation for Generator ID: ${generator.id}`);\n    }\n    validateEntitySettings(generator, state, messages) {\n        /**\n         * Validates the entity-related settings of a Generator.\n         * Ensures entity references exist and constraints on entity creation are valid.\n         */\n        this.log(`Starting entity settings validation for Generator ID: ${generator.id}`);\n        if (!generator.entityId) {\n            this.log(`Validation failed: Generator ID ${generator.id} does not specify an entity ID.`);\n            messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('entity reference', generator.id, 'Must specify an entity ID'));\n        }\n        else {\n            const entityExists = state.modelDefinition.entities.get(generator.entityId);\n            if (!entityExists) {\n                this.log(`Validation failed: Generator ID ${generator.id} references a non-existent entity (${generator.entityId}).`);\n                messages.push(ValidationMessages_1.ValidationMessages.generatorValidation('entity reference', generator.id, `References non-existent entity ${generator.entityId}`));\n            }\n        }\n        if (generator.periodicOccurrences !== Infinity && generator.maxEntities !== Infinity) {\n            const totalEntities = generator.periodicOccurrences * generator.entitiesPerCreation;\n            if (totalEntities > generator.maxEntities) {\n                this.log(`Warning: Generator ID ${generator.id} may exceed maximum entities limit.`);\n                messages.push({\n                    type: 'warning',\n                    message: `Generator ${generator.id} may reach maximum entities limit before completing all periodic occurrences`,\n                    elementId: generator.id\n                });\n            }\n        }\n        this.log(`Completed entity settings validation for Generator ID: ${generator.id}`);\n    }\n    validateGeneratorInteractions(generators, messages) {\n        /**\n         * Validates interactions among multiple Generators.\n         * Checks for overlapping start times and potential system overload due to high entity generation rates.\n         */\n        var _a;\n        this.log(`Starting generator interactions validation.`);\n        const startTimes = new Map();\n        generators.forEach(generator => {\n            var _a;\n            const startTime = ((_a = generator.periodicStartDuration) === null || _a === void 0 ? void 0 : _a.durationLength) || 0;\n            const existingGenerators = startTimes.get(startTime) || [];\n            existingGenerators.push(generator);\n            startTimes.set(startTime, existingGenerators);\n        });\n        startTimes.forEach((overlappingGenerators, startTime) => {\n            if (overlappingGenerators.length > 1) {\n                this.log(`Warning: Overlapping start times detected for Generators: ${overlappingGenerators.map(g => g.id).join(', ')} at time ${startTime}.`);\n                messages.push({\n                    type: 'warning',\n                    message: `Multiple generators (${overlappingGenerators.map(g => g.id).join(', ')}) start at the same time (${startTime})`,\n                    elementId: overlappingGenerators[0].id\n                });\n            }\n        });\n        let totalEntitiesPerSecond = 0;\n        generators.forEach(generator => {\n            var _a;\n            if ((_a = generator.periodIntervalDuration) === null || _a === void 0 ? void 0 : _a.durationLength) {\n                const generatorRate = generator.entitiesPerCreation / generator.periodIntervalDuration.durationLength;\n                totalEntitiesPerSecond += generatorRate;\n            }\n        });\n        if (totalEntitiesPerSecond > 1000) {\n            this.log(`Warning: High entity generation rate detected (${totalEntitiesPerSecond.toFixed(2)} entities/second).`);\n            messages.push({\n                type: 'warning',\n                message: `High entity generation rate detected (${totalEntitiesPerSecond.toFixed(2)} entities/second)`,\n                elementId: (_a = generators[0]) === null || _a === void 0 ? void 0 : _a.id\n            });\n        }\n        this.log(`Completed generator interactions validation.`);\n    }\n}\nexports.GeneratorValidation = GeneratorValidation;\n// Constants for validation limits\nGeneratorValidation.MIN_ENTITIES_PER_CREATION = 1;\nGeneratorValidation.MAX_ENTITIES_PER_CREATION = 1000;\nGeneratorValidation.MIN_PERIODIC_OCCURRENCES = 1;\nGeneratorValidation.MIN_MAX_ENTITIES = 1;\nGeneratorValidation.MAX_MAX_ENTITIES = 1000000;\n\n\n//# sourceURL=webpack:///./src/services/validation/GeneratorValidation.ts?");

/***/ }),

/***/ "./src/services/validation/ModelValidationService.ts":
/*!***********************************************************!*\
  !*** ./src/services/validation/ModelValidationService.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelValidationService = void 0;\nconst ActivityValidation_1 = __webpack_require__(/*! ./ActivityValidation */ \"./src/services/validation/ActivityValidation.ts\");\nconst ConnectorValidation_1 = __webpack_require__(/*! ./ConnectorValidation */ \"./src/services/validation/ConnectorValidation.ts\");\nconst ElementCountsValidation_1 = __webpack_require__(/*! ./ElementCountsValidation */ \"./src/services/validation/ElementCountsValidation.ts\");\nconst GeneratorValidation_1 = __webpack_require__(/*! ./GeneratorValidation */ \"./src/services/validation/GeneratorValidation.ts\");\nconst ResourceValidation_1 = __webpack_require__(/*! ./ResourceValidation */ \"./src/services/validation/ResourceValidation.ts\");\nconst ValidationMessages_1 = __webpack_require__(/*! ./ValidationMessages */ \"./src/services/validation/ValidationMessages.ts\");\nconst EntityValidation_1 = __webpack_require__(/*! ./EntityValidation */ \"./src/services/validation/EntityValidation.ts\");\nclass ModelValidationService {\n    constructor() {\n        this.cachedState = null;\n        this.lastModelDefinitionHash = null;\n        this.rules = [\n            new ElementCountsValidation_1.ElementCountsValidation(),\n            new ActivityValidation_1.ActivityValidation(),\n            new ConnectorValidation_1.ConnectorValidation(),\n            new GeneratorValidation_1.GeneratorValidation(),\n            new ResourceValidation_1.ResourceValidation(),\n            new EntityValidation_1.EntityValidation()\n        ];\n    }\n    validate(modelDefinition) {\n        const messages = [];\n        // ModelDefinitionLogger.log(modelDefinition)\n        try {\n            // Generate a hash of the model definition for cache comparison\n            const currentHash = this.generateModelHash(modelDefinition);\n            // Create or retrieve cached ModelState\n            const state = this.getModelState(modelDefinition, currentHash);\n            // Batch validate all rules\n            this.batchValidate(state, messages);\n            // Add success message if no issues found\n            if (messages.length === 0) {\n                messages.push(ValidationMessages_1.ValidationMessages.validationSuccess());\n            }\n            // Calculate validation metrics\n            const result = this.calculateValidationMetrics(messages);\n            // Log validation results\n            this.logValidationResults(result);\n            return result;\n        }\n        catch (error) {\n            console.error('[ModelValidation] Validation error:', error);\n            return {\n                isValid: false,\n                errorCount: 1,\n                warningCount: 0,\n                messages: [ValidationMessages_1.ValidationMessages.validationError(error)]\n            };\n        }\n    }\n    /**\n     * Enable or disable logging for a specific validation rule by its class name.\n     * @param ruleName - The class name of the validation rule.\n     * @param enabled - True to enable logging, false to disable.\n     */\n    setRuleLogging(ruleName, enabled) {\n        const rule = this.rules.find(r => r.constructor.name === ruleName);\n        if (rule) {\n            rule.setLogging(enabled);\n            console.log(`[ModelValidationService] Logging for ${ruleName} set to ${enabled}`);\n        }\n        else {\n            console.warn(`[ModelValidationService] Validation rule ${ruleName} not found.`);\n        }\n    }\n    generateModelHash(modelDefinition) {\n        // Create a simple hash based on model contents\n        const activities = modelDefinition.activities.size();\n        const connectors = modelDefinition.connectors.size();\n        const resources = modelDefinition.resources.size();\n        const generators = modelDefinition.generators.size();\n        return `${activities}-${connectors}-${resources}-${generators}`;\n    }\n    getModelState(modelDefinition, currentHash) {\n        // Reuse cached state if model hasn't changed\n        if (this.cachedState && this.lastModelDefinitionHash === currentHash) {\n            return this.cachedState;\n        }\n        // Create new state\n        const state = {\n            modelDefinition,\n            connections: new Map(modelDefinition.connectors.getAll().map(c => [c.id, c])),\n            activityRelationships: this.buildActivityRelationships(modelDefinition)\n        };\n        // Cache the new state\n        this.cachedState = state;\n        this.lastModelDefinitionHash = currentHash;\n        return state;\n    }\n    batchValidate(state, messages) {\n        // Log the details of the model definition activities\n        console.log(\"[ModelValidation] Starting batch validation.\");\n        // ModelDefinitionLogger.logModelDefinition(state.modelDefinition)\n        // Validate all rules\n        const validationPromises = this.rules.map(rule => {\n            return new Promise((resolve) => {\n                rule.validate(state, messages);\n                resolve();\n            });\n        });\n        // Wait for all validations to complete\n        Promise.all(validationPromises).then(() => {\n            console.log(\"[ModelValidation] Batch validation completed.\");\n        });\n    }\n    calculateValidationMetrics(messages) {\n        const errorCount = messages.filter(m => m.type === 'error').length;\n        const warningCount = messages.filter(m => m.type === 'warning').length;\n        return {\n            isValid: errorCount === 0,\n            errorCount,\n            warningCount,\n            messages\n        };\n    }\n    logValidationResults(result) {\n        console.log('[ModelValidation] Validation results:', {\n            isValid: result.isValid,\n            errorCount: result.errorCount,\n            warningCount: result.warningCount,\n            messageCount: result.messages.length,\n            messages: result.messages\n        });\n    }\n    buildActivityRelationships(modelDefinition) {\n        const relationships = new Map();\n        // Initialize relationships map for better performance\n        const activities = modelDefinition.activities.getAll();\n        const connectors = modelDefinition.connectors.getAll();\n        // Pre-allocate relationships for all activities\n        activities.forEach(activity => {\n            relationships.set(activity.id, {\n                incomingConnectors: new Set(),\n                outgoingConnectors: new Set(),\n                assignedResources: new Set()\n            });\n        });\n        // Process connectors in batch\n        connectors.forEach(connector => {\n            const sourceRel = relationships.get(connector.sourceId);\n            const targetRel = relationships.get(connector.targetId);\n            if (sourceRel)\n                sourceRel.outgoingConnectors.add(connector.id);\n            if (targetRel)\n                targetRel.incomingConnectors.add(connector.id);\n        });\n        // Process resource assignments efficiently\n        activities.forEach(activity => {\n            const activityRel = relationships.get(activity.id);\n            if (!activityRel || !activity.operationSteps)\n                return;\n            // Process resource requests using reduce instead of flatMap\n            const resourceRequests = activity.operationSteps.reduce((requests, step) => {\n                var _a;\n                if ((_a = step.resourceSetRequest) === null || _a === void 0 ? void 0 : _a.requests) {\n                    requests.push(...step.resourceSetRequest.requests);\n                }\n                return requests;\n            }, []);\n            // Batch process resource assignments\n            resourceRequests.forEach(request => {\n                if ('resource' in request && request.resource) {\n                    activityRel.assignedResources.add(request.resource.id);\n                }\n            });\n        });\n        return relationships;\n    }\n}\nexports.ModelValidationService = ModelValidationService;\n\n\n//# sourceURL=webpack:///./src/services/validation/ModelValidationService.ts?");

/***/ }),

/***/ "./src/services/validation/ResourceValidation.ts":
/*!*******************************************************!*\
  !*** ./src/services/validation/ResourceValidation.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResourceValidation = void 0;\nconst ValidationRule_1 = __webpack_require__(/*! ./ValidationRule */ \"./src/services/validation/ValidationRule.ts\");\nclass ResourceValidation extends ValidationRule_1.ValidationRule {\n    validate(state, messages) {\n        const resources = state.modelDefinition.resources.getAll();\n        this.log(\"Starting validation of resources.\");\n        // First validate each resource's data\n        resources.forEach(resource => {\n            this.validateResourceData(resource, messages);\n        });\n        // Then check resource usage across activities\n        this.validateResourceUsage(state, messages);\n        this.log(\"Completed validation of resources.\");\n    }\n    validateResourceData(resource, messages) {\n        /**\n         * Validates the basic properties of a resource, such as name and capacity.\n         */\n        this.log(`Validating data for Resource ID: ${resource.id}`);\n        if (!resource.name || resource.name.trim().length === 0) {\n            this.log(`Resource ID ${resource.id} has no name.`);\n            messages.push({\n                type: 'warning',\n                message: `Resource ${resource.id} has no name`,\n                elementId: resource.id\n            });\n        }\n        if (typeof resource.capacity !== 'number' || resource.capacity < 1) {\n            this.log(`Resource ID ${resource.id} has invalid capacity: ${resource.capacity}`);\n            messages.push({\n                type: 'error',\n                message: `Resource ${resource.id} has invalid capacity (must be >= 1)`,\n                elementId: resource.id\n            });\n        }\n        if (Math.floor(resource.capacity) !== resource.capacity) {\n            this.log(`Resource ID ${resource.id} has non-integer capacity: ${resource.capacity}`);\n            messages.push({\n                type: 'error',\n                message: `Resource ${resource.id} capacity must be a whole number`,\n                elementId: resource.id\n            });\n        }\n        if (resource.capacity > 1000000) {\n            this.log(`Resource ID ${resource.id} has unusually high capacity: ${resource.capacity}`);\n            messages.push({\n                type: 'warning',\n                message: `Resource ${resource.id} has unusually high capacity (${resource.capacity})`,\n                elementId: resource.id\n            });\n        }\n    }\n    validateResourceUsage(state, messages) {\n        /**\n         * Validates how resources are used across activities, ensuring no conflicts or underutilization.\n         */\n        this.log(\"Validating resource usage across activities.\");\n        const resources = state.modelDefinition.resources.getAll();\n        const activities = state.modelDefinition.activities.getAll();\n        const resourceUsage = new Map(); // Resource ID -> Set of Activity IDs\n        resources.forEach(resource => {\n            resourceUsage.set(resource.id, new Set());\n        });\n        activities.forEach(activity => {\n            if (activity.operationSteps) {\n                activity.operationSteps.forEach(step => {\n                    var _a;\n                    if ((_a = step.resourceSetRequest) === null || _a === void 0 ? void 0 : _a.requests) {\n                        this.processResourceRequests(step.resourceSetRequest.requests, activity, resourceUsage, messages);\n                    }\n                });\n            }\n        });\n        resourceUsage.forEach((usedByActivities, resourceId) => {\n            if (usedByActivities.size === 0) {\n                this.log(`Resource ID ${resourceId} is not used by any activity.`);\n                messages.push({\n                    type: 'warning',\n                    message: `Resource ${resourceId} is not used by any activity`,\n                    elementId: resourceId\n                });\n            }\n        });\n        this.checkResourceConflicts(state, resourceUsage, messages);\n    }\n    processResourceRequests(requests, activity, resourceUsage, messages) {\n        /**\n         * Processes resource requests within an activity's operation steps.\n         */\n        requests.forEach(request => {\n            if (request.requests) {\n                this.processResourceRequests(request.requests, activity, resourceUsage, messages);\n                return;\n            }\n            if (request.resource) {\n                const resourceId = request.resource.id;\n                const usageSet = resourceUsage.get(resourceId);\n                if (usageSet) {\n                    usageSet.add(activity.id);\n                    if (typeof request.quantity !== 'number' || request.quantity < 1) {\n                        this.log(`Activity ID ${activity.id} has invalid resource quantity for Resource ID ${resourceId}`);\n                        messages.push({\n                            type: 'error',\n                            message: `Invalid resource quantity in activity ${activity.id} for resource ${resourceId}`,\n                            elementId: activity.id\n                        });\n                    }\n                }\n                else {\n                    this.log(`Activity ID ${activity.id} references non-existent Resource ID ${resourceId}`);\n                    messages.push({\n                        type: 'error',\n                        message: `Activity ${activity.id} references non-existent resource ${resourceId}`,\n                        elementId: activity.id\n                    });\n                }\n            }\n        });\n    }\n    checkResourceConflicts(state, resourceUsage, messages) {\n        /**\n         * Checks for conflicts in resource usage, such as overutilization.\n         */\n        this.log(\"Checking for resource usage conflicts.\");\n        const resources = state.modelDefinition.resources.getAll();\n        resources.forEach(resource => {\n            const usedByActivities = resourceUsage.get(resource.id);\n            if (usedByActivities && usedByActivities.size > 1) {\n                this.validateConcurrentResourceUsage(state, resource, Array.from(usedByActivities), messages);\n            }\n        });\n    }\n    validateConcurrentResourceUsage(state, resource, activityIds, messages) {\n        /**\n         * Validates concurrent usage of a resource across multiple activities.\n         */\n        this.log(`Validating concurrent usage for Resource ID: ${resource.id}`);\n        const activities = activityIds\n            .map(id => state.modelDefinition.activities.get(id))\n            .filter(activity => activity !== undefined);\n        let totalMaxPossibleDemand = 0;\n        activities.forEach(activity => {\n            const maxDemand = this.calculateMaxResourceDemand(activity, resource.id);\n            totalMaxPossibleDemand += maxDemand;\n        });\n        if (totalMaxPossibleDemand > resource.capacity) {\n            this.log(`Resource ID ${resource.id} might be overutilized. Capacity: ${resource.capacity}, Demand: ${totalMaxPossibleDemand}`);\n            messages.push({\n                type: 'warning',\n                message: `Potential resource conflict: Resource ${resource.id} (capacity: ${resource.capacity}) might be overutilized. Maximum possible demand: ${totalMaxPossibleDemand}`,\n                elementId: resource.id\n            });\n        }\n    }\n    calculateMaxResourceDemand(activity, resourceId) {\n        /**\n         * Calculates the maximum possible demand for a resource by a single activity.\n         */\n        var _a;\n        let maxDemand = 0;\n        (_a = activity.operationSteps) === null || _a === void 0 ? void 0 : _a.forEach((step) => {\n            var _a;\n            if ((_a = step.resourceSetRequest) === null || _a === void 0 ? void 0 : _a.requests) {\n                step.resourceSetRequest.requests.forEach((request) => {\n                    var _a;\n                    if (((_a = request.resource) === null || _a === void 0 ? void 0 : _a.id) === resourceId) {\n                        maxDemand = Math.max(maxDemand, request.quantity || 0);\n                    }\n                });\n            }\n        });\n        return maxDemand;\n    }\n}\nexports.ResourceValidation = ResourceValidation;\n\n\n//# sourceURL=webpack:///./src/services/validation/ResourceValidation.ts?");

/***/ }),

/***/ "./src/services/validation/ValidationMessages.ts":
/*!*******************************************************!*\
  !*** ./src/services/validation/ValidationMessages.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ValidationMessages = void 0;\nclass ValidationMessages {\n    // Existing messages...\n    static missingName(elementType, elementId) {\n        return {\n            type: 'warning',\n            message: `${elementType} ${elementId} has no name`,\n            elementId\n        };\n    }\n    static isolatedElement(elementType, elementId) {\n        return {\n            type: 'error',\n            message: `${elementType} ${elementId} is isolated (no connections)`,\n            elementId\n        };\n    }\n    static invalidConnection(connectorId, type, elementId) {\n        return {\n            type: 'error',\n            message: `Connector ${connectorId} has invalid ${type} (${elementId})`,\n            elementId: connectorId\n        };\n    }\n    static invalidCapacity(elementType, elementId, minimum = 1) {\n        return {\n            type: 'error',\n            message: `${elementType} ${elementId} has invalid capacity (must be >= ${minimum})`,\n            elementId\n        };\n    }\n    // New messages for Activity validation\n    static noConnections(elementType, elementId, direction) {\n        return {\n            type: 'warning',\n            message: `${elementType} ${elementId} has no ${direction} connections (potential ${direction === 'incoming' ? 'start' : 'end'} activity)`,\n            elementId\n        };\n    }\n    static largeBufferCapacity(elementType, elementId, type) {\n        return {\n            type: 'warning',\n            message: `${elementType} ${elementId} has unusually large ${type} buffer capacity`,\n            elementId\n        };\n    }\n    static invalidBufferCapacity(elementType, elementId, type) {\n        return {\n            type: 'error',\n            message: `${elementType} ${elementId} has invalid ${type} buffer capacity`,\n            elementId\n        };\n    }\n    static missingOperationSteps(elementId) {\n        return {\n            type: 'error',\n            message: `Activity ${elementId} is missing operation steps property`,\n            elementId\n        };\n    }\n    static noOperationSteps(elementId) {\n        return {\n            type: 'warning',\n            message: `Activity ${elementId} has no operation steps defined`,\n            elementId\n        };\n    }\n    static invalidStepDuration(elementId, stepNumber) {\n        return {\n            type: 'error',\n            message: `Activity ${elementId} operation step ${stepNumber} has invalid duration`,\n            elementId\n        };\n    }\n    static unusualStepDuration(elementId, stepNumber, duration) {\n        return {\n            type: 'warning',\n            message: `Activity ${elementId} operation step ${stepNumber} has unusual duration (${duration} seconds)`,\n            elementId\n        };\n    }\n    static duplicateResourceRequest(elementId, stepNumber) {\n        return {\n            type: 'warning',\n            message: `Activity ${elementId} operation step ${stepNumber} requests the same resource multiple times`,\n            elementId\n        };\n    }\n    static invalidResourceQuantity(elementId, stepNumber) {\n        return {\n            type: 'error',\n            message: `Activity ${elementId} operation step ${stepNumber} has invalid resource quantity`,\n            elementId\n        };\n    }\n    static unusualCycleTime(elementId, type, time) {\n        return {\n            type: 'warning',\n            message: `Activity ${elementId} has unusually ${type} ${type === 'short' ? 'minimum' : 'maximum'} cycle time (${time} seconds)`,\n            elementId\n        };\n    }\n    static bufferOverflowRisk(elementId) {\n        return {\n            type: 'warning',\n            message: `Activity ${elementId} may experience input buffer overflow at maximum throughput`,\n            elementId\n        };\n    }\n    static smallInputBuffer(elementId) {\n        return {\n            type: 'warning',\n            message: `Activity ${elementId} input buffer may be too small for incoming flow capacity`,\n            elementId\n        };\n    }\n    static circularDependency(elementId) {\n        return {\n            type: 'warning',\n            message: `Potential circular dependency detected involving activity ${elementId}`,\n            elementId\n        };\n    }\n    static resourceLeak(elementId) {\n        return {\n            type: 'warning',\n            message: `Activity ${elementId} requests resources but never releases them`,\n            elementId\n        };\n    }\n    // Existing utility messages...\n    static validationSuccess() {\n        return {\n            type: 'info',\n            message: 'Model validation passed successfully'\n        };\n    }\n    static validationError(error) {\n        return {\n            type: 'error',\n            message: `Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n        };\n    }\n    // Generator Validation\n    static generatorValidation(category, generatorId, detail) {\n        return {\n            type: 'error',\n            message: `Generator ${generatorId} has invalid ${category}: ${detail}`,\n            elementId: generatorId\n        };\n    }\n    // Element Counts\n    static missingRequiredElement(elementType) {\n        return {\n            type: 'error',\n            message: `Model must have at least one ${elementType}`,\n        };\n    }\n}\nexports.ValidationMessages = ValidationMessages;\n\n\n//# sourceURL=webpack:///./src/services/validation/ValidationMessages.ts?");

/***/ }),

/***/ "./src/services/validation/ValidationRule.ts":
/*!***************************************************!*\
  !*** ./src/services/validation/ValidationRule.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ValidationRule = void 0;\n/**\n * Base class for validation rules\n */\nclass ValidationRule {\n    constructor() {\n        /**\n         * Flag to enable or disable logging across all validation rules.\n         */\n        this.loggingEnabled = false;\n    }\n    /**\n     * Method to toggle logging.\n     * @param enabled - True to enable logging, false to disable.\n     */\n    setLogging(enabled) {\n        this.loggingEnabled = enabled;\n    }\n    /**\n     * Checks if logging is enabled.\n     * @returns True if logging is enabled, false otherwise.\n     */\n    isLoggingEnabled() {\n        return this.loggingEnabled;\n    }\n    /**\n     * Logs a message if logging is enabled.\n     * @param message - The message to log.\n     */\n    log(message) {\n        if (this.isLoggingEnabled()) {\n            console.log(`[${this.constructor.name}] ${message}`);\n        }\n    }\n}\nexports.ValidationRule = ValidationRule;\n\n\n//# sourceURL=webpack:///./src/services/validation/ValidationRule.ts?");

/***/ }),

/***/ "../../shared/dist/core/logging/QuodsiLogger.js":
/*!******************************************************!*\
  !*** ../../shared/dist/core/logging/QuodsiLogger.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\r\n// shared/src/core/logging/QuodsiLogger.ts\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.QuodsiLogger = void 0;\r\nvar QuodsiLogger = /** @class */ (function () {\r\n    // No initialization in constructor since we can't access LOG_PREFIX\r\n    function QuodsiLogger() {\r\n        this.loggingEnabled = false;\r\n    }\r\n    QuodsiLogger.prototype.setLogging = function (enabled) {\r\n        // Initialize on first use if needed\r\n        if (!QuodsiLogger.instanceMap.has(this.LOG_PREFIX)) {\r\n            QuodsiLogger.instanceMap.set(this.LOG_PREFIX, enabled);\r\n        }\r\n        else {\r\n            QuodsiLogger.instanceMap.set(this.LOG_PREFIX, enabled);\r\n        }\r\n        this.loggingEnabled = enabled;\r\n        if (enabled) {\r\n            this.log(\"Logging enabled\");\r\n        }\r\n    };\r\n    QuodsiLogger.prototype.isLoggingEnabled = function () {\r\n        // Initialize as false if not yet set\r\n        if (!QuodsiLogger.instanceMap.has(this.LOG_PREFIX)) {\r\n            QuodsiLogger.instanceMap.set(this.LOG_PREFIX, false);\r\n            this.loggingEnabled = false;\r\n        }\r\n        return this.loggingEnabled;\r\n    };\r\n    QuodsiLogger.prototype.log = function (message) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        if (this.isLoggingEnabled()) {\r\n            console.log.apply(console, __spreadArray([\"\".concat(this.LOG_PREFIX, \" \").concat(message)], args, false));\r\n        }\r\n    };\r\n    QuodsiLogger.prototype.logError = function (message) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        if (this.isLoggingEnabled()) {\r\n            console.error.apply(console, __spreadArray([\"\".concat(this.LOG_PREFIX, \" \").concat(message)], args, false));\r\n        }\r\n    };\r\n    QuodsiLogger.prototype.logWarning = function (message) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        if (this.isLoggingEnabled()) {\r\n            console.warn.apply(console, __spreadArray([\"\".concat(this.LOG_PREFIX, \" \").concat(message)], args, false));\r\n        }\r\n    };\r\n    QuodsiLogger.prototype.logDebug = function (message) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        if (this.isLoggingEnabled()) {\r\n            console.debug.apply(console, __spreadArray([\"\".concat(this.LOG_PREFIX, \" \").concat(message)], args, false));\r\n        }\r\n    };\r\n    QuodsiLogger.instanceMap = new Map();\r\n    return QuodsiLogger;\r\n}());\r\nexports.QuodsiLogger = QuodsiLogger;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/core/logging/QuodsiLogger.js?");

/***/ }),

/***/ "../../shared/dist/factories/SimulationObjectTypeFactory.js":
/*!******************************************************************!*\
  !*** ../../shared/dist/factories/SimulationObjectTypeFactory.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimulationObjectTypeFactory = void 0;\r\nvar __1 = __webpack_require__(/*! .. */ \"../../shared/dist/index.js\");\r\nvar SimulationObjectTypeFactory;\r\n(function (SimulationObjectTypeFactory) {\r\n    function createActivity(lucidId) {\r\n        return __1.Activity.createDefault(lucidId);\r\n    }\r\n    SimulationObjectTypeFactory.createActivity = createActivity;\r\n    function createConnector(lucidId) {\r\n        return __1.Connector.createDefault(lucidId);\r\n    }\r\n    SimulationObjectTypeFactory.createConnector = createConnector;\r\n    function createGenerator(lucidId) {\r\n        return __1.Generator.createDefault(lucidId);\r\n    }\r\n    SimulationObjectTypeFactory.createGenerator = createGenerator;\r\n    function createResource(lucidId) {\r\n        return __1.Resource.createDefault(lucidId);\r\n    }\r\n    SimulationObjectTypeFactory.createResource = createResource;\r\n    function createEntity(lucidId) {\r\n        return __1.Entity.createDefault(lucidId);\r\n    }\r\n    SimulationObjectTypeFactory.createEntity = createEntity;\r\n    function createElement(type, lucidId) {\r\n        switch (type) {\r\n            case __1.SimulationObjectType.Activity:\r\n                return createActivity(lucidId);\r\n            case __1.SimulationObjectType.Connector:\r\n                return createConnector(lucidId);\r\n            case __1.SimulationObjectType.Generator:\r\n                return createGenerator(lucidId);\r\n            case __1.SimulationObjectType.Resource:\r\n                return createResource(lucidId);\r\n            case __1.SimulationObjectType.Entity:\r\n                return createEntity(lucidId);\r\n            default:\r\n                return {\r\n                    id: lucidId,\r\n                    name: 'New Element',\r\n                    type: type\r\n                };\r\n        }\r\n    }\r\n    SimulationObjectTypeFactory.createElement = createElement;\r\n})(SimulationObjectTypeFactory = exports.SimulationObjectTypeFactory || (exports.SimulationObjectTypeFactory = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/factories/SimulationObjectTypeFactory.js?");

/***/ }),

/***/ "../../shared/dist/index.js":
/*!**********************************!*\
  !*** ../../shared/dist/index.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./core/logging/QuodsiLogger */ \"../../shared/dist/core/logging/QuodsiLogger.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/ActivityRelationships */ \"../../shared/dist/types/ActivityRelationships.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/BlockAnalysis */ \"../../shared/dist/types/BlockAnalysis.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/ConversionResult */ \"../../shared/dist/types/ConversionResult.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/EditorReferenceData */ \"../../shared/dist/types/EditorReferenceData.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/messaging */ \"../../shared/dist/types/messaging/index.js\"), exports); // This exports JsonTypes, MessageTypes, and utils\r\n__exportStar(__webpack_require__(/*! ./types/PageStatus */ \"../../shared/dist/types/PageStatus.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/ProcessAnalysisResult */ \"../../shared/dist/types/ProcessAnalysisResult.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/SelectionState */ \"../../shared/dist/types/SelectionState.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/SelectionType */ \"../../shared/dist/types/SelectionType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/simComponentType */ \"../../shared/dist/types/simComponentType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/simComponentTypes */ \"../../shared/dist/types/simComponentTypes.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/SimulationElement */ \"../../shared/dist/types/SimulationElement.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/SimulationElementFactory */ \"../../shared/dist/types/SimulationElementFactory.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/SimulationElementWrapper */ \"../../shared/dist/types/SimulationElementWrapper.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/validation */ \"../../shared/dist/types/validation/index.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/MetaData */ \"../../shared/dist/types/MetaData.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/DiagramElementType */ \"../../shared/dist/types/DiagramElementType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Activity */ \"../../shared/dist/types/elements/Activity.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ActivityListManager */ \"../../shared/dist/types/elements/ActivityListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Connector */ \"../../shared/dist/types/elements/Connector.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ConnectorListManager */ \"../../shared/dist/types/elements/ConnectorListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ConnectType */ \"../../shared/dist/types/elements/ConnectType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Distribution */ \"../../shared/dist/types/elements/Distribution.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/DistributionType */ \"../../shared/dist/types/elements/DistributionType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Duration */ \"../../shared/dist/types/elements/Duration.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/DurationType */ \"../../shared/dist/types/elements/DurationType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Entity */ \"../../shared/dist/types/elements/Entity.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/EntityListManager */ \"../../shared/dist/types/elements/EntityListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Experiment */ \"../../shared/dist/types/elements/Experiment.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Generator */ \"../../shared/dist/types/elements/Generator.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/GeneratorListManager */ \"../../shared/dist/types/elements/GeneratorListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Model */ \"../../shared/dist/types/elements/Model.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ModelDefaults */ \"../../shared/dist/types/elements/ModelDefaults.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ModelDefinition */ \"../../shared/dist/types/elements/ModelDefinition.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ModelUtils */ \"../../shared/dist/types/elements/ModelUtils.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/OperationStep */ \"../../shared/dist/types/elements/OperationStep.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/PeriodUnit */ \"../../shared/dist/types/elements/PeriodUnit.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/RequestSetType */ \"../../shared/dist/types/elements/RequestSetType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Resource */ \"../../shared/dist/types/elements/Resource.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ResourceListManager */ \"../../shared/dist/types/elements/ResourceListManager.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ResourceRequest */ \"../../shared/dist/types/elements/ResourceRequest.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ResourceSetRequest */ \"../../shared/dist/types/elements/ResourceSetRequest.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/Scenario */ \"../../shared/dist/types/elements/Scenario.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/SimulationObject */ \"../../shared/dist/types/elements/SimulationObject.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/SimulationTimeType */ \"../../shared/dist/types/elements/SimulationTimeType.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./factories/SimulationObjectTypeFactory */ \"../../shared/dist/factories/SimulationObjectTypeFactory.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/accordion/ModelElement */ \"../../shared/dist/types/accordion/ModelElement.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/accordion/ModelStructure */ \"../../shared/dist/types/accordion/ModelStructure.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/accordion/ValidationState */ \"../../shared/dist/types/accordion/ValidationState.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/accordion/AccordionState */ \"../../shared/dist/types/accordion/AccordionState.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./types/elements/ModelDefinitionLogger */ \"../../shared/dist/types/elements/ModelDefinitionLogger.js\"), exports);\r\n\n\n//# sourceURL=webpack:///../../shared/dist/index.js?");

/***/ }),

/***/ "../../shared/dist/types/ActivityRelationships.js":
/*!********************************************************!*\
  !*** ../../shared/dist/types/ActivityRelationships.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/ActivityRelationships.js?");

/***/ }),

/***/ "../../shared/dist/types/BlockAnalysis.js":
/*!************************************************!*\
  !*** ../../shared/dist/types/BlockAnalysis.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/BlockAnalysis.js?");

/***/ }),

/***/ "../../shared/dist/types/ConversionResult.js":
/*!***************************************************!*\
  !*** ../../shared/dist/types/ConversionResult.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/ConversionResult.js?");

/***/ }),

/***/ "../../shared/dist/types/DiagramElementType.js":
/*!*****************************************************!*\
  !*** ../../shared/dist/types/DiagramElementType.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DiagramElementType = void 0;\r\nvar DiagramElementType;\r\n(function (DiagramElementType) {\r\n    DiagramElementType[\"BLOCK\"] = \"block\";\r\n    DiagramElementType[\"LINE\"] = \"line\";\r\n})(DiagramElementType = exports.DiagramElementType || (exports.DiagramElementType = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/DiagramElementType.js?");

/***/ }),

/***/ "../../shared/dist/types/EditorReferenceData.js":
/*!******************************************************!*\
  !*** ../../shared/dist/types/EditorReferenceData.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/EditorReferenceData.js?");

/***/ }),

/***/ "../../shared/dist/types/MetaData.js":
/*!*******************************************!*\
  !*** ../../shared/dist/types/MetaData.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/MetaData.js?");

/***/ }),

/***/ "../../shared/dist/types/PageStatus.js":
/*!*********************************************!*\
  !*** ../../shared/dist/types/PageStatus.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/PageStatus.js?");

/***/ }),

/***/ "../../shared/dist/types/ProcessAnalysisResult.js":
/*!********************************************************!*\
  !*** ../../shared/dist/types/ProcessAnalysisResult.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/ProcessAnalysisResult.js?");

/***/ }),

/***/ "../../shared/dist/types/SelectionState.js":
/*!*************************************************!*\
  !*** ../../shared/dist/types/SelectionState.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/SelectionState.js?");

/***/ }),

/***/ "../../shared/dist/types/SelectionType.js":
/*!************************************************!*\
  !*** ../../shared/dist/types/SelectionType.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SelectionType = void 0;\r\n/**\r\n * Defines all possible selection types\r\n */\r\nvar SelectionType;\r\n(function (SelectionType) {\r\n    SelectionType[\"NONE\"] = \"none\";\r\n    SelectionType[\"UNCONVERTED_ELEMENT\"] = \"unconverted_element\";\r\n    SelectionType[\"MULTIPLE\"] = \"multiple\";\r\n    SelectionType[\"UNKNOWN_BLOCK\"] = \"unknown_block\";\r\n    SelectionType[\"UNKNOWN_LINE\"] = \"unknown_line\";\r\n    SelectionType[\"ACTIVITY\"] = \"activity\";\r\n    SelectionType[\"CONNECTOR\"] = \"connector\";\r\n    SelectionType[\"ENTITY\"] = \"entity\";\r\n    SelectionType[\"GENERATOR\"] = \"generator\";\r\n    SelectionType[\"RESOURCE\"] = \"resource\";\r\n    SelectionType[\"MODEL\"] = \"model\";\r\n})(SelectionType = exports.SelectionType || (exports.SelectionType = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/SelectionType.js?");

/***/ }),

/***/ "../../shared/dist/types/SimulationElement.js":
/*!****************************************************!*\
  !*** ../../shared/dist/types/SimulationElement.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/SimulationElement.js?");

/***/ }),

/***/ "../../shared/dist/types/SimulationElementFactory.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/SimulationElementFactory.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimulationElementFactory = void 0;\r\nvar Model_1 = __webpack_require__(/*! ./elements/Model */ \"../../shared/dist/types/elements/Model.js\");\r\nvar Activity_1 = __webpack_require__(/*! ./elements/Activity */ \"../../shared/dist/types/elements/Activity.js\");\r\nvar Connector_1 = __webpack_require__(/*! ./elements/Connector */ \"../../shared/dist/types/elements/Connector.js\");\r\nvar Resource_1 = __webpack_require__(/*! ./elements/Resource */ \"../../shared/dist/types/elements/Resource.js\");\r\nvar Generator_1 = __webpack_require__(/*! ./elements/Generator */ \"../../shared/dist/types/elements/Generator.js\");\r\nvar Entity_1 = __webpack_require__(/*! ./elements/Entity */ \"../../shared/dist/types/elements/Entity.js\");\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./elements/SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar ConnectType_1 = __webpack_require__(/*! ./elements/ConnectType */ \"../../shared/dist/types/elements/ConnectType.js\");\r\nvar Duration_1 = __webpack_require__(/*! ./elements/Duration */ \"../../shared/dist/types/elements/Duration.js\");\r\nvar SimulationElementWrapper_1 = __webpack_require__(/*! ./SimulationElementWrapper */ \"../../shared/dist/types/SimulationElementWrapper.js\");\r\nexports.SimulationElementFactory = {\r\n    createElement: function (metadata, data) {\r\n        switch (metadata.type) {\r\n            case SimulationObjectType_1.SimulationObjectType.Model:\r\n                return new SimulationElementWrapper_1.SimulationElementWrapper(this.createModel(data));\r\n            case SimulationObjectType_1.SimulationObjectType.Activity:\r\n                return new SimulationElementWrapper_1.SimulationElementWrapper(this.createActivity(data));\r\n            case SimulationObjectType_1.SimulationObjectType.Connector:\r\n                return new SimulationElementWrapper_1.SimulationElementWrapper(this.createConnector(data));\r\n            case SimulationObjectType_1.SimulationObjectType.Resource:\r\n                return new SimulationElementWrapper_1.SimulationElementWrapper(this.createResource(data));\r\n            case SimulationObjectType_1.SimulationObjectType.Generator:\r\n                return new SimulationElementWrapper_1.SimulationElementWrapper(this.createGenerator(data));\r\n            case SimulationObjectType_1.SimulationObjectType.Entity:\r\n                return new SimulationElementWrapper_1.SimulationElementWrapper(this.createEntity(data));\r\n            default:\r\n                throw new Error(\"Unknown element type: \".concat(metadata.type));\r\n        }\r\n    },\r\n    createModel: function (data) {\r\n        return new Model_1.Model(data.id, // Use provided ID instead of generating new one\r\n        data.name || 'New Model', data.reps || 1, data.forecastDays || 30, data.seed, data.oneClockUnit, data.simulationTimeType, data.warmupClockPeriod, data.warmupClockPeriodUnit, data.runClockPeriod, data.runClockPeriodUnit, data.warmupDateTime ? new Date(data.warmupDateTime) : null, data.startDateTime ? new Date(data.startDateTime) : null, data.finishDateTime ? new Date(data.finishDateTime) : null);\r\n    },\r\n    createActivity: function (data) {\r\n        var _a, _b;\r\n        return new Activity_1.Activity(data.id, // Use provided ID instead of generating new one\r\n        data.name || 'New Activity', data.capacity || 1, (_a = data.inputBufferCapacity) !== null && _a !== void 0 ? _a : Infinity, (_b = data.outputBufferCapacity) !== null && _b !== void 0 ? _b : Infinity, data.operationSteps || []);\r\n    },\r\n    createConnector: function (data) {\r\n        return new Connector_1.Connector(data.id, data.name || 'New Connector', data.sourceId, data.targetId, data.probability || 1.0, data.connectType || ConnectType_1.ConnectType.Probability, data.operationSteps || []);\r\n    },\r\n    createResource: function (data) {\r\n        return new Resource_1.Resource(data.id, // Use provided ID instead of generating new one\r\n        data.name || 'New Resource', data.capacity || 1);\r\n    },\r\n    createGenerator: function (data) {\r\n        var _a, _b;\r\n        return new Generator_1.Generator(data.id, // Use provided ID instead of generating new one\r\n        data.name || 'New Generator', data.activityKeyId || '', data.entityType || 'All', (_a = data.periodicOccurrences) !== null && _a !== void 0 ? _a : Infinity, data.periodIntervalDuration || new Duration_1.Duration(), data.entitiesPerCreation || 1, data.periodicStartDuration || new Duration_1.Duration(), (_b = data.maxEntities) !== null && _b !== void 0 ? _b : Infinity);\r\n    },\r\n    createEntity: function (data) {\r\n        return new Entity_1.Entity(data.id, // Use provided ID instead of generating new one\r\n        data.name || 'New Entity');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/SimulationElementFactory.js?");

/***/ }),

/***/ "../../shared/dist/types/SimulationElementWrapper.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/SimulationElementWrapper.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimulationElementWrapper = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./elements/SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar SimulationElementWrapper = /** @class */ (function () {\r\n    function SimulationElementWrapper(data, version) {\r\n        if (version === void 0) { version = '1.0.0'; }\r\n        this.id = data.id;\r\n        this.type = data.type;\r\n        this.name = data.name;\r\n        this.version = version;\r\n        this.data = data;\r\n    }\r\n    SimulationElementWrapper.prototype.validate = function () {\r\n        var messages = [];\r\n        switch (this.type) {\r\n            case SimulationObjectType_1.SimulationObjectType.Model:\r\n                this.validateModel(this.data, messages);\r\n                break;\r\n            case SimulationObjectType_1.SimulationObjectType.Activity:\r\n                this.validateActivity(this.data, messages);\r\n                break;\r\n            case SimulationObjectType_1.SimulationObjectType.Connector:\r\n                this.validateConnector(this.data, messages);\r\n                break;\r\n            case SimulationObjectType_1.SimulationObjectType.Resource:\r\n                this.validateResource(this.data, messages);\r\n                break;\r\n            case SimulationObjectType_1.SimulationObjectType.Generator:\r\n                this.validateGenerator(this.data, messages);\r\n                break;\r\n            case SimulationObjectType_1.SimulationObjectType.Entity:\r\n                this.validateEntity(this.data, messages);\r\n                break;\r\n        }\r\n        var errorCount = messages.filter(function (m) { return m.type === 'error'; }).length;\r\n        var warningCount = messages.filter(function (m) { return m.type === 'warning'; }).length;\r\n        return {\r\n            isValid: errorCount === 0,\r\n            errorCount: errorCount,\r\n            warningCount: warningCount,\r\n            messages: messages\r\n        };\r\n    };\r\n    SimulationElementWrapper.prototype.toStorage = function () {\r\n        return __assign(__assign({}, this.data), { version: this.version });\r\n    };\r\n    SimulationElementWrapper.prototype.fromStorage = function (data) {\r\n        return new SimulationElementWrapper(data, data.version);\r\n    };\r\n    SimulationElementWrapper.prototype.validateModel = function (model, messages) {\r\n        if (model.reps < 1) {\r\n            messages.push({ type: 'error', message: 'Model must have at least 1 replication', elementId: model.id });\r\n        }\r\n        if (model.forecastDays < 1) {\r\n            messages.push({ type: 'error', message: 'Forecast days must be at least 1', elementId: model.id });\r\n        }\r\n    };\r\n    SimulationElementWrapper.prototype.validateActivity = function (activity, messages) {\r\n        if (activity.capacity < 1) {\r\n            messages.push({ type: 'error', message: 'Activity capacity must be at least 1', elementId: activity.id });\r\n        }\r\n        if (!activity.operationSteps || activity.operationSteps.length === 0) {\r\n            messages.push({ type: 'warning', message: 'Activity has no operation steps', elementId: activity.id });\r\n        }\r\n    };\r\n    SimulationElementWrapper.prototype.validateConnector = function (connector, messages) {\r\n        if (connector.probability < 0 || connector.probability > 1) {\r\n            messages.push({ type: 'error', message: 'Connector probability must be between 0 and 1', elementId: connector.id });\r\n        }\r\n    };\r\n    SimulationElementWrapper.prototype.validateResource = function (resource, messages) {\r\n        if (resource.capacity < 1) {\r\n            messages.push({ type: 'error', message: 'Resource capacity must be at least 1', elementId: resource.id });\r\n        }\r\n    };\r\n    SimulationElementWrapper.prototype.validateGenerator = function (generator, messages) {\r\n        if (generator.entitiesPerCreation < 1) {\r\n            messages.push({ type: 'error', message: 'Generator must create at least 1 entity per creation', elementId: generator.id });\r\n        }\r\n        if (!generator.periodIntervalDuration) {\r\n            messages.push({ type: 'error', message: 'Generator must have a period interval duration', elementId: generator.id });\r\n        }\r\n    };\r\n    SimulationElementWrapper.prototype.validateEntity = function (entity, messages) {\r\n        if (!entity.name || entity.name.trim().length === 0) {\r\n            messages.push({ type: 'warning', message: 'Entity has no name', elementId: entity.id });\r\n        }\r\n    };\r\n    return SimulationElementWrapper;\r\n}());\r\nexports.SimulationElementWrapper = SimulationElementWrapper;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/SimulationElementWrapper.js?");

/***/ }),

/***/ "../../shared/dist/types/accordion/AccordionState.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/accordion/AccordionState.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/accordion/AccordionState.js?");

/***/ }),

/***/ "../../shared/dist/types/accordion/ModelElement.js":
/*!*********************************************************!*\
  !*** ../../shared/dist/types/accordion/ModelElement.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/accordion/ModelElement.js?");

/***/ }),

/***/ "../../shared/dist/types/accordion/ModelStructure.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/accordion/ModelStructure.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/accordion/ModelStructure.js?");

/***/ }),

/***/ "../../shared/dist/types/accordion/ValidationState.js":
/*!************************************************************!*\
  !*** ../../shared/dist/types/accordion/ValidationState.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/accordion/ValidationState.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Activity.js":
/*!****************************************************!*\
  !*** ../../shared/dist/types/elements/Activity.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Activity = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar OperationStep_1 = __webpack_require__(/*! ./OperationStep */ \"../../shared/dist/types/elements/OperationStep.js\");\r\nvar Duration_1 = __webpack_require__(/*! ./Duration */ \"../../shared/dist/types/elements/Duration.js\");\r\nvar PeriodUnit_1 = __webpack_require__(/*! ./PeriodUnit */ \"../../shared/dist/types/elements/PeriodUnit.js\");\r\nvar DurationType_1 = __webpack_require__(/*! ./DurationType */ \"../../shared/dist/types/elements/DurationType.js\");\r\nvar Activity = /** @class */ (function () {\r\n    function Activity(id, name, capacity, inputBufferCapacity, outputBufferCapacity, operationSteps, connectors) {\r\n        if (capacity === void 0) { capacity = 1; }\r\n        if (inputBufferCapacity === void 0) { inputBufferCapacity = 1; }\r\n        if (outputBufferCapacity === void 0) { outputBufferCapacity = 1; }\r\n        if (operationSteps === void 0) { operationSteps = []; }\r\n        if (connectors === void 0) { connectors = []; }\r\n        this.id = id;\r\n        this.name = name;\r\n        this.capacity = capacity;\r\n        this.inputBufferCapacity = inputBufferCapacity;\r\n        this.outputBufferCapacity = outputBufferCapacity;\r\n        this.operationSteps = operationSteps;\r\n        this.connectors = connectors;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Activity;\r\n    }\r\n    Activity.createDefault = function (id) {\r\n        var defaultDuration = new Duration_1.Duration(1, PeriodUnit_1.PeriodUnit.MINUTES, DurationType_1.DurationType.CONSTANT);\r\n        var defaultOperationStep = new OperationStep_1.OperationStep(null, defaultDuration);\r\n        return new Activity(id, 'New Activity', 1, // capacity\r\n        1, // inputBufferCapacity\r\n        1, // outputBufferCapacity\r\n        [defaultOperationStep], // operationSteps\r\n        [] // connectors\r\n        );\r\n    };\r\n    return Activity;\r\n}());\r\nexports.Activity = Activity;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/Activity.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ActivityListManager.js":
/*!***************************************************************!*\
  !*** ../../shared/dist/types/elements/ActivityListManager.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ActivityListManager = void 0;\r\nvar ComponentListManager_1 = __webpack_require__(/*! ./ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\");\r\nvar ActivityListManager = /** @class */ (function (_super) {\r\n    __extends(ActivityListManager, _super);\r\n    function ActivityListManager() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ActivityListManager.prototype.getByCapacityThreshold = function (minCapacity) {\r\n        return this.getAll().filter(function (activity) { return activity.capacity >= minCapacity; });\r\n    };\r\n    return ActivityListManager;\r\n}(ComponentListManager_1.ComponentListManager));\r\nexports.ActivityListManager = ActivityListManager;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/ActivityListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ComponentListManager.js":
/*!****************************************************************!*\
  !*** ../../shared/dist/types/elements/ComponentListManager.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ComponentListManager = void 0;\r\nvar ComponentListManager = /** @class */ (function () {\r\n    function ComponentListManager() {\r\n        this.items = new Map();\r\n    }\r\n    ComponentListManager.prototype.add = function (item) {\r\n        this.items.set(item.id, item);\r\n    };\r\n    ComponentListManager.prototype.remove = function (id) {\r\n        this.items.delete(id);\r\n    };\r\n    ComponentListManager.prototype.get = function (id) {\r\n        return this.items.get(id);\r\n    };\r\n    ComponentListManager.prototype.getAll = function () {\r\n        return Array.from(this.items.values());\r\n    };\r\n    ComponentListManager.prototype.clear = function () {\r\n        this.items.clear();\r\n    };\r\n    ComponentListManager.prototype.size = function () {\r\n        return this.items.size;\r\n    };\r\n    return ComponentListManager;\r\n}());\r\nexports.ComponentListManager = ComponentListManager;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/ComponentListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ConnectType.js":
/*!*******************************************************!*\
  !*** ../../shared/dist/types/elements/ConnectType.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ConnectTypeUtils = exports.ConnectType = void 0;\r\n// connectType.ts\r\nvar ConnectType;\r\n(function (ConnectType) {\r\n    ConnectType[\"Probability\"] = \"Probability\";\r\n    ConnectType[\"AttributeValue\"] = \"AttributeValue\";\r\n})(ConnectType = exports.ConnectType || (exports.ConnectType = {}));\r\nvar ConnectTypeUtils = /** @class */ (function () {\r\n    function ConnectTypeUtils() {\r\n    }\r\n    ConnectTypeUtils.stringToConnectRule = function (inputStr) {\r\n        // Normalize the input string to lower case to make the matching case-insensitive\r\n        var normalizedStr = inputStr.toLowerCase();\r\n        // Define a mapping of string representations to ConnectType values\r\n        var stringToEnumMapping = {\r\n            \"percentage\": ConnectType.Probability,\r\n            \"attributevalue\": ConnectType.AttributeValue\r\n        };\r\n        // Look up the normalized string in the mapping and return the corresponding ConnectType value\r\n        // If the input string doesn't match any key in the mapping, throw an Error\r\n        if (normalizedStr in stringToEnumMapping) {\r\n            return stringToEnumMapping[normalizedStr];\r\n        }\r\n        else {\r\n            throw new Error(\"Unknown ConnectType: '\".concat(inputStr, \"'\"));\r\n        }\r\n    };\r\n    return ConnectTypeUtils;\r\n}());\r\nexports.ConnectTypeUtils = ConnectTypeUtils;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/ConnectType.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Connector.js":
/*!*****************************************************!*\
  !*** ../../shared/dist/types/elements/Connector.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Connector = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar ConnectType_1 = __webpack_require__(/*! ./ConnectType */ \"../../shared/dist/types/elements/ConnectType.js\");\r\nvar Connector = /** @class */ (function () {\r\n    function Connector(id, name, sourceId, targetId, probability, connectType, operationSteps) {\r\n        if (probability === void 0) { probability = 1.0; }\r\n        if (connectType === void 0) { connectType = ConnectType_1.ConnectType.Probability; }\r\n        if (operationSteps === void 0) { operationSteps = []; }\r\n        this.id = id;\r\n        this.name = name;\r\n        this.sourceId = sourceId;\r\n        this.targetId = targetId;\r\n        this.probability = probability;\r\n        this.connectType = connectType;\r\n        this.operationSteps = operationSteps;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Connector;\r\n    }\r\n    Connector.createDefault = function (id) {\r\n        return new Connector(id, 'New Connector', '', // sourceId\r\n        '', // targetId\r\n        1.0, // probability\r\n        ConnectType_1.ConnectType.Probability, // connectType\r\n        [] // operationSteps\r\n        );\r\n    };\r\n    return Connector;\r\n}());\r\nexports.Connector = Connector;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/Connector.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ConnectorListManager.js":
/*!****************************************************************!*\
  !*** ../../shared/dist/types/elements/ConnectorListManager.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ConnectorListManager = void 0;\r\nvar ComponentListManager_1 = __webpack_require__(/*! ./ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\");\r\nvar ConnectorListManager = /** @class */ (function (_super) {\r\n    __extends(ConnectorListManager, _super);\r\n    function ConnectorListManager() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ConnectorListManager.prototype.getIncomingConnectors = function (activityId) {\r\n        return this.getAll().filter(function (connector) { return connector.targetId === activityId; });\r\n    };\r\n    ConnectorListManager.prototype.getOutgoingConnectors = function (activityId) {\r\n        return this.getAll().filter(function (connector) { return connector.sourceId === activityId; });\r\n    };\r\n    return ConnectorListManager;\r\n}(ComponentListManager_1.ComponentListManager));\r\nexports.ConnectorListManager = ConnectorListManager;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/ConnectorListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Distribution.js":
/*!********************************************************!*\
  !*** ../../shared/dist/types/elements/Distribution.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Distribution = void 0;\r\nvar Distribution = /** @class */ (function () {\r\n    function Distribution(distributionType, parameters, description) {\r\n        if (description === void 0) { description = \"\"; }\r\n        this.distributionType = distributionType;\r\n        this.parameters = parameters;\r\n        this.description = description;\r\n    }\r\n    return Distribution;\r\n}());\r\nexports.Distribution = Distribution;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/Distribution.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/DistributionType.js":
/*!************************************************************!*\
  !*** ../../shared/dist/types/elements/DistributionType.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DistributionType = void 0;\r\nvar DistributionType;\r\n(function (DistributionType) {\r\n    DistributionType[\"MULTINOMIAL\"] = \"multinomial\";\r\n    DistributionType[\"UNIFORM\"] = \"uniform\";\r\n    DistributionType[\"TRIANGULAR\"] = \"triangular\";\r\n    DistributionType[\"EXPONENTIAL\"] = \"exponential\";\r\n    DistributionType[\"NORMAL\"] = \"normal\";\r\n    DistributionType[\"LOGNORMAL\"] = \"lognormal\";\r\n    DistributionType[\"BETA\"] = \"beta\";\r\n    DistributionType[\"GAMMA\"] = \"gamma\";\r\n    DistributionType[\"WEIBULL\"] = \"weibull\";\r\n    DistributionType[\"DISCRETE\"] = \"discrete\";\r\n    DistributionType[\"POISSON\"] = \"poisson\";\r\n    DistributionType[\"BINOMIAL\"] = \"binomial\";\r\n    DistributionType[\"BERNOULLI\"] = \"bernoulli\";\r\n    DistributionType[\"GEOMETRIC\"] = \"geometric\";\r\n    DistributionType[\"NEGATIVE_BINOMIAL\"] = \"negative_binomial\";\r\n    DistributionType[\"SAMPLE_MULTINOMIAL\"] = \"sample_multinomial\";\r\n    DistributionType[\"SAMPLE_MULTINOMIAL_ONE\"] = \"sample_multinomial_one\";\r\n    DistributionType[\"PROBABILITY_VALUES\"] = \"probability_values\";\r\n    DistributionType[\"SAMPLE_NEXT_SERVICE_INDEX\"] = \"sample_next_service_index\";\r\n    DistributionType[\"CHI_SQUARE\"] = \"chisquare\";\r\n    DistributionType[\"F_DISTRIBUTION\"] = \"f_distribution\";\r\n    DistributionType[\"HYPERGEOMETRIC\"] = \"hypergeometric\";\r\n    DistributionType[\"LAPLACE\"] = \"laplace\";\r\n    DistributionType[\"LOGISTIC\"] = \"logistic\";\r\n    DistributionType[\"LOG_SERIES\"] = \"logseries\";\r\n    DistributionType[\"PARETO\"] = \"pareto\";\r\n    DistributionType[\"RAYLEIGH\"] = \"rayleigh\";\r\n    DistributionType[\"T_DISTRIBUTION\"] = \"t_distribution\";\r\n    DistributionType[\"VON_MISES\"] = \"vonmises\";\r\n    DistributionType[\"WALD\"] = \"wald\";\r\n    DistributionType[\"ZIPF\"] = \"zipf\";\r\n})(DistributionType = exports.DistributionType || (exports.DistributionType = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/DistributionType.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Duration.js":
/*!****************************************************!*\
  !*** ../../shared/dist/types/elements/Duration.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Duration = void 0;\r\nvar PeriodUnit_1 = __webpack_require__(/*! ./PeriodUnit */ \"../../shared/dist/types/elements/PeriodUnit.js\");\r\nvar DurationType_1 = __webpack_require__(/*! ./DurationType */ \"../../shared/dist/types/elements/DurationType.js\");\r\nvar Duration = /** @class */ (function () {\r\n    function Duration(durationLength, durationPeriodUnit, durationType, distribution) {\r\n        if (durationLength === void 0) { durationLength = 0.0; }\r\n        if (durationPeriodUnit === void 0) { durationPeriodUnit = PeriodUnit_1.PeriodUnit.MINUTES; }\r\n        if (durationType === void 0) { durationType = DurationType_1.DurationType.CONSTANT; }\r\n        if (distribution === void 0) { distribution = null; }\r\n        this.durationLength = durationLength;\r\n        this.durationPeriodUnit = durationPeriodUnit;\r\n        this.durationType = durationType;\r\n        this.distribution = distribution;\r\n    }\r\n    return Duration;\r\n}());\r\nexports.Duration = Duration;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/Duration.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/DurationType.js":
/*!********************************************************!*\
  !*** ../../shared/dist/types/elements/DurationType.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DurationType = void 0;\r\nvar DurationType;\r\n(function (DurationType) {\r\n    DurationType[\"CONSTANT\"] = \"CONSTANT\";\r\n    DurationType[\"DISTRIBUTION\"] = \"DISTRIBUTION\";\r\n})(DurationType = exports.DurationType || (exports.DurationType = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/DurationType.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Entity.js":
/*!**************************************************!*\
  !*** ../../shared/dist/types/elements/Entity.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Entity = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar Entity = /** @class */ (function () {\r\n    function Entity(id, name) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Entity;\r\n    }\r\n    Entity.createDefault = function (id) {\r\n        return new Entity(id, 'New Entity');\r\n    };\r\n    return Entity;\r\n}());\r\nexports.Entity = Entity;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/Entity.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/EntityListManager.js":
/*!*************************************************************!*\
  !*** ../../shared/dist/types/elements/EntityListManager.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EntityListManager = void 0;\r\nvar ComponentListManager_1 = __webpack_require__(/*! ./ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\");\r\nvar EntityListManager = /** @class */ (function (_super) {\r\n    __extends(EntityListManager, _super);\r\n    function EntityListManager() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return EntityListManager;\r\n}(ComponentListManager_1.ComponentListManager));\r\nexports.EntityListManager = EntityListManager;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/EntityListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Experiment.js":
/*!******************************************************!*\
  !*** ../../shared/dist/types/elements/Experiment.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/Experiment.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Generator.js":
/*!*****************************************************!*\
  !*** ../../shared/dist/types/elements/Generator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Generator = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar Duration_1 = __webpack_require__(/*! ./Duration */ \"../../shared/dist/types/elements/Duration.js\");\r\nvar ModelDefaults_1 = __webpack_require__(/*! ./ModelDefaults */ \"../../shared/dist/types/elements/ModelDefaults.js\");\r\nvar Generator = /** @class */ (function () {\r\n    function Generator(id, name, activityKeyId, entityId, periodicOccurrences, periodIntervalDuration, entitiesPerCreation, periodicStartDuration, maxEntities) {\r\n        if (activityKeyId === void 0) { activityKeyId = \"\"; }\r\n        if (entityId === void 0) { entityId = ModelDefaults_1.ModelDefaults.DEFAULT_ENTITY_ID; }\r\n        if (periodicOccurrences === void 0) { periodicOccurrences = Infinity; }\r\n        if (periodIntervalDuration === void 0) { periodIntervalDuration = new Duration_1.Duration(); }\r\n        if (entitiesPerCreation === void 0) { entitiesPerCreation = 1; }\r\n        if (periodicStartDuration === void 0) { periodicStartDuration = new Duration_1.Duration(); }\r\n        if (maxEntities === void 0) { maxEntities = Infinity; }\r\n        this.id = id;\r\n        this.name = name;\r\n        this.activityKeyId = activityKeyId;\r\n        this.entityId = entityId;\r\n        this.periodicOccurrences = periodicOccurrences;\r\n        this.periodIntervalDuration = periodIntervalDuration;\r\n        this.entitiesPerCreation = entitiesPerCreation;\r\n        this.periodicStartDuration = periodicStartDuration;\r\n        this.maxEntities = maxEntities;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Generator;\r\n    }\r\n    Generator.createDefault = function (id) {\r\n        return new Generator(id, 'New Generator', '', // activityKeyId\r\n        ModelDefaults_1.ModelDefaults.DEFAULT_ENTITY_ID, Infinity, // periodicOccurrences\r\n        new Duration_1.Duration(), // periodIntervalDuration\r\n        1, // entitiesPerCreation\r\n        new Duration_1.Duration(), // periodicStartDuration\r\n        Infinity // maxEntities\r\n        );\r\n    };\r\n    return Generator;\r\n}());\r\nexports.Generator = Generator;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/Generator.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/GeneratorListManager.js":
/*!****************************************************************!*\
  !*** ../../shared/dist/types/elements/GeneratorListManager.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GeneratorListManager = void 0;\r\nvar ComponentListManager_1 = __webpack_require__(/*! ./ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\");\r\nvar GeneratorListManager = /** @class */ (function (_super) {\r\n    __extends(GeneratorListManager, _super);\r\n    function GeneratorListManager() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    GeneratorListManager.prototype.getByEntityId = function (entityId) {\r\n        return this.getAll().filter(function (generator) { return generator.entityId === entityId; });\r\n    };\r\n    return GeneratorListManager;\r\n}(ComponentListManager_1.ComponentListManager));\r\nexports.GeneratorListManager = GeneratorListManager;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/GeneratorListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Model.js":
/*!*************************************************!*\
  !*** ../../shared/dist/types/elements/Model.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Model = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar Model = /** @class */ (function () {\r\n    function Model(id, name, reps, forecastDays, seed, oneClockUnit, simulationTimeType, warmupClockPeriod, warmupClockPeriodUnit, runClockPeriod, runClockPeriodUnit, warmupDateTime, startDateTime, finishDateTime) {\r\n        if (warmupDateTime === void 0) { warmupDateTime = null; }\r\n        if (startDateTime === void 0) { startDateTime = null; }\r\n        if (finishDateTime === void 0) { finishDateTime = null; }\r\n        this.id = id;\r\n        this.name = name;\r\n        this.reps = reps;\r\n        this.forecastDays = forecastDays;\r\n        this.seed = seed;\r\n        this.oneClockUnit = oneClockUnit;\r\n        this.simulationTimeType = simulationTimeType;\r\n        this.warmupClockPeriod = warmupClockPeriod;\r\n        this.warmupClockPeriodUnit = warmupClockPeriodUnit;\r\n        this.runClockPeriod = runClockPeriod;\r\n        this.runClockPeriodUnit = runClockPeriodUnit;\r\n        this.warmupDateTime = warmupDateTime;\r\n        this.startDateTime = startDateTime;\r\n        this.finishDateTime = finishDateTime;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Model;\r\n    }\r\n    return Model;\r\n}());\r\nexports.Model = Model;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/Model.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ModelDefaults.js":
/*!*********************************************************!*\
  !*** ../../shared/dist/types/elements/ModelDefaults.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelDefaults = void 0;\r\nvar PeriodUnit_1 = __webpack_require__(/*! ./PeriodUnit */ \"../../shared/dist/types/elements/PeriodUnit.js\");\r\nvar SimulationTimeType_1 = __webpack_require__(/*! ./SimulationTimeType */ \"../../shared/dist/types/elements/SimulationTimeType.js\");\r\nvar ModelDefaults;\r\n(function (ModelDefaults) {\r\n    ModelDefaults.DEFAULT_SEED = 12345;\r\n    ModelDefaults.DEFAULT_CLOCK_UNIT = PeriodUnit_1.PeriodUnit.MINUTES;\r\n    ModelDefaults.DEFAULT_SIMULATION_TIME_TYPE = SimulationTimeType_1.SimulationTimeType.Clock;\r\n    ModelDefaults.DEFAULT_WARMUP_PERIOD = 0.0;\r\n    ModelDefaults.DEFAULT_RUN_PERIOD = 0.0;\r\n    ModelDefaults.DEFAULT_REPS = 1;\r\n    ModelDefaults.DEFAULT_FORECAST_DAYS = 30;\r\n    ModelDefaults.DEFAULT_ENTITY_ID = \"00000000-0000-0000-0000-000000000000\";\r\n    ModelDefaults.DEFAULT_ENTITY_NAME = \"Default Entity\";\r\n})(ModelDefaults = exports.ModelDefaults || (exports.ModelDefaults = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/ModelDefaults.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ModelDefinition.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/elements/ModelDefinition.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelDefinition = void 0;\r\nvar ActivityListManager_1 = __webpack_require__(/*! ./ActivityListManager */ \"../../shared/dist/types/elements/ActivityListManager.js\");\r\nvar ConnectorListManager_1 = __webpack_require__(/*! ./ConnectorListManager */ \"../../shared/dist/types/elements/ConnectorListManager.js\");\r\nvar Entity_1 = __webpack_require__(/*! ./Entity */ \"../../shared/dist/types/elements/Entity.js\");\r\nvar EntityListManager_1 = __webpack_require__(/*! ./EntityListManager */ \"../../shared/dist/types/elements/EntityListManager.js\");\r\nvar GeneratorListManager_1 = __webpack_require__(/*! ./GeneratorListManager */ \"../../shared/dist/types/elements/GeneratorListManager.js\");\r\nvar ModelDefaults_1 = __webpack_require__(/*! ./ModelDefaults */ \"../../shared/dist/types/elements/ModelDefaults.js\");\r\nvar ResourceListManager_1 = __webpack_require__(/*! ./ResourceListManager */ \"../../shared/dist/types/elements/ResourceListManager.js\");\r\nvar ModelDefinition = /** @class */ (function () {\r\n    function ModelDefinition(model) {\r\n        this.model = model;\r\n        this.activities = new ActivityListManager_1.ActivityListManager();\r\n        this.connectors = new ConnectorListManager_1.ConnectorListManager();\r\n        this.resources = new ResourceListManager_1.ResourceListManager();\r\n        this.generators = new GeneratorListManager_1.GeneratorListManager();\r\n        this.entities = new EntityListManager_1.EntityListManager();\r\n        // Add default entity\r\n        var defaultEntity = new Entity_1.Entity(ModelDefaults_1.ModelDefaults.DEFAULT_ENTITY_ID, ModelDefaults_1.ModelDefaults.DEFAULT_ENTITY_NAME);\r\n        this.entities.add(defaultEntity);\r\n    }\r\n    Object.defineProperty(ModelDefinition.prototype, \"id\", {\r\n        get: function () { return this.model.id; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ModelDefinition.prototype, \"name\", {\r\n        get: function () { return this.model.name; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return ModelDefinition;\r\n}());\r\nexports.ModelDefinition = ModelDefinition;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/ModelDefinition.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ModelDefinitionLogger.js":
/*!*****************************************************************!*\
  !*** ../../shared/dist/types/elements/ModelDefinitionLogger.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelDefinitionLogger = void 0;\r\nvar QuodsiLogger_1 = __webpack_require__(/*! ../../core/logging/QuodsiLogger */ \"../../shared/dist/core/logging/QuodsiLogger.js\");\r\nvar ModelDefinitionLogger = /** @class */ (function (_super) {\r\n    __extends(ModelDefinitionLogger, _super);\r\n    function ModelDefinitionLogger() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.LOG_PREFIX = '[ModelDefinitionLogger]';\r\n        return _this;\r\n    }\r\n    ModelDefinitionLogger.logModelDefinition = function (modelDefinition) {\r\n        var logger = new ModelDefinitionLogger();\r\n        logger.setLogging(true);\r\n        logger.logDefinition(modelDefinition);\r\n    };\r\n    ModelDefinitionLogger.prototype.logDefinition = function (modelDefinition) {\r\n        this.log(\"\\nLogging Model Definition:\");\r\n        try {\r\n            // Log basic model details\r\n            this.log(\"Model ID: \".concat(modelDefinition.id));\r\n            this.log(\"Model Name: \".concat(modelDefinition.name));\r\n            this.logActivities(modelDefinition);\r\n            this.logConnectors(modelDefinition);\r\n            this.logResources(modelDefinition);\r\n            this.logGenerators(modelDefinition);\r\n            this.logEntities(modelDefinition);\r\n        }\r\n        catch (error) {\r\n            this.logError(\"An error occurred while logging the model definition:\", error);\r\n        }\r\n    };\r\n    ModelDefinitionLogger.prototype.logActivities = function (modelDefinition) {\r\n        var _this = this;\r\n        this.log(\"\\nActivities:\");\r\n        var activities = modelDefinition.activities.getAll();\r\n        activities.forEach(function (activity) { return _this.safeExecute(function () { return _this.logActivity(activity); }, \"Activity ID: \".concat(activity === null || activity === void 0 ? void 0 : activity.id)); });\r\n    };\r\n    ModelDefinitionLogger.prototype.logConnectors = function (modelDefinition) {\r\n        var _this = this;\r\n        this.log(\"\\nConnectors:\");\r\n        var connectors = modelDefinition.connectors.getAll();\r\n        connectors.forEach(function (connector) { return _this.safeExecute(function () { return _this.logConnector(connector); }, \"Connector ID: \".concat(connector === null || connector === void 0 ? void 0 : connector.id)); });\r\n    };\r\n    ModelDefinitionLogger.prototype.logResources = function (modelDefinition) {\r\n        var _this = this;\r\n        this.log(\"\\nResources:\");\r\n        var resources = modelDefinition.resources.getAll();\r\n        resources.forEach(function (resource) { return _this.safeExecute(function () { return _this.logResource(resource); }, \"Resource ID: \".concat(resource === null || resource === void 0 ? void 0 : resource.id)); });\r\n    };\r\n    ModelDefinitionLogger.prototype.logGenerators = function (modelDefinition) {\r\n        var _this = this;\r\n        this.log(\"\\nGenerators:\");\r\n        var generators = modelDefinition.generators.getAll();\r\n        generators.forEach(function (generator) { return _this.safeExecute(function () { return _this.logGenerator(generator); }, \"Generator ID: \".concat(generator === null || generator === void 0 ? void 0 : generator.id)); });\r\n    };\r\n    ModelDefinitionLogger.prototype.logEntities = function (modelDefinition) {\r\n        var _this = this;\r\n        this.log(\"\\nEntities:\");\r\n        var entities = modelDefinition.entities.getAll();\r\n        entities.forEach(function (entity) { return _this.safeExecute(function () { return _this.logEntity(entity); }, \"Entity ID: \".concat(entity === null || entity === void 0 ? void 0 : entity.id)); });\r\n    };\r\n    ModelDefinitionLogger.prototype.safeExecute = function (action, context) {\r\n        try {\r\n            action();\r\n        }\r\n        catch (error) {\r\n            this.logError(\"Failed to log \".concat(context, \":\"), error);\r\n        }\r\n    };\r\n    ModelDefinitionLogger.prototype.logActivity = function (activity) {\r\n        var _this = this;\r\n        var _a, _b;\r\n        this.log(\"  Activity ID: \".concat(activity.id));\r\n        this.log(\"    Name: \".concat(activity.name));\r\n        this.log(\"    Capacity: \".concat(activity.capacity));\r\n        this.log(\"    Input Buffer Capacity: \".concat(activity.inputBufferCapacity));\r\n        this.log(\"    Output Buffer Capacity: \".concat(activity.outputBufferCapacity));\r\n        this.log(\"    Number of Operation Steps: \".concat(((_a = activity.operationSteps) === null || _a === void 0 ? void 0 : _a.length) || 0));\r\n        (_b = activity.operationSteps) === null || _b === void 0 ? void 0 : _b.forEach(function (step, index) {\r\n            var _a, _b;\r\n            _this.log(\"      Operation Step \".concat(index + 1, \":\"));\r\n            _this.log(\"        Duration: \".concat(((_a = step.duration) === null || _a === void 0 ? void 0 : _a.durationLength) || \"Not defined\"));\r\n            if ((_b = step.resourceSetRequest) === null || _b === void 0 ? void 0 : _b.requests) {\r\n                _this.log(\"        Resource Requests:\");\r\n                step.resourceSetRequest.requests.forEach(function (request) {\r\n                    if ('resource' in request && request.resource) {\r\n                        _this.log(\"          Resource ID: \".concat(request.resource.id, \", Quantity: \").concat(request.quantity || \"Not defined\"));\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    ModelDefinitionLogger.prototype.logConnector = function (connector) {\r\n        var _this = this;\r\n        this.log(\"  Connector ID: \".concat(connector.id));\r\n        this.log(\"    Name: \".concat(connector.name || \"Unnamed\"));\r\n        this.log(\"    Source ID: \".concat(connector.sourceId || \"Not defined\"));\r\n        this.log(\"    Target ID: \".concat(connector.targetId || \"Not defined\"));\r\n        this.log(\"    Probability: \".concat(connector.probability !== undefined ? connector.probability : \"Not defined\"));\r\n        this.log(\"    Connection Type: \".concat(connector.connectType || \"Not defined\"));\r\n        var operationSteps = connector.operationSteps;\r\n        this.log(\"    Number of Operation Steps: \".concat((operationSteps === null || operationSteps === void 0 ? void 0 : operationSteps.length) || 0));\r\n        operationSteps === null || operationSteps === void 0 ? void 0 : operationSteps.forEach(function (step, index) {\r\n            var _a, _b;\r\n            _this.log(\"      Operation Step \".concat(index + 1, \":\"));\r\n            _this.log(\"        Duration: \".concat(((_a = step.duration) === null || _a === void 0 ? void 0 : _a.durationLength) || \"Not defined\"));\r\n            if ((_b = step.resourceSetRequest) === null || _b === void 0 ? void 0 : _b.requests) {\r\n                _this.log(\"        Resource Requests:\");\r\n                step.resourceSetRequest.requests.forEach(function (request) {\r\n                    if ('resource' in request && request.resource) {\r\n                        _this.log(\"          Resource ID: \".concat(request.resource.id, \", Quantity: \").concat(request.quantity || \"Not defined\"));\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    ModelDefinitionLogger.prototype.logResource = function (resource) {\r\n        this.log(\"  Resource ID: \".concat(resource.id));\r\n        this.log(\"    Name: \".concat(resource.name));\r\n        this.log(\"    Capacity: \".concat(resource.capacity));\r\n    };\r\n    ModelDefinitionLogger.prototype.logGenerator = function (generator) {\r\n        var _a, _b;\r\n        this.log(\"  Generator ID: \".concat(generator.id));\r\n        this.log(\"    Name: \".concat(generator.name || \"Unnamed\"));\r\n        this.log(\"    Activity Key ID: \".concat(generator.activityKeyId || \"Not defined\"));\r\n        this.log(\"    Entity ID: \".concat(generator.entityId || \"Not defined\"));\r\n        this.log(\"    Periodic Occurrences: \".concat(generator.periodicOccurrences || \"Not defined\"));\r\n        var periodIntervalDuration = (_a = generator.periodIntervalDuration) === null || _a === void 0 ? void 0 : _a.durationLength;\r\n        this.log(\"    Period Interval Duration: \".concat(periodIntervalDuration !== undefined ? periodIntervalDuration : \"Not defined\"));\r\n        this.log(\"    Entities Per Creation: \".concat(generator.entitiesPerCreation || \"Not defined\"));\r\n        var periodicStartDuration = (_b = generator.periodicStartDuration) === null || _b === void 0 ? void 0 : _b.durationLength;\r\n        this.log(\"    Periodic Start Duration: \".concat(periodicStartDuration !== undefined ? periodicStartDuration : \"Not defined\"));\r\n        this.log(\"    Max Entities: \".concat(generator.maxEntities || \"Not defined\"));\r\n    };\r\n    ModelDefinitionLogger.prototype.logEntity = function (entity) {\r\n        this.log(\"  Entity ID: \".concat(entity.id));\r\n        this.log(\"    Name: \".concat(entity.name));\r\n    };\r\n    return ModelDefinitionLogger;\r\n}(QuodsiLogger_1.QuodsiLogger));\r\nexports.ModelDefinitionLogger = ModelDefinitionLogger;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/ModelDefinitionLogger.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ModelUtils.js":
/*!******************************************************!*\
  !*** ../../shared/dist/types/elements/ModelUtils.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelUtils = void 0;\r\nvar SimulationTimeType_1 = __webpack_require__(/*! ./SimulationTimeType */ \"../../shared/dist/types/elements/SimulationTimeType.js\");\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar ModelDefaults_1 = __webpack_require__(/*! ./ModelDefaults */ \"../../shared/dist/types/elements/ModelDefaults.js\");\r\nvar ModelUtils = /** @class */ (function () {\r\n    function ModelUtils() {\r\n    }\r\n    /**\r\n     * Generates a UUID for the model\r\n     */\r\n    ModelUtils.generateUUID = function () {\r\n        var _a;\r\n        try {\r\n            // Check if we're in a browser environment and have crypto support\r\n            if (typeof window !== 'undefined' && ((_a = window === null || window === void 0 ? void 0 : window.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID)) {\r\n                return window.crypto.randomUUID();\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Silently fall through to fallback\r\n        }\r\n        // Fallback implementation\r\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n            var r = Math.random() * 16 | 0;\r\n            var v = c === 'x' ? r : (r & 0x3 | 0x8);\r\n            return v.toString(16);\r\n        });\r\n    };\r\n    /**\r\n     * Creates a new default model instance with a UUID\r\n     */\r\n    ModelUtils.createNew = function (name) {\r\n        if (name === void 0) { name = 'New Model'; }\r\n        return ModelUtils.createWithDefaults({\r\n            name: name\r\n            // Remove id generation - it will be set by the caller\r\n        });\r\n    };\r\n    /**\r\n     * Creates a complete Model object with default values for all optional fields\r\n     */\r\n    ModelUtils.createWithDefaults = function (partialModel) {\r\n        var defaults = {\r\n            id: partialModel.id,\r\n            name: partialModel.name || 'New Model',\r\n            type: SimulationObjectType_1.SimulationObjectType.Model,\r\n            reps: ModelDefaults_1.ModelDefaults.DEFAULT_REPS,\r\n            forecastDays: ModelDefaults_1.ModelDefaults.DEFAULT_FORECAST_DAYS,\r\n            seed: ModelDefaults_1.ModelDefaults.DEFAULT_SEED,\r\n            oneClockUnit: ModelDefaults_1.ModelDefaults.DEFAULT_CLOCK_UNIT,\r\n            simulationTimeType: ModelDefaults_1.ModelDefaults.DEFAULT_SIMULATION_TIME_TYPE,\r\n            warmupClockPeriod: ModelDefaults_1.ModelDefaults.DEFAULT_WARMUP_PERIOD,\r\n            warmupClockPeriodUnit: ModelDefaults_1.ModelDefaults.DEFAULT_CLOCK_UNIT,\r\n            runClockPeriod: ModelDefaults_1.ModelDefaults.DEFAULT_RUN_PERIOD,\r\n            runClockPeriodUnit: ModelDefaults_1.ModelDefaults.DEFAULT_CLOCK_UNIT,\r\n            warmupDateTime: null,\r\n            startDateTime: null,\r\n            finishDateTime: null\r\n        };\r\n        return __assign(__assign({}, defaults), partialModel);\r\n    };\r\n    ModelUtils.validate = function (model) {\r\n        var validated = __assign({}, model);\r\n        // Ensure model has a valid UUID\r\n        if (!validated.id) {\r\n            validated.id = ModelUtils.generateUUID();\r\n        }\r\n        validated.reps = Math.max(1, model.reps);\r\n        validated.forecastDays = Math.max(1, model.forecastDays);\r\n        if (validated.warmupClockPeriod !== undefined) {\r\n            validated.warmupClockPeriod = Math.max(0, validated.warmupClockPeriod);\r\n        }\r\n        if (validated.runClockPeriod !== undefined) {\r\n            validated.runClockPeriod = Math.max(0, validated.runClockPeriod);\r\n        }\r\n        if (validated.simulationTimeType === SimulationTimeType_1.SimulationTimeType.Clock) {\r\n            validated.warmupDateTime = null;\r\n            validated.startDateTime = null;\r\n            validated.finishDateTime = null;\r\n        }\r\n        else if (validated.simulationTimeType === SimulationTimeType_1.SimulationTimeType.CalendarDate) {\r\n            validated.warmupClockPeriod = undefined;\r\n            validated.runClockPeriod = undefined;\r\n            validated.warmupClockPeriodUnit = undefined;\r\n            validated.runClockPeriodUnit = undefined;\r\n        }\r\n        return validated;\r\n    };\r\n    ModelUtils.isComplete = function (model) {\r\n        return (typeof model.id === 'string' &&\r\n            model.id.length > 0 &&\r\n            typeof model.name === 'string' &&\r\n            typeof model.reps === 'number' &&\r\n            typeof model.forecastDays === 'number' &&\r\n            model.type === SimulationObjectType_1.SimulationObjectType.Model);\r\n    };\r\n    return ModelUtils;\r\n}());\r\nexports.ModelUtils = ModelUtils;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/ModelUtils.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/OperationStep.js":
/*!*********************************************************!*\
  !*** ../../shared/dist/types/elements/OperationStep.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.OperationStep = void 0;\r\nvar Duration_1 = __webpack_require__(/*! ./Duration */ \"../../shared/dist/types/elements/Duration.js\");\r\nvar OperationStep = /** @class */ (function () {\r\n    function OperationStep(resourceSetRequest, duration) {\r\n        if (resourceSetRequest === void 0) { resourceSetRequest = null; }\r\n        if (duration === void 0) { duration = new Duration_1.Duration(); }\r\n        this.resourceSetRequest = resourceSetRequest;\r\n        this.duration = duration;\r\n    }\r\n    return OperationStep;\r\n}());\r\nexports.OperationStep = OperationStep;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/OperationStep.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/PeriodUnit.js":
/*!******************************************************!*\
  !*** ../../shared/dist/types/elements/PeriodUnit.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.PeriodUnit = void 0;\r\nvar PeriodUnit;\r\n(function (PeriodUnit) {\r\n    PeriodUnit[\"SECONDS\"] = \"SECONDS\";\r\n    PeriodUnit[\"MINUTES\"] = \"MINUTES\";\r\n    PeriodUnit[\"HOURS\"] = \"HOURS\";\r\n    PeriodUnit[\"DAYS\"] = \"DAYS\";\r\n})(PeriodUnit = exports.PeriodUnit || (exports.PeriodUnit = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/PeriodUnit.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/RequestSetType.js":
/*!**********************************************************!*\
  !*** ../../shared/dist/types/elements/RequestSetType.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.RequestSetType = void 0;\r\nvar RequestSetType;\r\n(function (RequestSetType) {\r\n    RequestSetType[\"AND\"] = \"and\";\r\n    RequestSetType[\"OR\"] = \"or\";\r\n})(RequestSetType = exports.RequestSetType || (exports.RequestSetType = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/RequestSetType.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Resource.js":
/*!****************************************************!*\
  !*** ../../shared/dist/types/elements/Resource.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Resource = void 0;\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar Resource = /** @class */ (function () {\r\n    function Resource(id, name, capacity) {\r\n        if (capacity === void 0) { capacity = 1; }\r\n        this.id = id;\r\n        this.name = name;\r\n        this.capacity = capacity;\r\n        this.type = SimulationObjectType_1.SimulationObjectType.Resource;\r\n    }\r\n    Resource.createDefault = function (id) {\r\n        return new Resource(id, 'New Resource', 1 // capacity\r\n        );\r\n    };\r\n    return Resource;\r\n}());\r\nexports.Resource = Resource;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/Resource.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ResourceListManager.js":
/*!***************************************************************!*\
  !*** ../../shared/dist/types/elements/ResourceListManager.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResourceListManager = void 0;\r\nvar ComponentListManager_1 = __webpack_require__(/*! ./ComponentListManager */ \"../../shared/dist/types/elements/ComponentListManager.js\");\r\nvar ResourceListManager = /** @class */ (function (_super) {\r\n    __extends(ResourceListManager, _super);\r\n    function ResourceListManager() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ResourceListManager.prototype.getByCapacity = function (capacity) {\r\n        return this.getAll().filter(function (resource) { return resource.capacity === capacity; });\r\n    };\r\n    return ResourceListManager;\r\n}(ComponentListManager_1.ComponentListManager));\r\nexports.ResourceListManager = ResourceListManager;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/ResourceListManager.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ResourceRequest.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/elements/ResourceRequest.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResourceRequest = void 0;\r\nvar ResourceRequest = /** @class */ (function () {\r\n    function ResourceRequest(keepResource, resource, quantity) {\r\n        if (keepResource === void 0) { keepResource = false; }\r\n        if (resource === void 0) { resource = null; }\r\n        if (quantity === void 0) { quantity = 1; }\r\n        this.keepResource = keepResource;\r\n        this.resource = resource;\r\n        this.quantity = quantity;\r\n    }\r\n    return ResourceRequest;\r\n}());\r\nexports.ResourceRequest = ResourceRequest;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/ResourceRequest.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/ResourceSetRequest.js":
/*!**************************************************************!*\
  !*** ../../shared/dist/types/elements/ResourceSetRequest.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResourceSetRequest = void 0;\r\nvar RequestSetType_1 = __webpack_require__(/*! ./RequestSetType */ \"../../shared/dist/types/elements/RequestSetType.js\");\r\nvar ResourceSetRequest = /** @class */ (function () {\r\n    function ResourceSetRequest(name, requestType, requests) {\r\n        if (name === void 0) { name = 'initial'; }\r\n        if (requestType === void 0) { requestType = RequestSetType_1.RequestSetType.AND; }\r\n        if (requests === void 0) { requests = []; }\r\n        this.name = name;\r\n        this.requestType = requestType;\r\n        this.requests = requests;\r\n    }\r\n    return ResourceSetRequest;\r\n}());\r\nexports.ResourceSetRequest = ResourceSetRequest;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/ResourceSetRequest.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/Scenario.js":
/*!****************************************************!*\
  !*** ../../shared/dist/types/elements/Scenario.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/Scenario.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/SimulationObject.js":
/*!************************************************************!*\
  !*** ../../shared/dist/types/elements/SimulationObject.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/SimulationObject.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/SimulationObjectType.js":
/*!****************************************************************!*\
  !*** ../../shared/dist/types/elements/SimulationObjectType.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimulationObjectType = void 0;\r\nvar SimulationObjectType;\r\n(function (SimulationObjectType) {\r\n    SimulationObjectType[\"Entity\"] = \"Entity\";\r\n    SimulationObjectType[\"Activity\"] = \"Activity\";\r\n    SimulationObjectType[\"Connector\"] = \"Connector\";\r\n    SimulationObjectType[\"Generator\"] = \"Generator\";\r\n    SimulationObjectType[\"Resource\"] = \"Resource\";\r\n    SimulationObjectType[\"Scenario\"] = \"Scenario\";\r\n    SimulationObjectType[\"Experiment\"] = \"Experiment\";\r\n    SimulationObjectType[\"Model\"] = \"Model\";\r\n    SimulationObjectType[\"None\"] = \"None\";\r\n})(SimulationObjectType = exports.SimulationObjectType || (exports.SimulationObjectType = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/SimulationObjectType.js?");

/***/ }),

/***/ "../../shared/dist/types/elements/SimulationTimeType.js":
/*!**************************************************************!*\
  !*** ../../shared/dist/types/elements/SimulationTimeType.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimulationTimeType = void 0;\r\nvar SimulationTimeType;\r\n(function (SimulationTimeType) {\r\n    SimulationTimeType[\"Clock\"] = \"Clock\";\r\n    SimulationTimeType[\"CalendarDate\"] = \"CalendarDate\";\r\n})(SimulationTimeType = exports.SimulationTimeType || (exports.SimulationTimeType = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/elements/SimulationTimeType.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/JsonTypes.js":
/*!******************************************************!*\
  !*** ../../shared/dist/types/messaging/JsonTypes.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/JsonTypes.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/MessageTypes.js":
/*!*********************************************************!*\
  !*** ../../shared/dist/types/messaging/MessageTypes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.MessageTypes = void 0;\r\nvar MessageTypes;\r\n(function (MessageTypes) {\r\n    // React App Lifecycle\r\n    MessageTypes[\"REACT_APP_READY\"] = \"reactAppReady\";\r\n    MessageTypes[\"INITIAL_STATE\"] = \"initialState\";\r\n    // Selection Management\r\n    MessageTypes[\"SELECTION_CHANGED\"] = \"selectionChanged\";\r\n    MessageTypes[\"SELECTION_CHANGED_PAGE_NO_MODEL\"] = \"selectionPageNoModel\";\r\n    MessageTypes[\"SELECTION_CHANGED_PAGE_WITH_MODEL\"] = \"selectionPageWithModel\";\r\n    MessageTypes[\"SELECTION_CHANGED_SIMULATION_OBJECT\"] = \"selectionSimObject\";\r\n    MessageTypes[\"SELECTION_CHANGED_MULTIPLE\"] = \"selectionMultiple\";\r\n    MessageTypes[\"SELECTION_CHANGED_UNCONVERTED\"] = \"selectionUnconverted\";\r\n    // Model Conversion\r\n    MessageTypes[\"CONVERT_PAGE\"] = \"convertPage\";\r\n    MessageTypes[\"CONVERSION_STARTED\"] = \"conversionStarted\";\r\n    MessageTypes[\"CONVERSION_COMPLETE\"] = \"conversionComplete\";\r\n    MessageTypes[\"CONVERSION_ERROR\"] = \"conversionError\";\r\n    // Element Data Operations\r\n    MessageTypes[\"GET_ELEMENT_DATA\"] = \"getElementData\";\r\n    MessageTypes[\"ELEMENT_DATA\"] = \"elementData\";\r\n    MessageTypes[\"UPDATE_ELEMENT_DATA\"] = \"updateElementData\";\r\n    MessageTypes[\"UPDATE_SUCCESS\"] = \"updateSuccess\";\r\n    MessageTypes[\"CONVERT_ELEMENT\"] = \"convertElement\";\r\n    // Model Validation\r\n    MessageTypes[\"VALIDATE_MODEL\"] = \"validateModel\";\r\n    MessageTypes[\"VALIDATION_RESULT\"] = \"validationResult\";\r\n    // Error Handling\r\n    MessageTypes[\"ERROR\"] = \"error\";\r\n    // Model Operations\r\n    MessageTypes[\"MODEL_SAVED\"] = \"modelSaved\";\r\n    MessageTypes[\"MODEL_LOADED\"] = \"modelLoaded\";\r\n    MessageTypes[\"REMOVE_MODEL\"] = \"removeModel\";\r\n    MessageTypes[\"MODEL_REMOVED\"] = \"modelRemoved\";\r\n    MessageTypes[\"SIMULATE_MODEL\"] = \"simulateModel\";\r\n    // Component Operations\r\n    MessageTypes[\"ACTIVITY_SAVED\"] = \"activitySaved\";\r\n    MessageTypes[\"CONNECTOR_SAVED\"] = \"connectorSaved\";\r\n    MessageTypes[\"ENTITY_SAVED\"] = \"entitySaved\";\r\n    MessageTypes[\"GENERATOR_SAVED\"] = \"generatorSaved\";\r\n    MessageTypes[\"RESOURCE_SAVED\"] = \"resourceSaved\";\r\n    // Tree View State Management\r\n    MessageTypes[\"TREE_STATE_UPDATE\"] = \"treeStateUpdate\";\r\n    MessageTypes[\"TREE_NODE_TOGGLE\"] = \"treeNodeToggle\";\r\n    MessageTypes[\"TREE_NODE_EXPAND_PATH\"] = \"treeNodeExpandPath\";\r\n    MessageTypes[\"TREE_STATE_SYNC\"] = \"treeStateSync\";\r\n})(MessageTypes = exports.MessageTypes || (exports.MessageTypes = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/MessageTypes.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/index.js":
/*!**************************************************!*\
  !*** ../../shared/dist/types/messaging/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./JsonTypes */ \"../../shared/dist/types/messaging/JsonTypes.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./payloads */ \"../../shared/dist/types/messaging/payloads/index.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./utils/MessageValidation */ \"../../shared/dist/types/messaging/utils/MessageValidation.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./utils/ExtensionMessaging */ \"../../shared/dist/types/messaging/utils/ExtensionMessaging.js\"), exports);\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/index.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/AppLifecyclePayloads.js":
/*!**************************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/AppLifecyclePayloads.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/payloads/AppLifecyclePayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ModelData.js":
/*!***************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ModelData.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/payloads/ModelData.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ModelItemData.js":
/*!*******************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ModelItemData.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/payloads/ModelItemData.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ModelItemPayloads.js":
/*!***********************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ModelItemPayloads.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/payloads/ModelItemPayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ModelPayloads.js":
/*!*******************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ModelPayloads.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/payloads/ModelPayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ModelTreePayloads.js":
/*!***********************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ModelTreePayloads.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/payloads/ModelTreePayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/SelectionPayloads.js":
/*!***********************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/SelectionPayloads.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/payloads/SelectionPayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/ValidationPayloads.js":
/*!************************************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/ValidationPayloads.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/payloads/ValidationPayloads.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/payloads/index.js":
/*!***********************************************************!*\
  !*** ../../shared/dist/types/messaging/payloads/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./ModelItemData */ \"../../shared/dist/types/messaging/payloads/ModelItemData.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ModelData */ \"../../shared/dist/types/messaging/payloads/ModelData.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./AppLifecyclePayloads */ \"../../shared/dist/types/messaging/payloads/AppLifecyclePayloads.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ModelPayloads */ \"../../shared/dist/types/messaging/payloads/ModelPayloads.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ModelItemPayloads */ \"../../shared/dist/types/messaging/payloads/ModelItemPayloads.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ValidationPayloads */ \"../../shared/dist/types/messaging/payloads/ValidationPayloads.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ModelTreePayloads */ \"../../shared/dist/types/messaging/payloads/ModelTreePayloads.js\"), exports);\r\n__exportStar(__webpack_require__(/*! ./SelectionPayloads */ \"../../shared/dist/types/messaging/payloads/SelectionPayloads.js\"), exports);\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/payloads/index.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/utils/ExtensionMessaging.js":
/*!*********************************************************************!*\
  !*** ../../shared/dist/types/messaging/utils/ExtensionMessaging.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ExtensionMessaging = void 0;\r\nvar ExtensionMessaging = /** @class */ (function () {\r\n    function ExtensionMessaging() {\r\n        this.handlers = new Map();\r\n    }\r\n    ExtensionMessaging.getInstance = function () {\r\n        if (!ExtensionMessaging.instance) {\r\n            ExtensionMessaging.instance = new ExtensionMessaging();\r\n        }\r\n        return ExtensionMessaging.instance;\r\n    };\r\n    /**\r\n     * Creates a serializable message. At runtime, enums will serialize to their string values.\r\n     */\r\n    ExtensionMessaging.prototype.createSerializableMessage = function (type, payload) {\r\n        return {\r\n            messagetype: type,\r\n            data: payload !== null && payload !== void 0 ? payload : null\r\n        };\r\n    };\r\n    ExtensionMessaging.prototype.handleIncomingMessage = function (message) {\r\n        console.log('[ExtensionMessaging] Received incoming message:', message);\r\n        if (!(message === null || message === void 0 ? void 0 : message.messagetype)) {\r\n            console.warn('[ExtensionMessaging] Message missing messagetype:', message);\r\n            return;\r\n        }\r\n        var handlers = this.handlers.get(message.messagetype);\r\n        if (handlers) {\r\n            console.log(\"[ExtensionMessaging] Found \".concat(handlers.size, \" handlers for incoming message type: \").concat(message.messagetype));\r\n            handlers.forEach(function (handler) { return handler(message.data); });\r\n        }\r\n        else {\r\n            console.warn(\"[ExtensionMessaging] No handlers found for incoming message type: \".concat(message.messagetype));\r\n        }\r\n    };\r\n    ExtensionMessaging.prototype.onMessage = function (type, handler) {\r\n        var _this = this;\r\n        if (!this.handlers.has(type)) {\r\n            this.handlers.set(type, new Set());\r\n        }\r\n        this.handlers.get(type).add(handler);\r\n        // Return unsubscribe function\r\n        return function () {\r\n            var _a;\r\n            (_a = _this.handlers.get(type)) === null || _a === void 0 ? void 0 : _a.delete(handler);\r\n        };\r\n    };\r\n    ExtensionMessaging.prototype.sendMessage = function (type, payload) {\r\n        console.log('[ExtensionMessaging] Sending message:', { type: type, payload: payload });\r\n        try {\r\n            // First, notify any local handlers\r\n            var handlers = this.handlers.get(type);\r\n            if (handlers) {\r\n                handlers.forEach(function (handler) { return handler(payload); });\r\n            }\r\n            // Then, send to parent window\r\n            var message = this.createSerializableMessage(type, payload);\r\n            window.parent.postMessage(message, \"*\");\r\n            console.log('[ExtensionMessaging] Message posted to parent window');\r\n        }\r\n        catch (error) {\r\n            console.error('[ExtensionMessaging] Failed to send message:', error);\r\n            throw error;\r\n        }\r\n    };\r\n    return ExtensionMessaging;\r\n}());\r\nexports.ExtensionMessaging = ExtensionMessaging;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/utils/ExtensionMessaging.js?");

/***/ }),

/***/ "../../shared/dist/types/messaging/utils/MessageValidation.js":
/*!********************************************************************!*\
  !*** ../../shared/dist/types/messaging/utils/MessageValidation.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isValidMessage = void 0;\r\nvar MessageTypes_1 = __webpack_require__(/*! ../MessageTypes */ \"../../shared/dist/types/messaging/MessageTypes.js\");\r\n/**\r\n * Type guard to check if a message is valid\r\n */\r\nfunction isValidMessage(message) {\r\n    return message\r\n        && typeof message === 'object'\r\n        && 'messagetype' in message\r\n        && Object.values(MessageTypes_1.MessageTypes).includes(message.messagetype);\r\n}\r\nexports.isValidMessage = isValidMessage;\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/messaging/utils/MessageValidation.js?");

/***/ }),

/***/ "../../shared/dist/types/simComponentType.js":
/*!***************************************************!*\
  !*** ../../shared/dist/types/simComponentType.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimComponentType = void 0;\r\nvar SimComponentType;\r\n(function (SimComponentType) {\r\n    SimComponentType[\"ACTIVITY\"] = \"activity\";\r\n    SimComponentType[\"GENERATOR\"] = \"generator\";\r\n    SimComponentType[\"CONNECTOR\"] = \"connector\";\r\n    SimComponentType[\"MODEL\"] = \"model\";\r\n    SimComponentType[\"ENTITY\"] = \"entity\";\r\n    SimComponentType[\"RESOURCE\"] = \"resource\";\r\n    SimComponentType[\"NONE\"] = \"none\";\r\n})(SimComponentType = exports.SimComponentType || (exports.SimComponentType = {}));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/simComponentType.js?");

/***/ }),

/***/ "../../shared/dist/types/simComponentTypes.js":
/*!****************************************************!*\
  !*** ../../shared/dist/types/simComponentTypes.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nvar _a;\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimComponentTypes = exports.SimComponentFactory = void 0;\r\nvar PeriodUnit_1 = __webpack_require__(/*! ./elements/PeriodUnit */ \"../../shared/dist/types/elements/PeriodUnit.js\");\r\nvar DurationType_1 = __webpack_require__(/*! ./elements/DurationType */ \"../../shared/dist/types/elements/DurationType.js\");\r\nvar SimulationObjectType_1 = __webpack_require__(/*! ./elements/SimulationObjectType */ \"../../shared/dist/types/elements/SimulationObjectType.js\");\r\nvar ConnectType_1 = __webpack_require__(/*! ./elements/ConnectType */ \"../../shared/dist/types/elements/ConnectType.js\");\r\nvar simComponentType_1 = __webpack_require__(/*! ./simComponentType */ \"../../shared/dist/types/simComponentType.js\");\r\nvar ModelDefaults_1 = __webpack_require__(/*! ./elements/ModelDefaults */ \"../../shared/dist/types/elements/ModelDefaults.js\");\r\nvar SimComponentFactory = /** @class */ (function () {\r\n    function SimComponentFactory() {\r\n    }\r\n    SimComponentFactory.createEmptyDuration = function () {\r\n        return {\r\n            durationLength: 0,\r\n            durationPeriodUnit: PeriodUnit_1.PeriodUnit.MINUTES,\r\n            durationType: DurationType_1.DurationType.CONSTANT,\r\n            distribution: null\r\n        };\r\n    };\r\n    SimComponentFactory.createEmpty = function (type, id) {\r\n        var creator = this.creators[type];\r\n        if (!creator) {\r\n            console.warn('[SimComponentFactory] Unknown component type:', type);\r\n            return {};\r\n        }\r\n        console.log('[SimComponentFactory] Creating empty component:', {\r\n            type: type,\r\n            id: id,\r\n            timestamp: new Date().toISOString()\r\n        });\r\n        return creator(id);\r\n    };\r\n    SimComponentFactory.creators = (_a = {},\r\n        _a[simComponentType_1.SimComponentType.ACTIVITY] = function (id) { return ({\r\n            id: id,\r\n            name: 'New Activity',\r\n            type: SimulationObjectType_1.SimulationObjectType.Activity,\r\n            capacity: 1,\r\n            inputBufferCapacity: 999,\r\n            outputBufferCapacity: 999,\r\n            operationSteps: [],\r\n            connectors: []\r\n        }); },\r\n        _a[simComponentType_1.SimComponentType.GENERATOR] = function (id) { return ({\r\n            id: id,\r\n            name: \"New Generator\",\r\n            type: SimulationObjectType_1.SimulationObjectType.Generator,\r\n            activityKeyId: \"\",\r\n            entityId: ModelDefaults_1.ModelDefaults.DEFAULT_ENTITY_ID,\r\n            periodicOccurrences: Infinity,\r\n            periodIntervalDuration: SimComponentFactory.createEmptyDuration(),\r\n            entitiesPerCreation: 1,\r\n            periodicStartDuration: SimComponentFactory.createEmptyDuration(),\r\n            maxEntities: Infinity\r\n        }); },\r\n        _a[simComponentType_1.SimComponentType.CONNECTOR] = function (id) { return ({\r\n            id: id,\r\n            name: \"New Connector\",\r\n            type: SimulationObjectType_1.SimulationObjectType.Connector,\r\n            sourceId: \"\",\r\n            targetId: \"\",\r\n            probability: 1.0,\r\n            connectType: ConnectType_1.ConnectType.Probability,\r\n            operationSteps: []\r\n        }); },\r\n        _a[simComponentType_1.SimComponentType.ENTITY] = function (id) { return ({\r\n            id: id,\r\n            name: \"New Entity\",\r\n            type: SimulationObjectType_1.SimulationObjectType.Entity\r\n        }); },\r\n        _a[simComponentType_1.SimComponentType.RESOURCE] = function (id) { return ({\r\n            id: id,\r\n            name: \"New Resource\",\r\n            type: SimulationObjectType_1.SimulationObjectType.Resource,\r\n            capacity: 1\r\n        }); },\r\n        _a[simComponentType_1.SimComponentType.MODEL] = function (id) { return ({}); },\r\n        _a[simComponentType_1.SimComponentType.NONE] = function (id) { return ({}); },\r\n        _a);\r\n    return SimComponentFactory;\r\n}());\r\nexports.SimComponentFactory = SimComponentFactory;\r\nexports.SimComponentTypes = [\r\n    {\r\n        type: simComponentType_1.SimComponentType.ACTIVITY,\r\n        displayName: 'Activity',\r\n        description: 'Process or task node',\r\n        createEmpty: function (id) { return SimComponentFactory.createEmpty(simComponentType_1.SimComponentType.ACTIVITY, id); }\r\n    },\r\n    {\r\n        type: simComponentType_1.SimComponentType.GENERATOR,\r\n        displayName: 'Generator',\r\n        description: 'Creates entities in simulation',\r\n        createEmpty: function (id) { return SimComponentFactory.createEmpty(simComponentType_1.SimComponentType.GENERATOR, id); }\r\n    },\r\n    {\r\n        type: simComponentType_1.SimComponentType.CONNECTOR,\r\n        displayName: 'Connector',\r\n        description: 'Connects activities',\r\n        createEmpty: function (id) { return SimComponentFactory.createEmpty(simComponentType_1.SimComponentType.CONNECTOR, id); }\r\n    },\r\n    {\r\n        type: simComponentType_1.SimComponentType.MODEL,\r\n        displayName: 'Model',\r\n        description: 'Simulation model container',\r\n        createEmpty: function (id) { return SimComponentFactory.createEmpty(simComponentType_1.SimComponentType.MODEL, id); }\r\n    },\r\n    {\r\n        type: simComponentType_1.SimComponentType.ENTITY,\r\n        displayName: 'Entity',\r\n        description: 'Object flowing through system',\r\n        createEmpty: function (id) { return SimComponentFactory.createEmpty(simComponentType_1.SimComponentType.ENTITY, id); }\r\n    },\r\n    {\r\n        type: simComponentType_1.SimComponentType.RESOURCE,\r\n        displayName: 'Resource',\r\n        description: 'Required for activities',\r\n        createEmpty: function (id) { return SimComponentFactory.createEmpty(simComponentType_1.SimComponentType.RESOURCE, id); }\r\n    },\r\n    {\r\n        type: simComponentType_1.SimComponentType.NONE,\r\n        displayName: 'None',\r\n        description: 'Remove all simulation components',\r\n        createEmpty: function (id) { return SimComponentFactory.createEmpty(simComponentType_1.SimComponentType.NONE, id); }\r\n    }\r\n];\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/simComponentTypes.js?");

/***/ }),

/***/ "../../shared/dist/types/validation/ValidationTypes.js":
/*!*************************************************************!*\
  !*** ../../shared/dist/types/validation/ValidationTypes.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n// types/ValidationTypes.ts\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/validation/ValidationTypes.js?");

/***/ }),

/***/ "../../shared/dist/types/validation/index.js":
/*!***************************************************!*\
  !*** ../../shared/dist/types/validation/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./ValidationTypes */ \"../../shared/dist/types/validation/ValidationTypes.js\"), exports);\r\n\n\n//# sourceURL=webpack:///../../shared/dist/types/validation/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/extension.ts");
/******/ 	
/******/ })()
;